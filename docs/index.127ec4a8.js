// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"iQ6VI":[function(require,module,exports) {
"use strict";
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "f828f65b127ec4a8";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] âœ¨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>ðŸ’¡ ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"azjEx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _vue = require("vue");
var _elementPlus = require("element-plus");
var _elementPlusDefault = parcelHelpers.interopDefault(_elementPlus);
var _indexCss = require("element-plus/dist/index.css");
// å…¨å±€æ ·å¼
var _globalCss = require("./assets/global.css");
var _appVue = require("./App.vue");
var _appVueDefault = parcelHelpers.interopDefault(_appVue);
const app = _vue.createApp(_appVueDefault.default);
app.use(_elementPlusDefault.default);
app.mount("#app");

},{"vue":"gzxs9","element-plus":"djgkP","element-plus/dist/index.css":"lBbja","./assets/global.css":"dwH06","./App.vue":"cLzs3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gzxs9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compile", ()=>compile
);
var _runtimeDom = require("@vue/runtime-dom");
parcelHelpers.exportAll(_runtimeDom, exports);
function initDev() {
    _runtimeDom.initCustomFormatter();
}
initDev();
const compile = ()=>{
    _runtimeDom.warn(`Runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
};

},{"@vue/runtime-dom":"9wNvI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9wNvI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Transition", ()=>Transition
);
parcelHelpers.export(exports, "TransitionGroup", ()=>TransitionGroup
);
parcelHelpers.export(exports, "VueElement", ()=>VueElement
);
parcelHelpers.export(exports, "createApp", ()=>createApp
);
parcelHelpers.export(exports, "createSSRApp", ()=>createSSRApp
);
parcelHelpers.export(exports, "defineCustomElement", ()=>defineCustomElement
);
parcelHelpers.export(exports, "defineSSRCustomElement", ()=>defineSSRCustomElement
);
parcelHelpers.export(exports, "hydrate", ()=>hydrate
);
parcelHelpers.export(exports, "initDirectivesForSSR", ()=>initDirectivesForSSR
);
parcelHelpers.export(exports, "render", ()=>render
);
parcelHelpers.export(exports, "useCssModule", ()=>useCssModule
);
parcelHelpers.export(exports, "useCssVars", ()=>useCssVars
);
parcelHelpers.export(exports, "vModelCheckbox", ()=>vModelCheckbox
);
parcelHelpers.export(exports, "vModelDynamic", ()=>vModelDynamic
);
parcelHelpers.export(exports, "vModelRadio", ()=>vModelRadio
);
parcelHelpers.export(exports, "vModelSelect", ()=>vModelSelect
);
parcelHelpers.export(exports, "vModelText", ()=>vModelText
);
parcelHelpers.export(exports, "vShow", ()=>vShow
);
parcelHelpers.export(exports, "withKeys", ()=>withKeys
);
parcelHelpers.export(exports, "withModifiers", ()=>withModifiers
);
var _runtimeCore = require("@vue/runtime-core");
var _shared = require("@vue/shared");
parcelHelpers.exportAll(_runtimeCore, exports);
const svgNS = 'http://www.w3.org/2000/svg';
const doc = typeof document !== 'undefined' ? document : null;
const templateContainer = doc && doc.createElement('template');
const nodeOps = {
    insert: (child, parent, anchor)=>{
        parent.insertBefore(child, anchor || null);
    },
    remove: (child)=>{
        const parent = child.parentNode;
        if (parent) parent.removeChild(child);
    },
    createElement: (tag, isSVG, is, props)=>{
        const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {
            is
        } : undefined);
        if (tag === 'select' && props && props.multiple != null) el.setAttribute('multiple', props.multiple);
        return el;
    },
    createText: (text)=>doc.createTextNode(text)
    ,
    createComment: (text)=>doc.createComment(text)
    ,
    setText: (node, text)=>{
        node.nodeValue = text;
    },
    setElementText: (el, text)=>{
        el.textContent = text;
    },
    parentNode: (node)=>node.parentNode
    ,
    nextSibling: (node)=>node.nextSibling
    ,
    querySelector: (selector)=>doc.querySelector(selector)
    ,
    setScopeId (el, id) {
        el.setAttribute(id, '');
    },
    cloneNode (el) {
        const cloned = el.cloneNode(true);
        // #3072
        // - in `patchDOMProp`, we store the actual value in the `el._value` property.
        // - normally, elements using `:value` bindings will not be hoisted, but if
        //   the bound value is a constant, e.g. `:value="true"` - they do get
        //   hoisted.
        // - in production, hoisted nodes are cloned when subsequent inserts, but
        //   cloneNode() does not copy the custom property we attached.
        // - This may need to account for other custom DOM properties we attach to
        //   elements in addition to `_value` in the future.
        if (`_value` in el) cloned._value = el._value;
        return cloned;
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent (content, parent, anchor, isSVG, start, end) {
        // <parent> before | first ... last | anchor </parent>
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        // #5308 can only take cached path if:
        // - has a single root node
        // - nextSibling info is still available
        if (start && (start === end || start.nextSibling)) // cached
        while(true){
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
        }
        else {
            // fresh insert
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
                // remove outer svg wrapper
                const wrapper = template.firstChild;
                while(wrapper.firstChild)template.appendChild(wrapper.firstChild);
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};
// compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]
function patchClass(el, value, isSVG) {
    // directly setting className should be faster than setAttribute in theory
    // if this is an element during a transition, take the temporary transition
    // classes into account.
    const transitionClasses = el._vtc;
    if (transitionClasses) value = (value ? [
        value,
        ...transitionClasses
    ] : [
        ...transitionClasses
    ]).join(' ');
    if (value == null) el.removeAttribute('class');
    else if (isSVG) el.setAttribute('class', value);
    else el.className = value;
}
function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = _shared.isString(next);
    if (next && !isCssString) {
        for(const key in next)setStyle(style, key, next[key]);
        if (prev && !_shared.isString(prev)) {
            for(const key in prev)if (next[key] == null) setStyle(style, key, '');
        }
    } else {
        const currentDisplay = style.display;
        if (isCssString) {
            if (prev !== next) style.cssText = next;
        } else if (prev) el.removeAttribute('style');
        // indicates that the `display` of the element is controlled by `v-show`,
        // so we always keep the current `display` value regardless of the `style`
        // value, thus handing over control to `v-show`.
        if ('_vod' in el) style.display = currentDisplay;
    }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if (_shared.isArray(val)) val.forEach((v)=>setStyle(style, name, v)
    );
    else if (name.startsWith('--')) // custom property definition
    style.setProperty(name, val);
    else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) // !important
        style.setProperty(_shared.hyphenate(prefixed), val.replace(importantRE, ''), 'important');
        else style[prefixed] = val;
    }
}
const prefixes = [
    'Webkit',
    'Moz',
    'ms'
];
const prefixCache = {
};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) return cached;
    let name = _runtimeCore.camelize(rawName);
    if (name !== 'filter' && name in style) return prefixCache[rawName] = name;
    name = _shared.capitalize(name);
    for(let i = 0; i < prefixes.length; i++){
        const prefixed = prefixes[i] + name;
        if (prefixed in style) return prefixCache[rawName] = prefixed;
    }
    return rawName;
}
const xlinkNS = 'http://www.w3.org/1999/xlink';
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith('xlink:')) {
        if (value == null) el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        else el.setAttributeNS(xlinkNS, key, value);
    } else {
        // note we are only checking boolean attributes that don't have a
        // corresponding dom prop of the same name here.
        const isBoolean = _shared.isSpecialBooleanAttr(key);
        if (value == null || isBoolean && !_shared.includeBooleanAttr(value)) el.removeAttribute(key);
        else el.setAttribute(key, isBoolean ? '' : value);
    }
}
// __UNSAFE__
// functions. The user is responsible for using them with only trusted content.
function patchDOMProp(el, key, value, // the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === 'innerHTML' || key === 'textContent') {
        if (prevChildren) unmountChildren(prevChildren, parentComponent, parentSuspense);
        el[key] = value == null ? '' : value;
        return;
    }
    if (key === 'value' && el.tagName !== 'PROGRESS' && // custom elements may use _value internally
    !el.tagName.includes('-')) {
        // store value as _value as well since
        // non-string values will be stringified.
        el._value = value;
        const newValue = value == null ? '' : value;
        if (el.value !== newValue || // #4956: always set for OPTION elements because its value falls back to
        // textContent if no value attribute is present. And setting .value for
        // OPTION has no side effect
        el.tagName === 'OPTION') el.value = newValue;
        if (value == null) el.removeAttribute(key);
        return;
    }
    if (value === '' || value == null) {
        const type = typeof el[key];
        if (type === 'boolean') {
            // e.g. <select multiple> compiles to { multiple: '' }
            el[key] = _shared.includeBooleanAttr(value);
            return;
        } else if (value == null && type === 'string') {
            // e.g. <div :id="null">
            el[key] = '';
            el.removeAttribute(key);
            return;
        } else if (type === 'number') {
            // e.g. <img :width="null">
            // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error
            try {
                el[key] = 0;
            } catch (_a) {
            }
            el.removeAttribute(key);
            return;
        }
    }
    // some properties perform value validation and throw
    try {
        el[key] = value;
    } catch (e) {
        _runtimeCore.warn(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` + `value ${value} is invalid.`, e);
    }
}
// Async edge case fix requires storing an event listener's attach timestamp.
let _getNow = Date.now;
let skipTimestampCheck = false;
if (typeof window !== 'undefined') {
    // Determine what event timestamp the browser is using. Annoyingly, the
    // timestamp can either be hi-res (relative to page load) or low-res
    // (relative to UNIX epoch), so in order to compare time we have to use the
    // same timestamp type when saving the flush timestamp.
    if (_getNow() > document.createEvent('Event').timeStamp) // if the low-res timestamp which is bigger than the event timestamp
    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listeners as well.
    _getNow = ()=>performance.now()
    ;
    // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
    // and does not fire microtasks in between event propagation, so safe to exclude.
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
}
// To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.
let cachedNow = 0;
const p = Promise.resolve();
const reset = ()=>{
    cachedNow = 0;
};
const getNow = ()=>cachedNow || (p.then(reset), cachedNow = _getNow())
;
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    // vei = vue event invokers
    const invokers = el._vei || (el._vei = {
    });
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) // patch
    existingInvoker.value = nextValue;
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            // add
            const invoker = invokers[rawName] = createInvoker(nextValue, instance);
            addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
            // remove
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = undefined;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {
        };
        let m;
        while(m = name.match(optionsModifierRE)){
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    return [
        _shared.hyphenate(name.slice(2)),
        options
    ];
}
function createInvoker(initialValue, instance) {
    const invoker = (e)=>{
        // async edge case #6566: inner click event triggers patch, event handler
        // attached to outer element during patch, and triggered again. This
        // happens because browsers fire microtask ticks between event propagation.
        // the solution is simple: we save the timestamp when a handler is attached,
        // and the handler would only fire if the event passed to it was fired
        // AFTER it was attached.
        const timeStamp = e.timeStamp || _getNow();
        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) _runtimeCore.callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */ , [
            e
        ]);
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e1, value) {
    if (_shared.isArray(value)) {
        const originalStop = e1.stopImmediatePropagation;
        e1.stopImmediatePropagation = ()=>{
            originalStop.call(e1);
            e1._stopped = true;
        };
        return value.map((fn)=>(e)=>!e._stopped && fn && fn(e)
        );
    } else return value;
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren)=>{
    if (key === 'class') patchClass(el, nextValue, isSVG);
    else if (key === 'style') patchStyle(el, prevValue, nextValue);
    else if (_shared.isOn(key)) // ignore v-model listeners
    {
        if (!_shared.isModelListener(key)) patchEvent(el, key, prevValue, nextValue, parentComponent);
    } else if (key[0] === '.' ? (key = key.slice(1), true) : key[0] === '^' ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    else {
        // special case for <input v-model type="checkbox"> with
        // :true-value & :false-value
        // store value as dom properties since non-string values will be
        // stringified.
        if (key === 'true-value') el._trueValue = nextValue;
        else if (key === 'false-value') el._falseValue = nextValue;
        patchAttr(el, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        // most keys must be set as attribute on svg elements to work
        // ...except innerHTML & textContent
        if (key === 'innerHTML' || key === 'textContent') return true;
        // or native onclick with function values
        if (key in el && nativeOnRE.test(key) && _shared.isFunction(value)) return true;
        return false;
    }
    // spellcheck and draggable are numerated attrs, however their
    // corresponding DOM properties are actually booleans - this leads to
    // setting it with a string "false" value leading it to be coerced to
    // `true`, so we need to always treat them as attributes.
    // Note that `contentEditable` doesn't have this problem: its DOM
    // property is also enumerated string values.
    if (key === 'spellcheck' || key === 'draggable') return false;
    // #1787, #2840 form property on form elements is readonly and must be set as
    // attribute.
    if (key === 'form') return false;
    // #1526 <input list> must be set as attribute
    if (key === 'list' && el.tagName === 'INPUT') return false;
    // #2766 <textarea type> must be set as attribute
    if (key === 'type' && el.tagName === 'TEXTAREA') return false;
    // native onclick with string value, must be set as attribute
    if (nativeOnRE.test(key) && _shared.isString(value)) return false;
    return key in el;
}
function defineCustomElement(options, hydate) {
    const Comp = _runtimeCore.defineComponent(options);
    class VueCustomElement extends VueElement {
        constructor(initialProps){
            super(Comp, initialProps, hydate);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
const defineSSRCustomElement = (options)=>{
    // @ts-ignore
    return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== 'undefined' ? HTMLElement : class {
};
class VueElement extends BaseClass {
    constructor(_def, _props = {
    }, hydrate1){
        super();
        this._def = _def;
        this._props = _props;
        /**
         * @internal
         */ this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate1) hydrate1(this._createVNode(), this.shadowRoot);
        else {
            if (this.shadowRoot) _runtimeCore.warn(`Custom element has pre-rendered declarative shadow root but is not ` + `defined as hydratable. Use \`defineSSRCustomElement\`.`);
            this.attachShadow({
                mode: 'open'
            });
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._instance) this._resolveDef();
    }
    disconnectedCallback() {
        this._connected = false;
        _runtimeCore.nextTick(()=>{
            if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
            }
        });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */ _resolveDef() {
        if (this._resolved) return;
        this._resolved = true;
        // set initial attrs
        for(let i = 0; i < this.attributes.length; i++)this._setAttr(this.attributes[i].name);
        // watch future attr changes
        new MutationObserver((mutations)=>{
            for (const m of mutations)this._setAttr(m.attributeName);
        }).observe(this, {
            attributes: true
        });
        const resolve = (def)=>{
            const { props , styles  } = def;
            const hasOptions = !_shared.isArray(props);
            const rawKeys = props ? hasOptions ? Object.keys(props) : props : [];
            // cast Number-type props set before resolve
            let numberProps;
            if (hasOptions) for(const key in this._props){
                const opt = props[key];
                if (opt === Number || opt && opt.type === Number) {
                    this._props[key] = _shared.toNumber(this._props[key]);
                    (numberProps || (numberProps = Object.create(null)))[key] = true;
                }
            }
            this._numberProps = numberProps;
            // check if there are props set pre-upgrade or connect
            for (const key1 of Object.keys(this))if (key1[0] !== '_') this._setProp(key1, this[key1], true, false);
            // defining getter/setters on prototype
            for (const key2 of rawKeys.map(_shared.camelize))Object.defineProperty(this, key2, {
                get () {
                    return this._getProp(key2);
                },
                set (val) {
                    this._setProp(key2, val);
                }
            });
            // apply CSS
            this._applyStyles(styles);
            // initial render
            this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) asyncDef().then(resolve);
        else resolve(this._def);
    }
    _setAttr(key) {
        let value = this.getAttribute(key);
        if (this._numberProps && this._numberProps[key]) value = _shared.toNumber(value);
        this._setProp(_shared.camelize(key), value, false);
    }
    /**
     * @internal
     */ _getProp(key) {
        return this._props[key];
    }
    /**
     * @internal
     */ _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) this._update();
            // reflect
            if (shouldReflect) {
                if (val === true) this.setAttribute(_shared.hyphenate(key), '');
                else if (typeof val === 'string' || typeof val === 'number') this.setAttribute(_shared.hyphenate(key), val + '');
                else if (!val) this.removeAttribute(_shared.hyphenate(key));
            }
        }
    }
    _update() {
        render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
        const vnode = _runtimeCore.createVNode(this._def, _shared.extend({
        }, this._props));
        if (!this._instance) vnode.ce = (instance)=>{
            this._instance = instance;
            instance.isCE = true;
            instance.ceReload = (newStyles)=>{
                // always reset styles
                if (this._styles) {
                    this._styles.forEach((s)=>this.shadowRoot.removeChild(s)
                    );
                    this._styles.length = 0;
                }
                this._applyStyles(newStyles);
                // if this is an async component, ceReload is called from the inner
                // component so no need to reload the async wrapper
                if (!this._def.__asyncLoader) {
                    // reload
                    this._instance = null;
                    this._update();
                }
            };
            // intercept emit
            instance.emit = (event, ...args)=>{
                this.dispatchEvent(new CustomEvent(event, {
                    detail: args
                }));
            };
            // locate nearest Vue custom element parent for provide/inject
            let parent = this;
            while(parent = parent && (parent.parentNode || parent.host))if (parent instanceof VueElement) {
                instance.parent = parent._instance;
                break;
            }
        };
        return vnode;
    }
    _applyStyles(styles) {
        if (styles) styles.forEach((css)=>{
            const s = document.createElement('style');
            s.textContent = css;
            this.shadowRoot.appendChild(s);
            (this._styles || (this._styles = [])).push(s);
        });
    }
}
function useCssModule(name = '$style') {
    /* istanbul ignore else */ {
        const instance = _runtimeCore.getCurrentInstance();
        if (!instance) {
            _runtimeCore.warn(`useCssModule must be called inside setup()`);
            return _shared.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            _runtimeCore.warn(`Current instance does not have CSS modules injected.`);
            return _shared.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            _runtimeCore.warn(`Current instance does not have CSS module named "${name}".`);
            return _shared.EMPTY_OBJ;
        }
        return mod;
    }
}
/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */ function useCssVars(getter) {
    const instance = _runtimeCore.getCurrentInstance();
    /* istanbul ignore next */ if (!instance) {
        _runtimeCore.warn(`useCssVars is called without current active component instance.`);
        return;
    }
    const setVars = ()=>setVarsOnVNode(instance.subTree, getter(instance.proxy))
    ;
    _runtimeCore.watchPostEffect(setVars);
    _runtimeCore.onMounted(()=>{
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, {
            childList: true
        });
        _runtimeCore.onUnmounted(()=>ob.disconnect()
        );
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128 /* SUSPENSE */ ) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) suspense.effects.push(()=>{
            setVarsOnVNode(suspense.activeBranch, vars);
        });
    }
    // drill down HOCs until it's a non-component vnode
    while(vnode.component)vnode = vnode.component.subTree;
    if (vnode.shapeFlag & 1 /* ELEMENT */  && vnode.el) setVarsOnNode(vnode.el, vars);
    else if (vnode.type === _runtimeCore.Fragment) vnode.children.forEach((c)=>setVarsOnVNode(c, vars)
    );
    else if (vnode.type === _runtimeCore.Static) {
        let { el , anchor  } = vnode;
        while(el){
            setVarsOnNode(el, vars);
            if (el === anchor) break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        for(const key in vars)style.setProperty(`--${key}`, vars[key]);
    }
}
const TRANSITION = 'transition';
const ANIMATION = 'animation';
// DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.
const Transition = (props, { slots  })=>_runtimeCore.h(_runtimeCore.BaseTransition, resolveTransitionProps(props), slots)
;
Transition.displayName = 'Transition';
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [
        String,
        Number,
        Object
    ],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /*#__PURE__*/ _shared.extend({
}, _runtimeCore.BaseTransition.props, DOMTransitionPropsValidators);
/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */ const callHook = (hook, args = [])=>{
    if (_shared.isArray(hook)) hook.forEach((h)=>h(...args)
    );
    else if (hook) hook(...args);
};
/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */ const hasExplicitCallback = (hook)=>{
    return hook ? _shared.isArray(hook) ? hook.some((h)=>h.length > 1
    ) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {
    };
    for(const key in rawProps)if (!(key in DOMTransitionPropsValidators)) baseProps[key] = rawProps[key];
    if (rawProps.css === false) return baseProps;
    const { name ='v' , type , duration , enterFromClass =`${name}-enter-from` , enterActiveClass =`${name}-enter-active` , enterToClass =`${name}-enter-to` , appearFromClass =enterFromClass , appearActiveClass =enterActiveClass , appearToClass =enterToClass , leaveFromClass =`${name}-leave-from` , leaveActiveClass =`${name}-leave-active` , leaveToClass =`${name}-leave-to`  } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter , onEnter , onEnterCancelled , onLeave , onLeaveCancelled , onBeforeAppear =onBeforeEnter , onAppear =onEnter , onAppearCancelled =onEnterCancelled  } = baseProps;
    const finishEnter = (el, isAppear, done)=>{
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done)=>{
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear)=>{
        return (el, done)=>{
            const hook = isAppear ? onAppear : onEnter;
            const resolve = ()=>finishEnter(el, isAppear, done)
            ;
            callHook(hook, [
                el,
                resolve
            ]);
            nextFrame(()=>{
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) whenTransitionEnds(el, type, enterDuration, resolve);
            });
        };
    };
    return _shared.extend(baseProps, {
        onBeforeEnter (el) {
            callHook(onBeforeEnter, [
                el
            ]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear (el) {
            callHook(onBeforeAppear, [
                el
            ]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave (el, done) {
            const resolve = ()=>finishLeave(el, done)
            ;
            addTransitionClass(el, leaveFromClass);
            // force reflow so *-leave-from classes immediately take effect (#2593)
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(()=>{
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) whenTransitionEnds(el, type, leaveDuration, resolve);
            });
            callHook(onLeave, [
                el,
                resolve
            ]);
        },
        onEnterCancelled (el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [
                el
            ]);
        },
        onAppearCancelled (el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [
                el
            ]);
        },
        onLeaveCancelled (el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [
                el
            ]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) return null;
    else if (_shared.isObject(duration)) return [
        NumberOf(duration.enter),
        NumberOf(duration.leave)
    ];
    else {
        const n = NumberOf(duration);
        return [
            n,
            n
        ];
    }
}
function NumberOf(val) {
    const res = _shared.toNumber(val);
    validateDuration(res);
    return res;
}
function validateDuration(val) {
    if (typeof val !== 'number') _runtimeCore.warn(`<transition> explicit duration is not a valid number - ` + `got ${JSON.stringify(val)}.`);
    else if (isNaN(val)) _runtimeCore.warn(`<transition> explicit duration is NaN - ` + 'the duration expression might be incorrect.');
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.add(c)
    );
    (el._vtc || (el._vtc = new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.remove(c)
    );
    const { _vtc  } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) el._vtc = undefined;
    }
}
function nextFrame(cb) {
    requestAnimationFrame(()=>{
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = ()=>{
        if (id === el._endId) resolve();
    };
    if (explicitTimeout) return setTimeout(resolveIfNotStale, explicitTimeout);
    const { type , timeout , propCount  } = getTransitionInfo(el, expectedType);
    if (!type) return resolve();
    const endEvent = type + 'end';
    let ended = 0;
    const end = ()=>{
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e)=>{
        if (e.target === el && ++ended >= propCount) end();
    };
    setTimeout(()=>{
        if (ended < propCount) end();
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    const getStyleProperties = (key)=>(styles[key] || '').split(', ')
    ;
    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + 'Delay');
    const animationDurations = getStyleProperties(ANIMATION + 'Duration');
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    /* istanbul ignore if */ if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while(delays.length < durations.length)delays = delays.concat(delays);
    return Math.max(...durations.map((d, i)=>toMs(d) + toMs(delays[i])
    ));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
// synchronously force layout to put elements into a certain state
function forceReflow() {
    return document.body.offsetHeight;
}
const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = {
    name: 'TransitionGroup',
    props: /*#__PURE__*/ _shared.extend({
    }, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup (props, { slots  }) {
        const instance = _runtimeCore.getCurrentInstance();
        const state = _runtimeCore.useTransitionState();
        let prevChildren;
        let children;
        _runtimeCore.onUpdated(()=>{
            // children is guaranteed to exist after initial render
            if (!prevChildren.length) return;
            const moveClass = props.moveClass || `${props.name || 'v'}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) return;
            // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            // force reflow to put everything in position
            forceReflow();
            movedChildren.forEach((c)=>{
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = '';
                const cb = el._moveCb = (e)=>{
                    if (e && e.target !== el) return;
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener('transitionend', cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                };
                el.addEventListener('transitionend', cb);
            });
        });
        return ()=>{
            const rawProps = _runtimeCore.toRaw(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || _runtimeCore.Fragment;
            prevChildren = children;
            children = slots.default ? _runtimeCore.getTransitionRawChildren(slots.default()) : [];
            for(let i = 0; i < children.length; i++){
                const child = children[i];
                if (child.key != null) _runtimeCore.setTransitionHooks(child, _runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance));
                else _runtimeCore.warn(`<TransitionGroup> children must be keyed.`);
            }
            if (prevChildren) for(let i1 = 0; i1 < prevChildren.length; i1++){
                const child = prevChildren[i1];
                _runtimeCore.setTransitionHooks(child, _runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance));
                positionMap.set(child, child.el.getBoundingClientRect());
            }
            return _runtimeCore.createVNode(tag, null, children);
        };
    }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) el._moveCb();
    if (el._enterCb) el._enterCb();
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    // Detect whether an element with the move class applied has
    // CSS transitions. Since the element may be inside an entering
    // transition at this very moment, we make a clone of it and remove
    // all other transition classes applied to ensure only the move class
    // is applied.
    const clone = el.cloneNode();
    if (el._vtc) el._vtc.forEach((cls)=>{
        cls.split(/\s+/).forEach((c)=>c && clone.classList.remove(c)
        );
    });
    moveClass.split(/\s+/).forEach((c)=>c && clone.classList.add(c)
    );
    clone.style.display = 'none';
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform  } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}
const getModelAssigner = (vnode)=>{
    const fn = vnode.props['onUpdate:modelValue'];
    return _shared.isArray(fn) ? (value)=>_shared.invokeArrayFns(fn, value)
     : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        trigger(target, 'input');
    }
}
function trigger(el, type) {
    const e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}
// We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.
const vModelText = {
    created (el, { modifiers: { lazy , trim , number  }  }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === 'number';
        addEventListener(el, lazy ? 'change' : 'input', (e)=>{
            if (e.target.composing) return;
            let domValue = el.value;
            if (trim) domValue = domValue.trim();
            else if (castToNumber) domValue = _shared.toNumber(domValue);
            el._assign(domValue);
        });
        if (trim) addEventListener(el, 'change', ()=>{
            el.value = el.value.trim();
        });
        if (!lazy) {
            addEventListener(el, 'compositionstart', onCompositionStart);
            addEventListener(el, 'compositionend', onCompositionEnd);
            // Safari < 10.2 & UIWebView doesn't fire compositionend when
            // switching focus before confirming composition choice
            // this also fixes the issue where some browsers e.g. iOS Chrome
            // fires "change" instead of "input" on autocomplete.
            addEventListener(el, 'change', onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted (el, { value  }) {
        el.value = value == null ? '' : value;
    },
    beforeUpdate (el, { value , modifiers: { lazy , trim , number  }  }, vnode) {
        el._assign = getModelAssigner(vnode);
        // avoid clearing unresolved text. #2302
        if (el.composing) return;
        if (document.activeElement === el) {
            if (lazy) return;
            if (trim && el.value.trim() === value) return;
            if ((number || el.type === 'number') && _shared.toNumber(el.value) === value) return;
        }
        const newValue = value == null ? '' : value;
        if (el.value !== newValue) el.value = newValue;
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created (el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', ()=>{
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if (_shared.isArray(modelValue)) {
                const index = _shared.looseIndexOf(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) assign(modelValue.concat(elementValue));
                else if (!checked && found) {
                    const filtered = [
                        ...modelValue
                    ];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            } else if (_shared.isSet(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) cloned.add(elementValue);
                else cloned.delete(elementValue);
                assign(cloned);
            } else assign(getCheckboxValue(el, checked));
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate (el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value , oldValue  }, vnode) {
    el._modelValue = value;
    if (_shared.isArray(value)) el.checked = _shared.looseIndexOf(value, vnode.props.value) > -1;
    else if (_shared.isSet(value)) el.checked = value.has(vnode.props.value);
    else if (value !== oldValue) el.checked = _shared.looseEqual(value, getCheckboxValue(el, true));
}
const vModelRadio = {
    created (el, { value  }, vnode) {
        el.checked = _shared.looseEqual(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', ()=>{
            el._assign(getValue(el));
        });
    },
    beforeUpdate (el, { value , oldValue  }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) el.checked = _shared.looseEqual(value, vnode.props.value);
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created (el, { value , modifiers: { number  }  }, vnode) {
        const isSetModel = _shared.isSet(value);
        addEventListener(el, 'change', ()=>{
            const selectedVal = Array.prototype.filter.call(el.options, (o)=>o.selected
            ).map((o)=>number ? _shared.toNumber(getValue(o)) : getValue(o)
            );
            el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted (el, { value  }) {
        setSelected(el, value);
    },
    beforeUpdate (el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated (el, { value  }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !_shared.isArray(value) && !_shared.isSet(value)) {
        _runtimeCore.warn(`<select multiple v-model> expects an Array or Set value for its binding, ` + `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for(let i = 0, l = el.options.length; i < l; i++){
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if (_shared.isArray(value)) option.selected = _shared.looseIndexOf(value, optionValue) > -1;
            else option.selected = value.has(optionValue);
        } else if (_shared.looseEqual(getValue(option), value)) {
            if (el.selectedIndex !== i) el.selectedIndex = i;
            return;
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) el.selectedIndex = -1;
}
// retrieve raw value set via :value bindings
function getValue(el) {
    return '_value' in el ? el._value : el.value;
}
// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
function getCheckboxValue(el, checked) {
    const key = checked ? '_trueValue' : '_falseValue';
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'created');
    },
    mounted (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'mounted');
    },
    beforeUpdate (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
    },
    updated (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'updated');
    }
};
function callModelHook(el, binding, vnode, prevVNode, hook) {
    let modelToUse;
    switch(el.tagName){
        case 'SELECT':
            modelToUse = vModelSelect;
            break;
        case 'TEXTAREA':
            modelToUse = vModelText;
            break;
        default:
            switch(vnode.props && vnode.props.type){
                case 'checkbox':
                    modelToUse = vModelCheckbox;
                    break;
                case 'radio':
                    modelToUse = vModelRadio;
                    break;
                default:
                    modelToUse = vModelText;
            }
    }
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value  })=>({
            value
        })
    ;
    vModelRadio.getSSRProps = ({ value  }, vnode)=>{
        if (vnode.props && _shared.looseEqual(vnode.props.value, value)) return {
            checked: true
        };
    };
    vModelCheckbox.getSSRProps = ({ value  }, vnode)=>{
        if (_shared.isArray(value)) {
            if (vnode.props && _shared.looseIndexOf(value, vnode.props.value) > -1) return {
                checked: true
            };
        } else if (_shared.isSet(value)) {
            if (vnode.props && value.has(vnode.props.value)) return {
                checked: true
            };
        } else if (value) return {
            checked: true
        };
    };
}
const systemModifiers = [
    'ctrl',
    'shift',
    'alt',
    'meta'
];
const modifierGuards = {
    stop: (e)=>e.stopPropagation()
    ,
    prevent: (e)=>e.preventDefault()
    ,
    self: (e)=>e.target !== e.currentTarget
    ,
    ctrl: (e)=>!e.ctrlKey
    ,
    shift: (e)=>!e.shiftKey
    ,
    alt: (e)=>!e.altKey
    ,
    meta: (e)=>!e.metaKey
    ,
    left: (e)=>'button' in e && e.button !== 0
    ,
    middle: (e)=>'button' in e && e.button !== 1
    ,
    right: (e)=>'button' in e && e.button !== 2
    ,
    exact: (e, modifiers)=>systemModifiers.some((m)=>e[`${m}Key`] && !modifiers.includes(m)
        )
};
/**
 * @private
 */ const withModifiers = (fn, modifiers)=>{
    return (event, ...args)=>{
        for(let i = 0; i < modifiers.length; i++){
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers)) return;
        }
        return fn(event, ...args);
    };
};
// Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.
const keyNames = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace'
};
/**
 * @private
 */ const withKeys = (fn, modifiers)=>{
    return (event)=>{
        if (!('key' in event)) return;
        const eventKey = _shared.hyphenate(event.key);
        if (modifiers.some((k)=>k === eventKey || keyNames[k] === eventKey
        )) return fn(event);
    };
};
const vShow = {
    beforeMount (el, { value  }, { transition  }) {
        el._vod = el.style.display === 'none' ? '' : el.style.display;
        if (transition && value) transition.beforeEnter(el);
        else setDisplay(el, value);
    },
    mounted (el, { value  }, { transition  }) {
        if (transition && value) transition.enter(el);
    },
    updated (el, { value , oldValue  }, { transition  }) {
        if (!value === !oldValue) return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            } else transition.leave(el, ()=>{
                setDisplay(el, false);
            });
        } else setDisplay(el, value);
    },
    beforeUnmount (el, { value  }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : 'none';
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVShowForSSR() {
    vShow.getSSRProps = ({ value  })=>{
        if (!value) return {
            style: {
                display: 'none'
            }
        };
    };
}
const rendererOptions = _shared.extend({
    patchProp
}, nodeOps);
// lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return renderer || (renderer = _runtimeCore.createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration ? renderer : _runtimeCore.createHydrationRenderer(rendererOptions);
    enabledHydration = true;
    return renderer;
}
// use explicit type casts here to avoid import() calls in rolled-up d.ts
const render = (...args)=>{
    ensureRenderer().render(...args);
};
const hydrate = (...args)=>{
    ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args)=>{
    const app = ensureRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount  } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app._component;
        if (!_shared.isFunction(component) && !component.render && !component.template) // __UNSAFE__
        // Reason: potential execution of JS expressions in in-DOM template.
        // The user must make sure the in-DOM template is trusted. If it's
        // rendered by the server, the template should not contain any user data.
        component.template = container.innerHTML;
        // clear content before mounting
        container.innerHTML = '';
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
            container.removeAttribute('v-cloak');
            container.setAttribute('data-v-app', '');
        }
        return proxy;
    };
    return app;
};
const createSSRApp = (...args)=>{
    const app = ensureHydrationRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount  } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (container) return mount(container, true, container instanceof SVGElement);
    };
    return app;
};
function injectNativeTagCheck(app) {
    // Inject `isNativeTag`
    // this is used for component name validation (dev only)
    Object.defineProperty(app.config, 'isNativeTag', {
        value: (tag)=>_shared.isHTMLTag(tag) || _shared.isSVGTag(tag)
        ,
        writable: false
    });
}
// dev only
function injectCompilerOptionsCheck(app) {
    if (_runtimeCore.isRuntimeOnly()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, 'isCustomElement', {
            get () {
                return isCustomElement;
            },
            set () {
                _runtimeCore.warn(`The \`isCustomElement\` config option is deprecated. Use ` + `\`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using ` + `a build of Vue.js that includes the runtime compiler (aka "full build"). ` + `Since you are using the runtime-only build, \`compilerOptions\` ` + `must be passed to \`@vue/compiler-dom\` in the build setup instead.\n` + `- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.\n` + `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` + `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
        Object.defineProperty(app.config, 'compilerOptions', {
            get () {
                _runtimeCore.warn(msg);
                return compilerOptions;
            },
            set () {
                _runtimeCore.warn(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if (_shared.isString(container)) {
        const res = document.querySelector(container);
        if (!res) _runtimeCore.warn(`Failed to mount app: mount target selector "${container}" returned null.`);
        return res;
    }
    if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === 'closed') _runtimeCore.warn(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    return container;
}
let ssrDirectiveInitialized = false;
/**
 * @internal
 */ const initDirectivesForSSR = ()=>{
    if (!ssrDirectiveInitialized) {
        ssrDirectiveInitialized = true;
        initVModelForSSR();
        initVShowForSSR();
    }
};

},{"@vue/runtime-core":"lmqBl","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lmqBl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>_reactivity.EffectScope
);
parcelHelpers.export(exports, "ReactiveEffect", ()=>_reactivity.ReactiveEffect
);
parcelHelpers.export(exports, "customRef", ()=>_reactivity.customRef
);
parcelHelpers.export(exports, "effect", ()=>_reactivity.effect
);
parcelHelpers.export(exports, "effectScope", ()=>_reactivity.effectScope
);
parcelHelpers.export(exports, "getCurrentScope", ()=>_reactivity.getCurrentScope
);
parcelHelpers.export(exports, "isProxy", ()=>_reactivity.isProxy
);
parcelHelpers.export(exports, "isReactive", ()=>_reactivity.isReactive
);
parcelHelpers.export(exports, "isReadonly", ()=>_reactivity.isReadonly
);
parcelHelpers.export(exports, "isRef", ()=>_reactivity.isRef
);
parcelHelpers.export(exports, "isShallow", ()=>_reactivity.isShallow
);
parcelHelpers.export(exports, "markRaw", ()=>_reactivity.markRaw
);
parcelHelpers.export(exports, "onScopeDispose", ()=>_reactivity.onScopeDispose
);
parcelHelpers.export(exports, "proxyRefs", ()=>_reactivity.proxyRefs
);
parcelHelpers.export(exports, "reactive", ()=>_reactivity.reactive
);
parcelHelpers.export(exports, "readonly", ()=>_reactivity.readonly
);
parcelHelpers.export(exports, "ref", ()=>_reactivity.ref
);
parcelHelpers.export(exports, "shallowReactive", ()=>_reactivity.shallowReactive
);
parcelHelpers.export(exports, "shallowReadonly", ()=>_reactivity.shallowReadonly
);
parcelHelpers.export(exports, "shallowRef", ()=>_reactivity.shallowRef
);
parcelHelpers.export(exports, "stop", ()=>_reactivity.stop
);
parcelHelpers.export(exports, "toRaw", ()=>_reactivity.toRaw
);
parcelHelpers.export(exports, "toRef", ()=>_reactivity.toRef
);
parcelHelpers.export(exports, "toRefs", ()=>_reactivity.toRefs
);
parcelHelpers.export(exports, "triggerRef", ()=>_reactivity.triggerRef
);
parcelHelpers.export(exports, "unref", ()=>_reactivity.unref
);
parcelHelpers.export(exports, "camelize", ()=>_shared.camelize
);
parcelHelpers.export(exports, "capitalize", ()=>_shared.capitalize
);
parcelHelpers.export(exports, "normalizeClass", ()=>_shared.normalizeClass
);
parcelHelpers.export(exports, "normalizeProps", ()=>_shared.normalizeProps
);
parcelHelpers.export(exports, "normalizeStyle", ()=>_shared.normalizeStyle
);
parcelHelpers.export(exports, "toDisplayString", ()=>_shared.toDisplayString
);
parcelHelpers.export(exports, "toHandlerKey", ()=>_shared.toHandlerKey
);
parcelHelpers.export(exports, "BaseTransition", ()=>BaseTransition
);
parcelHelpers.export(exports, "Comment", ()=>Comment
);
parcelHelpers.export(exports, "Fragment", ()=>Fragment
);
parcelHelpers.export(exports, "KeepAlive", ()=>KeepAlive
);
parcelHelpers.export(exports, "Static", ()=>Static
);
parcelHelpers.export(exports, "Suspense", ()=>Suspense
);
parcelHelpers.export(exports, "Teleport", ()=>Teleport
);
parcelHelpers.export(exports, "Text", ()=>Text
);
parcelHelpers.export(exports, "callWithAsyncErrorHandling", ()=>callWithAsyncErrorHandling
);
parcelHelpers.export(exports, "callWithErrorHandling", ()=>callWithErrorHandling
);
parcelHelpers.export(exports, "cloneVNode", ()=>cloneVNode
);
parcelHelpers.export(exports, "compatUtils", ()=>compatUtils
);
parcelHelpers.export(exports, "computed", ()=>computed
);
parcelHelpers.export(exports, "createBlock", ()=>createBlock
);
parcelHelpers.export(exports, "createCommentVNode", ()=>createCommentVNode
);
parcelHelpers.export(exports, "createElementBlock", ()=>createElementBlock
);
parcelHelpers.export(exports, "createElementVNode", ()=>createBaseVNode
);
parcelHelpers.export(exports, "createHydrationRenderer", ()=>createHydrationRenderer
);
parcelHelpers.export(exports, "createPropsRestProxy", ()=>createPropsRestProxy
);
parcelHelpers.export(exports, "createRenderer", ()=>createRenderer
);
parcelHelpers.export(exports, "createSlots", ()=>createSlots
);
parcelHelpers.export(exports, "createStaticVNode", ()=>createStaticVNode
);
parcelHelpers.export(exports, "createTextVNode", ()=>createTextVNode
);
parcelHelpers.export(exports, "createVNode", ()=>createVNode
);
parcelHelpers.export(exports, "defineAsyncComponent", ()=>defineAsyncComponent
);
parcelHelpers.export(exports, "defineComponent", ()=>defineComponent
);
parcelHelpers.export(exports, "defineEmits", ()=>defineEmits
);
parcelHelpers.export(exports, "defineExpose", ()=>defineExpose
);
parcelHelpers.export(exports, "defineProps", ()=>defineProps
);
parcelHelpers.export(exports, "devtools", ()=>devtools
);
parcelHelpers.export(exports, "getCurrentInstance", ()=>getCurrentInstance
);
parcelHelpers.export(exports, "getTransitionRawChildren", ()=>getTransitionRawChildren
);
parcelHelpers.export(exports, "guardReactiveProps", ()=>guardReactiveProps
);
parcelHelpers.export(exports, "h", ()=>h
);
parcelHelpers.export(exports, "handleError", ()=>handleError
);
parcelHelpers.export(exports, "initCustomFormatter", ()=>initCustomFormatter
);
parcelHelpers.export(exports, "inject", ()=>inject
);
parcelHelpers.export(exports, "isMemoSame", ()=>isMemoSame
);
parcelHelpers.export(exports, "isRuntimeOnly", ()=>isRuntimeOnly
);
parcelHelpers.export(exports, "isVNode", ()=>isVNode
);
parcelHelpers.export(exports, "mergeDefaults", ()=>mergeDefaults
);
parcelHelpers.export(exports, "mergeProps", ()=>mergeProps
);
parcelHelpers.export(exports, "nextTick", ()=>nextTick
);
parcelHelpers.export(exports, "onActivated", ()=>onActivated
);
parcelHelpers.export(exports, "onBeforeMount", ()=>onBeforeMount
);
parcelHelpers.export(exports, "onBeforeUnmount", ()=>onBeforeUnmount
);
parcelHelpers.export(exports, "onBeforeUpdate", ()=>onBeforeUpdate
);
parcelHelpers.export(exports, "onDeactivated", ()=>onDeactivated
);
parcelHelpers.export(exports, "onErrorCaptured", ()=>onErrorCaptured
);
parcelHelpers.export(exports, "onMounted", ()=>onMounted
);
parcelHelpers.export(exports, "onRenderTracked", ()=>onRenderTracked
);
parcelHelpers.export(exports, "onRenderTriggered", ()=>onRenderTriggered
);
parcelHelpers.export(exports, "onServerPrefetch", ()=>onServerPrefetch
);
parcelHelpers.export(exports, "onUnmounted", ()=>onUnmounted
);
parcelHelpers.export(exports, "onUpdated", ()=>onUpdated
);
parcelHelpers.export(exports, "openBlock", ()=>openBlock
);
parcelHelpers.export(exports, "popScopeId", ()=>popScopeId
);
parcelHelpers.export(exports, "provide", ()=>provide
);
parcelHelpers.export(exports, "pushScopeId", ()=>pushScopeId
);
parcelHelpers.export(exports, "queuePostFlushCb", ()=>queuePostFlushCb
);
parcelHelpers.export(exports, "registerRuntimeCompiler", ()=>registerRuntimeCompiler
);
parcelHelpers.export(exports, "renderList", ()=>renderList
);
parcelHelpers.export(exports, "renderSlot", ()=>renderSlot
);
parcelHelpers.export(exports, "resolveComponent", ()=>resolveComponent
);
parcelHelpers.export(exports, "resolveDirective", ()=>resolveDirective
);
parcelHelpers.export(exports, "resolveDynamicComponent", ()=>resolveDynamicComponent
);
parcelHelpers.export(exports, "resolveFilter", ()=>resolveFilter
);
parcelHelpers.export(exports, "resolveTransitionHooks", ()=>resolveTransitionHooks
);
parcelHelpers.export(exports, "setBlockTracking", ()=>setBlockTracking
);
parcelHelpers.export(exports, "setDevtoolsHook", ()=>setDevtoolsHook
);
parcelHelpers.export(exports, "setTransitionHooks", ()=>setTransitionHooks
);
parcelHelpers.export(exports, "ssrContextKey", ()=>ssrContextKey
);
parcelHelpers.export(exports, "ssrUtils", ()=>ssrUtils
);
parcelHelpers.export(exports, "toHandlers", ()=>toHandlers
);
parcelHelpers.export(exports, "transformVNodeArgs", ()=>transformVNodeArgs
);
parcelHelpers.export(exports, "useAttrs", ()=>useAttrs
);
parcelHelpers.export(exports, "useSSRContext", ()=>useSSRContext
);
parcelHelpers.export(exports, "useSlots", ()=>useSlots
);
parcelHelpers.export(exports, "useTransitionState", ()=>useTransitionState
);
parcelHelpers.export(exports, "version", ()=>version
);
parcelHelpers.export(exports, "warn", ()=>warn
);
parcelHelpers.export(exports, "watch", ()=>watch
);
parcelHelpers.export(exports, "watchEffect", ()=>watchEffect
);
parcelHelpers.export(exports, "watchPostEffect", ()=>watchPostEffect
);
parcelHelpers.export(exports, "watchSyncEffect", ()=>watchSyncEffect
);
parcelHelpers.export(exports, "withAsyncContext", ()=>withAsyncContext
);
parcelHelpers.export(exports, "withCtx", ()=>withCtx
);
parcelHelpers.export(exports, "withDefaults", ()=>withDefaults
);
parcelHelpers.export(exports, "withDirectives", ()=>withDirectives
);
parcelHelpers.export(exports, "withMemo", ()=>withMemo
);
parcelHelpers.export(exports, "withScopeId", ()=>withScopeId
);
var _reactivity = require("@vue/reactivity");
var _shared = require("@vue/shared");
const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn(msg, ...args) {
    // avoid props formatting or warn handler tracking deps that might be mutated
    // during patch, leading to infinite recursion.
    _reactivity.pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */ , [
        msg + args.join(''),
        instance && instance.proxy,
        trace.map(({ vnode  })=>`at <${formatComponentName(instance, vnode.type)}>`
        ).join('\n'),
        trace
    ]);
    else {
        const warnArgs = [
            `[Vue warn]: ${msg}`,
            ...args
        ];
        /* istanbul ignore if */ if (trace.length && // avoid spamming console during tests
        true) warnArgs.push(`\n`, ...formatTrace(trace));
        console.warn(...warnArgs);
    }
    _reactivity.resetTracking();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) return [];
    // we can't just use the stack because it will be incomplete during updates
    // that did not start from the root. Re-construct the parent chain using
    // instance parent pointers.
    const normalizedStack = [];
    while(currentVNode){
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) last.recurseCount++;
        else normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
        });
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
/* istanbul ignore next */ function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i)=>{
        logs.push(...i === 0 ? [] : [
            `\n`
        ], ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode , recurseCount  }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props ? [
        open,
        ...formatProps(vnode.props),
        close
    ] : [
        open + close
    ];
}
/* istanbul ignore next */ function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key)=>{
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) res.push(` ...`);
    return res;
}
/* istanbul ignore next */ function formatProp(key, value, raw) {
    if (_shared.isString(value)) {
        value = JSON.stringify(value);
        return raw ? value : [
            `${key}=${value}`
        ];
    } else if (typeof value === 'number' || typeof value === 'boolean' || value == null) return raw ? value : [
        `${key}=${value}`
    ];
    else if (_reactivity.isRef(value)) {
        value = formatProp(key, _reactivity.toRaw(value.value), true);
        return raw ? value : [
            `${key}=Ref<`,
            value,
            `>`
        ];
    } else if (_shared.isFunction(value)) return [
        `${key}=fn${value.name ? `<${value.name}>` : ``}`
    ];
    else {
        value = _reactivity.toRaw(value);
        return raw ? value : [
            `${key}=`,
            value
        ];
    }
}
const ErrorTypeStrings = {
    ["sp" /* SERVER_PREFETCH */ ]: 'serverPrefetch hook',
    ["bc" /* BEFORE_CREATE */ ]: 'beforeCreate hook',
    ["c" /* CREATED */ ]: 'created hook',
    ["bm" /* BEFORE_MOUNT */ ]: 'beforeMount hook',
    ["m" /* MOUNTED */ ]: 'mounted hook',
    ["bu" /* BEFORE_UPDATE */ ]: 'beforeUpdate hook',
    ["u" /* UPDATED */ ]: 'updated',
    ["bum" /* BEFORE_UNMOUNT */ ]: 'beforeUnmount hook',
    ["um" /* UNMOUNTED */ ]: 'unmounted hook',
    ["a" /* ACTIVATED */ ]: 'activated hook',
    ["da" /* DEACTIVATED */ ]: 'deactivated hook',
    ["ec" /* ERROR_CAPTURED */ ]: 'errorCaptured hook',
    ["rtc" /* RENDER_TRACKED */ ]: 'renderTracked hook',
    ["rtg" /* RENDER_TRIGGERED */ ]: 'renderTriggered hook',
    [0 /* SETUP_FUNCTION */ ]: 'setup function',
    [1 /* RENDER_FUNCTION */ ]: 'render function',
    [2 /* WATCH_GETTER */ ]: 'watcher getter',
    [3 /* WATCH_CALLBACK */ ]: 'watcher callback',
    [4 /* WATCH_CLEANUP */ ]: 'watcher cleanup function',
    [5 /* NATIVE_EVENT_HANDLER */ ]: 'native event handler',
    [6 /* COMPONENT_EVENT_HANDLER */ ]: 'component event handler',
    [7 /* VNODE_HOOK */ ]: 'vnode hook',
    [8 /* DIRECTIVE_HOOK */ ]: 'directive hook',
    [9 /* TRANSITION_HOOK */ ]: 'transition hook',
    [10 /* APP_ERROR_HANDLER */ ]: 'app errorHandler',
    [11 /* APP_WARN_HANDLER */ ]: 'app warnHandler',
    [12 /* FUNCTION_REF */ ]: 'ref function',
    [13 /* ASYNC_COMPONENT_LOADER */ ]: 'async component loader',
    [14 /* SCHEDULER */ ]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    } catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (_shared.isFunction(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && _shared.isPromise(res)) res.catch((err)=>{
            handleError(err, instance, type);
        });
        return res;
    }
    const values = [];
    for(let i = 0; i < fn.length; i++)values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        // the exposed instance is the render proxy to keep it consistent with 2.x
        const exposedInstance = instance.proxy;
        // in production the hook receives only the error code
        const errorInfo = ErrorTypeStrings[type];
        while(cur){
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) for(let i = 0; i < errorCapturedHooks.length; i++){
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) return;
            }
            cur = cur.parent;
        }
        // app-level handling
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */ , [
                err,
                exposedInstance,
                errorInfo
            ]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    {
        const info = ErrorTypeStrings[type];
        if (contextVNode) pushWarningContext(contextVNode);
        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) popWarningContext();
        // crash in dev by default so it's more noticeable
        if (throwInDev) throw err;
        else console.error(err);
    }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
// #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.
function findInsertionIndex(id) {
    // the start index should be `flushIndex + 1`
    let start = flushIndex + 1;
    let end = queue.length;
    while(start < end){
        const middle = start + end >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id ? start = middle + 1 : end = middle;
    }
    return start;
}
function queueJob(job) {
    // the dedupe search uses the startIndex argument of Array.includes()
    // by default the search index includes the current job that is being run
    // so it cannot recursively trigger itself again.
    // if the job is a watch() callback, the search will start with a +1 index to
    // allow it recursively trigger itself - it is the user's responsibility to
    // ensure it doesn't end up in an infinite loop.
    if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
        if (job.id == null) queue.push(job);
        else queue.splice(findInsertionIndex(job.id), 0, job);
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) queue.splice(i, 1);
}
function queueCb(cb, activeQueue, pendingQueue, index) {
    if (!_shared.isArray(cb)) {
        if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) pendingQueue.push(cb);
    } else // if cb is an array, it is a component lifecycle hook which can only be
    // triggered by a job, which is already deduped in the main queue, so
    // we can skip duplicate check here to improve perf
    pendingQueue.push(...cb);
    queueFlush();
}
function queuePreFlushCb(cb) {
    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
    if (pendingPreFlushCbs.length) {
        currentPreFlushParentJob = parentJob;
        activePreFlushCbs = [
            ...new Set(pendingPreFlushCbs)
        ];
        pendingPreFlushCbs.length = 0;
        seen = seen || new Map();
        for(preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++){
            if (checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) continue;
            activePreFlushCbs[preFlushIndex]();
        }
        activePreFlushCbs = null;
        preFlushIndex = 0;
        currentPreFlushParentJob = null;
        // recursively flush until it drains
        flushPreFlushCbs(seen, parentJob);
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [
            ...new Set(pendingPostFlushCbs)
        ];
        pendingPostFlushCbs.length = 0;
        // #1947 already has active queue, nested flushPostFlushCbs call
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        seen = seen || new Map();
        activePostFlushCbs.sort((a, b)=>getId(a) - getId(b)
        );
        for(postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++){
            if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) continue;
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job)=>job.id == null ? Infinity : job.id
;
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    seen = seen || new Map();
    flushPreFlushCbs(seen);
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child so its render effect will have smaller
    //    priority number)
    // 2. If a component is unmounted during a parent component's update,
    //    its update can be skipped.
    queue.sort((a, b)=>getId(a) - getId(b)
    );
    // conditional usage of checkRecursiveUpdate must be determined out of
    // try ... catch block since Rollup by default de-optimizes treeshaking
    // inside try-catch. This can leave all warning code unshaked. Although
    // they would get eventually shaken by a minifier like terser, some minifiers
    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
    const check = (job)=>checkRecursiveUpdates(seen, job)
    ;
    try {
        for(flushIndex = 0; flushIndex < queue.length; flushIndex++){
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (check(job)) continue;
                // console.log(`running:`, job.id)
                callWithErrorHandling(job, null, 14 /* SCHEDULER */ );
            }
        }
    } finally{
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        // some postFlushCb queued jobs!
        // keep flushing until it drains.
        if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) flushJobs(seen);
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) seen.set(fn, 1);
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` + `This means you have a reactive effect that is mutating its own ` + `dependencies and thus recursively triggering itself. Possible sources ` + `include component template, render function, updated hook or ` + `watcher source function.`);
            return true;
        } else seen.set(fn, count + 1);
    }
}
/* eslint-disable no-restricted-globals */ let isHmrUpdating = false;
const hmrDirtyComponents = new Set();
_shared.getGlobalThis().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
};
const map = new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) return false;
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) return;
    // update initial record (for not-yet-rendered component)
    record.initialDef.render = newRender;
    [
        ...record.instances
    ].forEach((instance)=>{
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        // this flag forces child components with slot content to update
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record) return;
    newComp = normalizeClassComponent(newComp);
    // update initial def (for not-yet-rendered components)
    updateComponentDef(record.initialDef, newComp);
    // create a snapshot which avoids the set being mutated during updates
    const instances = [
        ...record.instances
    ];
    for (const instance1 of instances){
        const oldComp = normalizeClassComponent(instance1.type);
        if (!hmrDirtyComponents.has(oldComp)) {
            // 1. Update existing comp definition to match new one
            if (oldComp !== record.initialDef) updateComponentDef(oldComp, newComp);
            // 2. mark definition dirty. This forces the renderer to replace the
            // component on patch.
            hmrDirtyComponents.add(oldComp);
        }
        // 3. invalidate options resolution cache
        instance1.appContext.optionsCache.delete(instance1.type);
        // 4. actually update
        if (instance1.ceReload) {
            // custom element
            hmrDirtyComponents.add(oldComp);
            instance1.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
        } else if (instance1.parent) {
            // 4. Force the parent instance to re-render. This will cause all updated
            // components to be unmounted and re-mounted. Queue the update so that we
            // don't end up forcing the same parent to re-render multiple times.
            queueJob(instance1.parent.update);
            // instance is the inner component of an async custom element
            // invoke to reset styles
            if (instance1.parent.type.__asyncLoader && instance1.parent.ceReload) instance1.parent.ceReload(newComp.styles);
        } else if (instance1.appContext.reload) // root instance mounted via createApp() has a reload method
        instance1.appContext.reload();
        else if (typeof window !== 'undefined') // root instance inside tree created via raw render(). Force reload.
        window.location.reload();
        else console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
    }
    // 5. make sure to cleanup dirty hmr components after update
    queuePostFlushCb(()=>{
        for (const instance of instances)hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    });
}
function updateComponentDef(oldComp, newComp) {
    _shared.extend(oldComp, newComp);
    for(const key in oldComp)if (key !== '__file' && !(key in newComp)) delete oldComp[key];
}
function tryWrap(fn) {
    return (id, arg)=>{
        try {
            return fn(id, arg);
        } catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` + `Full reload required.`);
        }
    };
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit(event, ...args) {
    if (devtools) devtools.emit(event, ...args);
    else if (!devtoolsNotInstalled) buffer.push({
        event,
        args
    });
}
function setDevtoolsHook(hook, target) {
    var _a, _b;
    devtools = hook;
    if (devtools) {
        devtools.enabled = true;
        buffer.forEach(({ event , args  })=>devtools.emit(event, ...args)
        );
        buffer = [];
    } else if (// handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    // eslint-disable-next-line no-restricted-globals
    typeof window !== 'undefined' && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook)=>{
            setDevtoolsHook(newHook, target);
        });
        // clear buffer after 3s - the user probably doesn't have devtools installed
        // at all, and keeping the buffer will cause memory leaks (#4738)
        setTimeout(()=>{
            if (!devtools) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3000);
    } else {
        // non-browser env, assume not installed
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version1) {
    emit("app:init" /* APP_INIT */ , app, version1, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    emit("app:unmount" /* APP_UNMOUNT */ , app);
}
const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */ );
const devtoolsComponentUpdated = /*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */ );
const devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */ );
function createDevtoolsComponentHook(hook) {
    return (component)=>{
        emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
    };
}
const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */ );
const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */ );
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time)=>{
        emit(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit("component:emit" /* COMPONENT_EMIT */ , component.appContext.app, component, event, params);
}
function emit$1(instance, event, ...rawArgs) {
    const props = instance.vnode.props || _shared.EMPTY_OBJ;
    {
        const { emitsOptions , propsOptions: [propsOptions]  } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) && true) {
                if (!propsOptions || !(_shared.toHandlerKey(event) in propsOptions)) warn(`Component emitted event "${event}" but it is neither declared in ` + `the emits option nor as an "${_shared.toHandlerKey(event)}" prop.`);
            } else {
                const validator = emitsOptions[event];
                if (_shared.isFunction(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) warn(`Invalid event arguments: event validation failed for event "${event}".`);
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith('update:');
    // for v-model update:xxx events, apply modifiers on args
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
        const { number , trim  } = props[modifiersKey] || _shared.EMPTY_OBJ;
        if (trim) args = rawArgs.map((a)=>a.trim()
        );
        else if (number) args = rawArgs.map(_shared.toNumber);
    }
    devtoolsComponentEmit(instance, event, args);
    {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[_shared.toHandlerKey(lowerCaseEvent)]) warn(`Event "${lowerCaseEvent}" is emitted in component ` + `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use "${_shared.hyphenate(event)}" instead of "${event}".`);
    }
    let handlerName;
    let handler = props[handlerName = _shared.toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = _shared.toHandlerKey(_shared.camelize(event))];
    // for v-model update:xxx events, also trigger kebab-case equivalent
    // for props passed via kebab-case
    if (!handler && isModelListener) handler = props[handlerName = _shared.toHandlerKey(_shared.hyphenate(event))];
    if (handler) callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */ , args);
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) instance.emitted = {
        };
        else if (instance.emitted[handlerName]) return;
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */ , args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== undefined) return cached;
    const raw1 = comp.emits;
    let normalized = {
    };
    // apply mixin/extends props
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !_shared.isFunction(comp)) {
        const extendEmits = (raw)=>{
            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                _shared.extend(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendEmits);
        if (comp.extends) extendEmits(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendEmits);
    }
    if (!raw1 && !hasExtends) {
        cache.set(comp, null);
        return null;
    }
    if (_shared.isArray(raw1)) raw1.forEach((key)=>normalized[key] = null
    );
    else _shared.extend(normalized, raw1);
    cache.set(comp, normalized);
    return normalized;
}
// Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.
function isEmitListener(options, key) {
    if (!options || !_shared.isOn(key)) return false;
    key = key.slice(2).replace(/Once$/, '');
    return _shared.hasOwn(options, key[0].toLowerCase() + key.slice(1)) || _shared.hasOwn(options, _shared.hyphenate(key)) || _shared.hasOwn(options, key);
}
/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */ let currentRenderingInstance = null;
let currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */ function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */ function pushScopeId(id) {
    currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */ function popScopeId() {
    currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */ const withScopeId = (_id)=>withCtx
;
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */ function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only
) {
    if (!ctx) return fn;
    // already normalized
    if (fn._n) return fn;
    const renderFnWithContext = (...args)=>{
        // If a user calls a compiled slot inside a template expression (#1745), it
        // can mess up block tracking, so by default we disable block tracking and
        // force bail out when invoking a compiled slot (indicated by the ._d flag).
        // This isn't necessary if rendering a compiled `<slot>`, so we flip the
        // ._d flag off when invoking the wrapped fn inside `renderSlot`.
        if (renderFnWithContext._d) setBlockTracking(-1);
        const prevInstance = setCurrentRenderingInstance(ctx);
        const res = fn(...args);
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) setBlockTracking(1);
        devtoolsComponentUpdated(ctx);
        return res;
    };
    // mark normalized to avoid duplicated wrapping
    renderFnWithContext._n = true;
    // mark this as compiled by default
    // this is used in vnode.ts -> normalizeChildren() to set the slot
    // rendering flag.
    renderFnWithContext._c = true;
    // disable block tracking by default
    renderFnWithContext._d = true;
    return renderFnWithContext;
}
/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */ let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component , vnode , proxy , withProxy , props , propsOptions: [propsOptions] , slots , attrs , emit: emit1 , render , renderCache , data , setupState , ctx , inheritAttrs  } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    accessedAttrs = false;
    try {
        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */ ) {
            // withProxy is a proxy with a different `has` trap only for
            // runtime-compiled render functions using `with` block.
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        } else {
            // functional
            const render = Component;
            // in dev, mark attrs accessed if optional props (attrs === props)
            if (attrs === props) markAttrsAccessed();
            result = normalizeVNode(render.length > 1 ? render(props, {
                get attrs () {
                    markAttrsAccessed();
                    return attrs;
                },
                slots,
                emit: emit1
            }) : render(props, null));
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
    } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1 /* RENDER_FUNCTION */ );
        result = createVNode(Comment);
    }
    // attr merging
    // in dev mode, comments are preserved, and it's possible for a template
    // to have comments along side the root element which makes it a fragment
    let root = result;
    let setRoot = undefined;
    if (result.patchFlag > 0 && result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */ ) [root, setRoot] = getChildRoot(result);
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag  } = root;
        if (keys.length) {
            if (shapeFlag & 7 /* COMPONENT */ ) {
                if (propsOptions && keys.some(_shared.isModelListener)) // If a v-model listener (onUpdate:xxx) has a corresponding declared
                // prop, it indicates this component expects to handle v-model and
                // it should not fallthrough.
                // related: #1543, #1643, #1989
                fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                root = cloneVNode(root, fallthroughAttrs);
            } else if (!accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for(let i = 0, l = allAttrs.length; i < l; i++){
                    const key = allAttrs[i];
                    if (_shared.isOn(key)) // ignore v-model handlers when they fail to fallthrough
                    {
                        if (!_shared.isModelListener(key)) // remove `on`, lowercase first letter to reflect event casing
                        // accurately
                        eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                    } else extraAttrs.push(key);
                }
                if (extraAttrs.length) warn(`Extraneous non-props attributes (` + `${extraAttrs.join(', ')}) ` + `were passed to component but could not be automatically inherited ` + `because component renders fragment or text root nodes.`);
                if (eventAttrs.length) warn(`Extraneous non-emits event listeners (` + `${eventAttrs.join(', ')}) ` + `were passed to component but could not be automatically inherited ` + `because component renders fragment or text root nodes. ` + `If the listener is intended to be a component custom event listener only, ` + `declare it using the "emits" option.`);
            }
        }
    }
    // inherit directives
    if (vnode.dirs) {
        if (!isElementRoot(root)) warn(`Runtime directive used on component with non-element root node. ` + `The directives will not function as intended.`);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    // inherit transition data
    if (vnode.transition) {
        if (!isElementRoot(root)) warn(`Component inside <Transition> renders non-element root node ` + `that cannot be animated.`);
        root.transition = vnode.transition;
    }
    if (setRoot) setRoot(root);
    else result = root;
    setCurrentRenderingInstance(prev);
    return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */ const getChildRoot = (vnode)=>{
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) return [
        vnode,
        undefined
    ];
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot)=>{
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) dynamicChildren[dynamicIndex] = updatedRoot;
            else if (updatedRoot.patchFlag > 0) vnode.dynamicChildren = [
                ...dynamicChildren,
                updatedRoot
            ];
        }
    };
    return [
        normalizeVNode(childRoot),
        setRoot
    ];
};
function filterSingleRoot(children) {
    let singleRoot;
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        if (isVNode(child)) // ignore user comment
        {
            if (child.type !== Comment || child.children === 'v-if') {
                if (singleRoot) // has more than 1 non-comment child, return now
                return;
                else singleRoot = child;
            }
        } else return;
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs)=>{
    let res;
    for(const key in attrs)if (key === 'class' || key === 'style' || _shared.isOn(key)) (res || (res = {
    }))[key] = attrs[key];
    return res;
};
const filterModelListeners = (attrs, props)=>{
    const res = {
    };
    for(const key in attrs)if (!_shared.isModelListener(key) || !(key.slice(9) in props)) res[key] = attrs[key];
    return res;
};
const isElementRoot = (vnode)=>{
    return vnode.shapeFlag & 7 /* ELEMENT */  || vnode.type === Comment // potential v-if branch switch
    ;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps , children: prevChildren , component  } = prevVNode;
    const { props: nextProps , children: nextChildren , patchFlag  } = nextVNode;
    const emits = component.emitsOptions;
    // Parent component's render function was hot-updated. Since this may have
    // caused the child component's slots content to have changed, we need to
    // force the child to update as well.
    if ((prevChildren || nextChildren) && isHmrUpdating) return true;
    // force child update for runtime directive or transition on component vnode.
    if (nextVNode.dirs || nextVNode.transition) return true;
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024 /* DYNAMIC_SLOTS */ ) // slot content that references values that might have changed,
        // e.g. in a v-for
        return true;
        if (patchFlag & 16 /* FULL_PROPS */ ) {
            if (!prevProps) return !!nextProps;
            // presence of this flag indicates props are always non-null
            return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8 /* PROPS */ ) {
            const dynamicProps = nextVNode.dynamicProps;
            for(let i = 0; i < dynamicProps.length; i++){
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) return true;
            }
        }
    } else {
        // this path is only taken by manually written render functions
        // so presence of any children leads to a forced update
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) return true;
        }
        if (prevProps === nextProps) return false;
        if (!prevProps) return !!nextProps;
        if (!nextProps) return true;
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) return true;
    for(let i = 0; i < nextKeys.length; i++){
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) return true;
    }
    return false;
}
function updateHOCHostEl({ vnode , parent  }, el // HostNode
) {
    while(parent && parent.subTree === vnode){
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}
const isSuspense = (type)=>type.__isSuspense
;
// Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.
const SuspenseImpl = {
    name: 'Suspense',
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, // platform-specific impl passed from renderer
    rendererInternals) {
        if (n1 == null) mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        else patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
// Force-casted public typing for h and TSX props inference
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if (_shared.isFunction(eventListener)) eventListener();
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch , o: { createElement  }  } = rendererInternals;
    const hiddenContainer = createElement('div');
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
    // start mounting the content subtree in an off-dom container
    patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    // now check if we have encountered any async deps
    if (suspense.deps > 0) {
        // has async
        // invoke @fallback event
        triggerEvent(vnode, 'onPending');
        triggerEvent(vnode, 'onFallback');
        // mount the fallback tree
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    } else // Suspense has no async deps. Just resolve.
    suspense.resolve();
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch , um: unmount , o: { createElement  }  }) {
    const suspense = n2.suspense = n1.suspense;
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch , pendingBranch , isInFallback , isHydrating  } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            // same root type but content may have changed.
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) suspense.resolve();
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, newFallback);
            }
        } else {
            // toggled before pending tree is resolved
            suspense.pendingId++;
            if (isHydrating) {
                // if toggled before hydration is finished, the current DOM tree is
                // no longer valid. set it as the active branch so it will be unmounted
                // when resolved
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            } else unmount(pendingBranch, parentComponent, suspense);
            // increment pending ID. this is used to invalidate async callbacks
            // reset suspense state
            suspense.deps = 0;
            // discard effects from pending branch
            suspense.effects.length = 0;
            // discard previous container
            suspense.hiddenContainer = createElement('div');
            if (isInFallback) {
                // already in fallback state
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                // toggled "back" to current active branch
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                // force resolve
                suspense.resolve(true);
            } else {
                // switched to a 3rd branch
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
            }
        }
    } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        // root did not change, just normal patch
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newBranch);
    } else {
        // root node toggled
        // invoke @pending event
        triggerEvent(n2, 'onPending');
        // mount pending branch in off-dom container
        suspense.pendingBranch = newBranch;
        suspense.pendingId++;
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) // incoming branch has no async deps, resolve now.
        suspense.resolve();
        else {
            const { timeout , pendingId  } = suspense;
            if (timeout > 0) setTimeout(()=>{
                if (suspense.pendingId === pendingId) suspense.fallback(newFallback);
            }, timeout);
            else if (timeout === 0) suspense.fallback(newFallback);
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode1, parent1, parentComponent1, container1, hiddenContainer, anchor1, isSVG1, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    /* istanbul ignore if */ if (!hasWarned) {
        hasWarned = true;
        // @ts-ignore `console.info` cannot be null error
        console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch , m: move , um: unmount , n: next , o: { parentNode , remove  }  } = rendererInternals;
    const timeout = _shared.toNumber(vnode1.props && vnode1.props.timeout);
    const suspense = {
        vnode: vnode1,
        parent: parent1,
        parentComponent: parentComponent1,
        isSVG: isSVG1,
        container: container1,
        hiddenContainer,
        anchor: anchor1,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === 'number' ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve (resume = false) {
            if (!resume && !suspense.pendingBranch) throw new Error(`suspense.resolve() is called without a pending branch.`);
            if (suspense.isUnmounted) throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
            const { vnode , activeBranch , pendingBranch , pendingId , effects , parentComponent , container  } = suspense;
            if (suspense.isHydrating) suspense.isHydrating = false;
            else if (!resume) {
                const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === 'out-in';
                if (delayEnter) activeBranch.transition.afterLeave = ()=>{
                    if (pendingId === suspense.pendingId) move(pendingBranch, container, anchor, 0 /* ENTER */ );
                };
                // this is initial anchor on mount
                let { anchor  } = suspense;
                // unmount current active tree
                if (activeBranch) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(activeBranch);
                    unmount(activeBranch, parentComponent, suspense, true);
                }
                if (!delayEnter) // move content from off-dom container to actual container
                move(pendingBranch, container, anchor, 0 /* ENTER */ );
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            // flush buffered effects
            // check if there is a pending parent suspense
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while(parent){
                if (parent.pendingBranch) {
                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            // no pending parent suspense, flush all jobs
            if (!hasUnresolvedAncestor) queuePostFlushCb(effects);
            suspense.effects = [];
            // invoke @resolve event
            triggerEvent(vnode, 'onResolve');
        },
        fallback (fallbackVNode) {
            if (!suspense.pendingBranch) return;
            const { vnode , activeBranch , parentComponent , container , isSVG  } = suspense;
            // invoke @fallback event
            triggerEvent(vnode, 'onFallback');
            const anchor = next(activeBranch);
            const mountFallback = ()=>{
                if (!suspense.isInFallback) return;
                // mount the fallback tree
                patch(null, fallbackVNode, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';
            if (delayEnter) activeBranch.transition.afterLeave = mountFallback;
            suspense.isInFallback = true;
            // unmount current active branch
            unmount(activeBranch, parentComponent, null, true // shouldRemove
            );
            if (!delayEnter) mountFallback();
        },
        move (container, anchor, type) {
            suspense.activeBranch && move(suspense.activeBranch, container, anchor, type);
            suspense.container = container;
        },
        next () {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep (instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) suspense.deps++;
            const hydratedEl = instance.vnode.el;
            instance.asyncDep.catch((err)=>{
                handleError(err, instance, 0 /* SETUP_FUNCTION */ );
            }).then((asyncSetupResult)=>{
                // retry when the setup() promise resolves.
                // component may have been unmounted before resolve.
                if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) return;
                // retry from this component
                instance.asyncResolved = true;
                const { vnode  } = instance;
                pushWarningContext(vnode);
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) // vnode may have been replaced if an update happened before the
                // async dep is resolved.
                vnode.el = hydratedEl;
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode, // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG1, optimized);
                if (placeholder) remove(placeholder);
                updateHOCHostEl(instance, vnode.el);
                popWarningContext();
                // only decrease deps count if suspense is not already resolved
                if (isInPendingSuspense && --suspense.deps === 0) suspense.resolve();
            });
        },
        unmount (parentSuspense, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) unmount(suspense.activeBranch, parentComponent1, parentSuspense, doRemove);
            if (suspense.pendingBranch) unmount(suspense.pendingBranch, parentComponent1, parentSuspense, doRemove);
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    /* eslint-disable no-restricted-globals */ const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
    // there are two possible scenarios for server-rendered suspense:
    // - success: ssr content should be fully resolved
    // - failure: ssr content should be the fallback branch.
    // however, on the client we don't really know if it has failed or not
    // attempt to hydrate the DOM assuming it has succeeded, but we still
    // need to construct a suspense boundary first
    const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) suspense.resolve();
    return result;
/* eslint-enable no-restricted-globals */ }
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag , children  } = vnode;
    const isSlotChildren = shapeFlag & 32 /* SLOTS_CHILDREN */ ;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if (_shared.isFunction(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            // disableTracking: false
            // allow block tracking for compiled slots
            // (see ./componentRenderContext.ts)
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if (_shared.isArray(s)) {
        const singleChild = filterSingleRoot(s);
        if (!singleChild) warn(`<Suspense> slots expect a single root node.`);
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) s.dynamicChildren = block.filter((c)=>c !== s
    );
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if (_shared.isArray(fn)) suspense.effects.push(...fn);
        else suspense.effects.push(fn);
    } else queuePostFlushCb(fn);
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode , parentComponent  } = suspense;
    const el = vnode.el = branch.el;
    // in case suspense is the root node of a component,
    // recursively update the HOC el
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}
function provide(key, value) {
    if (!currentInstance) warn(`provide() can only be used inside setup().`);
    else {
        let provides = currentInstance.provides;
        // by default an instance inherits its parent's provides object
        // but when it needs to provide values of its own, it creates its
        // own provides object using parent provides object as prototype.
        // this way in `inject` we can simply look up injections from direct
        // parent and let the prototype chain do the work.
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) provides = currentInstance.provides = Object.create(parentProvides);
        // TS doesn't allow symbol as index type
        provides[key] = value;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the instance is at root
        const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
        if (provides && key in provides) // TS doesn't allow symbol as index type
        return provides[key];
        else if (arguments.length > 1) return treatDefaultAsFactory && _shared.isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
        else warn(`injection "${String(key)}" not found.`);
    } else warn(`inject() can only be used inside setup() or functional components.`);
}
// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, Object.assign(options || {
    }, {
        flush: 'post'
    }));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, Object.assign(options || {
    }, {
        flush: 'sync'
    }));
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {
};
// implementation
function watch(source, cb, options) {
    if (!_shared.isFunction(cb)) warn(`\`watch(fn, options?)\` signature has been moved to a separate API. ` + `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` + `supports \`watch(source, cb, options?) signature.`);
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate , deep , flush , onTrack , onTrigger  } = _shared.EMPTY_OBJ) {
    if (!cb) {
        if (immediate !== undefined) warn(`watch() "immediate" option is only respected when using the ` + `watch(source, callback, options?) signature.`);
        if (deep !== undefined) warn(`watch() "deep" option is only respected when using the ` + `watch(source, callback, options?) signature.`);
    }
    const warnInvalidSource = (s)=>{
        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` + `a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (_reactivity.isRef(source)) {
        getter = ()=>source.value
        ;
        forceTrigger = _reactivity.isShallow(source);
    } else if (_reactivity.isReactive(source)) {
        getter = ()=>source
        ;
        deep = true;
    } else if (_shared.isArray(source)) {
        isMultiSource = true;
        forceTrigger = source.some(_reactivity.isReactive);
        getter = ()=>source.map((s)=>{
                if (_reactivity.isRef(s)) return s.value;
                else if (_reactivity.isReactive(s)) return traverse(s);
                else if (_shared.isFunction(s)) return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */ );
                else warnInvalidSource(s);
            })
        ;
    } else if (_shared.isFunction(source)) {
        if (cb) // getter with cb
        getter = ()=>callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */ )
        ;
        else // no cb -> simple effect
        getter = ()=>{
            if (instance && instance.isUnmounted) return;
            if (cleanup) cleanup();
            return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */ , [
                onCleanup
            ]);
        };
    } else {
        getter = _shared.NOOP;
        warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = ()=>traverse(baseGetter())
        ;
    }
    let cleanup;
    let onCleanup = (fn)=>{
        cleanup = effect.onStop = ()=>{
            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */ );
        };
    };
    // in SSR there is no need to setup an actual effect, and it should be noop
    // unless it's eager
    if (isInSSRComponentSetup) {
        // we will also not call the invalidate callback (+ runner is not set up)
        onCleanup = _shared.NOOP;
        if (!cb) getter();
        else if (immediate) callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */ , [
            getter(),
            isMultiSource ? [] : undefined,
            onCleanup
        ]);
        return _shared.NOOP;
    }
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    const job = ()=>{
        if (!effect.active) return;
        if (cb) {
            // watch(source, cb)
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i)=>_shared.hasChanged(v, oldValue[i])
            ) : _shared.hasChanged(newValue, oldValue)) || false) {
                // cleanup before running cb again
                if (cleanup) cleanup();
                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */ , [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        } else // watchEffect
        effect.run();
    };
    // important: mark the job as a watcher callback so that scheduler knows
    // it is allowed to self-trigger (#1727)
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === 'sync') scheduler = job; // the scheduler function gets called directly
    else if (flush === 'post') scheduler = ()=>queuePostRenderEffect(job, instance && instance.suspense)
    ;
    else // default: 'pre'
    scheduler = ()=>{
        if (!instance || instance.isMounted) queuePreFlushCb(job);
        else // with 'pre' option, the first call must happen before
        // the component is mounted so it is called synchronously.
        job();
    };
    const effect = new _reactivity.ReactiveEffect(getter, scheduler);
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
    // initial run
    if (cb) {
        if (immediate) job();
        else oldValue = effect.run();
    } else if (flush === 'post') queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    else effect.run();
    return ()=>{
        effect.stop();
        if (instance && instance.scope) _shared.remove(instance.scope.effects, effect);
    };
}
// this.$watch
function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = _shared.isString(source) ? source.includes('.') ? createPathGetter(publicThis, source) : ()=>publicThis[source]
     : source.bind(publicThis, publicThis);
    let cb;
    if (_shared.isFunction(value)) cb = value;
    else {
        cb = value.handler;
        options = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) setCurrentInstance(cur);
    else unsetCurrentInstance();
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split('.');
    return ()=>{
        let cur = ctx;
        for(let i = 0; i < segments.length && cur; i++)cur = cur[segments[i]];
        return cur;
    };
}
function traverse(value, seen) {
    if (!_shared.isObject(value) || value["__v_skip" /* SKIP */ ]) return value;
    seen = seen || new Set();
    if (seen.has(value)) return value;
    seen.add(value);
    if (_reactivity.isRef(value)) traverse(value.value, seen);
    else if (_shared.isArray(value)) for(let i = 0; i < value.length; i++)traverse(value[i], seen);
    else if (_shared.isSet(value) || _shared.isMap(value)) value.forEach((v)=>{
        traverse(v, seen);
    });
    else if (_shared.isPlainObject(value)) for(const key in value)traverse(value[key], seen);
    return value;
}
function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: new Map()
    };
    onMounted(()=>{
        state.isMounted = true;
    });
    onBeforeUnmount(()=>{
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [
    Function,
    Array
];
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
    },
    setup (props, { slots  }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return ()=>{
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) return;
            // warn multiple elements
            if (children.length > 1) warn("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
            // there's no need to track reactivity for these props so use the raw
            // props for a bit better perf
            const rawProps = _reactivity.toRaw(props);
            const { mode  } = rawProps;
            // check mode
            if (mode && mode !== 'in-out' && mode !== 'out-in' && mode !== 'default') warn(`invalid <transition> mode: ${mode}`);
            // at this point children has a guaranteed length of 1.
            const child = children[0];
            if (state.isLeaving) return emptyPlaceholder(child);
            // in the case of <transition><keep-alive/></transition>, we need to
            // compare the type of the kept-alive children.
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) return emptyPlaceholder(child);
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey  } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === undefined) prevTransitionKey = key;
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            // handle mode
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                // update old tree's hooks in case of dynamic transition
                setTransitionHooks(oldInnerChild, leavingHooks);
                // switching between different views
                if (mode === 'out-in') {
                    state.isLeaving = true;
                    // return placeholder node and queue update when leave finishes
                    leavingHooks.afterLeave = ()=>{
                        state.isLeaving = false;
                        instance.update();
                    };
                    return emptyPlaceholder(child);
                } else if (mode === 'in-out' && innerChild.type !== Comment) leavingHooks.delayLeave = (el, earlyRemove, delayedLeave)=>{
                    const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                    leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                    // early removal callback
                    el._leaveCb = ()=>{
                        earlyRemove();
                        el._leaveCb = undefined;
                        delete enterHooks.delayedLeave;
                    };
                    enterHooks.delayedLeave = delayedLeave;
                };
            }
            return child;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes  } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
// The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.
function resolveTransitionHooks(vnode2, props, state, instance) {
    const { appear , mode , persisted =false , onBeforeEnter , onEnter , onAfterEnter , onEnterCancelled , onBeforeLeave , onLeave , onAfterLeave , onLeaveCancelled , onBeforeAppear , onAppear , onAfterAppear , onAppearCancelled  } = props;
    const key = String(vnode2.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode2);
    const callHook1 = (hook, args)=>{
        hook && callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */ , args);
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter (el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) hook = onBeforeAppear || onBeforeEnter;
                else return;
            }
            // for same element (v-show)
            if (el._leaveCb) el._leaveCb(true);
            // for toggled element with same key (v-if)
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode2, leavingVNode) && leavingVNode.el._leaveCb) // force early removal (not cancelled)
            leavingVNode.el._leaveCb();
            callHook1(hook, [
                el
            ]);
        },
        enter (el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                } else return;
            }
            let called = false;
            const done = el._enterCb = (cancelled)=>{
                if (called) return;
                called = true;
                if (cancelled) callHook1(cancelHook, [
                    el
                ]);
                else callHook1(afterHook, [
                    el
                ]);
                if (hooks.delayedLeave) hooks.delayedLeave();
                el._enterCb = undefined;
            };
            if (hook) {
                hook(el, done);
                if (hook.length <= 1) done();
            } else done();
        },
        leave (el, remove) {
            const key = String(vnode2.key);
            if (el._enterCb) el._enterCb(true);
            if (state.isUnmounting) return remove();
            callHook1(onBeforeLeave, [
                el
            ]);
            let called = false;
            const done = el._leaveCb = (cancelled)=>{
                if (called) return;
                called = true;
                remove();
                if (cancelled) callHook1(onLeaveCancelled, [
                    el
                ]);
                else callHook1(onAfterLeave, [
                    el
                ]);
                el._leaveCb = undefined;
                if (leavingVNodesCache[key] === vnode2) delete leavingVNodesCache[key];
            };
            leavingVNodesCache[key] = vnode2;
            if (onLeave) {
                onLeave(el, done);
                if (onLeave.length <= 1) done();
            } else done();
        },
        clone (vnode) {
            return resolveTransitionHooks(vnode, props, state, instance);
        }
    };
    return hooks;
}
// the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : undefined : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 /* COMPONENT */  && vnode.component) setTransitionHooks(vnode.component.subTree, hooks);
    else if (vnode.shapeFlag & 128 /* SUSPENSE */ ) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else vnode.transition = hooks;
}
function getTransitionRawChildren(children, keepComment = false) {
    let ret = [];
    let keyedFragmentCount = 0;
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        // handle fragment children case, e.g. v-for
        if (child.type === Fragment) {
            if (child.patchFlag & 128 /* KEYED_FRAGMENT */ ) keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
        } else if (keepComment || child.type !== Comment) ret.push(child);
    }
    // #1126 if a transition children list contains multiple sub fragments, these
    // fragments will be merged into a flat children array. Since each v-for
    // fragment may contain different static bindings inside, we need to de-op
    // these children to force full diffs to ensure correct behavior.
    if (keyedFragmentCount > 1) for(let i1 = 0; i1 < ret.length; i1++)ret[i1].patchFlag = -2 /* BAIL */ ;
    return ret;
}
// implementation, close to no-op
function defineComponent(options) {
    return _shared.isFunction(options) ? {
        setup: options,
        name: options.name
    } : options;
}
const isAsyncWrapper = (i)=>!!i.type.__asyncLoader
;
function defineAsyncComponent(source) {
    if (_shared.isFunction(source)) source = {
        loader: source
    };
    const { loader , loadingComponent , errorComponent , delay =200 , timeout , suspensible =true , onError: userOnError  } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = ()=>{
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = ()=>{
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err)=>{
            err = err instanceof Error ? err : new Error(String(err));
            if (userOnError) return new Promise((resolve1, reject)=>{
                const userRetry = ()=>resolve1(retry())
                ;
                const userFail = ()=>reject(err)
                ;
                userOnError(err, userRetry, userFail, retries + 1);
            });
            else throw err;
        }).then((comp)=>{
            if (thisRequest !== pendingRequest && pendingRequest) return pendingRequest;
            if (!comp) warn(`Async component loader resolved to undefined. ` + `If you are using retry(), make sure to return its return value.`);
            // interop module default
            if (comp && (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) comp = comp.default;
            if (comp && !_shared.isObject(comp) && !_shared.isFunction(comp)) throw new Error(`Invalid async component load result: ${comp}`);
            resolvedComp = comp;
            return comp;
        }));
    };
    return defineComponent({
        name: 'AsyncComponentWrapper',
        __asyncLoader: load,
        get __asyncResolved () {
            return resolvedComp;
        },
        setup () {
            const instance = currentInstance;
            // already resolved
            if (resolvedComp) return ()=>createInnerComp(resolvedComp, instance)
            ;
            const onError = (err)=>{
                pendingRequest = null;
                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */ , !errorComponent /* do not throw in dev if user provided error component */ );
            };
            // suspense-controlled or SSR.
            if (suspensible && instance.suspense || isInSSRComponentSetup) return load().then((comp)=>{
                return ()=>createInnerComp(comp, instance)
                ;
            }).catch((err)=>{
                onError(err);
                return ()=>errorComponent ? createVNode(errorComponent, {
                        error: err
                    }) : null
                ;
            });
            const loaded = _reactivity.ref(false);
            const error = _reactivity.ref();
            const delayed = _reactivity.ref(!!delay);
            if (delay) setTimeout(()=>{
                delayed.value = false;
            }, delay);
            if (timeout != null) setTimeout(()=>{
                if (!loaded.value && !error.value) {
                    const err = new Error(`Async component timed out after ${timeout}ms.`);
                    onError(err);
                    error.value = err;
                }
            }, timeout);
            load().then(()=>{
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) // parent is keep-alive, force update so the loaded component's
                // name is taken into account
                queueJob(instance.parent.update);
            }).catch((err)=>{
                onError(err);
                error.value = err;
            });
            return ()=>{
                if (loaded.value && resolvedComp) return createInnerComp(resolvedComp, instance);
                else if (error.value && errorComponent) return createVNode(errorComponent, {
                    error: error.value
                });
                else if (loadingComponent && !delayed.value) return createVNode(loadingComponent);
            };
        }
    });
}
function createInnerComp(comp, { vnode: { ref , props , children  }  }) {
    const vnode = createVNode(comp, props, children);
    // ensure inner component inherits the async wrapper's ref owner
    vnode.ref = ref;
    return vnode;
}
const isKeepAlive = (vnode)=>vnode.type.__isKeepAlive
;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [
            String,
            RegExp,
            Array
        ],
        exclude: [
            String,
            RegExp,
            Array
        ],
        max: [
            String,
            Number
        ]
    },
    setup (props, { slots  }) {
        const instance2 = getCurrentInstance();
        // KeepAlive communicates with the instantiated renderer via the
        // ctx where the renderer passes in its internals,
        // and the KeepAlive instance exposes activate/deactivate implementations.
        // The whole point of this is to avoid importing KeepAlive directly in the
        // renderer to facilitate tree-shaking.
        const sharedContext = instance2.ctx;
        // if the internal renderer is not registered, it indicates that this is server-side rendering,
        // for KeepAlive, we just need to render its children
        if (!sharedContext.renderer) return slots.default;
        const cache = new Map();
        const keys = new Set();
        let current = null;
        instance2.__v_cache = cache;
        const parentSuspense = instance2.suspense;
        const { renderer: { p: patch , m: move , um: _unmount , o: { createElement  }  }  } = sharedContext;
        const storageContainer = createElement('div');
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized)=>{
            const instance = vnode.component;
            move(vnode, container, anchor, 0 /* ENTER */ , parentSuspense);
            // in case props have changed
            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(()=>{
                instance.isDeactivated = false;
                if (instance.a) _shared.invokeArrayFns(instance.a);
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance.parent, vnode);
            }, parentSuspense);
            // Update components tree
            devtoolsComponentAdded(instance);
        };
        sharedContext.deactivate = (vnode)=>{
            const instance = vnode.component;
            move(vnode, storageContainer, null, 1 /* LEAVE */ , parentSuspense);
            queuePostRenderEffect(()=>{
                if (instance.da) _shared.invokeArrayFns(instance.da);
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance.parent, vnode);
                instance.isDeactivated = true;
            }, parentSuspense);
            // Update components tree
            devtoolsComponentAdded(instance);
        };
        function unmount(vnode) {
            // reset the shapeFlag so it can be properly unmounted
            resetShapeFlag(vnode);
            _unmount(vnode, instance2, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key)=>{
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) pruneCacheEntry(key);
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || cached.type !== current.type) unmount(cached);
            else if (current) // current active instance should no longer be kept-alive.
            // we can't unmount it now but it might be later, so reset its flag now.
            resetShapeFlag(current);
            cache.delete(key);
            keys.delete(key);
        }
        // prune cache on include/exclude prop change
        watch(()=>[
                props.include,
                props.exclude
            ]
        , ([include, exclude])=>{
            include && pruneCache((name)=>matches(include, name)
            );
            exclude && pruneCache((name)=>!matches(exclude, name)
            );
        }, // prune post-render after `current` has been updated
        {
            flush: 'post',
            deep: true
        });
        // cache sub tree after render
        let pendingCacheKey = null;
        const cacheSubtree = ()=>{
            // fix #1621, the pendingCacheKey could be 0
            if (pendingCacheKey != null) cache.set(pendingCacheKey, getInnerChild(instance2.subTree));
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(()=>{
            cache.forEach((cached)=>{
                const { subTree , suspense  } = instance2;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type) {
                    // current instance will be unmounted as part of keep-alive's unmount
                    resetShapeFlag(vnode);
                    // but invoke its deactivated hook here
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return ()=>{
            pendingCacheKey = null;
            if (!slots.default) return null;
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                warn(`KeepAlive should contain exactly one component child.`);
                current = null;
                return children;
            } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */ ) && !(rawVNode.shapeFlag & 128 /* SUSPENSE */ )) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            // for async components, name check should be based in its loaded
            // inner component if available
            const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {
            } : comp);
            const { include , exclude , max  } = props;
            if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            // clone vnode if it's reused because we are going to mutate it
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128 /* SUSPENSE */ ) rawVNode.ssContent = vnode;
            }
            // #1513 it's possible for the returned vnode to be cloned due to attr
            // fallthrough or scopeId, so the vnode here may not be the final vnode
            // that is mounted. Instead of caching it directly, we store the pending
            // key and cache `instance.subTree` (the normalized vnode) in
            // beforeMount/beforeUpdate hooks.
            pendingCacheKey = key;
            if (cachedVNode) {
                // copy over mounted state
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) // recursively update transition hooks on subTree
                setTransitionHooks(vnode, vnode.transition);
                // avoid vnode being mounted as fresh
                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */ ;
                // make this key the freshest
                keys.delete(key);
                keys.add(key);
            } else {
                keys.add(key);
                // prune oldest entry
                if (max && keys.size > parseInt(max, 10)) pruneCacheEntry(keys.values().next().value);
            }
            // avoid vnode being unmounted
            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */ ;
            current = vnode;
            return rawVNode;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if (_shared.isArray(pattern)) return pattern.some((p)=>matches(p, name)
    );
    else if (_shared.isString(pattern)) return pattern.split(',').includes(name);
    else if (pattern.test) return pattern.test(name);
    /* istanbul ignore next */ return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a" /* ACTIVATED */ , target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da" /* DEACTIVATED */ , target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    // cache the deactivate branch check wrapper for injected hooks so the same
    // hook can be properly deduped by the scheduler. "__wdc" stands for "with
    // deactivation check".
    const wrappedHook = hook.__wdc || (hook.__wdc = ()=>{
        // only fire the hook if the target instance is NOT in a deactivated branch.
        let current = target;
        while(current){
            if (current.isDeactivated) return;
            current = current.parent;
        }
        return hook();
    });
    injectHook(type, wrappedHook, target);
    // In addition to registering it on the target instance, we walk up the parent
    // chain and register it on all ancestor instances that are keep-alive roots.
    // This avoids the need to walk the entire component tree when invoking these
    // hooks, and more importantly, avoids the need to track child components in
    // arrays.
    if (target) {
        let current = target.parent;
        while(current && current.parent){
            if (isKeepAlive(current.parent.vnode)) injectToKeepAliveRoot(wrappedHook, type, target, current);
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    // injectHook wraps the original for error handling, so make sure to remove
    // the wrapped version.
    const injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(()=>{
        _shared.remove(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    let shapeFlag = vnode.shapeFlag;
    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */ ) shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */ ;
    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */ ) shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */ ;
    vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 /* SUSPENSE */  ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        // cache the error handling wrapper for injected hooks so the same hook
        // can be properly deduped by the scheduler. "__weh" stands for "with error
        // handling".
        const wrappedHook = hook.__weh || (hook.__weh = (...args)=>{
            if (target.isUnmounted) return;
            // disable tracking inside all lifecycle hooks
            // since they can potentially be called inside effects.
            _reactivity.pauseTracking();
            // Set currentInstance during hook invocation.
            // This assumes the hook does not synchronously trigger other hooks, which
            // can only be false when the user does something really funky.
            setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            unsetCurrentInstance();
            _reactivity.resetTracking();
            return res;
        });
        if (prepend) hooks.unshift(wrappedHook);
        else hooks.push(wrappedHook);
        return wrappedHook;
    } else {
        const apiName = _shared.toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ''));
        warn(`${apiName} is called when there is no active component instance to be ` + `associated with. ` + `Lifecycle injection APIs can only be used during execution of setup().` + (` If you are using async setup(), make sure to register lifecycle ` + `hooks before the first await statement.`));
    }
}
const createHook = (lifecycle)=>(hook, target = currentInstance)=>// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp" /* SERVER_PREFETCH */ ) && injectHook(lifecycle, hook, target)
;
const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */ );
const onMounted = createHook("m" /* MOUNTED */ );
const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */ );
const onUpdated = createHook("u" /* UPDATED */ );
const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */ );
const onUnmounted = createHook("um" /* UNMOUNTED */ );
const onServerPrefetch = createHook("sp" /* SERVER_PREFETCH */ );
const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */ );
const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */ );
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec" /* ERROR_CAPTURED */ , hook, target);
}
function createDuplicateChecker() {
    const cache = Object.create(null);
    return (type, key)=>{
        if (cache[key]) warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        else cache[key] = type;
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    // do not cache property access on public proxy during state initialization
    shouldCacheAccess = false;
    // call beforeCreate first before accessing other options since
    // the hook may mutate resolved options (#2791)
    if (options.beforeCreate) callHook(options.beforeCreate, instance, "bc" /* BEFORE_CREATE */ );
    const { // state
    data: dataOptions , computed: computedOptions , methods , watch: watchOptions , provide: provideOptions , inject: injectOptions , // lifecycle
    created , beforeMount , mounted , beforeUpdate , updated , activated , deactivated , beforeDestroy , beforeUnmount , destroyed , unmounted , render , renderTracked , renderTriggered , errorCaptured , serverPrefetch , // public API
    expose , inheritAttrs , // assets
    components , directives , filters  } = options;
    const checkDuplicateProperties = createDuplicateChecker();
    {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) for(const key in propsOptions)checkDuplicateProperties("Props" /* PROPS */ , key);
    }
    // options initialization order (to be consistent with Vue 2):
    // - props (already done outside of this function)
    // - inject
    // - methods
    // - data (deferred since it relies on `this` access)
    // - computed
    // - watch (deferred since it relies on `this` access)
    if (injectOptions) resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
    if (methods) for(const key3 in methods){
        const methodHandler = methods[key3];
        if (_shared.isFunction(methodHandler)) {
            Object.defineProperty(ctx, key3, {
                value: methodHandler.bind(publicThis),
                configurable: true,
                enumerable: true,
                writable: true
            });
            checkDuplicateProperties("Methods" /* METHODS */ , key3);
        } else warn(`Method "${key3}" has type "${typeof methodHandler}" in the component definition. ` + `Did you reference the function correctly?`);
    }
    if (dataOptions) {
        if (!_shared.isFunction(dataOptions)) warn(`The data option must be a function. ` + `Plain object usage is no longer supported.`);
        const data = dataOptions.call(publicThis, publicThis);
        if (_shared.isPromise(data)) warn(`data() returned a Promise - note data() cannot be async; If you ` + `intend to perform data fetching before component renders, use ` + `async setup() + <Suspense>.`);
        if (!_shared.isObject(data)) warn(`data() should return an object.`);
        else {
            instance.data = _reactivity.reactive(data);
            for(const key in data){
                checkDuplicateProperties("Data" /* DATA */ , key);
                // expose data on ctx during dev
                if (key[0] !== '$' && key[0] !== '_') Object.defineProperty(ctx, key, {
                    configurable: true,
                    enumerable: true,
                    get: ()=>data[key]
                    ,
                    set: _shared.NOOP
                });
            }
        }
    }
    // state initialization complete at this point - start caching access
    shouldCacheAccess = true;
    if (computedOptions) for(const key1 in computedOptions){
        const opt = computedOptions[key1];
        const get = _shared.isFunction(opt) ? opt.bind(publicThis, publicThis) : _shared.isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : _shared.NOOP;
        if (get === _shared.NOOP) warn(`Computed property "${key1}" has no getter.`);
        const set = !_shared.isFunction(opt) && _shared.isFunction(opt.set) ? opt.set.bind(publicThis) : ()=>{
            warn(`Write operation failed: computed property "${key1}" is readonly.`);
        };
        const c = computed({
            get,
            set
        });
        Object.defineProperty(ctx, key1, {
            enumerable: true,
            configurable: true,
            get: ()=>c.value
            ,
            set: (v)=>c.value = v
        });
        checkDuplicateProperties("Computed" /* COMPUTED */ , key1);
    }
    if (watchOptions) for(const key2 in watchOptions)createWatcher(watchOptions[key2], ctx, publicThis, key2);
    if (provideOptions) {
        const provides = _shared.isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key)=>{
            provide(key, provides[key]);
        });
    }
    if (created) callHook(created, instance, "c" /* CREATED */ );
    function registerLifecycleHook(register, hook) {
        if (_shared.isArray(hook)) hook.forEach((_hook)=>register(_hook.bind(publicThis))
        );
        else if (hook) register(hook.bind(publicThis));
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (_shared.isArray(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {
            });
            expose.forEach((key)=>{
                Object.defineProperty(exposed, key, {
                    get: ()=>publicThis[key]
                    ,
                    set: (val)=>publicThis[key] = val
                });
            });
        } else if (!instance.exposed) instance.exposed = {
        };
    }
    // options that are handled when creating the instance but also need to be
    // applied from mixins
    if (render && instance.render === _shared.NOOP) instance.render = render;
    if (inheritAttrs != null) instance.inheritAttrs = inheritAttrs;
    // asset options.
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = _shared.NOOP, unwrapRef = false) {
    if (_shared.isArray(injectOptions)) injectOptions = normalizeInject(injectOptions);
    for(const key in injectOptions){
        const opt = injectOptions[key];
        let injected;
        if (_shared.isObject(opt)) {
            if ('default' in opt) injected = inject(opt.from || key, opt.default, true);
            else injected = inject(opt.from || key);
        } else injected = inject(opt);
        if (_reactivity.isRef(injected)) {
            // TODO remove the check in 3.3
            if (unwrapRef) Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: ()=>injected.value
                ,
                set: (v)=>injected.value = v
            });
            else {
                warn(`injected property "${key}" is a ref and will be auto-unwrapped ` + `and no longer needs \`.value\` in the next minor release. ` + `To opt-in to the new behavior now, ` + `set \`app.config.unwrapInjectedRef = true\` (this config is ` + `temporary and will not be needed in the future.)`);
                ctx[key] = injected;
            }
        } else ctx[key] = injected;
        checkDuplicateProperties("Inject" /* INJECT */ , key);
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling(_shared.isArray(hook) ? hook.map((h1)=>h1.bind(instance.proxy)
    ) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes('.') ? createPathGetter(publicThis, key) : ()=>publicThis[key]
    ;
    if (_shared.isString(raw)) {
        const handler = ctx[raw];
        if (_shared.isFunction(handler)) watch(getter, handler);
        else warn(`Invalid watch handler specified by key "${raw}"`, handler);
    } else if (_shared.isFunction(raw)) watch(getter, raw.bind(publicThis));
    else if (_shared.isObject(raw)) {
        if (_shared.isArray(raw)) raw.forEach((r)=>createWatcher(r, ctx, publicThis, key)
        );
        else {
            const handler = _shared.isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if (_shared.isFunction(handler)) watch(getter, handler, raw);
            else warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
    } else warn(`Invalid watch option: "${key}"`, raw);
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */ function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins , extends: extendsOptions  } = base;
    const { mixins: globalMixins , optionsCache: cache , config: { optionMergeStrategies  }  } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) resolved = cached;
    else if (!globalMixins.length && !mixins && !extendsOptions) resolved = base;
    else {
        resolved = {
        };
        if (globalMixins.length) globalMixins.forEach((m)=>mergeOptions(resolved, m, optionMergeStrategies, true)
        );
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins , extends: extendsOptions  } = from;
    if (extendsOptions) mergeOptions(to, extendsOptions, strats, true);
    if (mixins) mixins.forEach((m)=>mergeOptions(to, m, strats, true)
    );
    for(const key in from)if (asMixin && key === 'expose') warn(`"expose" option is ignored when declared in mixins or extends. ` + `It should only be declared in the base component itself.`);
    else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeObjectOptions,
    emits: mergeObjectOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) return to;
    if (!to) return from;
    return function mergedDataFn() {
        return _shared.extend(_shared.isFunction(to) ? to.call(this, this) : to, _shared.isFunction(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if (_shared.isArray(raw)) {
        const res = {
        };
        for(let i = 0; i < raw.length; i++)res[raw[i]] = raw[i];
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [
        ...new Set([].concat(to, from))
    ] : from;
}
function mergeObjectOptions(to, from) {
    return to ? _shared.extend(_shared.extend(Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = _shared.extend(Object.create(null), to);
    for(const key in from)merged[key] = mergeAsArray(to[key], from[key]);
    return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {
    };
    const attrs = {
    };
    _shared.def(attrs, InternalObjectKey, 1);
    instance.propsDefaults = Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    // ensure all declared prop keys are present
    for(const key in instance.propsOptions[0])if (!(key in props)) props[key] = undefined;
    validateProps(rawProps || {
    }, props, instance);
    if (isStateful) // stateful
    instance.props = isSSR ? props : _reactivity.shallowReactive(props);
    else if (!instance.type.props) // functional w/ optional props, props === attrs
    instance.props = attrs;
    else // functional w/ declared props
    instance.props = props;
    instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props , attrs , vnode: { patchFlag  }  } = instance;
    const rawCurrentProps = _reactivity.toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (// always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId) && (optimized || patchFlag > 0) && !(patchFlag & 16 /* FULL_PROPS */ )) {
        if (patchFlag & 8 /* PROPS */ ) {
            // Compiler-generated props & no keys change, just set the updated
            // the props.
            const propsToUpdate = instance.vnode.dynamicProps;
            for(let i = 0; i < propsToUpdate.length; i++){
                let key = propsToUpdate[i];
                // PROPS flag guarantees rawProps to be non-null
                const value = rawProps[key];
                if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if (_shared.hasOwn(attrs, key)) {
                        if (value !== attrs[key]) {
                            attrs[key] = value;
                            hasAttrsChanged = true;
                        }
                    } else {
                        const camelizedKey = _shared.camelize(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
                    }
                } else if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                }
            }
        }
    } else {
        // full props update.
        if (setFullProps(instance, rawProps, props, attrs)) hasAttrsChanged = true;
        // in case of dynamic props, check if we need to delete keys from
        // the props object
        let kebabKey;
        for(const key in rawCurrentProps)if (!rawProps || !_shared.hasOwn(rawProps, key) && ((kebabKey = _shared.hyphenate(key)) === key || !_shared.hasOwn(rawProps, kebabKey))) {
            if (options) {
                if (rawPrevProps && (rawPrevProps[key] !== undefined || // for kebab-case
                rawPrevProps[kebabKey] !== undefined)) props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true);
            } else delete props[key];
        }
        // in the case of functional component w/o props declaration, props and
        // attrs point to the same object so it should already have been updated.
        if (attrs !== rawCurrentProps) {
            for(const key in attrs)if (!rawProps || !_shared.hasOwn(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
            }
        }
    }
    // trigger updates for $attrs in case it's used in component slots
    if (hasAttrsChanged) _reactivity.trigger(instance, "set" /* SET */ , '$attrs');
    validateProps(rawProps || {
    }, props, instance);
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) for(let key in rawProps){
        // key, ref are reserved and never passed down
        if (_shared.isReservedProp(key)) continue;
        const value = rawProps[key];
        // prop option names are camelized during normalization, so to support
        // kebab -> camel conversion here we need to camelize the key.
        let camelKey;
        if (options && _shared.hasOwn(options, camelKey = _shared.camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) props[camelKey] = value;
            else (rawCastValues || (rawCastValues = {
            }))[camelKey] = value;
        } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = _reactivity.toRaw(props);
        const castValues = rawCastValues || _shared.EMPTY_OBJ;
        for(let i = 0; i < needCastKeys.length; i++){
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !_shared.hasOwn(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = _shared.hasOwn(opt, 'default');
        // default values
        if (hasDefault && value === undefined) {
            const defaultValue = opt.default;
            if (opt.type !== Function && _shared.isFunction(defaultValue)) {
                const { propsDefaults  } = instance;
                if (key in propsDefaults) value = propsDefaults[key];
                else {
                    setCurrentInstance(instance);
                    value = propsDefaults[key] = defaultValue.call(null, props);
                    unsetCurrentInstance();
                }
            } else value = defaultValue;
        }
        // boolean casting
        if (opt[0 /* shouldCast */ ]) {
            if (isAbsent && !hasDefault) value = false;
            else if (opt[1 /* shouldCastTrue */ ] && (value === '' || value === _shared.hyphenate(key))) value = true;
        }
    }
    return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) return cached;
    const raw2 = comp.props;
    const normalized = {
    };
    const needCastKeys = [];
    // apply mixin/extends props
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !_shared.isFunction(comp)) {
        const extendProps = (raw)=>{
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw, appContext, true);
            _shared.extend(normalized, props);
            if (keys) needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendProps);
        if (comp.extends) extendProps(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendProps);
    }
    if (!raw2 && !hasExtends) {
        cache.set(comp, _shared.EMPTY_ARR);
        return _shared.EMPTY_ARR;
    }
    if (_shared.isArray(raw2)) for(let i = 0; i < raw2.length; i++){
        if (!_shared.isString(raw2[i])) warn(`props must be strings when using array syntax.`, raw2[i]);
        const normalizedKey = _shared.camelize(raw2[i]);
        if (validatePropName(normalizedKey)) normalized[normalizedKey] = _shared.EMPTY_OBJ;
    }
    else if (raw2) {
        if (!_shared.isObject(raw2)) warn(`invalid props options`, raw2);
        for(const key in raw2){
            const normalizedKey = _shared.camelize(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw2[key];
                const prop = normalized[normalizedKey] = _shared.isArray(opt) || _shared.isFunction(opt) ? {
                    type: opt
                } : opt;
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */ ] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */ ] = stringIndex < 0 || booleanIndex < stringIndex;
                    // if the prop needs boolean casting or default value
                    if (booleanIndex > -1 || _shared.hasOwn(prop, 'default')) needCastKeys.push(normalizedKey);
                }
            }
        }
    }
    const res = [
        normalized,
        needCastKeys
    ];
    cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== '$') return true;
    else warn(`Invalid prop name: "${key}" is a reserved property.`);
    return false;
}
// use function string name to check type constructors
// so that it works across vms / iframes.
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ctor === null ? 'null' : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if (_shared.isArray(expectedTypes)) return expectedTypes.findIndex((t)=>isSameType(t, type)
    );
    else if (_shared.isFunction(expectedTypes)) return isSameType(expectedTypes, type) ? 0 : -1;
    return -1;
}
/**
 * dev only
 */ function validateProps(rawProps, props, instance) {
    const resolvedValues = _reactivity.toRaw(props);
    const options = instance.propsOptions[0];
    for(const key in options){
        let opt = options[key];
        if (opt == null) continue;
        validateProp(key, resolvedValues[key], opt, !_shared.hasOwn(rawProps, key) && !_shared.hasOwn(rawProps, _shared.hyphenate(key)));
    }
}
/**
 * dev only
 */ function validateProp(name, value, prop, isAbsent) {
    const { type , required , validator  } = prop;
    // required!
    if (required && isAbsent) {
        warn('Missing required prop: "' + name + '"');
        return;
    }
    // missing but optional
    if (value == null && !prop.required) return;
    // type check
    if (type != null && type !== true) {
        let isValid = false;
        const types = _shared.isArray(type) ? type : [
            type
        ];
        const expectedTypes = [];
        // value is valid as long as one of the specified types match
        for(let i = 0; i < types.length && !isValid; i++){
            const { valid , expectedType  } = assertType(value, types[i]);
            expectedTypes.push(expectedType || '');
            isValid = valid;
        }
        if (!isValid) {
            warn(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    // custom validator
    if (validator && !validator(value)) warn('Invalid prop: custom validator check failed for prop "' + name + '".');
}
const isSimpleType = /*#__PURE__*/ _shared.makeMap('String,Number,Boolean,Function,Symbol,BigInt');
/**
 * dev only
 */ function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') valid = value instanceof type;
    } else if (expectedType === 'Object') valid = _shared.isObject(value);
    else if (expectedType === 'Array') valid = _shared.isArray(value);
    else if (expectedType === 'null') valid = value === null;
    else valid = value instanceof type;
    return {
        valid,
        expectedType
    };
}
/**
 * dev only
 */ function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` + ` Expected ${expectedTypes.map(_shared.capitalize).join(' | ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = _shared.toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) message += ` with value ${expectedValue}`;
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) message += `with value ${receivedValue}.`;
    return message;
}
/**
 * dev only
 */ function styleValue(value, type) {
    if (type === 'String') return `"${value}"`;
    else if (type === 'Number') return `${Number(value)}`;
    else return `${value}`;
}
/**
 * dev only
 */ function isExplicable(type) {
    const explicitTypes = [
        'string',
        'number',
        'boolean'
    ];
    return explicitTypes.some((elem)=>type.toLowerCase() === elem
    );
}
/**
 * dev only
 */ function isBoolean(...args) {
    return args.some((elem)=>elem.toLowerCase() === 'boolean'
    );
}
const isInternalKey = (key)=>key[0] === '_' || key === '$stable'
;
const normalizeSlotValue = (value)=>_shared.isArray(value) ? value.map(normalizeVNode) : [
        normalizeVNode(value)
    ]
;
const normalizeSlot = (key, rawSlot, ctx)=>{
    const normalized = withCtx((...args)=>{
        if (currentInstance) warn(`Slot "${key}" invoked outside of the render function: ` + `this will not track dependencies used in the slot. ` + `Invoke the slot function inside the render function instead.`);
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance)=>{
    const ctx = rawSlots._ctx;
    for(const key in rawSlots){
        if (isInternalKey(key)) continue;
        const value = rawSlots[key];
        if (_shared.isFunction(value)) slots[key] = normalizeSlot(key, value, ctx);
        else if (value != null) {
            warn(`Non-function value encountered for slot "${key}". ` + `Prefer function slots for better performance.`);
            const normalized = normalizeSlotValue(value);
            slots[key] = ()=>normalized
            ;
        }
    }
};
const normalizeVNodeSlots = (instance, children)=>{
    if (!isKeepAlive(instance.vnode) && true) warn(`Non-function value encountered for default slot. ` + `Prefer function slots for better performance.`);
    const normalized = normalizeSlotValue(children);
    instance.slots.default = ()=>normalized
    ;
};
const initSlots = (instance, children)=>{
    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */ ) {
        const type = children._;
        if (type) {
            // users can get the shallow readonly version of the slots object through `this.$slots`,
            // we should avoid the proxy object polluting the slots of the internal instance
            instance.slots = _reactivity.toRaw(children);
            // make compiler marker non-enumerable
            _shared.def(children, '_', type);
        } else normalizeObjectSlots(children, instance.slots = {
        });
    } else {
        instance.slots = {
        };
        if (children) normalizeVNodeSlots(instance, children);
    }
    _shared.def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized)=>{
    const { vnode , slots  } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = _shared.EMPTY_OBJ;
    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */ ) {
        const type = children._;
        if (type) {
            // compiled slots.
            if (isHmrUpdating) // Parent was HMR updated so slot content may have changed.
            // force update slots and mark instance for hmr as well
            _shared.extend(slots, children);
            else if (optimized && type === 1 /* STABLE */ ) // compiled AND stable.
            // no need to update, and skip stale slots removal.
            needDeletionCheck = false;
            else {
                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                // normalization.
                _shared.extend(slots, children);
                // #2893
                // when rendering the optimized slots by manually written render function,
                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
                // i.e. let the `renderSlot` create the bailed Fragment
                if (!optimized && type === 1 /* STABLE */ ) delete slots._;
            }
        } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    } else if (children) {
        // non slot object children (direct value) passed to a component
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = {
            default: 1
        };
    }
    // delete stale slots
    if (needDeletionCheck) {
        for(const key in slots)if (!isInternalKey(key) && !(key in deletionComparisonTarget)) delete slots[key];
    }
};
/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/ function validateDirectiveName(name) {
    if (_shared.isBuiltInDirective(name)) warn('Do not use built-in directive ids as custom directive id: ' + name);
}
/**
 * Adds directives to a VNode.
 */ function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        warn(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for(let i = 0; i < directives.length; i++){
        let [dir, value, arg, modifiers = _shared.EMPTY_OBJ] = directives[i];
        if (_shared.isFunction(dir)) dir = {
            mounted: dir,
            updated: dir
        };
        if (dir.deep) traverse(value);
        bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
        });
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for(let i = 0; i < bindings.length; i++){
        const binding = bindings[i];
        if (oldBindings) binding.oldValue = oldBindings[i].value;
        let hook = binding.dir[name];
        if (hook) {
            // disable tracking inside all lifecycle hooks
            // since they can potentially be called inside effects.
            _reactivity.pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */ , [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            _reactivity.resetTracking();
        }
    }
}
function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: _shared.NO,
            performance: false,
            globalProperties: {
            },
            optionMergeStrategies: {
            },
            errorHandler: undefined,
            warnHandler: undefined,
            compilerOptions: {
            }
        },
        mixins: [],
        components: {
        },
        directives: {
        },
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap()
    };
}
let uid = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (rootProps != null && !_shared.isObject(rootProps)) {
            warn(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = new Set();
        let isMounted = false;
        const app = context.app = {
            _uid: uid++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config () {
                return context.config;
            },
            set config (v){
                warn(`app.config cannot be replaced. Modify individual options instead.`);
            },
            use (plugin, ...options) {
                if (installedPlugins.has(plugin)) warn(`Plugin has already been applied to target app.`);
                else if (plugin && _shared.isFunction(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                } else if (_shared.isFunction(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                } else warn(`A plugin must either be a function or an object with an "install" ` + `function.`);
                return app;
            },
            mixin (mixin) {
                if (__VUE_OPTIONS_API__) {
                    if (!context.mixins.includes(mixin)) context.mixins.push(mixin);
                    else warn('Mixin has already been applied to target app' + (mixin.name ? `: ${mixin.name}` : ''));
                } else warn('Mixins are only available in builds supporting Options API');
                return app;
            },
            component (name, component) {
                validateComponentName(name, context.config);
                if (!component) return context.components[name];
                if (context.components[name]) warn(`Component "${name}" has already been registered in target app.`);
                context.components[name] = component;
                return app;
            },
            directive (name, directive) {
                validateDirectiveName(name);
                if (!directive) return context.directives[name];
                if (context.directives[name]) warn(`Directive "${name}" has already been registered in target app.`);
                context.directives[name] = directive;
                return app;
            },
            mount (rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                    const vnode = createVNode(rootComponent, rootProps);
                    // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.
                    vnode.appContext = context;
                    context.reload = ()=>{
                        render(cloneVNode(vnode), rootContainer, isSVG);
                    };
                    if (isHydrate && hydrate) hydrate(vnode, rootContainer);
                    else render(vnode, rootContainer, isSVG);
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    app._instance = vnode.component;
                    devtoolsInitApp(app, version);
                    return getExposeProxy(vnode.component) || vnode.component.proxy;
                } else warn(`App has already been mounted.\n` + `If you want to remount the same app, move your app creation logic ` + `into a factory function and create fresh app instances for each ` + `mount - e.g. \`const createMyApp = () => createApp(App)\``);
            },
            unmount () {
                if (isMounted) {
                    render(null, app._container);
                    app._instance = null;
                    devtoolsUnmountApp(app);
                    delete app._container.__vue_app__;
                } else warn(`Cannot unmount an app that is not mounted.`);
            },
            provide (key, value) {
                if (key in context.provides) warn(`App already provides property with key "${String(key)}". ` + `It will be overwritten with the new value.`);
                // TypeScript doesn't allow symbols as index type
                // https://github.com/Microsoft/TypeScript/issues/24587
                context.provides[key] = value;
                return app;
            }
        };
        return app;
    };
}
/**
 * Function for handling a template ref
 */ function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (_shared.isArray(rawRef)) {
        rawRef.forEach((r, i)=>setRef(r, oldRawRef && (_shared.isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount)
        );
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) // when mounting async components, nothing needs to be done,
    // because the template ref is forwarded to inner component
    return;
    const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */  ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner , r: ref  } = rawRef;
    if (!owner) {
        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` + `A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === _shared.EMPTY_OBJ ? owner.refs = {
    } : owner.refs;
    const setupState = owner.setupState;
    // dynamic ref changed. unset old ref
    if (oldRef != null && oldRef !== ref) {
        if (_shared.isString(oldRef)) {
            refs[oldRef] = null;
            if (_shared.hasOwn(setupState, oldRef)) setupState[oldRef] = null;
        } else if (_reactivity.isRef(oldRef)) oldRef.value = null;
    }
    if (_shared.isFunction(ref)) callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */ , [
        value,
        refs
    ]);
    else {
        const _isString = _shared.isString(ref);
        const _isRef = _reactivity.isRef(ref);
        if (_isString || _isRef) {
            const doSet = ()=>{
                if (rawRef.f) {
                    const existing = _isString ? refs[ref] : ref.value;
                    if (isUnmount) _shared.isArray(existing) && _shared.remove(existing, refValue);
                    else {
                        if (!_shared.isArray(existing)) {
                            if (_isString) refs[ref] = [
                                refValue
                            ];
                            else {
                                ref.value = [
                                    refValue
                                ];
                                if (rawRef.k) refs[rawRef.k] = ref.value;
                            }
                        } else if (!existing.includes(refValue)) existing.push(refValue);
                    }
                } else if (_isString) {
                    refs[ref] = value;
                    if (_shared.hasOwn(setupState, ref)) setupState[ref] = value;
                } else if (_reactivity.isRef(ref)) {
                    ref.value = value;
                    if (rawRef.k) refs[rawRef.k] = value;
                } else warn('Invalid template ref type:', ref, `(${typeof ref})`);
            };
            if (value) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            } else doSet();
        } else warn('Invalid template ref type:', ref, `(${typeof ref})`);
    }
}
let hasMismatch = false;
const isSVGContainer = (container)=>/svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject'
;
const isComment = (node)=>node.nodeType === 8 /* COMMENT */ 
;
// Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent , p: patch , o: { patchProp , nextSibling , parentNode , remove , insert , createComment  }  } = rendererInternals;
    const hydrate = (vnode, container)=>{
        if (!container.hasChildNodes()) {
            warn(`Attempting to hydrate existing markup but container is empty. ` + `Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        if (hasMismatch && true) // this error should show up in production
        console.error(`Hydration completed but contains mismatches.`);
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false)=>{
        const isFragmentStart = isComment(node) && node.data === '[';
        const onMismatch = ()=>handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart)
        ;
        const { type , ref , shapeFlag  } = vnode;
        const domType = node.nodeType;
        vnode.el = node;
        let nextNode = null;
        switch(type){
            case Text:
                if (domType !== 3 /* TEXT */ ) nextNode = onMismatch();
                else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        warn(`Hydration text mismatch:` + `\n- Client: ${JSON.stringify(node.data)}` + `\n- Server: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (domType !== 8 /* COMMENT */  || isFragmentStart) nextNode = onMismatch();
                else nextNode = nextSibling(node);
                break;
            case Static:
                if (domType !== 1 /* ELEMENT */ ) nextNode = onMismatch();
                else {
                    // determine anchor, adopt content
                    nextNode = node;
                    // if the static vnode has its content stripped during build,
                    // adopt it from the server-rendered HTML.
                    const needToAdoptContent = !vnode.children.length;
                    for(let i = 0; i < vnode.staticCount; i++){
                        if (needToAdoptContent) vnode.children += nextNode.outerHTML;
                        if (i === vnode.staticCount - 1) vnode.anchor = nextNode;
                        nextNode = nextSibling(nextNode);
                    }
                    return nextNode;
                }
                break;
            case Fragment:
                if (!isFragmentStart) nextNode = onMismatch();
                else nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */ ) {
                    if (domType !== 1 /* ELEMENT */  || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) nextNode = onMismatch();
                    else nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                } else if (shapeFlag & 6 /* COMPONENT */ ) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.
                    nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
                    // #3787
                    // if component is async, it may get moved / unmounted before its
                    // inner component is loaded, so we need to give it a placeholder
                    // vnode that matches its adopted DOM.
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                        } else subTree = node.nodeType === 3 ? createTextVNode('') : createVNode('div');
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                } else if (shapeFlag & 64 /* TELEPORT */ ) {
                    if (domType !== 8 /* COMMENT */ ) nextNode = onMismatch();
                    else nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                } else if (shapeFlag & 128 /* SUSPENSE */ ) nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                else warn('Invalid HostVNode type:', type, `(${typeof type})`);
        }
        if (ref != null) setRef(ref, null, parentSuspense, vnode);
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!vnode.dynamicChildren;
        const { type , props , patchFlag , shapeFlag , dirs  } = vnode;
        // #4006 for form elements with non-string v-model value bindings
        // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">
        const forcePatchValue = type === 'input' && dirs || type === 'option';
        {
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, 'created');
            // props
            if (props) {
                if (forcePatchValue || !optimized || patchFlag & 48 /* HYDRATE_EVENTS */ ) {
                    for(const key in props)if (forcePatchValue && key.endsWith('value') || _shared.isOn(key) && !_shared.isReservedProp(key)) patchProp(el, key, null, props[key], false, undefined, parentComponent);
                } else if (props.onClick) // Fast path for click listeners (which is most often) to avoid
                // iterating through props.
                patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);
            }
            // vnode / directive hooks
            let vnodeHooks;
            if (vnodeHooks = props && props.onVnodeBeforeMount) invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) queueEffectWithSuspense(()=>{
                vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
            }, parentSuspense);
            // children
            if (shapeFlag & 16 /* ARRAY_CHILDREN */  && // skip if element has innerHTML / textContent
            !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned1 = false;
                while(next){
                    hasMismatch = true;
                    if (!hasWarned1) {
                        warn(`Hydration children mismatch in <${vnode.type}>: ` + `server rendered element contains more child nodes than client vdom.`);
                        hasWarned1 = true;
                    }
                    // The SSRed DOM contains more nodes than it should. Remove them.
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            } else if (shapeFlag & 8 /* TEXT_CHILDREN */ ) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    warn(`Hydration text content mismatch in <${vnode.type}>:\n` + `- Client: ${el.textContent}\n` + `- Server: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned2 = false;
        for(let i = 0; i < l; i++){
            const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
            if (node) node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            else if (vnode.type === Text && !vnode.children) continue;
            else {
                hasMismatch = true;
                if (!hasWarned2) {
                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` + `server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned2 = true;
                }
                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        const { slotScopeIds: fragmentSlotScopeIds  } = vnode;
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === ']') return nextSibling(vnode.anchor = next);
        else {
            // fragment didn't hydrate successfully, since we didn't get a end anchor
            // back. This should have led to node/children mismatch warnings.
            hasMismatch = true;
            // since the anchor is missing, we need to create one and insert it
            insert(vnode.anchor = createComment(`]`), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment)=>{
        hasMismatch = true;
        warn(`Hydration node mismatch:\n- Client vnode:`, vnode.type, `\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */  ? `(text)` : isComment(node) && node.data === '[' ? `(start of fragment)` : ``);
        vnode.el = null;
        if (isFragment) {
            // remove excessive fragment nodes
            const end = locateClosingAsyncAnchor(node);
            while(true){
                const next = nextSibling(node);
                if (next && next !== end) remove(next);
                else break;
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
    };
    const locateClosingAsyncAnchor = (node)=>{
        let match = 0;
        while(node){
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === '[') match++;
                if (node.data === ']') {
                    if (match === 0) return nextSibling(node);
                    else match--;
                }
            }
        }
        return node;
    };
    return [
        hydrate,
        hydrateNode
    ];
}
/* eslint-disable no-restricted-globals */ let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) perf.mark(`vue-${type}-${instance.uid}`);
    devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now());
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now());
}
function isSupported() {
    if (supported !== undefined) return supported;
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    } else supported = false;
    return supported;
}
/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */ function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== 'boolean') {
        needWarn.push(`__VUE_OPTIONS_API__`);
        _shared.getGlobalThis().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {
        needWarn.push(`__VUE_PROD_DEVTOOLS__`);
        _shared.getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(', ')} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, ` + `which expects these compile-time feature flags to be globally injected ` + `via the bundler config in order to get better tree-shaking in the ` + `production bundle.\n\n` + `For more details, see https://link.vuejs.org/feature-flags.`);
    }
}
const queuePostRenderEffect = queueEffectWithSuspense;
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */ function createRenderer(options) {
    return baseCreateRenderer(options);
}
// Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
// implementation
function baseCreateRenderer(options, createHydrationFns) {
    initFeatureFlags();
    const target = _shared.getGlobalThis();
    target.__VUE__ = true;
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    const { insert: hostInsert , remove: hostRemove , patchProp: hostPatchProp , createElement: hostCreateElement , createText: hostCreateText , createComment: hostCreateComment , setText: hostSetText , setElementText: hostSetElementText , parentNode: hostParentNode , nextSibling: hostNextSibling , setScopeId: hostSetScopeId = _shared.NOOP , cloneNode: hostCloneNode , insertStaticContent: hostInsertStaticContent  } = options;
    // Note: functions inside this closure should use `const xxx = () => {}`
    // style in order to prevent being inlined by minifiers.
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren)=>{
        if (n1 === n2) return;
        // patching & not same type, unmount old tree
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2 /* BAIL */ ) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type , ref , shapeFlag  } = n2;
        switch(type){
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) mountStaticNode(n2, container, anchor, isSVG);
                else patchStaticNode(n1, n2, container, isSVG);
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */ ) processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (shapeFlag & 6 /* COMPONENT */ ) processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (shapeFlag & 64 /* TELEPORT */ ) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                else if (shapeFlag & 128 /* SUSPENSE */ ) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                else warn('Invalid VNode type:', type, `(${typeof type})`);
        }
        // set ref
        if (ref != null && parentComponent) setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    };
    const processText = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
        else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) hostSetText(el, n2.children);
        }
    };
    const processCommentNode = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateComment(n2.children || ''), container, anchor);
        else // there's no support for dynamic comments
        n2.el = n1.el;
    };
    const mountStaticNode = (n2, container, anchor, isSVG)=>{
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    /**
     * Dev / HMR only
     */ const patchStaticNode = (n1, n2, container, isSVG)=>{
        // static nodes are only patched during dev for HMR
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            // remove existing
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        } else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el , anchor  }, container, nextSibling)=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el , anchor  })=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        isSVG = isSVG || n2.type === 'svg';
        if (n1 == null) mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        else patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        let el;
        let vnodeHook;
        const { type , props , shapeFlag , transition , patchFlag , dirs  } = vnode;
        el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
        // mount children first, since some props may rely on child content
        // being already rendered, e.g. `<select value>`
        if (shapeFlag & 8 /* TEXT_CHILDREN */ ) hostSetElementText(el, vnode.children);
        else if (shapeFlag & 16 /* ARRAY_CHILDREN */ ) mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, 'created');
        // props
        if (props) {
            for(const key in props)if (key !== 'value' && !_shared.isReservedProp(key)) hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            /**
                 * Special case for setting value on DOM elements:
                 * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
                 * - it needs to be forced (#1471)
                 * #2353 proposes adding another renderer option to configure this, but
                 * the properties affects are so finite it is worth special casing it
                 * here to reduce the complexity. (Special casing it also should not
                 * affect non-DOM renderers)
                 */ if ('value' in props) hostPatchProp(el, 'value', null, props.value);
            if (vnodeHook = props.onVnodeBeforeMount) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        // scopeId
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        Object.defineProperty(el, '__vnode', {
            value: vnode,
            enumerable: false
        });
        Object.defineProperty(el, '__vueParentComponent', {
            value: parentComponent,
            enumerable: false
        });
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
        // #1689 For inside suspense + suspense resolved case, just call it
        const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
        if (needCallTransitionHooks) transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
        }, parentSuspense);
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent)=>{
        if (scopeId) hostSetScopeId(el, scopeId);
        if (slotScopeIds) for(let i = 0; i < slotScopeIds.length; i++)hostSetScopeId(el, slotScopeIds[i]);
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (subTree.patchFlag > 0 && subTree.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */ ) subTree = filterSingleRoot(subTree.children) || subTree;
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0)=>{
        for(let i = start; i < children.length; i++){
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        const el = n2.el = n1.el;
        let { patchFlag , dynamicChildren , dirs  } = n2;
        // #1426 take the old vnode's patch flag into account since user may clone a
        // compiler-generated vnode, which de-opts to FULL_PROPS
        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */ ;
        const oldProps = n1.props || _shared.EMPTY_OBJ;
        const newProps = n2.props || _shared.EMPTY_OBJ;
        let vnodeHook;
        // disable recurse in beforeUpdate hooks
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        if (dirs) invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
        parentComponent && toggleRecurse(parentComponent, true);
        if (isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            if (parentComponent && parentComponent.type.__hmrId) traverseStaticChildren(n1, n2);
        } else if (!optimized) // full diff
        patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        if (patchFlag > 0) {
            // the presence of a patchFlag means this element's render code was
            // generated by the compiler and can take the fast path.
            // in this path old node and new node are guaranteed to have the same shape
            // (i.e. at the exact same position in the source template)
            if (patchFlag & 16 /* FULL_PROPS */ ) // element props contain dynamic keys, full diff needed
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            else {
                // class
                // this flag is matched when the element has dynamic class bindings.
                if (patchFlag & 2 /* CLASS */ ) {
                    if (oldProps.class !== newProps.class) hostPatchProp(el, 'class', null, newProps.class, isSVG);
                }
                // style
                // this flag is matched when the element has dynamic style bindings
                if (patchFlag & 4 /* STYLE */ ) hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                // props
                // This flag is matched when the element has dynamic prop/attr bindings
                // other than class and style. The keys of dynamic prop/attrs are saved for
                // faster iteration.
                // Note dynamic keys like :[foo]="bar" will cause this optimization to
                // bail out and go through a full diff because we need to unset the old key
                if (patchFlag & 8 /* PROPS */ ) {
                    // if the flag is present then dynamicProps must be non-null
                    const propsToUpdate = n2.dynamicProps;
                    for(let i = 0; i < propsToUpdate.length; i++){
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        // #1471 force patch value
                        if (next !== prev || key === 'value') hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
            // text
            // This flag is matched when the element has only dynamic text children.
            if (patchFlag & 1 /* TEXT */ ) {
                if (n1.children !== n2.children) hostSetElementText(el, n2.children);
            }
        } else if (!optimized && dynamicChildren == null) // unoptimized, full diff
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
        }, parentSuspense);
    };
    // The fast path for blocks.
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds)=>{
        for(let i = 0; i < newChildren.length; i++){
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            // Determine the container (parent element) for the patch.
            const container = // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & 70 /* TELEPORT */ ) ? hostParentNode(oldVNode.el) : // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG)=>{
        if (oldProps !== newProps) {
            for(const key in newProps){
                // empty string is not valid prop
                if (_shared.isReservedProp(key)) continue;
                const next = newProps[key];
                const prev = oldProps[key];
                // defer patching value
                if (next !== prev && key !== 'value') hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
            if (oldProps !== _shared.EMPTY_OBJ) {
                for(const key in oldProps)if (!_shared.isReservedProp(key) && !(key in newProps)) hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
            if ('value' in newProps) hostPatchProp(el, 'value', oldProps.value, newProps.value);
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText('');
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText('');
        let { patchFlag , dynamicChildren , slotScopeIds: fragmentSlotScopeIds  } = n2;
        if (isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        // check if this is a slot fragment with :slotted scope ids
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            // a fragment can only have array children
            // since they are either generated by the compiler, or implicitly created
            // from arrays.
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */  && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
            // a stable fragment (template root or <template v-for>) doesn't need to
            // patch children order, but it may contain dynamicChildren.
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
            if (parentComponent && parentComponent.type.__hmrId) traverseStaticChildren(n1, n2);
            else if (// #2080 if the stable fragment has a key, it's a <template v-for> that may
            //  get moved around. Make sure all root level vnodes inherit el.
            // #2134 or if it's a component root, it may also get moved around
            // as the component is being moved.
            n2.key != null || parentComponent && n2 === parentComponent.subTree) traverseStaticChildren(n1, n2, true);
        } else // keyed / unkeyed, or manual fragments.
        // for keyed & unkeyed, since they are compiler generated from v-for,
        // each child is guaranteed to be a block so the fragment will never
        // have dynamicChildren.
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */ ) parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            else mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        } else updateComponent(n1, n2, optimized);
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized)=>{
        const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
        if (instance.type.__hmrId) registerHMR(instance);
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
        // inject renderer internals for keepAlive
        if (isKeepAlive(initialVNode)) instance.ctx.renderer = internals;
        startMeasure(instance, `init`);
        setupComponent(instance);
        endMeasure(instance, `init`);
        // setup() is async. This component relies on async logic to be resolved
        // before proceeding
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            // Give it a placeholder if this is not hydration
            // TODO handle self-defined fallback
            if (!initialVNode.el) {
                const placeholder = instance.subTree = createVNode(Comment);
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        popWarningContext();
        endMeasure(instance, `mount`);
    };
    const updateComponent = (n1, n2, optimized)=>{
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
                pushWarningContext(n2);
                updateComponentPreRender(instance, n2, optimized);
                popWarningContext();
                return;
            } else {
                // normal update
                instance.next = n2;
                // in case the child component is also queued, remove it to avoid
                // double updating the same child component in the same flush.
                invalidateJob(instance.update);
                // instance.update is the reactive effect.
                instance.update();
            }
        } else {
            // no update needed. just copy over properties
            n2.component = n1.component;
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)=>{
        const componentUpdateFn = ()=>{
            if (!instance.isMounted) {
                let vnodeHook;
                const { el , props  } = initialVNode;
                const { bm , m , parent  } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                // beforeMount hook
                if (bm) _shared.invokeArrayFns(bm);
                // onVnodeBeforeMount
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) invokeVNodeHook(vnodeHook, parent, initialVNode);
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    // vnode has adopted host node - perform hydration instead of mount.
                    const hydrateSubTree = ()=>{
                        startMeasure(instance, `render`);
                        instance.subTree = renderComponentRoot(instance);
                        endMeasure(instance, `render`);
                        startMeasure(instance, `hydrate`);
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        endMeasure(instance, `hydrate`);
                    };
                    if (isAsyncWrapperVNode) initialVNode.type.__asyncLoader().then(// note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    ()=>!instance.isUnmounted && hydrateSubTree()
                    );
                    else hydrateSubTree();
                } else {
                    startMeasure(instance, `render`);
                    const subTree = instance.subTree = renderComponentRoot(instance);
                    endMeasure(instance, `render`);
                    startMeasure(instance, `patch`);
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    endMeasure(instance, `patch`);
                    initialVNode.el = subTree.el;
                }
                // mounted hook
                if (m) queuePostRenderEffect(m, parentSuspense);
                // onVnodeMounted
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, scopedInitialVNode)
                    , parentSuspense);
                }
                // activated hook for keep-alive roots.
                // #1742 activated hook must be accessed after first render
                // since the hook may be injected by a child keep-alive
                if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */ ) instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                instance.isMounted = true;
                devtoolsComponentAdded(instance);
                // #2458: deference mount-only object parameters to prevent memleaks
                initialVNode = container = anchor = null;
            } else {
                // updateComponent
                // This is triggered by mutation of component's own state (next: null)
                // OR parent calling processComponent (next: VNode)
                let { next , bu , u , parent , vnode  } = instance;
                let originNext = next;
                let vnodeHook;
                pushWarningContext(next || instance.vnode);
                // Disallow component effect recursion during pre-lifecycle hooks.
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                } else next = vnode;
                // beforeUpdate hook
                if (bu) _shared.invokeArrayFns(bu);
                // onVnodeBeforeUpdate
                if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parent, next, vnode);
                toggleRecurse(instance, true);
                startMeasure(instance, `render`);
                const nextTree = renderComponentRoot(instance);
                endMeasure(instance, `render`);
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                startMeasure(instance, `patch`);
                patch(prevTree, nextTree, // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                endMeasure(instance, `patch`);
                next.el = nextTree.el;
                if (originNext === null) // self-triggered update. In case of HOC, update parent component
                // vnode el. HOC is indicated by parent instance's subTree pointing
                // to child component's vnode
                updateHOCHostEl(instance, nextTree.el);
                // updated hook
                if (u) queuePostRenderEffect(u, parentSuspense);
                // onVnodeUpdated
                if (vnodeHook = next.props && next.props.onVnodeUpdated) queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, next, vnode)
                , parentSuspense);
                devtoolsComponentUpdated(instance);
                popWarningContext();
            }
        };
        // create reactive effect for rendering
        const effect = instance.effect = new _reactivity.ReactiveEffect(componentUpdateFn, ()=>queueJob(instance.update)
        , instance.scope // track it in component's effect scope
        );
        const update = instance.update = effect.run.bind(effect);
        update.id = instance.uid;
        // allowRecurse
        // #1801, #2043 component render effects should allow recursive updates
        toggleRecurse(instance, true);
        effect.onTrack = instance.rtc ? (e)=>_shared.invokeArrayFns(instance.rtc, e)
         : void 0;
        effect.onTrigger = instance.rtg ? (e)=>_shared.invokeArrayFns(instance.rtg, e)
         : void 0;
        // @ts-ignore (for scheduler)
        update.ownerInstance = instance;
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized)=>{
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        _reactivity.pauseTracking();
        // props update may have triggered pre-flush watchers.
        // flush them before the render update.
        flushPreFlushCbs(undefined, instance.update);
        _reactivity.resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false)=>{
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag , shapeFlag  } = n2;
        // fast path
        if (patchFlag > 0) {
            if (patchFlag & 128 /* KEYED_FRAGMENT */ ) {
                // this could be either fully-keyed or mixed (some keyed some not)
                // presence of patchFlag means children are guaranteed to be arrays
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            } else if (patchFlag & 256 /* UNKEYED_FRAGMENT */ ) {
                // unkeyed
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
        }
        // children has 3 possibilities: text, array or no children.
        if (shapeFlag & 8 /* TEXT_CHILDREN */ ) {
            // text children fast path
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */ ) unmountChildren(c1, parentComponent, parentSuspense);
            if (c2 !== c1) hostSetElementText(container, c2);
        } else if (prevShapeFlag & 16 /* ARRAY_CHILDREN */ ) {
            // prev children was array
            if (shapeFlag & 16 /* ARRAY_CHILDREN */ ) // two arrays, cannot assume anything, do full diff
            patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else // no new children, just unmount old
            unmountChildren(c1, parentComponent, parentSuspense, true);
        } else {
            // prev children was text OR null
            // new children is array OR null
            if (prevShapeFlag & 8 /* TEXT_CHILDREN */ ) hostSetElementText(container, '');
            // mount new if array
            if (shapeFlag & 16 /* ARRAY_CHILDREN */ ) mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        c1 = c1 || _shared.EMPTY_ARR;
        c2 = c2 || _shared.EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for(i = 0; i < commonLength; i++){
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) // remove old
        unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        else // mount new
        mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    };
    // can be all-keyed or mixed
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1; // prev ending index
        let e2 = l2 - 1; // next ending index
        // 1. sync from start
        // (a b) c
        // (a b) d e
        while(i <= e1 && i <= e2){
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else break;
            i++;
        }
        // 2. sync from end
        // a (b c)
        // d e (b c)
        while(i <= e1 && i <= e2){
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else break;
            e1--;
            e2--;
        }
        // 3. common sequence + mount
        // (a b)
        // (a b) c
        // i = 2, e1 = 1, e2 = 2
        // (a b)
        // c (a b)
        // i = 0, e1 = -1, e2 = 0
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while(i <= e2){
                    patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    i++;
                }
            }
        } else if (i > e2) while(i <= e1){
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
        }
        else {
            const s1 = i; // prev starting index
            const s2 = i; // next starting index
            // 5.1 build key:index map for newChildren
            const keyToNewIndexMap = new Map();
            for(i = s2; i <= e2; i++){
                const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                if (nextChild.key != null) {
                    if (keyToNewIndexMap.has(nextChild.key)) warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            // 5.2 loop through old children left to be patched and try to patch
            // matching nodes & remove nodes that are no longer present
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            // used to track whether any node has moved
            let maxNewIndexSoFar = 0;
            // works as Map<newIndex, oldIndex>
            // Note that oldIndex is offset by +1
            // and oldIndex = 0 is a special value indicating the new node has
            // no corresponding old node.
            // used for determining longest stable subsequence
            const newIndexToOldIndexMap = new Array(toBePatched);
            for(i = 0; i < toBePatched; i++)newIndexToOldIndexMap[i] = 0;
            for(i = s1; i <= e1; i++){
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) newIndex = keyToNewIndexMap.get(prevChild.key);
                else {
                    // key-less node, try to locate a key-less node of the same type
                    for(j = s2; j <= e2; j++)if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                        newIndex = j;
                        break;
                    }
                }
                if (newIndex === undefined) unmount(prevChild, parentComponent, parentSuspense, true);
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) maxNewIndexSoFar = newIndex;
                    else moved = true;
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    patched++;
                }
            }
            // 5.3 move and mount
            // generate longest stable subsequence only when nodes have moved
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : _shared.EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            // looping backwards so that we can use last patched node as anchor
            for(i = toBePatched - 1; i >= 0; i--){
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) // mount new
                patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) move(nextChild, container, anchor, 2 /* REORDER */ );
                    else j--;
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null)=>{
        const { el , type , transition , children , shapeFlag  } = vnode;
        if (shapeFlag & 6 /* COMPONENT */ ) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128 /* SUSPENSE */ ) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64 /* TELEPORT */ ) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for(let i = 0; i < children.length; i++)move(children[i], container, anchor, moveType);
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        // single nodes
        const needTransition = moveType !== 2 /* REORDER */  && shapeFlag & 1 /* ELEMENT */  && transition;
        if (needTransition) {
            if (moveType === 0 /* ENTER */ ) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(()=>transition.enter(el)
                , parentSuspense);
            } else {
                const { leave , delayLeave , afterLeave  } = transition;
                const remove = ()=>hostInsert(el, container, anchor)
                ;
                const performLeave = ()=>{
                    leave(el, ()=>{
                        remove();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) delayLeave(el, remove, performLeave);
                else performLeave();
            }
        } else hostInsert(el, container, anchor);
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false)=>{
        const { type , props , ref , children , dynamicChildren , shapeFlag , patchFlag , dirs  } = vnode;
        // unset ref
        if (ref != null) setRef(ref, null, parentSuspense, vnode, true);
        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */ ) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */  && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        if (shapeFlag & 6 /* COMPONENT */ ) unmountComponent(vnode.component, parentSuspense, doRemove);
        else {
            if (shapeFlag & 128 /* SUSPENSE */ ) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
            if (shapeFlag & 64 /* TELEPORT */ ) vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */ )) // fast path for block nodes: only need to unmount dynamic children.
            unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            else if (type === Fragment && patchFlag & 384 /* UNKEYED_FRAGMENT */  || !optimized && shapeFlag & 16 /* ARRAY_CHILDREN */ ) unmountChildren(children, parentComponent, parentSuspense);
            if (doRemove) remove1(vnode);
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
        }, parentSuspense);
    };
    const remove1 = (vnode)=>{
        const { type , el , anchor , transition  } = vnode;
        if (type === Fragment) {
            removeFragment(el, anchor);
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = ()=>{
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) transition.afterLeave();
        };
        if (vnode.shapeFlag & 1 /* ELEMENT */  && transition && !transition.persisted) {
            const { leave , delayLeave  } = transition;
            const performLeave = ()=>leave(el, performRemove)
            ;
            if (delayLeave) delayLeave(vnode.el, performRemove, performLeave);
            else performLeave();
        } else performRemove();
    };
    const removeFragment = (cur, end)=>{
        // For fragments, directly remove all contained DOM nodes.
        // (fragment child nodes cannot have transition)
        let next;
        while(cur !== end){
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove)=>{
        if (instance.type.__hmrId) unregisterHMR(instance);
        const { bum , scope , update , subTree , um  } = instance;
        // beforeUnmount hook
        if (bum) _shared.invokeArrayFns(bum);
        // stop effects in component scope
        scope.stop();
        // update may be null if a component is unmounted before its async
        // setup has resolved.
        if (update) {
            // so that scheduler will no longer invoke it
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        // unmounted hook
        if (um) queuePostRenderEffect(um, parentSuspense);
        queuePostRenderEffect(()=>{
            instance.isUnmounted = true;
        }, parentSuspense);
        // A component with async dep inside a pending suspense is unmounted before
        // its async dep resolves. This should remove the dep from the suspense, and
        // cause the suspense to resolve immediately if that was the last dep.
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) parentSuspense.resolve();
        }
        devtoolsComponentRemoved(instance);
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0)=>{
        for(let i = start; i < children.length; i++)unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    };
    const getNextHostNode = (vnode)=>{
        if (vnode.shapeFlag & 6 /* COMPONENT */ ) return getNextHostNode(vnode.component.subTree);
        if (vnode.shapeFlag & 128 /* SUSPENSE */ ) return vnode.suspense.next();
        return hostNextSibling(vnode.anchor || vnode.el);
    };
    const render = (vnode, container, isSVG)=>{
        if (vnode == null) {
            if (container._vnode) unmount(container._vnode, null, null, true);
        } else patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove1,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) [hydrate, hydrateNode] = createHydrationFns(internals);
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function toggleRecurse({ effect , update  }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always be moved. Therefore, in order to ensure correct move
 * position, el should be inherited from previous nodes.
 */ function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (_shared.isArray(ch1) && _shared.isArray(ch2)) for(let i = 0; i < ch1.length; i++){
        // this is only called in the optimized path so array children are
        // guaranteed to be vnodes
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 /* ELEMENT */  && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */ ) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
            }
            if (!shallow) traverseStaticChildren(c1, c2);
        }
        // also inherit for comment nodes, but not placeholders (e.g. v-if which
        // would have received .el during block patch)
        if (c2.type === Comment && !c2.el) c2.el = c1.el;
    }
}
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr) {
    const p = arr.slice();
    const result = [
        0
    ];
    let i, j, u, v, c;
    const len = arr.length;
    for(i = 0; i < len; i++){
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v = result.length - 1;
            while(u < v){
                c = u + v >> 1;
                if (arr[result[c]] < arrI) u = c + 1;
                else v = c;
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) p[i] = result[u - 1];
                result[u] = i;
            }
        }
    }
    u = result.length;
    v = result[u - 1];
    while(u-- > 0){
        result[u] = v;
        v = p[v];
    }
    return result;
}
const isTeleport = (type)=>type.__isTeleport
;
const isTeleportDisabled = (props)=>props && (props.disabled || props.disabled === '')
;
const isTargetSVG = (target)=>typeof SVGElement !== 'undefined' && target instanceof SVGElement
;
const resolveTarget = (props, select)=>{
    const targetSelector = props && props.to;
    if (_shared.isString(targetSelector)) {
        if (!select) {
            warn(`Current renderer does not support string target for Teleports. ` + `(missing querySelector renderer option)`);
            return null;
        } else {
            const target = select(targetSelector);
            if (!target) warn(`Failed to locate Teleport target with selector "${targetSelector}". ` + `Note the target element must exist before the component is mounted - ` + `i.e. the target cannot be rendered by the component itself, and ` + `ideally should be outside of the entire Vue component tree.`);
            return target;
        }
    } else {
        if (!targetSelector && !isTeleportDisabled(props)) warn(`Invalid Teleport target: ${targetSelector}`);
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process (n1, n2, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren , pc: patchChildren , pbc: patchBlockChildren , o: { insert , querySelector , createText , createComment  }  } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag , children , dynamicChildren  } = n2;
        // #3302
        // HMR updated, force full diff
        if (isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            // insert anchors in the main view
            const placeholder = n2.el = createComment('teleport start');
            const mainAnchor = n2.anchor = createComment('teleport end');
            insert(placeholder, container2, anchor2);
            insert(mainAnchor, container2, anchor2);
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText('');
            if (target) {
                insert(targetAnchor, target);
                // #2652 we could be teleporting from a non-SVG tree into an SVG tree
                isSVG = isSVG || isTargetSVG(target);
            } else if (!disabled) warn('Invalid Teleport target on mount:', target, `(${typeof target})`);
            const mount = (container, anchor)=>{
                // Teleport *always* has Array children. This is enforced in both the
                // compiler and vnode children normalization.
                if (shapeFlag & 16 /* ARRAY_CHILDREN */ ) mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            };
            if (disabled) mount(container2, mainAnchor);
            else if (target) mount(target, targetAnchor);
        } else {
            // update content
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container2 : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
                // fast path when the teleport happens to be a block root
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                // even in block tree mode we need to make sure all root-level nodes
                // in the teleport inherit previous DOM references so that they can
                // be moved in future patches.
                traverseStaticChildren(n1, n2, true);
            } else if (!optimized) patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            if (disabled) {
                if (!wasDisabled) // enabled -> disabled
                // move into main container
                moveTeleport(n2, container2, mainAnchor, internals, 1 /* TOGGLE */ );
            } else {
                // target changed
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
                    if (nextTarget) moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */ );
                    else warn('Invalid Teleport target on update:', target, `(${typeof target})`);
                } else if (wasDisabled) // disabled -> enabled
                // move into teleport target
                moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */ );
            }
        }
    },
    remove (vnode, parentComponent, parentSuspense, optimized, { um: unmount , o: { remove: hostRemove  }  }, doRemove) {
        const { shapeFlag , children , anchor , targetAnchor , target , props  } = vnode;
        if (target) hostRemove(targetAnchor);
        // an unmounted teleport should always remove its children if not disabled
        if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16 /* ARRAY_CHILDREN */ ) for(let i = 0; i < children.length; i++){
                const child = children[i];
                unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert  } , m: move  }, moveType = 2 /* REORDER */ ) {
    // move target anchor if this is a target change.
    if (moveType === 0 /* TARGET_CHANGE */ ) insert(vnode.targetAnchor, container, parentAnchor);
    const { el , anchor , shapeFlag , children , props  } = vnode;
    const isReorder = moveType === 2 /* REORDER */ ;
    // move main view anchor if this is a re-order.
    if (isReorder) insert(el, container, parentAnchor);
    // if this is a re-order and teleport is enabled (content is in target)
    // do not move children. So the opposite is: only move children if this
    // is not a reorder, or the teleport is disabled
    if (!isReorder || isTeleportDisabled(props)) {
        // Teleport has either Array children or no children.
        if (shapeFlag & 16 /* ARRAY_CHILDREN */ ) for(let i = 0; i < children.length; i++)move(children[i], container, parentAnchor, 2 /* REORDER */ );
    }
    // move main view anchor if this is a re-order.
    if (isReorder) insert(anchor, container, parentAnchor);
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling , parentNode , querySelector  }  }, hydrateChildren) {
    const target = vnode.target = resolveTarget(vnode.props, querySelector);
    if (target) {
        // if multiple teleports rendered to the same target element, we need to
        // pick up from where the last teleport finished instead of the first node
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */ ) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            } else {
                vnode.anchor = nextSibling(node);
                vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
        }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
// Force-casted public typing for h and TSX props inference
const Teleport = TeleportImpl;
const COMPONENTS = 'components';
const DIRECTIVES = 'directives';
/**
 * @private
 */ function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */ function resolveDynamicComponent(component) {
    if (_shared.isString(component)) return resolveAsset(COMPONENTS, component, false) || component;
    else // invalid types will fallthrough to createVNode and raise warning
    return component || NULL_DYNAMIC_COMPONENT;
}
/**
 * @private
 */ function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
// implementation
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        // explicit self name has highest priority
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component);
            if (selfName && (selfName === name || selfName === _shared.camelize(name) || selfName === _shared.capitalize(_shared.camelize(name)))) return Component;
        }
        const res = // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) // fallback to implicit self-reference
        return Component;
        if (warnMissing && !res) {
            const extra = type === COMPONENTS ? `\nIf this is a native custom element, make sure to exclude it from ` + `component resolution via compilerOptions.isCustomElement.` : ``;
            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
    } else warn(`resolve${_shared.capitalize(type.slice(0, -1))} ` + `can only be used in render() or setup().`);
}
function resolve(registry, name) {
    return registry && (registry[name] || registry[_shared.camelize(name)] || registry[_shared.capitalize(_shared.camelize(name))]);
}
const Fragment = Symbol('Fragment');
const Text = Symbol('Text');
const Comment = Symbol('Comment');
const Static = Symbol('Static');
// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
const blockStack = [];
let currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */ function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
let isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */ function setBlockTracking(value) {
    isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
    // save current block children on the block vnode
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || _shared.EMPTY_ARR : null;
    // close block
    closeBlock();
    // a block is always going to be patched, so track it as a child of its
    // parent block
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(vnode);
    return vnode;
}
/**
 * @private
 */ function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */ function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 /* COMPONENT */  && hmrDirtyComponents.has(n2.type)) // HMR only: if the component has been hot-updated, force a reload.
    return false;
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */ function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args)=>{
    return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key  })=>key != null ? key : null
;
const normalizeRef = ({ ref , ref_key , ref_for  })=>{
    return ref != null ? _shared.isString(ref) || _reactivity.isRef(ref) || _shared.isFunction(ref) ? {
        i: currentRenderingInstance,
        r: ref,
        k: ref_key,
        f: !!ref_for
    } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ELEMENT */ , isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        // normalize suspense children
        if (shapeFlag & 128 /* SUSPENSE */ ) type.normalize(vnode);
    } else if (children) // compiled element vnode - if children is passed, only possible types are
    // string or Array.
    vnode.shapeFlag |= _shared.isString(children) ? 8 /* TEXT_CHILDREN */  : 16 /* ARRAY_CHILDREN */ ;
    // validate key
    if (vnode.key !== vnode.key) warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    // track vnode for block tree
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6 /* COMPONENT */ ) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32 /* HYDRATE_EVENTS */ ) currentBlock.push(vnode);
    return vnode;
}
const createVNode = createVNodeWithArgsTransform;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (!type) warn(`Invalid vnode type when creating vnode: ${type}.`);
        type = Comment;
    }
    if (isVNode(type)) {
        // createVNode receiving an existing vnode. This happens in cases like
        // <component :is="vnode"/>
        // #2078 make sure to merge refs during the clone instead of overwriting it
        const cloned = cloneVNode(type, props, true);
        if (children) normalizeChildren(cloned, children);
        return cloned;
    }
    // class component normalization.
    if (isClassComponent(type)) type = type.__vccOpts;
    // class & style normalization.
    if (props) {
        // for reactive or proxy objects, we need to clone it to enable mutation.
        props = guardReactiveProps(props);
        let { class: klass , style  } = props;
        if (klass && !_shared.isString(klass)) props.class = _shared.normalizeClass(klass);
        if (_shared.isObject(style)) {
            // reactive state objects need to be cloned since they are likely to be
            // mutated
            if (_reactivity.isProxy(style) && !_shared.isArray(style)) style = _shared.extend({
            }, style);
            props.style = _shared.normalizeStyle(style);
        }
    }
    // encode the vnode type information into a bitmap
    const shapeFlag = _shared.isString(type) ? 1 /* ELEMENT */  : isSuspense(type) ? 128 /* SUSPENSE */  : isTeleport(type) ? 64 /* TELEPORT */  : _shared.isObject(type) ? 4 /* STATEFUL_COMPONENT */  : _shared.isFunction(type) ? 2 /* FUNCTIONAL_COMPONENT */  : 0;
    if (shapeFlag & 4 /* STATEFUL_COMPONENT */  && _reactivity.isProxy(type)) {
        type = _reactivity.toRaw(type);
        warn(`Vue received a Component which was made a reactive object. This can ` + `lead to unnecessary performance overhead, and should be avoided by ` + `marking the component with \`markRaw\` or using \`shallowRef\` ` + `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props) return null;
    return _reactivity.isProxy(props) || InternalObjectKey in props ? _shared.extend({
    }, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    const { props , ref , patchFlag , children  } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {
    }, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref ? _shared.isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [
            ref,
            normalizeRef(extraProps)
        ] : normalizeRef(extraProps) : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: patchFlag === -1 /* HOISTED */  && _shared.isArray(children) ? children.map(deepCloneVNode) : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 // hoisted node
         ? 16 /* FULL_PROPS */  : patchFlag | 16 /* FULL_PROPS */  : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor
    };
    return cloned;
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */ function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (_shared.isArray(vnode.children)) cloned.children = vnode.children.map(deepCloneVNode);
    return cloned;
}
/**
 * @private
 */ function createTextVNode(text = ' ', flag = 0) {
    return createVNode(Text, null, text, flag);
}
/**
 * @private
 */ function createStaticVNode(content, numberOfNodes) {
    // A static vnode can contain multiple stringified elements, and the number
    // of elements is necessary for hydration.
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
/**
 * @private
 */ function createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a
// block to ensure correct updates.
asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === 'boolean') // empty placeholder
    return createVNode(Comment);
    else if (_shared.isArray(child)) // fragment
    return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
    child.slice());
    else if (typeof child === 'object') // already vnode, this should be the most common since compiled templates
    // always produce all-vnode children arrays
    return cloneIfMounted(child);
    else // strings and numbers
    return createVNode(Text, null, String(child));
}
// optimized normalization for template-compiled render fns
function cloneIfMounted(child) {
    return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag  } = vnode;
    if (children == null) children = null;
    else if (_shared.isArray(children)) type = 16 /* ARRAY_CHILDREN */ ;
    else if (typeof children === 'object') {
        if (shapeFlag & 65 /* TELEPORT */ ) {
            // Normalize slot to plain children for plain element and Teleport
            const slot = children.default;
            if (slot) {
                // _c marker is added by withCtx() indicating this is a compiled slot
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        } else {
            type = 32 /* SLOTS_CHILDREN */ ;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) children._ctx = currentRenderingInstance;
            else if (slotFlag === 3 /* FORWARDED */  && currentRenderingInstance) {
                // a child component receives forwarded slots from the parent.
                // its slot type is determined by its parent's slot type.
                if (currentRenderingInstance.slots._ === 1 /* STABLE */ ) children._ = 1 /* STABLE */ ;
                else {
                    children._ = 2 /* DYNAMIC */ ;
                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */ ;
                }
            }
        }
    } else if (_shared.isFunction(children)) {
        children = {
            default: children,
            _ctx: currentRenderingInstance
        };
        type = 32 /* SLOTS_CHILDREN */ ;
    } else {
        children = String(children);
        // force teleport children to array so it can be moved around
        if (shapeFlag & 64 /* TELEPORT */ ) {
            type = 16 /* ARRAY_CHILDREN */ ;
            children = [
                createTextVNode(children)
            ];
        } else type = 8 /* TEXT_CHILDREN */ ;
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {
    };
    for(let i = 0; i < args.length; i++){
        const toMerge = args[i];
        for(const key in toMerge){
            if (key === 'class') {
                if (ret.class !== toMerge.class) ret.class = _shared.normalizeClass([
                    ret.class,
                    toMerge.class
                ]);
            } else if (key === 'style') ret.style = _shared.normalizeStyle([
                ret.style,
                toMerge.style
            ]);
            else if (_shared.isOn(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming && existing !== incoming && !(_shared.isArray(existing) && existing.includes(incoming))) ret[key] = existing ? [].concat(existing, incoming) : incoming;
            } else if (key !== '') ret[key] = toMerge[key];
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */ , [
        vnode,
        prevVNode
    ]);
}
/**
 * Actual implementation
 */ function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache && cache[index];
    if (_shared.isArray(source) || _shared.isString(source)) {
        ret = new Array(source.length);
        for(let i = 0, l = source.length; i < l; i++)ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);
    } else if (typeof source === 'number') {
        if (!Number.isInteger(source)) {
            warn(`The v-for range expect an integer value but got ${source}.`);
            return [];
        }
        ret = new Array(source);
        for(let i = 0; i < source; i++)ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);
    } else if (_shared.isObject(source)) {
        if (source[Symbol.iterator]) ret = Array.from(source, (item, i)=>renderItem(item, i, undefined, cached && cached[i])
        );
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for(let i = 0, l = keys.length; i < l; i++){
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    } else ret = [];
    if (cache) cache[index] = ret;
    return ret;
}
/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */ function createSlots(slots, dynamicSlots) {
    for(let i = 0; i < dynamicSlots.length; i++){
        const slot = dynamicSlots[i];
        // array of dynamic slot generated by <template v-for="..." #[...]>
        if (_shared.isArray(slot)) for(let j = 0; j < slot.length; j++)slots[slot[j].name] = slot[j].fn;
        else if (slot) // conditional single slot generated by <template v-if="..." #foo>
        slots[slot.name] = slot.fn;
    }
    return slots;
}
/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */ function renderSlot(slots, name, props = {
}, // this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback, noSlotted) {
    if (currentRenderingInstance.isCE) return createVNode('slot', name === 'default' ? null : {
        name
    }, fallback && fallback());
    let slot = slots[name];
    if (slot && slot.length > 1) {
        warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` + `function. You need to mark this component with $dynamic-slots in the ` + `parent template.`);
        slot = ()=>[]
        ;
    }
    // a compiled slot disables block tracking by default to avoid manual
    // invocation interfering with template-based block tracking, but in
    // `renderSlot` we can be sure that it's template-based so we can force
    // enable it.
    if (slot && slot._c) slot._d = false;
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, {
        key: props.key || `_${name}`
    }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */  ? 64 /* STABLE_FRAGMENT */  : -2 /* BAIL */ );
    if (!noSlotted && rendered.scopeId) rendered.slotScopeIds = [
        rendered.scopeId + '-s'
    ];
    if (slot && slot._c) slot._d = true;
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some((child)=>{
        if (!isVNode(child)) return true;
        if (child.type === Comment) return false;
        if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
        return true;
    }) ? vnodes : null;
}
/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */ function toHandlers(obj) {
    const ret = {
    };
    if (!_shared.isObject(obj)) {
        warn(`v-on with no argument expects an object value.`);
        return ret;
    }
    for(const key in obj)ret[_shared.toHandlerKey(key)] = obj[key];
    return ret;
}
/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */ const getPublicInstance = (i)=>{
    if (!i) return null;
    if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = _shared.extend(Object.create(null), {
    $: (i)=>i
    ,
    $el: (i)=>i.vnode.el
    ,
    $data: (i)=>i.data
    ,
    $props: (i)=>_reactivity.shallowReadonly(i.props)
    ,
    $attrs: (i)=>_reactivity.shallowReadonly(i.attrs)
    ,
    $slots: (i)=>_reactivity.shallowReadonly(i.slots)
    ,
    $refs: (i)=>_reactivity.shallowReadonly(i.refs)
    ,
    $parent: (i)=>getPublicInstance(i.parent)
    ,
    $root: (i)=>getPublicInstance(i.root)
    ,
    $emit: (i)=>i.emit
    ,
    $options: (i)=>__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type
    ,
    $forceUpdate: (i)=>()=>queueJob(i.update)
    ,
    $nextTick: (i)=>nextTick.bind(i.proxy)
    ,
    $watch: (i)=>__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : _shared.NOOP
});
const PublicInstanceProxyHandlers = {
    get ({ _: instance  }, key) {
        const { ctx , setupState , data , props , accessCache , type , appContext  } = instance;
        // for internal formatters to know that this is a Vue instance
        if (key === '__isVue') return true;
        // prioritize <script setup> bindings during dev.
        // this allows even properties that start with _ or $ to be used - so that
        // it aligns with the production behavior where the render fn is inlined and
        // indeed has access to all declared variables.
        if (setupState !== _shared.EMPTY_OBJ && setupState.__isScriptSetup && _shared.hasOwn(setupState, key)) return setupState[key];
        // data / props / ctx
        // This getter gets called for every property access on the render context
        // during render and is a major hotspot. The most expensive part of this
        // is the multiple hasOwn() calls. It's much faster to do a simple property
        // access on a plain object, so we use an accessCache object (with null
        // prototype) to memoize what access type a key corresponds to.
        let normalizedProps;
        if (key[0] !== '$') {
            const n = accessCache[key];
            if (n !== undefined) switch(n){
                case 1 /* SETUP */ :
                    return setupState[key];
                case 2 /* DATA */ :
                    return data[key];
                case 4 /* CONTEXT */ :
                    return ctx[key];
                case 3 /* PROPS */ :
                    return props[key];
            }
            else if (setupState !== _shared.EMPTY_OBJ && _shared.hasOwn(setupState, key)) {
                accessCache[key] = 1 /* SETUP */ ;
                return setupState[key];
            } else if (data !== _shared.EMPTY_OBJ && _shared.hasOwn(data, key)) {
                accessCache[key] = 2 /* DATA */ ;
                return data[key];
            } else if (// only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && _shared.hasOwn(normalizedProps, key)) {
                accessCache[key] = 3 /* PROPS */ ;
                return props[key];
            } else if (ctx !== _shared.EMPTY_OBJ && _shared.hasOwn(ctx, key)) {
                accessCache[key] = 4 /* CONTEXT */ ;
                return ctx[key];
            } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) accessCache[key] = 0 /* OTHER */ ;
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        // public $xxx properties
        if (publicGetter) {
            if (key === '$attrs') {
                _reactivity.track(instance, "get" /* GET */ , key);
                markAttrsAccessed();
            }
            return publicGetter(instance);
        } else if (// css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])) return cssModule;
        else if (ctx !== _shared.EMPTY_OBJ && _shared.hasOwn(ctx, key)) {
            // user may set custom properties to `this` that start with `$`
            accessCache[key] = 4 /* CONTEXT */ ;
            return ctx[key];
        } else if (globalProperties = appContext.config.globalProperties, _shared.hasOwn(globalProperties, key)) return globalProperties[key];
        else if (currentRenderingInstance && (!_shared.isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
        // to infinite warning loop
        key.indexOf('__v') !== 0)) {
            if (data !== _shared.EMPTY_OBJ && (key[0] === '$' || key[0] === '_') && _shared.hasOwn(data, key)) warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` + `character ("$" or "_") and is not proxied on the render context.`);
            else if (instance === currentRenderingInstance) warn(`Property ${JSON.stringify(key)} was accessed during render ` + `but is not defined on instance.`);
        }
    },
    set ({ _: instance  }, key, value) {
        const { data , setupState , ctx  } = instance;
        if (setupState !== _shared.EMPTY_OBJ && _shared.hasOwn(setupState, key)) {
            setupState[key] = value;
            return true;
        } else if (data !== _shared.EMPTY_OBJ && _shared.hasOwn(data, key)) {
            data[key] = value;
            return true;
        } else if (_shared.hasOwn(instance.props, key)) {
            warn(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
            return false;
        }
        if (key[0] === '$' && key.slice(1) in instance) {
            warn(`Attempting to mutate public property "${key}". ` + `Properties starting with $ are reserved and readonly.`, instance);
            return false;
        } else if (key in instance.appContext.config.globalProperties) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value
        });
        else ctx[key] = value;
        return true;
    },
    has ({ _: { data , setupState , accessCache , ctx , appContext , propsOptions  }  }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== _shared.EMPTY_OBJ && _shared.hasOwn(data, key) || setupState !== _shared.EMPTY_OBJ && _shared.hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && _shared.hasOwn(normalizedProps, key) || _shared.hasOwn(ctx, key) || _shared.hasOwn(publicPropertiesMap, key) || _shared.hasOwn(appContext.config.globalProperties, key);
    },
    defineProperty (target, key, descriptor) {
        if (descriptor.get != null) this.set(target, key, descriptor.get(), null);
        else if (descriptor.value != null) this.set(target, key, descriptor.value, null);
        return Reflect.defineProperty(target, key, descriptor);
    }
};
PublicInstanceProxyHandlers.ownKeys = (target)=>{
    warn(`Avoid app logic that relies on enumerating keys on a component instance. ` + `The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
};
const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ _shared.extend({
}, PublicInstanceProxyHandlers, {
    get (target, key) {
        // fast path for unscopables when using `with` block
        if (key === Symbol.unscopables) return;
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has (_, key) {
        const has = key[0] !== '_' && !_shared.isGloballyWhitelisted(key);
        if (!has && PublicInstanceProxyHandlers.has(_, key)) warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        return has;
    }
});
// dev only
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.
function createDevRenderContext(instance) {
    const target = {
    };
    // expose internal instance for proxy handlers
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: ()=>instance
    });
    // expose public properties
    Object.keys(publicPropertiesMap).forEach((key)=>{
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: ()=>publicPropertiesMap[key](instance)
            ,
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: _shared.NOOP
        });
    });
    return target;
}
// dev only
function exposePropsOnRenderContext(instance) {
    const { ctx , propsOptions: [propsOptions]  } = instance;
    if (propsOptions) Object.keys(propsOptions).forEach((key)=>{
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>instance.props[key]
            ,
            set: _shared.NOOP
        });
    });
}
// dev only
function exposeSetupStateOnRenderContext(instance) {
    const { ctx , setupState  } = instance;
    Object.keys(_reactivity.toRaw(setupState)).forEach((key)=>{
        if (!setupState.__isScriptSetup) {
            if (key[0] === '$' || key[0] === '_') {
                warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` + `which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: ()=>setupState[key]
                ,
                set: _shared.NOOP
            });
        }
    });
}
const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    // inherit parent app context - or - if root, adopt from root vnode
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid$1++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new _reactivity.EffectScope(true),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resovled assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        emitted: null,
        // props default value
        propsDefaults: _shared.EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: _shared.EMPTY_OBJ,
        data: _shared.EMPTY_OBJ,
        props: _shared.EMPTY_OBJ,
        attrs: _shared.EMPTY_OBJ,
        slots: _shared.EMPTY_OBJ,
        refs: _shared.EMPTY_OBJ,
        setupState: _shared.EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    instance.ctx = createDevRenderContext(instance);
    instance.root = parent ? parent.root : instance;
    instance.emit = emit$1.bind(null, instance);
    // apply custom element special handling
    if (vnode.ce) vnode.ce(instance);
    return instance;
}
let currentInstance = null;
const getCurrentInstance = ()=>currentInstance || currentRenderingInstance
;
const setCurrentInstance = (instance)=>{
    currentInstance = instance;
    instance.scope.on();
};
const unsetCurrentInstance = ()=>{
    currentInstance && currentInstance.scope.off();
    currentInstance = null;
};
const isBuiltInTag = /*#__PURE__*/ _shared.makeMap('slot,component');
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || _shared.NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) warn('Do not use built-in or reserved HTML elements as component id: ' + name);
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */ ;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props , children  } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    if (Component.name) validateComponentName(Component.name, instance.appContext.config);
    if (Component.components) {
        const names = Object.keys(Component.components);
        for(let i = 0; i < names.length; i++)validateComponentName(names[i], instance.appContext.config);
    }
    if (Component.directives) {
        const names = Object.keys(Component.directives);
        for(let i = 0; i < names.length; i++)validateDirectiveName(names[i]);
    }
    if (Component.compilerOptions && isRuntimeOnly()) warn(`"compilerOptions" is only supported when using a build of Vue that ` + `includes the runtime compiler. Since you are using a runtime-only ` + `build, the options should be passed via your build tool config instead.`);
    // 0. create render proxy property access cache
    instance.accessCache = Object.create(null);
    // 1. create public instance / render proxy
    // also mark it raw so it's never observed
    instance.proxy = _reactivity.markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    exposePropsOnRenderContext(instance);
    // 2. call setup()
    const { setup  } = Component;
    if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        setCurrentInstance(instance);
        _reactivity.pauseTracking();
        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */ , [
            _reactivity.shallowReadonly(instance.props),
            setupContext
        ]);
        _reactivity.resetTracking();
        unsetCurrentInstance();
        if (_shared.isPromise(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) // return the promise so server-renderer can wait on it
            return setupResult.then((resolvedResult)=>{
                handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e)=>{
                handleError(e, instance, 0 /* SETUP_FUNCTION */ );
            });
            else // async setup returned Promise.
            // bail here and wait for re-entry.
            instance.asyncDep = setupResult;
        } else handleSetupResult(instance, setupResult, isSSR);
    } else finishComponentSetup(instance, isSSR);
}
function handleSetupResult(instance, setupResult, isSSR) {
    if (_shared.isFunction(setupResult)) {
        // setup returned an inline render function
        if (instance.type.__ssrInlineRender) // when the function's name is `ssrRender` (compiled by SFC inline mode),
        // set it as ssrRender instead.
        instance.ssrRender = setupResult;
        else instance.render = setupResult;
    } else if (_shared.isObject(setupResult)) {
        if (isVNode(setupResult)) warn(`setup() should not return VNodes directly - ` + `return a render function instead.`);
        instance.devtoolsRawSetupState = setupResult;
        instance.setupState = _reactivity.proxyRefs(setupResult);
        exposeSetupStateOnRenderContext(instance);
    } else if (setupResult !== undefined) warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */ function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = (i)=>{
        if (i.render._rc) i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    };
}
// dev only
const isRuntimeOnly = ()=>!compile
;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    // template / render function normalization
    // could be already set when returned from setup()
    if (!instance.render) {
        // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
        // is done by server-renderer
        if (!isSSR && compile && !Component.render) {
            const template = Component.template;
            if (template) {
                startMeasure(instance, `compile`);
                const { isCustomElement , compilerOptions  } = instance.appContext.config;
                const { delimiters , compilerOptions: componentCompilerOptions  } = Component;
                const finalCompilerOptions = _shared.extend(_shared.extend({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                endMeasure(instance, `compile`);
            }
        }
        instance.render = Component.render || _shared.NOOP;
        // for runtime-compiled render functions using `with` blocks, the render
        // proxy used needs a different `has` handler which is more performant and
        // also only allows a whitelist of globals to fallthrough.
        if (installWithProxy) installWithProxy(instance);
    }
    // support for 2.x options
    if (__VUE_OPTIONS_API__ && true) {
        setCurrentInstance(instance);
        _reactivity.pauseTracking();
        applyOptions(instance);
        _reactivity.resetTracking();
        unsetCurrentInstance();
    }
    // warn missing template/render
    // the runtime compilation of template in SSR is done by server-render
    if (!Component.render && instance.render === _shared.NOOP && !isSSR) {
        /* istanbul ignore if */ if (!compile && Component.template) warn(`Component provided template option but ` + `runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
        else warn(`Component is missing template or render function.`);
    }
}
function createAttrsProxy(instance) {
    return new Proxy(instance.attrs, {
        get (target, key) {
            markAttrsAccessed();
            _reactivity.track(instance, "get" /* GET */ , '$attrs');
            return target[key];
        },
        set () {
            warn(`setupContext.attrs is readonly.`);
            return false;
        },
        deleteProperty () {
            warn(`setupContext.attrs is readonly.`);
            return false;
        }
    });
}
function createSetupContext(instance) {
    const expose = (exposed)=>{
        if (instance.exposed) warn(`expose() should be called only once per setup().`);
        instance.exposed = exposed || {
        };
    };
    let attrs;
    // We use getters in dev in case libs like test-utils overwrite instance
    // properties (overwrites should not be done in prod)
    return Object.freeze({
        get attrs () {
            return attrs || (attrs = createAttrsProxy(instance));
        },
        get slots () {
            return _reactivity.shallowReadonly(instance.slots);
        },
        get emit () {
            return (event, ...args)=>instance.emit(event, ...args)
            ;
        },
        expose
    });
}
function getExposeProxy(instance) {
    if (instance.exposed) return instance.exposeProxy || (instance.exposeProxy = new Proxy(_reactivity.proxyRefs(_reactivity.markRaw(instance.exposed)), {
        get (target, key) {
            if (key in target) return target[key];
            else if (key in publicPropertiesMap) return publicPropertiesMap[key](instance);
        }
    }));
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str)=>str.replace(classifyRE, (c)=>c.toUpperCase()
    ).replace(/[-_]/g, '')
;
function getComponentName(Component) {
    return _shared.isFunction(Component) ? Component.displayName || Component.name : Component.name;
}
/* istanbul ignore next */ function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) name = match[1];
    }
    if (!name && instance && instance.parent) {
        // try to infer the name based on reverse resolution
        const inferFromRegistry = (registry)=>{
            for(const key in registry){
                if (registry[key] === Component) return key;
            }
        };
        name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
    return _shared.isFunction(value) && '__vccOpts' in value;
}
const computed = (getterOrOptions, debugOptions)=>{
    // @ts-ignore
    return _reactivity.computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
// dev only
const warnRuntimeUsage = (method)=>warn(`${method}() is a compiler-hint helper that is only usable inside ` + `<script setup> of a single file component. Its arguments should be ` + `compiled away and passing it at runtime has no effect.`)
;
// implementation
function defineProps() {
    warnRuntimeUsage(`defineProps`);
    return null;
}
// implementation
function defineEmits() {
    warnRuntimeUsage(`defineEmits`);
    return null;
}
/**
 * Vue `<script setup>` compiler macro for declaring a component's exposed
 * instance properties when it is accessed by a parent component via template
 * refs.
 *
 * `<script setup>` components are closed by default - i.e. variables inside
 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
 * via `defineExpose`.
 *
 * This is only usable inside `<script setup>`, is compiled away in the
 * output and should **not** be actually called at runtime.
 */ function defineExpose(exposed) {
    warnRuntimeUsage(`defineExpose`);
}
/**
 * Vue `<script setup>` compiler macro for providing props default values when
 * using type-based `defineProps` declaration.
 *
 * Example usage:
 * ```ts
 * withDefaults(defineProps<{
 *   size?: number
 *   labels?: string[]
 * }>(), {
 *   size: 3,
 *   labels: () => ['default label']
 * })
 * ```
 *
 * This is only usable inside `<script setup>`, is compiled away in the output
 * and should **not** be actually called at runtime.
 */ function withDefaults(props, defaults) {
    warnRuntimeUsage(`withDefaults`);
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function getContext() {
    const i = getCurrentInstance();
    if (!i) warn(`useContext() called without active instance.`);
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */ function mergeDefaults(raw, defaults) {
    const props = _shared.isArray(raw) ? raw.reduce((normalized, p)=>(normalized[p] = {
        }, normalized)
    , {
    }) : raw;
    for(const key in defaults){
        const opt = props[key];
        if (opt) {
            if (_shared.isArray(opt) || _shared.isFunction(opt)) props[key] = {
                type: opt,
                default: defaults[key]
            };
            else opt.default = defaults[key];
        } else if (opt === null) props[key] = {
            default: defaults[key]
        };
        else warn(`props default key "${key}" has no corresponding declaration.`);
    }
    return props;
}
/**
 * Used to create a proxy for the rest element when destructuring props with
 * defineProps().
 * @internal
 */ function createPropsRestProxy(props, excludedKeys) {
    const ret = {
    };
    for(const key in props)if (!excludedKeys.includes(key)) Object.defineProperty(ret, key, {
        enumerable: true,
        get: ()=>props[key]
    });
    return ret;
}
/**
 * `<script setup>` helper for persisting the current instance context over
 * async/await flows.
 *
 * `@vue/compiler-sfc` converts the following:
 *
 * ```ts
 * const x = await foo()
 * ```
 *
 * into:
 *
 * ```ts
 * let __temp, __restore
 * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
 * ```
 * @internal
 */ function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (!ctx) warn(`withAsyncContext called without active current instance. ` + `This is likely a bug.`);
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if (_shared.isPromise(awaitable)) awaitable = awaitable.catch((e)=>{
        setCurrentInstance(ctx);
        throw e;
    });
    return [
        awaitable,
        ()=>setCurrentInstance(ctx)
    ];
}
// Actual implementation
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if (_shared.isObject(propsOrChildren) && !_shared.isArray(propsOrChildren)) {
            // single vnode without props
            if (isVNode(propsOrChildren)) return createVNode(type, null, [
                propsOrChildren
            ]);
            // props without children
            return createVNode(type, propsOrChildren);
        } else // omit props
        return createVNode(type, null, propsOrChildren);
    } else {
        if (l > 3) children = Array.prototype.slice.call(arguments, 2);
        else if (l === 3 && isVNode(children)) children = [
            children
        ];
        return createVNode(type, propsOrChildren, children);
    }
}
const ssrContextKey = Symbol(`ssrContext`);
const useSSRContext = ()=>{
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) warn(`Server rendering context not provided. Make sure to only call ` + `useSSRContext() conditionally in the server build.`);
        return ctx;
    }
};
function isShallow(value) {
    return !!(value && value["__v_isShallow" /* IS_SHALLOW */ ]);
}
function initCustomFormatter() {
    /* eslint-disable no-restricted-globals */ if (typeof window === 'undefined') return;
    const vueStyle = {
        style: 'color:#3ba776'
    };
    const numberStyle = {
        style: 'color:#0b1bc9'
    };
    const stringStyle = {
        style: 'color:#b62e24'
    };
    const keywordStyle = {
        style: 'color:#9d288c'
    };
    // custom formatter for Chrome
    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
    const formatter = {
        header (obj) {
            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
            if (!_shared.isObject(obj)) return null;
            if (obj.__isVue) return [
                'div',
                vueStyle,
                `VueInstance`
            ];
            else if (_reactivity.isRef(obj)) return [
                'div',
                {
                },
                [
                    'span',
                    vueStyle,
                    genRefFlag(obj)
                ],
                '<',
                formatValue(obj.value),
                `>`
            ];
            else if (_reactivity.isReactive(obj)) return [
                'div',
                {
                },
                [
                    'span',
                    vueStyle,
                    isShallow(obj) ? 'ShallowReactive' : 'Reactive'
                ],
                '<',
                formatValue(obj),
                `>${_reactivity.isReadonly(obj) ? ` (readonly)` : ``}`
            ];
            else if (_reactivity.isReadonly(obj)) return [
                'div',
                {
                },
                [
                    'span',
                    vueStyle,
                    isShallow(obj) ? 'ShallowReadonly' : 'Readonly'
                ],
                '<',
                formatValue(obj),
                '>'
            ];
            return null;
        },
        hasBody (obj) {
            return obj && obj.__isVue;
        },
        body (obj) {
            if (obj && obj.__isVue) return [
                'div',
                {
                },
                ...formatInstance(obj.$)
            ];
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) blocks.push(createInstanceBlock('props', _reactivity.toRaw(instance.props)));
        if (instance.setupState !== _shared.EMPTY_OBJ) blocks.push(createInstanceBlock('setup', instance.setupState));
        if (instance.data !== _shared.EMPTY_OBJ) blocks.push(createInstanceBlock('data', _reactivity.toRaw(instance.data)));
        const computed1 = extractKeys(instance, 'computed');
        if (computed1) blocks.push(createInstanceBlock('computed', computed1));
        const injected = extractKeys(instance, 'inject');
        if (injected) blocks.push(createInstanceBlock('injected', injected));
        blocks.push([
            'div',
            {
            },
            [
                'span',
                {
                    style: keywordStyle.style + ';opacity:0.66'
                },
                '$ (internal): '
            ],
            [
                'object',
                {
                    object: instance
                }
            ]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = _shared.extend({
        }, target);
        if (!Object.keys(target).length) return [
            'span',
            {
            }
        ];
        return [
            'div',
            {
                style: 'line-height:1.25em;margin-bottom:0.6em'
            },
            [
                'div',
                {
                    style: 'color:#476582'
                },
                type
            ],
            [
                'div',
                {
                    style: 'padding-left:1.25em'
                },
                ...Object.keys(target).map((key)=>{
                    return [
                        'div',
                        {
                        },
                        [
                            'span',
                            keywordStyle,
                            key + ': '
                        ],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v, asRaw = true) {
        if (typeof v === 'number') return [
            'span',
            numberStyle,
            v
        ];
        else if (typeof v === 'string') return [
            'span',
            stringStyle,
            JSON.stringify(v)
        ];
        else if (typeof v === 'boolean') return [
            'span',
            keywordStyle,
            v
        ];
        else if (_shared.isObject(v)) return [
            'object',
            {
                object: asRaw ? _reactivity.toRaw(v) : v
            }
        ];
        else return [
            'span',
            stringStyle,
            String(v)
        ];
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if (_shared.isFunction(Comp)) return;
        const extracted = {
        };
        for(const key in instance.ctx)if (isKeyOfType(Comp, key, type)) extracted[key] = instance.ctx[key];
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if (_shared.isArray(opts) && opts.includes(key) || _shared.isObject(opts) && key in opts) return true;
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) return true;
        if (Comp.mixins && Comp.mixins.some((m)=>isKeyOfType(m, key, type)
        )) return true;
    }
    function genRefFlag(v) {
        if (isShallow(v)) return `ShallowRef`;
        if (v.effect) return `ComputedRef`;
        return `Ref`;
    }
    if (window.devtoolsFormatters) window.devtoolsFormatters.push(formatter);
    else window.devtoolsFormatters = [
        formatter
    ];
}
function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) return cached;
    const ret = render();
    // shallow clone
    ret.memo = memo.slice();
    return cache[index] = ret;
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) return false;
    for(let i = 0; i < prev.length; i++){
        if (prev[i] !== memo[i]) return false;
    }
    // make sure to let parent block track it when returning cached
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(cached);
    return true;
}
// Core API ------------------------------------------------------------------
const version = "3.2.31";
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode,
    normalizeVNode
};
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */ const ssrUtils = _ssrUtils;
/**
 * @internal only exposed in compat builds
 */ const resolveFilter = null;
/**
 * @internal only exposed in compat builds.
 */ const compatUtils = null;

},{"@vue/reactivity":"d7UXQ","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7UXQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>EffectScope
);
parcelHelpers.export(exports, "ITERATE_KEY", ()=>ITERATE_KEY
);
parcelHelpers.export(exports, "ReactiveEffect", ()=>ReactiveEffect
);
parcelHelpers.export(exports, "computed", ()=>computed
);
parcelHelpers.export(exports, "customRef", ()=>customRef
);
parcelHelpers.export(exports, "deferredComputed", ()=>deferredComputed
);
parcelHelpers.export(exports, "effect", ()=>effect
);
parcelHelpers.export(exports, "effectScope", ()=>effectScope
);
parcelHelpers.export(exports, "enableTracking", ()=>enableTracking
);
parcelHelpers.export(exports, "getCurrentScope", ()=>getCurrentScope
);
parcelHelpers.export(exports, "isProxy", ()=>isProxy
);
parcelHelpers.export(exports, "isReactive", ()=>isReactive
);
parcelHelpers.export(exports, "isReadonly", ()=>isReadonly
);
parcelHelpers.export(exports, "isRef", ()=>isRef
);
parcelHelpers.export(exports, "isShallow", ()=>isShallow
);
parcelHelpers.export(exports, "markRaw", ()=>markRaw
);
parcelHelpers.export(exports, "onScopeDispose", ()=>onScopeDispose
);
parcelHelpers.export(exports, "pauseTracking", ()=>pauseTracking
);
parcelHelpers.export(exports, "proxyRefs", ()=>proxyRefs
);
parcelHelpers.export(exports, "reactive", ()=>reactive
);
parcelHelpers.export(exports, "readonly", ()=>readonly
);
parcelHelpers.export(exports, "ref", ()=>ref
);
parcelHelpers.export(exports, "resetTracking", ()=>resetTracking
);
parcelHelpers.export(exports, "shallowReactive", ()=>shallowReactive
);
parcelHelpers.export(exports, "shallowReadonly", ()=>shallowReadonly
);
parcelHelpers.export(exports, "shallowRef", ()=>shallowRef
);
parcelHelpers.export(exports, "stop", ()=>stop
);
parcelHelpers.export(exports, "toRaw", ()=>toRaw
);
parcelHelpers.export(exports, "toRef", ()=>toRef
);
parcelHelpers.export(exports, "toRefs", ()=>toRefs
);
parcelHelpers.export(exports, "track", ()=>track
);
parcelHelpers.export(exports, "trigger", ()=>trigger
);
parcelHelpers.export(exports, "triggerRef", ()=>triggerRef
);
parcelHelpers.export(exports, "unref", ()=>unref
);
var _shared = require("@vue/shared");
function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
    constructor(detached = false){
        this.active = true;
        this.effects = [];
        this.cleanups = [];
        if (!detached && activeEffectScope) {
            this.parent = activeEffectScope;
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
    }
    run(fn) {
        if (this.active) try {
            activeEffectScope = this;
            return fn();
        } finally{
            activeEffectScope = this.parent;
        }
        else warn(`cannot run an inactive effect scope.`);
    }
    on() {
        activeEffectScope = this;
    }
    off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this.active) {
            let i, l;
            for(i = 0, l = this.effects.length; i < l; i++)this.effects[i].stop();
            for(i = 0, l = this.cleanups.length; i < l; i++)this.cleanups[i]();
            if (this.scopes) for(i = 0, l = this.scopes.length; i < l; i++)this.scopes[i].stop(true);
            // nested scope, dereference from parent to avoid memory leaks
            if (this.parent && !fromParent) {
                // optimized O(1) removal
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect1, scope = activeEffectScope) {
    if (scope && scope.active) scope.effects.push(effect1);
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) activeEffectScope.cleanups.push(fn);
    else warn(`onScopeDispose() is called when there is no active effect scope` + ` to be associated with.`);
}
const createDep = (effects)=>{
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
};
const wasTracked = (dep)=>(dep.w & trackOpBit) > 0
;
const newTracked = (dep)=>(dep.n & trackOpBit) > 0
;
const initDepMarkers = ({ deps  })=>{
    if (deps.length) for(let i = 0; i < deps.length; i++)deps[i].w |= trackOpBit; // set was tracked
};
const finalizeDepMarkers = (effect2)=>{
    const { deps  } = effect2;
    if (deps.length) {
        let ptr = 0;
        for(let i = 0; i < deps.length; i++){
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) dep.delete(effect2);
            else deps[ptr++] = dep;
            // clear bits
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
    }
};
const targetMap = new WeakMap();
// The number of effects currently being tracked recursively.
let effectTrackDepth = 0;
let trackOpBit = 1;
/**
 * The bitwise track markers support at most 30 levels of recursion.
 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
 * When recursion depth is greater, fall back to using a full cleanup.
 */ const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol('iterate');
const MAP_KEY_ITERATE_KEY = Symbol('Map key iterate');
class ReactiveEffect {
    constructor(fn, scheduler1 = null, scope){
        this.fn = fn;
        this.scheduler = scheduler1;
        this.active = true;
        this.deps = [];
        this.parent = undefined;
        recordEffectScope(this, scope);
    }
    run() {
        if (!this.active) return this.fn();
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while(parent){
            if (parent === this) return;
            parent = parent.parent;
        }
        try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) initDepMarkers(this);
            else cleanupEffect(this);
            return this.fn();
        } finally{
            if (effectTrackDepth <= maxMarkerBits) finalizeDepMarkers(this);
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = undefined;
        }
    }
    stop() {
        if (this.active) {
            cleanupEffect(this);
            if (this.onStop) this.onStop();
            this.active = false;
        }
    }
}
function cleanupEffect(effect3) {
    const { deps  } = effect3;
    if (deps.length) {
        for(let i = 0; i < deps.length; i++)deps[i].delete(effect3);
        deps.length = 0;
    }
}
function effect(fn, options) {
    if (fn.effect) fn = fn.effect.fn;
    const _effect = new ReactiveEffect(fn);
    if (options) {
        _shared.extend(_effect, options);
        if (options.scope) recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) _effect.run();
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === undefined ? true : last;
}
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) targetMap.set(target, depsMap = new Map());
        let dep = depsMap.get(key);
        if (!dep) depsMap.set(key, dep = createDep());
        const eventInfo = {
            effect: activeEffect,
            target,
            type,
            key
        };
        trackEffects(dep, eventInfo);
    }
}
function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack1 = false;
    if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
            dep.n |= trackOpBit; // set newly tracked
            shouldTrack1 = !wasTracked(dep);
        }
    } else // Full cleanup mode.
    shouldTrack1 = !dep.has(activeEffect);
    if (shouldTrack1) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (activeEffect.onTrack) activeEffect.onTrack(Object.assign({
            effect: activeEffect
        }, debuggerEventExtraInfo));
    }
}
function trigger(target, type, key1, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) // never been tracked
    return;
    let deps = [];
    if (type === "clear" /* CLEAR */ ) // collection being cleared
    // trigger all effects for target
    deps = [
        ...depsMap.values()
    ];
    else if (key1 === 'length' && _shared.isArray(target)) depsMap.forEach((dep, key)=>{
        if (key === 'length' || key >= newValue) deps.push(dep);
    });
    else {
        // schedule runs for SET | ADD | DELETE
        if (key1 !== void 0) deps.push(depsMap.get(key1));
        // also run for iteration key on ADD | DELETE | Map.SET
        switch(type){
            case "add" /* ADD */ :
                if (!_shared.isArray(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if (_shared.isMap(target)) deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                } else if (_shared.isIntegerKey(key1)) // new index added to array -> length changes
                deps.push(depsMap.get('length'));
                break;
            case "delete" /* DELETE */ :
                if (!_shared.isArray(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if (_shared.isMap(target)) deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
                break;
            case "set" /* SET */ :
                if (_shared.isMap(target)) deps.push(depsMap.get(ITERATE_KEY));
                break;
        }
    }
    const eventInfo = {
        target,
        type,
        key: key1,
        newValue,
        oldValue,
        oldTarget
    };
    if (deps.length === 1) {
        if (deps[0]) triggerEffects(deps[0], eventInfo);
    } else {
        const effects = [];
        for (const dep of deps)if (dep) effects.push(...dep);
        triggerEffects(createDep(effects), eventInfo);
    }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
    // spread into array for stabilization
    for (const effect4 of _shared.isArray(dep) ? dep : [
        ...dep
    ])if (effect4 !== activeEffect || effect4.allowRecurse) {
        if (effect4.onTrigger) effect4.onTrigger(_shared.extend({
            effect: effect4
        }, debuggerEventExtraInfo));
        if (effect4.scheduler) effect4.scheduler();
        else effect4.run();
    }
}
const isNonTrackableKeys = /*#__PURE__*/ _shared.makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key)=>Symbol[key]
).filter(_shared.isSymbol));
const get = /*#__PURE__*/ createGetter();
const shallowGet = /*#__PURE__*/ createGetter(false, true);
const readonlyGet = /*#__PURE__*/ createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {
    };
    [
        'includes',
        'indexOf',
        'lastIndexOf'
    ].forEach((key)=>{
        instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for(let i = 0, l = this.length; i < l; i++)track(arr, "get" /* GET */ , i + '');
            // we run the method using the original args first (which may be reactive)
            const res = arr[key](...args);
            if (res === -1 || res === false) // if that didn't work, run it again using raw values.
            return arr[key](...args.map(toRaw));
            else return res;
        };
    });
    [
        'push',
        'pop',
        'shift',
        'unshift',
        'splice'
    ].forEach((key)=>{
        instrumentations[key] = function(...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function createGetter(isReadonly1 = false, shallow = false) {
    return function get(target, key, receiver) {
        if (key === "__v_isReactive" /* IS_REACTIVE */ ) return !isReadonly1;
        else if (key === "__v_isReadonly" /* IS_READONLY */ ) return isReadonly1;
        else if (key === "__v_isShallow" /* IS_SHALLOW */ ) return shallow;
        else if (key === "__v_raw" /* RAW */  && receiver === (isReadonly1 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) return target;
        const targetIsArray = _shared.isArray(target);
        if (!isReadonly1 && targetIsArray && _shared.hasOwn(arrayInstrumentations, key)) return Reflect.get(arrayInstrumentations, key, receiver);
        const res = Reflect.get(target, key, receiver);
        if (_shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) return res;
        if (!isReadonly1) track(target, "get" /* GET */ , key);
        if (shallow) return res;
        if (isRef(res)) {
            // ref unwrapping - does not apply for Array + integer key.
            const shouldUnwrap = !targetIsArray || !_shared.isIntegerKey(key);
            return shouldUnwrap ? res.value : res;
        }
        if (_shared.isObject(res)) // Convert returned value into a proxy as well. we do the isObject check
        // here to avoid invalid value warning. Also need to lazy access readonly
        // and reactive here to avoid circular dependency.
        return isReadonly1 ? readonly(res) : reactive(res);
        return res;
    };
}
const set = /*#__PURE__*/ createSetter();
const shallowSet = /*#__PURE__*/ createSetter(true);
function createSetter(shallow = false) {
    return function set(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) return false;
        if (!shallow && !isReadonly(value)) {
            if (!isShallow(value)) {
                value = toRaw(value);
                oldValue = toRaw(oldValue);
            }
            if (!_shared.isArray(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = _shared.isArray(target) && _shared.isIntegerKey(key) ? Number(key) < target.length : _shared.hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        // don't trigger if target is something up in the prototype chain of original
        if (target === toRaw(receiver)) {
            if (!hadKey) trigger(target, "add" /* ADD */ , key, value);
            else if (_shared.hasChanged(value, oldValue)) trigger(target, "set" /* SET */ , key, value, oldValue);
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = _shared.hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) trigger(target, "delete" /* DELETE */ , key, undefined, oldValue);
    return result;
}
function has(target, key) {
    const result = Reflect.has(target, key);
    if (!_shared.isSymbol(key) || !builtInSymbols.has(key)) track(target, "has" /* HAS */ , key);
    return result;
}
function ownKeys(target) {
    track(target, "iterate" /* ITERATE */ , _shared.isArray(target) ? 'length' : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set (target, key) {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    },
    deleteProperty (target, key) {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    }
};
const shallowReactiveHandlers = /*#__PURE__*/ _shared.extend({
}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
const shallowReadonlyHandlers = /*#__PURE__*/ _shared.extend({
}, readonlyHandlers, {
    get: shallowReadonlyGet
});
const toShallow = (value)=>value
;
const getProto = (v)=>Reflect.getPrototypeOf(v)
;
function get$1(target, key, isReadonly2 = false, isShallow1 = false) {
    // #1772: readonly(reactive(Map)) should return readonly + reactive version
    // of the value
    target = target["__v_raw" /* RAW */ ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) !isReadonly2 && track(rawTarget, "get" /* GET */ , key);
    !isReadonly2 && track(rawTarget, "get" /* GET */ , rawKey);
    const { has: has1  } = getProto(rawTarget);
    const wrap = isShallow1 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has1.call(rawTarget, key)) return wrap(target.get(key));
    else if (has1.call(rawTarget, rawKey)) return wrap(target.get(rawKey));
    else if (target !== rawTarget) // #3602 readonly(reactive(Map))
    // ensure that the nested reactive `Map` can do tracking for itself
    target.get(key);
}
function has$1(key, isReadonly3 = false) {
    const target = this["__v_raw" /* RAW */ ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) !isReadonly3 && track(rawTarget, "has" /* HAS */ , key);
    !isReadonly3 && track(rawTarget, "has" /* HAS */ , rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly4 = false) {
    target = target["__v_raw" /* RAW */ ];
    !isReadonly4 && track(toRaw(target), "iterate" /* ITERATE */ , ITERATE_KEY);
    return Reflect.get(target, 'size', target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add" /* ADD */ , value, value);
    }
    return this;
}
function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2 , get: get1  } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    } else checkIdentityKeys(target, has2, key);
    const oldValue = get1.call(target, key);
    target.set(key, value);
    if (!hadKey) trigger(target, "add" /* ADD */ , key, value);
    else if (_shared.hasChanged(value, oldValue)) trigger(target, "set" /* SET */ , key, value, oldValue);
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has3 , get: get2  } = getProto(target);
    let hadKey = has3.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has3.call(target, key);
    } else checkIdentityKeys(target, has3, key);
    const oldValue = get2 ? get2.call(target, key) : undefined;
    // forward the operation before queueing reactions
    const result = target.delete(key);
    if (hadKey) trigger(target, "delete" /* DELETE */ , key, undefined, oldValue);
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = _shared.isMap(target) ? new Map(target) : new Set(target);
    // forward the operation before queueing reactions
    const result = target.clear();
    if (hadItems) trigger(target, "clear" /* CLEAR */ , undefined, undefined, oldTarget);
    return result;
}
function createForEach(isReadonly5, isShallow2) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw" /* RAW */ ];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly5 ? toReadonly : toReactive;
        !isReadonly5 && track(rawTarget, "iterate" /* ITERATE */ , ITERATE_KEY);
        return target.forEach((value, key)=>{
            // important: make sure the callback is
            // 1. invoked with the reactive map as `this` and 3rd arg
            // 2. the value received should be a corresponding reactive/readonly.
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly6, isShallow3) {
    return function(...args) {
        const target = this["__v_raw" /* RAW */ ];
        const rawTarget = toRaw(target);
        const targetIsMap = _shared.isMap(rawTarget);
        const isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === 'keys' && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow3 ? toShallow : isReadonly6 ? toReadonly : toReactive;
        !isReadonly6 && track(rawTarget, "iterate" /* ITERATE */ , isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        // return a wrapped iterator which returns observed versions of the
        // values emitted from the real iterator
        return {
            // iterator protocol
            next () {
                const { value , done  } = innerIterator.next();
                return done ? {
                    value,
                    done
                } : {
                    value: isPair ? [
                        wrap(value[0]),
                        wrap(value[1])
                    ] : wrap(value),
                    done
                };
            },
            // iterable protocol
            [Symbol.iterator] () {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function(...args) {
        {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${_shared.capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" /* DELETE */  ? false : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations1 = {
        get (key) {
            return get$1(this, key);
        },
        get size () {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations1 = {
        get (key) {
            return get$1(this, key, false, true);
        },
        get size () {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations1 = {
        get (key) {
            return get$1(this, key, true);
        },
        get size () {
            return size(this, true);
        },
        has (key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */ ),
        set: createReadonlyMethod("set" /* SET */ ),
        delete: createReadonlyMethod("delete" /* DELETE */ ),
        clear: createReadonlyMethod("clear" /* CLEAR */ ),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations1 = {
        get (key) {
            return get$1(this, key, true, true);
        },
        get size () {
            return size(this, true);
        },
        has (key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */ ),
        set: createReadonlyMethod("set" /* SET */ ),
        delete: createReadonlyMethod("delete" /* DELETE */ ),
        clear: createReadonlyMethod("clear" /* CLEAR */ ),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = [
        'keys',
        'values',
        'entries',
        Symbol.iterator
    ];
    iteratorMethods.forEach((method)=>{
        mutableInstrumentations1[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations1[method] = createIterableMethod(method, true, false);
        shallowInstrumentations1[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations1[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations1,
        readonlyInstrumentations1,
        shallowInstrumentations1,
        shallowReadonlyInstrumentations1
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();
function createInstrumentationGetter(isReadonly7, shallow) {
    const instrumentations = shallow ? isReadonly7 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly7 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver)=>{
        if (key === "__v_isReactive" /* IS_REACTIVE */ ) return !isReadonly7;
        else if (key === "__v_isReadonly" /* IS_READONLY */ ) return isReadonly7;
        else if (key === "__v_raw" /* RAW */ ) return target;
        return Reflect.get(_shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has4, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has4.call(target, rawKey)) {
        const type = _shared.toRawType(target);
        console.warn(`Reactive ${type} contains both the raw and reactive ` + `versions of the same object${type === `Map` ? ` as keys` : ``}, ` + `which can lead to inconsistencies. ` + `Avoid differentiating between the raw and reactive versions ` + `of an object and only use the reactive version if possible.`);
    }
}
const reactiveMap = new WeakMap();
const shallowReactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
const shallowReadonlyMap = new WeakMap();
function targetTypeMap(rawType) {
    switch(rawType){
        case 'Object':
        case 'Array':
            return 1 /* COMMON */ ;
        case 'Map':
        case 'Set':
        case 'WeakMap':
        case 'WeakSet':
            return 2 /* COLLECTION */ ;
        default:
            return 0 /* INVALID */ ;
    }
}
function getTargetType(value) {
    return value["__v_skip" /* SKIP */ ] || !Object.isExtensible(value) ? 0 /* INVALID */  : targetTypeMap(_shared.toRawType(value));
}
function reactive(target) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (isReadonly(target)) return target;
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */ function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */ function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */ function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly8, baseHandlers, collectionHandlers, proxyMap) {
    if (!_shared.isObject(target)) {
        console.warn(`value cannot be made reactive: ${String(target)}`);
        return target;
    }
    // target is already a Proxy, return it.
    // exception: calling readonly() on a reactive object
    if (target["__v_raw" /* RAW */ ] && !(isReadonly8 && target["__v_isReactive" /* IS_REACTIVE */ ])) return target;
    // target already has corresponding Proxy
    const existingProxy = proxyMap.get(target);
    if (existingProxy) return existingProxy;
    // only a whitelist of value types can be observed.
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */ ) return target;
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */  ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) return isReactive(value["__v_raw" /* RAW */ ]);
    return !!(value && value["__v_isReactive" /* IS_REACTIVE */ ]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly" /* IS_READONLY */ ]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow" /* IS_SHALLOW */ ]);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw" /* RAW */ ];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    _shared.def(value, "__v_skip" /* SKIP */ , true);
    return value;
}
const toReactive = (value)=>_shared.isObject(value) ? reactive(value) : value
;
const toReadonly = (value)=>_shared.isObject(value) ? readonly(value) : value
;
function trackRefValue(ref1) {
    if (shouldTrack && activeEffect) {
        ref1 = toRaw(ref1);
        trackEffects(ref1.dep || (ref1.dep = createDep()), {
            target: ref1,
            type: "get" /* GET */ ,
            key: 'value'
        });
    }
}
function triggerRefValue(ref2, newVal) {
    ref2 = toRaw(ref2);
    if (ref2.dep) triggerEffects(ref2.dep, {
        target: ref2,
        type: "set" /* SET */ ,
        key: 'value',
        newValue: newVal
    });
}
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) return rawValue;
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow){
        this.__v_isShallow = __v_isShallow;
        this.dep = undefined;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        newVal = this.__v_isShallow ? newVal : toRaw(newVal);
        if (_shared.hasChanged(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = this.__v_isShallow ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
        }
    }
}
function triggerRef(ref3) {
    triggerRefValue(ref3, ref3.value);
}
function unref(ref4) {
    return isRef(ref4) ? ref4.value : ref4;
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver)=>unref(Reflect.get(target, key, receiver))
    ,
    set: (target, key, value, receiver)=>{
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        } else return Reflect.set(target, key, value, receiver);
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory){
        this.dep = undefined;
        this.__v_isRef = true;
        const { get: get3 , set: set1  } = factory(()=>trackRefValue(this)
        , ()=>triggerRefValue(this)
        );
        this._get = get3;
        this._set = set1;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (!isProxy(object)) console.warn(`toRefs() expects a reactive object but received a plain one.`);
    const ret = _shared.isArray(object) ? new Array(object.length) : {
    };
    for(const key in object)ret[key] = toRef(object, key);
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue){
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
    }
    get value() {
        const val = this._object[this._key];
        return val === undefined ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
}
function toRef(object, key, defaultValue) {
    const val = object[key];
    return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
class ComputedRefImpl {
    constructor(getter, _setter, isReadonly9, isSSR){
        this._setter = _setter;
        this.dep = undefined;
        this.__v_isRef = true;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, ()=>{
            if (!this._dirty) {
                this._dirty = true;
                triggerRefValue(this);
            }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly" /* IS_READONLY */ ] = isReadonly9;
    }
    get value() {
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        const self = toRaw(this);
        trackRefValue(self);
        if (self._dirty || !self._cacheable) {
            self._dirty = false;
            self._value = self.effect.run();
        }
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = _shared.isFunction(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = ()=>{
            console.warn('Write operation failed: computed value is readonly');
        };
    } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
}
var _a;
const tick = Promise.resolve();
const queue = [];
let queued = false;
const scheduler = (fn)=>{
    queue.push(fn);
    if (!queued) {
        queued = true;
        tick.then(flush);
    }
};
const flush = ()=>{
    for(let i = 0; i < queue.length; i++)queue[i]();
    queue.length = 0;
    queued = false;
};
class DeferredComputedRefImpl {
    constructor(getter){
        this.dep = undefined;
        this._dirty = true;
        this.__v_isRef = true;
        this[_a] = true;
        let compareTarget;
        let hasCompareTarget = false;
        let scheduled = false;
        this.effect = new ReactiveEffect(getter, (computedTrigger)=>{
            if (this.dep) {
                if (computedTrigger) {
                    compareTarget = this._value;
                    hasCompareTarget = true;
                } else if (!scheduled) {
                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;
                    scheduled = true;
                    hasCompareTarget = false;
                    scheduler(()=>{
                        if (this.effect.active && this._get() !== valueToCompare) triggerRefValue(this);
                        scheduled = false;
                    });
                }
                // chained upstream computeds are notified synchronously to ensure
                // value invalidation in case of sync access; normal effects are
                // deferred to be triggered in scheduler.
                for (const e of this.dep)if (e.computed instanceof DeferredComputedRefImpl) e.scheduler(true);
            }
            this._dirty = true;
        });
        this.effect.computed = this;
    }
    _get() {
        if (this._dirty) {
            this._dirty = false;
            return this._value = this.effect.run();
        }
        return this._value;
    }
    get value() {
        trackRefValue(this);
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        return toRaw(this)._get();
    }
}
_a = "__v_isReadonly" /* IS_READONLY */ ;
function deferredComputed(getter) {
    return new DeferredComputedRefImpl(getter);
}

},{"@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3SM3y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMPTY_ARR", ()=>EMPTY_ARR
);
parcelHelpers.export(exports, "EMPTY_OBJ", ()=>EMPTY_OBJ
);
parcelHelpers.export(exports, "NO", ()=>NO
);
parcelHelpers.export(exports, "NOOP", ()=>NOOP
);
parcelHelpers.export(exports, "PatchFlagNames", ()=>PatchFlagNames
);
parcelHelpers.export(exports, "camelize", ()=>camelize
);
parcelHelpers.export(exports, "capitalize", ()=>capitalize
);
parcelHelpers.export(exports, "def", ()=>def
);
parcelHelpers.export(exports, "escapeHtml", ()=>escapeHtml
);
parcelHelpers.export(exports, "escapeHtmlComment", ()=>escapeHtmlComment
);
parcelHelpers.export(exports, "extend", ()=>extend
);
parcelHelpers.export(exports, "generateCodeFrame", ()=>generateCodeFrame
);
parcelHelpers.export(exports, "getGlobalThis", ()=>getGlobalThis
);
parcelHelpers.export(exports, "hasChanged", ()=>hasChanged
);
parcelHelpers.export(exports, "hasOwn", ()=>hasOwn
);
parcelHelpers.export(exports, "hyphenate", ()=>hyphenate
);
parcelHelpers.export(exports, "includeBooleanAttr", ()=>includeBooleanAttr
);
parcelHelpers.export(exports, "invokeArrayFns", ()=>invokeArrayFns
);
parcelHelpers.export(exports, "isArray", ()=>isArray
);
parcelHelpers.export(exports, "isBooleanAttr", ()=>isBooleanAttr
);
parcelHelpers.export(exports, "isBuiltInDirective", ()=>isBuiltInDirective
);
parcelHelpers.export(exports, "isDate", ()=>isDate
);
parcelHelpers.export(exports, "isFunction", ()=>isFunction
);
parcelHelpers.export(exports, "isGloballyWhitelisted", ()=>isGloballyWhitelisted
);
parcelHelpers.export(exports, "isHTMLTag", ()=>isHTMLTag
);
parcelHelpers.export(exports, "isIntegerKey", ()=>isIntegerKey
);
parcelHelpers.export(exports, "isKnownHtmlAttr", ()=>isKnownHtmlAttr
);
parcelHelpers.export(exports, "isKnownSvgAttr", ()=>isKnownSvgAttr
);
parcelHelpers.export(exports, "isMap", ()=>isMap
);
parcelHelpers.export(exports, "isModelListener", ()=>isModelListener
);
parcelHelpers.export(exports, "isNoUnitNumericStyleProp", ()=>isNoUnitNumericStyleProp
);
parcelHelpers.export(exports, "isObject", ()=>isObject
);
parcelHelpers.export(exports, "isOn", ()=>isOn
);
parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject
);
parcelHelpers.export(exports, "isPromise", ()=>isPromise
);
parcelHelpers.export(exports, "isReservedProp", ()=>isReservedProp
);
parcelHelpers.export(exports, "isSSRSafeAttrName", ()=>isSSRSafeAttrName
);
parcelHelpers.export(exports, "isSVGTag", ()=>isSVGTag
);
parcelHelpers.export(exports, "isSet", ()=>isSet
);
parcelHelpers.export(exports, "isSpecialBooleanAttr", ()=>isSpecialBooleanAttr
);
parcelHelpers.export(exports, "isString", ()=>isString
);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol
);
parcelHelpers.export(exports, "isVoidTag", ()=>isVoidTag
);
parcelHelpers.export(exports, "looseEqual", ()=>looseEqual
);
parcelHelpers.export(exports, "looseIndexOf", ()=>looseIndexOf
);
parcelHelpers.export(exports, "makeMap", ()=>makeMap
);
parcelHelpers.export(exports, "normalizeClass", ()=>normalizeClass
);
parcelHelpers.export(exports, "normalizeProps", ()=>normalizeProps
);
parcelHelpers.export(exports, "normalizeStyle", ()=>normalizeStyle
);
parcelHelpers.export(exports, "objectToString", ()=>objectToString
);
parcelHelpers.export(exports, "parseStringStyle", ()=>parseStringStyle
);
parcelHelpers.export(exports, "propsToAttrMap", ()=>propsToAttrMap
);
parcelHelpers.export(exports, "remove", ()=>remove
);
parcelHelpers.export(exports, "slotFlagsText", ()=>slotFlagsText
);
parcelHelpers.export(exports, "stringifyStyle", ()=>stringifyStyle
);
parcelHelpers.export(exports, "toDisplayString", ()=>toDisplayString
);
parcelHelpers.export(exports, "toHandlerKey", ()=>toHandlerKey
);
parcelHelpers.export(exports, "toNumber", ()=>toNumber
);
parcelHelpers.export(exports, "toRawType", ()=>toRawType
);
parcelHelpers.export(exports, "toTypeString", ()=>toTypeString
);
var global = arguments[3];
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */ function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for(let i = 0; i < list.length; i++)map[list[i]] = true;
    return expectsLowerCase ? (val)=>!!map[val.toLowerCase()]
     : (val)=>!!map[val]
    ;
}
/**
 * dev only flag -> name mapping
 */ const PatchFlagNames = {
    [1 /* TEXT */ ]: `TEXT`,
    [2 /* CLASS */ ]: `CLASS`,
    [4 /* STYLE */ ]: `STYLE`,
    [8 /* PROPS */ ]: `PROPS`,
    [16 /* FULL_PROPS */ ]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */ ]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */ ]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */ ]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */ ]: `UNKEYED_FRAGMENT`,
    [512 /* NEED_PATCH */ ]: `NEED_PATCH`,
    [1024 /* DYNAMIC_SLOTS */ ]: `DYNAMIC_SLOTS`,
    [2048 /* DEV_ROOT_FRAGMENT */ ]: `DEV_ROOT_FRAGMENT`,
    [-1 /* HOISTED */ ]: `HOISTED`,
    [-2 /* BAIL */ ]: `BAIL`
};
/**
 * Dev only
 */ const slotFlagsText = {
    [1 /* STABLE */ ]: 'STABLE',
    [2 /* DYNAMIC */ ]: 'DYNAMIC',
    [3 /* FORWARDED */ ]: 'FORWARDED'
};
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);
const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    // Split the content into individual lines but capture the newline sequence
    // that separated each line. This is important because the actual sequence is
    // needed to properly take into account the full line length for offset
    // comparison
    let lines = source.split(/(\r?\n)/);
    // Separate the lines and newline sequences into separate arrays for easier referencing
    const newlineSequences = lines.filter((_, idx)=>idx % 2 === 1
    );
    lines = lines.filter((_, idx)=>idx % 2 === 0
    );
    let count = 0;
    const res = [];
    for(let i = 0; i < lines.length; i++){
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
            for(let j = i - range; j <= i + range || end > count; j++){
                if (j < 0 || j >= lines.length) continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
                if (j === i) {
                    // push underline
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                } else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join('\n');
}
/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */ const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */ const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` + `loop,open,required,reversed,scoped,seamless,` + `checked,muted,multiple,selected`);
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */ function includeBooleanAttr(value) {
    return !!value || value === '';
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {
};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) return attrValidationCache[name];
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) console.error(`unsafe attribute name: ${name}`);
    return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */ const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` + `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` + `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` + `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` + `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` + `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` + // SVG
`fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` + `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */ const isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` + `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` + `border,buffered,capture,challenge,charset,checked,cite,class,code,` + `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` + `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` + `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` + `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` + `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` + `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` + `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` + `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` + `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` + `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` + `start,step,style,summary,tabindex,target,title,translate,type,usemap,` + `value,width,wrap`);
/**
 * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 */ const isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` + `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` + `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` + `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` + `color-interpolation-filters,color-profile,color-rendering,` + `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` + `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` + `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` + `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` + `font-family,font-size,font-size-adjust,font-stretch,font-style,` + `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` + `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` + `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` + `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` + `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` + `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` + `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` + `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` + `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` + `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` + `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` + `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` + `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` + `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` + `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` + `specularConstant,specularExponent,speed,spreadMethod,startOffset,` + `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` + `strikethrough-position,strikethrough-thickness,string,stroke,` + `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` + `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` + `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` + `text-decoration,text-rendering,textLength,to,transform,transform-origin,` + `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` + `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` + `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` + `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` + `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` + `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` + `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {
        };
        for(let i = 0; i < value.length; i++){
            const item = value[i];
            const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) for(const key in normalized)res[key] = normalized[key];
        }
        return res;
    } else if (isString(value)) return value;
    else if (isObject(value)) return value;
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {
    };
    cssText.split(listDelimiterRE).forEach((item)=>{
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles || isString(styles)) return ret;
    for(const key in styles){
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) || typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey)) // only render valid values
        ret += `${normalizedKey}:${value};`;
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) res = value;
    else if (isArray(value)) for(let i = 0; i < value.length; i++){
        const normalized = normalizeClass(value[i]);
        if (normalized) res += normalized + ' ';
    }
    else if (isObject(value)) {
        for(const name in value)if (value[name]) res += name + ' ';
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props) return null;
    let { class: klass , style  } = props;
    if (klass && !isString(klass)) props.class = normalizeClass(klass);
    if (style) props.style = normalizeStyle(style);
    return props;
}
// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */ const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */ const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */ const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);
const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) return str;
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escaped = '&quot;';
                break;
            case 38:
                escaped = '&amp;';
                break;
            case 39:
                escaped = '&#39;';
                break;
            case 60:
                escaped = '&lt;';
                break;
            case 62:
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) html += str.slice(lastIndex, index);
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}
function looseCompareArrays(a, b) {
    if (a.length !== b.length) return false;
    let equal = true;
    for(let i = 0; equal && i < a.length; i++)equal = looseEqual(a[i], b[i]);
    return equal;
}
function looseEqual(a, b) {
    if (a === b) return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */ if (!aValidType || !bValidType) return false;
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) return false;
        for(const key in a){
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) return false;
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex((item)=>looseEqual(item, val)
    );
}
/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */ const toDisplayString = (val)=>{
    return isString(val) ? val : val == null ? '' : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val1)=>{
    // can't use isRef here since @vue/shared has no deps
    if (val1 && val1.__v_isRef) return replacer(_key, val1.value);
    else if (isMap(val1)) return {
        [`Map(${val1.size})`]: [
            ...val1.entries()
        ].reduce((entries, [key, val])=>{
            entries[`${key} =>`] = val;
            return entries;
        }, {
        })
    };
    else if (isSet(val1)) return {
        [`Set(${val1.size})`]: [
            ...val1.values()
        ]
    };
    else if (isObject(val1) && !isArray(val1) && !isPlainObject(val1)) return String(val1);
    return val1;
};
const EMPTY_OBJ = Object.freeze({
});
const EMPTY_ARR = Object.freeze([]);
const NOOP = ()=>{
};
/**
 * Always return false.
 */ const NO = ()=>false
;
const onRE = /^on[^a-z]/;
const isOn = (key)=>onRE.test(key)
;
const isModelListener = (key)=>key.startsWith('onUpdate:')
;
const extend = Object.assign;
const remove = (arr, el)=>{
    const i = arr.indexOf(el);
    if (i > -1) arr.splice(i, 1);
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key)=>hasOwnProperty.call(val, key)
;
const isArray = Array.isArray;
const isMap = (val)=>toTypeString(val) === '[object Map]'
;
const isSet = (val)=>toTypeString(val) === '[object Set]'
;
const isDate = (val)=>val instanceof Date
;
const isFunction = (val)=>typeof val === 'function'
;
const isString = (val)=>typeof val === 'string'
;
const isSymbol = (val)=>typeof val === 'symbol'
;
const isObject = (val)=>val !== null && typeof val === 'object'
;
const isPromise = (val)=>{
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value)=>objectToString.call(value)
;
const toRawType = (value)=>{
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val)=>toTypeString(val) === '[object Object]'
;
const isIntegerKey = (key)=>isString(key) && key !== 'NaN' && key[0] !== '-' && '' + parseInt(key, 10) === key
;
const isReservedProp = /*#__PURE__*/ makeMap(// the leading comma is intentional so empty string "" is also included
",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
const cacheStringFunction = (fn)=>{
    const cache = Object.create(null);
    return (str)=>{
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */ const camelize = cacheStringFunction((str)=>{
    return str.replace(camelizeRE, (_, c)=>c ? c.toUpperCase() : ''
    );
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */ const hyphenate = cacheStringFunction((str)=>str.replace(hyphenateRE, '-$1').toLowerCase()
);
/**
 * @private
 */ const capitalize = cacheStringFunction((str)=>str.charAt(0).toUpperCase() + str.slice(1)
);
/**
 * @private
 */ const toHandlerKey = cacheStringFunction((str)=>str ? `on${capitalize(str)}` : ``
);
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue)=>!Object.is(value, oldValue)
;
const invokeArrayFns = (fns, arg)=>{
    for(let i = 0; i < fns.length; i++)fns[i](arg);
};
const def = (obj, key, value)=>{
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const toNumber = (val)=>{
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = ()=>{
    return _globalThis || (_globalThis = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {
    });
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"djgkP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_defaultsMjsDefault.default
);
parcelHelpers.export(exports, "makeInstaller", ()=>_makeInstallerMjs.makeInstaller
);
parcelHelpers.export(exports, "affixEmits", ()=>_affixMjs.affixEmits
);
parcelHelpers.export(exports, "affixProps", ()=>_affixMjs.affixProps
);
parcelHelpers.export(exports, "ElAffix", ()=>_indexMjs4.ElAffix
);
parcelHelpers.export(exports, "alertEffects", ()=>_alertMjs.alertEffects
);
parcelHelpers.export(exports, "alertEmits", ()=>_alertMjs.alertEmits
);
parcelHelpers.export(exports, "alertProps", ()=>_alertMjs.alertProps
);
parcelHelpers.export(exports, "ElAlert", ()=>_indexMjs5.ElAlert
);
parcelHelpers.export(exports, "ElAutocomplete", ()=>_indexMjs6.ElAutocomplete
);
parcelHelpers.export(exports, "avatarEmits", ()=>_avatarMjs.avatarEmits
);
parcelHelpers.export(exports, "avatarProps", ()=>_avatarMjs.avatarProps
);
parcelHelpers.export(exports, "ElAvatar", ()=>_indexMjs7.ElAvatar
);
parcelHelpers.export(exports, "backtopEmits", ()=>_backtopMjs.backtopEmits
);
parcelHelpers.export(exports, "backtopProps", ()=>_backtopMjs.backtopProps
);
parcelHelpers.export(exports, "ElBacktop", ()=>_indexMjs8.ElBacktop
);
parcelHelpers.export(exports, "badgeProps", ()=>_badgeMjs.badgeProps
);
parcelHelpers.export(exports, "ElBadge", ()=>_indexMjs9.ElBadge
);
parcelHelpers.export(exports, "breadcrumbProps", ()=>_breadcrumbMjs.breadcrumbProps
);
parcelHelpers.export(exports, "breadcrumbItemProps", ()=>_breadcrumbItemMjs.breadcrumbItemProps
);
parcelHelpers.export(exports, "ElBreadcrumb", ()=>_indexMjs10.ElBreadcrumb
);
parcelHelpers.export(exports, "ElBreadcrumbItem", ()=>_indexMjs10.ElBreadcrumbItem
);
parcelHelpers.export(exports, "buttonEmits", ()=>_buttonMjs.buttonEmits
);
parcelHelpers.export(exports, "buttonNativeTypes", ()=>_buttonMjs.buttonNativeTypes
);
parcelHelpers.export(exports, "buttonProps", ()=>_buttonMjs.buttonProps
);
parcelHelpers.export(exports, "buttonTypes", ()=>_buttonMjs.buttonTypes
);
parcelHelpers.export(exports, "ElButton", ()=>_indexMjs11.ElButton
);
parcelHelpers.export(exports, "ElButtonGroup", ()=>_indexMjs11.ElButtonGroup
);
parcelHelpers.export(exports, "calendarEmits", ()=>_calendarMjs.calendarEmits
);
parcelHelpers.export(exports, "calendarProps", ()=>_calendarMjs.calendarProps
);
parcelHelpers.export(exports, "ElCalendar", ()=>_indexMjs12.ElCalendar
);
parcelHelpers.export(exports, "cardProps", ()=>_cardMjs.cardProps
);
parcelHelpers.export(exports, "ElCard", ()=>_indexMjs13.ElCard
);
parcelHelpers.export(exports, "ElCarousel", ()=>_indexMjs14.ElCarousel
);
parcelHelpers.export(exports, "ElCarouselItem", ()=>_indexMjs14.ElCarouselItem
);
parcelHelpers.export(exports, "ElCascader", ()=>_indexMjs15.ElCascader
);
parcelHelpers.export(exports, "CASCADER_PANEL_INJECTION_KEY", ()=>_typesMjs.CASCADER_PANEL_INJECTION_KEY
);
parcelHelpers.export(exports, "ExpandTrigger", ()=>_typesMjs.ExpandTrigger
);
parcelHelpers.export(exports, "CommonProps", ()=>_configMjs.CommonProps
);
parcelHelpers.export(exports, "DefaultProps", ()=>_configMjs.DefaultProps
);
parcelHelpers.export(exports, "useCascaderConfig", ()=>_configMjs.useCascaderConfig
);
parcelHelpers.export(exports, "ElCascaderPanel", ()=>_indexMjs16.ElCascaderPanel
);
parcelHelpers.export(exports, "checkTagEmits", ()=>_checkTagMjs.checkTagEmits
);
parcelHelpers.export(exports, "checkTagProps", ()=>_checkTagMjs.checkTagProps
);
parcelHelpers.export(exports, "ElCheckTag", ()=>_indexMjs17.ElCheckTag
);
parcelHelpers.export(exports, "ElCheckbox", ()=>_indexMjs18.ElCheckbox
);
parcelHelpers.export(exports, "ElCheckboxButton", ()=>_indexMjs18.ElCheckboxButton
);
parcelHelpers.export(exports, "ElCheckboxGroup", ()=>_indexMjs18.ElCheckboxGroup
);
parcelHelpers.export(exports, "colProps", ()=>_colMjs.colProps
);
parcelHelpers.export(exports, "ElCol", ()=>_indexMjs19.ElCol
);
parcelHelpers.export(exports, "ElCollapse", ()=>_indexMjs20.ElCollapse
);
parcelHelpers.export(exports, "ElCollapseItem", ()=>_indexMjs20.ElCollapseItem
);
parcelHelpers.export(exports, "ElCollapseTransition", ()=>_indexMjs21.ElCollapseTransition
);
parcelHelpers.export(exports, "ElColorPicker", ()=>_indexMjs22.ElColorPicker
);
parcelHelpers.export(exports, "configProviderProps", ()=>_configProviderMjs.configProviderProps
);
parcelHelpers.export(exports, "messageConfig", ()=>_configProviderMjs.messageConfig
);
parcelHelpers.export(exports, "ElConfigProvider", ()=>_indexMjs23.ElConfigProvider
);
parcelHelpers.export(exports, "ElAside", ()=>_indexMjs24.ElAside
);
parcelHelpers.export(exports, "ElContainer", ()=>_indexMjs24.ElContainer
);
parcelHelpers.export(exports, "ElFooter", ()=>_indexMjs24.ElFooter
);
parcelHelpers.export(exports, "ElHeader", ()=>_indexMjs24.ElHeader
);
parcelHelpers.export(exports, "ElMain", ()=>_indexMjs24.ElMain
);
parcelHelpers.export(exports, "ElDatePicker", ()=>_indexMjs25.ElDatePicker
);
parcelHelpers.export(exports, "ElDescriptions", ()=>_indexMjs26.ElDescriptions
);
parcelHelpers.export(exports, "ElDescriptionsItem", ()=>_indexMjs26.ElDescriptionsItem
);
parcelHelpers.export(exports, "useDialog", ()=>_useDialogMjs.useDialog
);
parcelHelpers.export(exports, "dialogEmits", ()=>_dialogMjs.dialogEmits
);
parcelHelpers.export(exports, "dialogProps", ()=>_dialogMjs.dialogProps
);
parcelHelpers.export(exports, "ElDialog", ()=>_indexMjs27.ElDialog
);
parcelHelpers.export(exports, "dividerProps", ()=>_dividerMjs.dividerProps
);
parcelHelpers.export(exports, "ElDivider", ()=>_indexMjs28.ElDivider
);
parcelHelpers.export(exports, "drawerEmits", ()=>_drawerMjs.drawerEmits
);
parcelHelpers.export(exports, "drawerProps", ()=>_drawerMjs.drawerProps
);
parcelHelpers.export(exports, "ElDrawer", ()=>_indexMjs29.ElDrawer
);
parcelHelpers.export(exports, "DROPDOWN_COLLECTION_INJECTION_KEY", ()=>_dropdownMjs.DROPDOWN_COLLECTION_INJECTION_KEY
);
parcelHelpers.export(exports, "DROPDOWN_COLLECTION_ITEM_INJECTION_KEY", ()=>_dropdownMjs.DROPDOWN_COLLECTION_ITEM_INJECTION_KEY
);
parcelHelpers.export(exports, "ElCollection", ()=>_dropdownMjs.ElCollection
);
parcelHelpers.export(exports, "ElCollectionItem", ()=>_dropdownMjs.ElCollectionItem
);
parcelHelpers.export(exports, "FIRST_KEYS", ()=>_dropdownMjs.FIRST_KEYS
);
parcelHelpers.export(exports, "FIRST_LAST_KEYS", ()=>_dropdownMjs.FIRST_LAST_KEYS
);
parcelHelpers.export(exports, "LAST_KEYS", ()=>_dropdownMjs.LAST_KEYS
);
parcelHelpers.export(exports, "dropdownItemProps", ()=>_dropdownMjs.dropdownItemProps
);
parcelHelpers.export(exports, "dropdownMenuProps", ()=>_dropdownMjs.dropdownMenuProps
);
parcelHelpers.export(exports, "dropdownProps", ()=>_dropdownMjs.dropdownProps
);
parcelHelpers.export(exports, "DROPDOWN_INJECTION_KEY", ()=>_tokensMjs.DROPDOWN_INJECTION_KEY
);
parcelHelpers.export(exports, "ElDropdown", ()=>_indexMjs30.ElDropdown
);
parcelHelpers.export(exports, "ElDropdownItem", ()=>_indexMjs30.ElDropdownItem
);
parcelHelpers.export(exports, "ElDropdownMenu", ()=>_indexMjs30.ElDropdownMenu
);
parcelHelpers.export(exports, "emptyProps", ()=>_emptyMjs.emptyProps
);
parcelHelpers.export(exports, "ElEmpty", ()=>_indexMjs31.ElEmpty
);
parcelHelpers.export(exports, "ElForm", ()=>_indexMjs32.ElForm
);
parcelHelpers.export(exports, "ElFormItem", ()=>_indexMjs32.ElFormItem
);
parcelHelpers.export(exports, "iconProps", ()=>_iconMjs.iconProps
);
parcelHelpers.export(exports, "ElIcon", ()=>_indexMjs33.ElIcon
);
parcelHelpers.export(exports, "imageEmits", ()=>_imageMjs.imageEmits
);
parcelHelpers.export(exports, "imageProps", ()=>_imageMjs.imageProps
);
parcelHelpers.export(exports, "ElImage", ()=>_indexMjs34.ElImage
);
parcelHelpers.export(exports, "imageViewerEmits", ()=>_imageViewerMjs.imageViewerEmits
);
parcelHelpers.export(exports, "imageViewerProps", ()=>_imageViewerMjs.imageViewerProps
);
parcelHelpers.export(exports, "ElImageViewer", ()=>_indexMjs35.ElImageViewer
);
parcelHelpers.export(exports, "inputEmits", ()=>_inputMjs.inputEmits
);
parcelHelpers.export(exports, "inputProps", ()=>_inputMjs.inputProps
);
parcelHelpers.export(exports, "ElInput", ()=>_indexMjs36.ElInput
);
parcelHelpers.export(exports, "inputNumberEmits", ()=>_inputNumberMjs.inputNumberEmits
);
parcelHelpers.export(exports, "inputNumberProps", ()=>_inputNumberMjs.inputNumberProps
);
parcelHelpers.export(exports, "ElInputNumber", ()=>_indexMjs37.ElInputNumber
);
parcelHelpers.export(exports, "linkEmits", ()=>_linkMjs.linkEmits
);
parcelHelpers.export(exports, "linkProps", ()=>_linkMjs.linkProps
);
parcelHelpers.export(exports, "ElLink", ()=>_indexMjs38.ElLink
);
parcelHelpers.export(exports, "menuEmits", ()=>_menuMjs.menuEmits
);
parcelHelpers.export(exports, "menuProps", ()=>_menuMjs.menuProps
);
parcelHelpers.export(exports, "menuItemEmits", ()=>_menuItemMjs.menuItemEmits
);
parcelHelpers.export(exports, "menuItemProps", ()=>_menuItemMjs.menuItemProps
);
parcelHelpers.export(exports, "menuItemGroupProps", ()=>_menuItemGroupMjs.menuItemGroupProps
);
parcelHelpers.export(exports, "subMenuProps", ()=>_subMenuMjs.subMenuProps
);
parcelHelpers.export(exports, "ElMenu", ()=>_indexMjs39.ElMenu
);
parcelHelpers.export(exports, "ElMenuItem", ()=>_indexMjs39.ElMenuItem
);
parcelHelpers.export(exports, "ElMenuItemGroup", ()=>_indexMjs39.ElMenuItemGroup
);
parcelHelpers.export(exports, "ElSubMenu", ()=>_indexMjs39.ElSubMenu
);
parcelHelpers.export(exports, "overlayEmits", ()=>_overlayMjs.overlayEmits
);
parcelHelpers.export(exports, "overlayProps", ()=>_overlayMjs.overlayProps
);
parcelHelpers.export(exports, "ElOverlay", ()=>_indexMjs40.ElOverlay
);
parcelHelpers.export(exports, "pageHeaderEmits", ()=>_pageHeaderMjs.pageHeaderEmits
);
parcelHelpers.export(exports, "pageHeaderProps", ()=>_pageHeaderMjs.pageHeaderProps
);
parcelHelpers.export(exports, "ElPageHeader", ()=>_indexMjs41.ElPageHeader
);
parcelHelpers.export(exports, "paginationEmits", ()=>_paginationMjs.paginationEmits
);
parcelHelpers.export(exports, "paginationProps", ()=>_paginationMjs.paginationProps
);
parcelHelpers.export(exports, "ElPagination", ()=>_indexMjs42.ElPagination
);
parcelHelpers.export(exports, "popconfirmProps", ()=>_popconfirmMjs.popconfirmProps
);
parcelHelpers.export(exports, "ElPopconfirm", ()=>_indexMjs43.ElPopconfirm
);
parcelHelpers.export(exports, "ElPopperArrow", ()=>_arrowMjsDefault.default
);
parcelHelpers.export(exports, "ElPopperTrigger", ()=>_triggerMjsDefault.default
);
parcelHelpers.export(exports, "ElPopperContent", ()=>_contentMjsDefault.default
);
parcelHelpers.export(exports, "useDeprecateAppendToBody", ()=>_deprecationMjs.useDeprecateAppendToBody
);
parcelHelpers.export(exports, "Effect", ()=>_popperMjs.Effect
);
parcelHelpers.export(exports, "usePopperArrowProps", ()=>_popperMjs.usePopperArrowProps
);
parcelHelpers.export(exports, "usePopperContentProps", ()=>_popperMjs.usePopperContentProps
);
parcelHelpers.export(exports, "usePopperCoreConfigProps", ()=>_popperMjs.usePopperCoreConfigProps
);
parcelHelpers.export(exports, "usePopperProps", ()=>_popperMjs.usePopperProps
);
parcelHelpers.export(exports, "usePopperTriggerProps", ()=>_popperMjs.usePopperTriggerProps
);
parcelHelpers.export(exports, "POPPER_CONTENT_INJECTION_KEY", ()=>_tokensMjs1.POPPER_CONTENT_INJECTION_KEY
);
parcelHelpers.export(exports, "POPPER_INJECTION_KEY", ()=>_tokensMjs1.POPPER_INJECTION_KEY
);
parcelHelpers.export(exports, "ElPopper", ()=>_indexMjs44.ElPopper
);
parcelHelpers.export(exports, "progressProps", ()=>_progressMjs.progressProps
);
parcelHelpers.export(exports, "ElProgress", ()=>_indexMjs45.ElProgress
);
parcelHelpers.export(exports, "radioEmits", ()=>_radioMjs.radioEmits
);
parcelHelpers.export(exports, "radioProps", ()=>_radioMjs.radioProps
);
parcelHelpers.export(exports, "radioPropsBase", ()=>_radioMjs.radioPropsBase
);
parcelHelpers.export(exports, "useRadio", ()=>_radioMjs.useRadio
);
parcelHelpers.export(exports, "radioGroupEmits", ()=>_radioGroupMjs.radioGroupEmits
);
parcelHelpers.export(exports, "radioGroupProps", ()=>_radioGroupMjs.radioGroupProps
);
parcelHelpers.export(exports, "radioButtonProps", ()=>_radioButtonMjs.radioButtonProps
);
parcelHelpers.export(exports, "ElRadio", ()=>_indexMjs46.ElRadio
);
parcelHelpers.export(exports, "ElRadioButton", ()=>_indexMjs46.ElRadioButton
);
parcelHelpers.export(exports, "ElRadioGroup", ()=>_indexMjs46.ElRadioGroup
);
parcelHelpers.export(exports, "rateEmits", ()=>_rateMjs.rateEmits
);
parcelHelpers.export(exports, "rateProps", ()=>_rateMjs.rateProps
);
parcelHelpers.export(exports, "ElRate", ()=>_indexMjs47.ElRate
);
parcelHelpers.export(exports, "IconComponentMap", ()=>_resultMjs.IconComponentMap
);
parcelHelpers.export(exports, "IconMap", ()=>_resultMjs.IconMap
);
parcelHelpers.export(exports, "resultProps", ()=>_resultMjs.resultProps
);
parcelHelpers.export(exports, "ElResult", ()=>_indexMjs48.ElResult
);
parcelHelpers.export(exports, "rowProps", ()=>_rowMjs.rowProps
);
parcelHelpers.export(exports, "ElRow", ()=>_indexMjs49.ElRow
);
parcelHelpers.export(exports, "BAR_MAP", ()=>_utilMjs.BAR_MAP
);
parcelHelpers.export(exports, "renderThumbStyle", ()=>_utilMjs.renderThumbStyle
);
parcelHelpers.export(exports, "scrollbarEmits", ()=>_scrollbarMjs.scrollbarEmits
);
parcelHelpers.export(exports, "scrollbarProps", ()=>_scrollbarMjs.scrollbarProps
);
parcelHelpers.export(exports, "thumbProps", ()=>_thumbMjs.thumbProps
);
parcelHelpers.export(exports, "ElScrollbar", ()=>_indexMjs50.ElScrollbar
);
parcelHelpers.export(exports, "selectGroupKey", ()=>_tokenMjs.selectGroupKey
);
parcelHelpers.export(exports, "selectKey", ()=>_tokenMjs.selectKey
);
parcelHelpers.export(exports, "ElOption", ()=>_indexMjs51.ElOption
);
parcelHelpers.export(exports, "ElOptionGroup", ()=>_indexMjs51.ElOptionGroup
);
parcelHelpers.export(exports, "ElSelect", ()=>_indexMjs51.ElSelect
);
parcelHelpers.export(exports, "selectV2InjectionKey", ()=>_tokenMjs1.selectV2InjectionKey
);
parcelHelpers.export(exports, "ElSelectV2", ()=>_indexMjs52.ElSelectV2
);
parcelHelpers.export(exports, "skeletonProps", ()=>_skeletonMjs.skeletonProps
);
parcelHelpers.export(exports, "skeletonItemProps", ()=>_skeletonItemMjs.skeletonItemProps
);
parcelHelpers.export(exports, "ElSkeleton", ()=>_indexMjs53.ElSkeleton
);
parcelHelpers.export(exports, "ElSkeletonItem", ()=>_indexMjs53.ElSkeletonItem
);
parcelHelpers.export(exports, "ElSlider", ()=>_indexMjs54.ElSlider
);
parcelHelpers.export(exports, "spaceProps", ()=>_spaceMjs.spaceProps
);
parcelHelpers.export(exports, "useSpace", ()=>_useSpaceMjs.useSpace
);
parcelHelpers.export(exports, "ElSpace", ()=>_indexMjs55.ElSpace
);
parcelHelpers.export(exports, "ElStep", ()=>_indexMjs56.ElStep
);
parcelHelpers.export(exports, "ElSteps", ()=>_indexMjs56.ElSteps
);
parcelHelpers.export(exports, "switchEmits", ()=>_switchMjs.switchEmits
);
parcelHelpers.export(exports, "switchProps", ()=>_switchMjs.switchProps
);
parcelHelpers.export(exports, "ElSwitch", ()=>_indexMjs57.ElSwitch
);
parcelHelpers.export(exports, "ElTable", ()=>_indexMjs58.ElTable
);
parcelHelpers.export(exports, "ElTableColumn", ()=>_indexMjs58.ElTableColumn
);
parcelHelpers.export(exports, "tabsEmits", ()=>_tabsMjs.tabsEmits
);
parcelHelpers.export(exports, "tabsProps", ()=>_tabsMjs.tabsProps
);
parcelHelpers.export(exports, "tabBar", ()=>_tabBarMjs.tabBar
);
parcelHelpers.export(exports, "tabNavProps", ()=>_tabNavMjs.tabNavProps
);
parcelHelpers.export(exports, "tabPaneProps", ()=>_tabPaneMjs.tabPaneProps
);
parcelHelpers.export(exports, "ElTabPane", ()=>_indexMjs59.ElTabPane
);
parcelHelpers.export(exports, "ElTabs", ()=>_indexMjs59.ElTabs
);
parcelHelpers.export(exports, "tagEmits", ()=>_tagMjs.tagEmits
);
parcelHelpers.export(exports, "tagProps", ()=>_tagMjs.tagProps
);
parcelHelpers.export(exports, "ElTag", ()=>_indexMjs60.ElTag
);
parcelHelpers.export(exports, "extractDateFormat", ()=>_dateUtilsMjs.extractDateFormat
);
parcelHelpers.export(exports, "extractTimeFormat", ()=>_dateUtilsMjs.extractTimeFormat
);
parcelHelpers.export(exports, "rangeArr", ()=>_dateUtilsMjs.rangeArr
);
parcelHelpers.export(exports, "DEFAULT_FORMATS_DATE", ()=>_constantMjs.DEFAULT_FORMATS_DATE
);
parcelHelpers.export(exports, "DEFAULT_FORMATS_DATEPICKER", ()=>_constantMjs.DEFAULT_FORMATS_DATEPICKER
);
parcelHelpers.export(exports, "DEFAULT_FORMATS_TIME", ()=>_constantMjs.DEFAULT_FORMATS_TIME
);
parcelHelpers.export(exports, "timePickerDefaultProps", ()=>_propsMjs.timePickerDefaultProps
);
parcelHelpers.export(exports, "CommonPicker", ()=>_pickerMjsDefault.default
);
parcelHelpers.export(exports, "TimePickPanel", ()=>_panelTimePickMjsDefault.default
);
parcelHelpers.export(exports, "ElTimePicker", ()=>_indexMjs61.ElTimePicker
);
parcelHelpers.export(exports, "ElTimeSelect", ()=>_indexMjs62.ElTimeSelect
);
parcelHelpers.export(exports, "timelineItemProps", ()=>_timelineItemMjs.timelineItemProps
);
parcelHelpers.export(exports, "ElTimeline", ()=>_indexMjs63.ElTimeline
);
parcelHelpers.export(exports, "ElTimelineItem", ()=>_indexMjs63.ElTimelineItem
);
parcelHelpers.export(exports, "useTooltipContentProps", ()=>_tooltipMjs.useTooltipContentProps
);
parcelHelpers.export(exports, "useTooltipProps", ()=>_tooltipMjs.useTooltipProps
);
parcelHelpers.export(exports, "useTooltipTriggerProps", ()=>_tooltipMjs.useTooltipTriggerProps
);
parcelHelpers.export(exports, "TOOLTIP_INJECTION_KEY", ()=>_tokensMjs2.TOOLTIP_INJECTION_KEY
);
parcelHelpers.export(exports, "ElTooltip", ()=>_indexMjs64.ElTooltip
);
parcelHelpers.export(exports, "CHANGE_EVENT", ()=>_eventMjs.CHANGE_EVENT
);
parcelHelpers.export(exports, "ElTransfer", ()=>_indexMjs65.ElTransfer
);
parcelHelpers.export(exports, "ElTree", ()=>_indexMjs66.ElTree
);
parcelHelpers.export(exports, "ElTreeV2", ()=>_indexMjs67.ElTreeV2
);
parcelHelpers.export(exports, "ElUpload", ()=>_indexMjs68.ElUpload
);
parcelHelpers.export(exports, "FixedSizeList", ()=>_fixedSizeListMjsDefault.default
);
parcelHelpers.export(exports, "DynamicSizeList", ()=>_dynamicSizeListMjsDefault.default
);
parcelHelpers.export(exports, "FixedSizeGrid", ()=>_fixedSizeGridMjsDefault.default
);
parcelHelpers.export(exports, "DynamicSizeGrid", ()=>_dynamicSizeGridMjsDefault.default
);
parcelHelpers.export(exports, "virtualizedGridProps", ()=>_propsMjs1.virtualizedGridProps
);
parcelHelpers.export(exports, "virtualizedListProps", ()=>_propsMjs1.virtualizedListProps
);
parcelHelpers.export(exports, "virtualizedProps", ()=>_propsMjs1.virtualizedProps
);
parcelHelpers.export(exports, "virtualizedScrollbarProps", ()=>_propsMjs1.virtualizedScrollbarProps
);
parcelHelpers.export(exports, "ElInfiniteScroll", ()=>_indexMjs69.ElInfiniteScroll
);
parcelHelpers.export(exports, "ElLoading", ()=>_indexMjs70.ElLoading
);
parcelHelpers.export(exports, "ElLoadingDirective", ()=>_indexMjs70.ElLoadingDirective
);
parcelHelpers.export(exports, "ElLoadingService", ()=>_indexMjs70.ElLoadingService
);
parcelHelpers.export(exports, "messageEmits", ()=>_messageMjs.messageEmits
);
parcelHelpers.export(exports, "messageProps", ()=>_messageMjs.messageProps
);
parcelHelpers.export(exports, "messageTypes", ()=>_messageMjs.messageTypes
);
parcelHelpers.export(exports, "ElMessage", ()=>_indexMjs71.ElMessage
);
parcelHelpers.export(exports, "ElMessageBox", ()=>_indexMjs72.ElMessageBox
);
parcelHelpers.export(exports, "notificationEmits", ()=>_notificationMjs.notificationEmits
);
parcelHelpers.export(exports, "notificationProps", ()=>_notificationMjs.notificationProps
);
parcelHelpers.export(exports, "notificationTypes", ()=>_notificationMjs.notificationTypes
);
parcelHelpers.export(exports, "ElNotification", ()=>_indexMjs73.ElNotification
);
parcelHelpers.export(exports, "ElPopover", ()=>_indexMjs74.ElPopover
);
parcelHelpers.export(exports, "ElPopoverDirective", ()=>_indexMjs74.ElPopoverDirective
);
parcelHelpers.export(exports, "ClickOutside", ()=>_indexMjsDefault.default
);
parcelHelpers.export(exports, "RepeatClick", ()=>_indexMjsDefault1.default
);
parcelHelpers.export(exports, "TrapFocus", ()=>_indexMjsDefault2.default
);
parcelHelpers.export(exports, "Mousewheel", ()=>_indexMjsDefault3.default
);
parcelHelpers.export(exports, "Resize", ()=>_indexMjsDefault4.default
);
parcelHelpers.export(exports, "useAttrs", ()=>_indexMjs80.useAttrs
);
parcelHelpers.export(exports, "useDisabled", ()=>_indexMjs81.useDisabled
);
parcelHelpers.export(exports, "useSize", ()=>_indexMjs81.useSize
);
parcelHelpers.export(exports, "useSizeProp", ()=>_indexMjs81.useSizeProp
);
parcelHelpers.export(exports, "useDeprecated", ()=>_indexMjs82.useDeprecated
);
parcelHelpers.export(exports, "useDraggable", ()=>_indexMjs83.useDraggable
);
parcelHelpers.export(exports, "useFocus", ()=>_indexMjs84.useFocus
);
parcelHelpers.export(exports, "useFormItem", ()=>_indexMjs85.useFormItem
);
parcelHelpers.export(exports, "provideGlobalConfig", ()=>_indexMjs86.provideGlobalConfig
);
parcelHelpers.export(exports, "useGlobalConfig", ()=>_indexMjs86.useGlobalConfig
);
parcelHelpers.export(exports, "buildLocaleContext", ()=>_indexMjs87.buildLocaleContext
);
parcelHelpers.export(exports, "buildTranslator", ()=>_indexMjs87.buildTranslator
);
parcelHelpers.export(exports, "translate", ()=>_indexMjs87.translate
);
parcelHelpers.export(exports, "useLocale", ()=>_indexMjs87.useLocale
);
parcelHelpers.export(exports, "useLockscreen", ()=>_indexMjs88.useLockscreen
);
parcelHelpers.export(exports, "useModal", ()=>_indexMjs89.useModal
);
parcelHelpers.export(exports, "createModelToggleComposable", ()=>_indexMjs90.createModelToggleComposable
);
parcelHelpers.export(exports, "useModelToggle", ()=>_indexMjs90.useModelToggle
);
parcelHelpers.export(exports, "useModelToggleEmits", ()=>_indexMjs90.useModelToggleEmits
);
parcelHelpers.export(exports, "useModelToggleProps", ()=>_indexMjs90.useModelToggleProps
);
parcelHelpers.export(exports, "usePreventGlobal", ()=>_indexMjs91.usePreventGlobal
);
parcelHelpers.export(exports, "useProp", ()=>_indexMjs92.useProp
);
parcelHelpers.export(exports, "useRestoreActive", ()=>_indexMjs93.useRestoreActive
);
parcelHelpers.export(exports, "useSameTarget", ()=>_indexMjs94.useSameTarget
);
parcelHelpers.export(exports, "useTeleport", ()=>_indexMjs95.useTeleport
);
parcelHelpers.export(exports, "useThrottleRender", ()=>_indexMjs96.useThrottleRender
);
parcelHelpers.export(exports, "useTimeout", ()=>_indexMjs97.useTimeout
);
parcelHelpers.export(exports, "useTransitionFallthrough", ()=>_indexMjs98.useTransitionFallthrough
);
parcelHelpers.export(exports, "useTransitionFallthroughEmits", ()=>_indexMjs98.useTransitionFallthroughEmits
);
parcelHelpers.export(exports, "ID_INJECTION_KEY", ()=>_indexMjs99.ID_INJECTION_KEY
);
parcelHelpers.export(exports, "useId", ()=>_indexMjs99.useId
);
parcelHelpers.export(exports, "useEscapeKeydown", ()=>_indexMjs100.useEscapeKeydown
);
parcelHelpers.export(exports, "POPPER_CONTAINER_ID", ()=>_indexMjs101.POPPER_CONTAINER_ID
);
parcelHelpers.export(exports, "POPPER_CONTAINER_SELECTOR", ()=>_indexMjs101.POPPER_CONTAINER_SELECTOR
);
parcelHelpers.export(exports, "usePopperContainer", ()=>_indexMjs101.usePopperContainer
);
parcelHelpers.export(exports, "useDelayedRender", ()=>_indexMjs102.useDelayedRender
);
parcelHelpers.export(exports, "useDelayedToggle", ()=>_indexMjs103.useDelayedToggle
);
parcelHelpers.export(exports, "useDelayedToggleProps", ()=>_indexMjs103.useDelayedToggleProps
);
parcelHelpers.export(exports, "FORWARD_REF_INJECTION_KEY", ()=>_indexMjs104.FORWARD_REF_INJECTION_KEY
);
parcelHelpers.export(exports, "useForwardRef", ()=>_indexMjs104.useForwardRef
);
parcelHelpers.export(exports, "useForwardRefDirective", ()=>_indexMjs104.useForwardRefDirective
);
parcelHelpers.export(exports, "useNamespace", ()=>_indexMjs105.useNamespace
);
parcelHelpers.export(exports, "useZIndex", ()=>_indexMjs106.useZIndex
);
parcelHelpers.export(exports, "elFormItemKey", ()=>_formMjs.elFormItemKey
);
parcelHelpers.export(exports, "elFormKey", ()=>_formMjs.elFormKey
);
parcelHelpers.export(exports, "buttonGroupContextKey", ()=>_buttonMjs1.buttonGroupContextKey
);
parcelHelpers.export(exports, "elBreadcrumbKey", ()=>_breadcrumbMjs1.elBreadcrumbKey
);
parcelHelpers.export(exports, "elPaginationKey", ()=>_paginationMjs1.elPaginationKey
);
parcelHelpers.export(exports, "configProviderContextKey", ()=>_configProviderMjs1.configProviderContextKey
);
parcelHelpers.export(exports, "radioGroupKey", ()=>_radioMjs1.radioGroupKey
);
parcelHelpers.export(exports, "tabsRootContextKey", ()=>_tabsMjs1.tabsRootContextKey
);
parcelHelpers.export(exports, "scrollbarContextKey", ()=>_scrollbarMjs1.scrollbarContextKey
);
parcelHelpers.export(exports, "install", ()=>install
);
parcelHelpers.export(exports, "version", ()=>version
);
var _defaultsMjs = require("./defaults.mjs");
var _defaultsMjsDefault = parcelHelpers.interopDefault(_defaultsMjs);
var _indexMjs = require("./components/index.mjs");
var _indexMjs1 = require("./directives/index.mjs");
var _indexMjs2 = require("./hooks/index.mjs");
var _indexMjs3 = require("./tokens/index.mjs");
var _makeInstallerMjs = require("./make-installer.mjs");
var _affixMjs = require("./components/affix/src/affix.mjs");
var _indexMjs4 = require("./components/affix/index.mjs");
var _alertMjs = require("./components/alert/src/alert.mjs");
var _indexMjs5 = require("./components/alert/index.mjs");
var _indexMjs6 = require("./components/autocomplete/index.mjs");
var _avatarMjs = require("./components/avatar/src/avatar.mjs");
var _indexMjs7 = require("./components/avatar/index.mjs");
var _backtopMjs = require("./components/backtop/src/backtop.mjs");
var _indexMjs8 = require("./components/backtop/index.mjs");
var _badgeMjs = require("./components/badge/src/badge.mjs");
var _indexMjs9 = require("./components/badge/index.mjs");
var _breadcrumbMjs = require("./components/breadcrumb/src/breadcrumb.mjs");
var _breadcrumbItemMjs = require("./components/breadcrumb/src/breadcrumb-item.mjs");
var _indexMjs10 = require("./components/breadcrumb/index.mjs");
var _buttonMjs = require("./components/button/src/button.mjs");
var _indexMjs11 = require("./components/button/index.mjs");
var _calendarMjs = require("./components/calendar/src/calendar.mjs");
var _indexMjs12 = require("./components/calendar/index.mjs");
var _cardMjs = require("./components/card/src/card.mjs");
var _indexMjs13 = require("./components/card/index.mjs");
var _indexMjs14 = require("./components/carousel/index.mjs");
var _indexMjs15 = require("./components/cascader/index.mjs");
var _typesMjs = require("./components/cascader-panel/src/types.mjs");
var _configMjs = require("./components/cascader-panel/src/config.mjs");
var _indexMjs16 = require("./components/cascader-panel/index.mjs");
var _checkTagMjs = require("./components/check-tag/src/check-tag.mjs");
var _indexMjs17 = require("./components/check-tag/index.mjs");
var _indexMjs18 = require("./components/checkbox/index.mjs");
var _colMjs = require("./components/col/src/col.mjs");
var _indexMjs19 = require("./components/col/index.mjs");
var _indexMjs20 = require("./components/collapse/index.mjs");
var _indexMjs21 = require("./components/collapse-transition/index.mjs");
var _indexMjs22 = require("./components/color-picker/index.mjs");
var _configProviderMjs = require("./components/config-provider/src/config-provider.mjs");
var _indexMjs23 = require("./components/config-provider/index.mjs");
var _indexMjs24 = require("./components/container/index.mjs");
var _indexMjs25 = require("./components/date-picker/index.mjs");
var _indexMjs26 = require("./components/descriptions/index.mjs");
var _useDialogMjs = require("./components/dialog/src/use-dialog.mjs");
var _dialogMjs = require("./components/dialog/src/dialog.mjs");
var _indexMjs27 = require("./components/dialog/index.mjs");
var _dividerMjs = require("./components/divider/src/divider.mjs");
var _indexMjs28 = require("./components/divider/index.mjs");
var _drawerMjs = require("./components/drawer/src/drawer.mjs");
var _indexMjs29 = require("./components/drawer/index.mjs");
var _dropdownMjs = require("./components/dropdown/src/dropdown.mjs");
var _tokensMjs = require("./components/dropdown/src/tokens.mjs");
var _indexMjs30 = require("./components/dropdown/index.mjs");
var _emptyMjs = require("./components/empty/src/empty.mjs");
var _indexMjs31 = require("./components/empty/index.mjs");
var _indexMjs32 = require("./components/form/index.mjs");
var _iconMjs = require("./components/icon/src/icon.mjs");
var _indexMjs33 = require("./components/icon/index.mjs");
var _imageMjs = require("./components/image/src/image.mjs");
var _indexMjs34 = require("./components/image/index.mjs");
var _imageViewerMjs = require("./components/image-viewer/src/image-viewer.mjs");
var _indexMjs35 = require("./components/image-viewer/index.mjs");
var _inputMjs = require("./components/input/src/input.mjs");
var _indexMjs36 = require("./components/input/index.mjs");
var _inputNumberMjs = require("./components/input-number/src/input-number.mjs");
var _indexMjs37 = require("./components/input-number/index.mjs");
var _linkMjs = require("./components/link/src/link.mjs");
var _indexMjs38 = require("./components/link/index.mjs");
var _menuMjs = require("./components/menu/src/menu.mjs");
var _menuItemMjs = require("./components/menu/src/menu-item.mjs");
var _menuItemGroupMjs = require("./components/menu/src/menu-item-group.mjs");
var _subMenuMjs = require("./components/menu/src/sub-menu.mjs");
var _indexMjs39 = require("./components/menu/index.mjs");
var _overlayMjs = require("./components/overlay/src/overlay.mjs");
var _indexMjs40 = require("./components/overlay/index.mjs");
var _pageHeaderMjs = require("./components/page-header/src/page-header.mjs");
var _indexMjs41 = require("./components/page-header/index.mjs");
var _paginationMjs = require("./components/pagination/src/pagination.mjs");
var _indexMjs42 = require("./components/pagination/index.mjs");
var _popconfirmMjs = require("./components/popconfirm/src/popconfirm.mjs");
var _indexMjs43 = require("./components/popconfirm/index.mjs");
var _arrowMjs = require("./components/popper/src/arrow.mjs");
var _arrowMjsDefault = parcelHelpers.interopDefault(_arrowMjs);
var _triggerMjs = require("./components/popper/src/trigger.mjs");
var _triggerMjsDefault = parcelHelpers.interopDefault(_triggerMjs);
var _contentMjs = require("./components/popper/src/content.mjs");
var _contentMjsDefault = parcelHelpers.interopDefault(_contentMjs);
var _deprecationMjs = require("./components/popper/src/deprecation.mjs");
var _popperMjs = require("./components/popper/src/popper.mjs");
var _tokensMjs1 = require("./components/popper/src/tokens.mjs");
var _indexMjs44 = require("./components/popper/index.mjs");
var _progressMjs = require("./components/progress/src/progress.mjs");
var _indexMjs45 = require("./components/progress/index.mjs");
var _radioMjs = require("./components/radio/src/radio.mjs");
var _radioGroupMjs = require("./components/radio/src/radio-group.mjs");
var _radioButtonMjs = require("./components/radio/src/radio-button.mjs");
var _indexMjs46 = require("./components/radio/index.mjs");
var _rateMjs = require("./components/rate/src/rate.mjs");
var _indexMjs47 = require("./components/rate/index.mjs");
var _resultMjs = require("./components/result/src/result.mjs");
var _indexMjs48 = require("./components/result/index.mjs");
var _rowMjs = require("./components/row/src/row.mjs");
var _indexMjs49 = require("./components/row/index.mjs");
var _utilMjs = require("./components/scrollbar/src/util.mjs");
var _scrollbarMjs = require("./components/scrollbar/src/scrollbar.mjs");
var _thumbMjs = require("./components/scrollbar/src/thumb.mjs");
var _indexMjs50 = require("./components/scrollbar/index.mjs");
var _tokenMjs = require("./components/select/src/token.mjs");
var _indexMjs51 = require("./components/select/index.mjs");
var _tokenMjs1 = require("./components/select-v2/src/token.mjs");
var _indexMjs52 = require("./components/select-v2/index.mjs");
var _skeletonMjs = require("./components/skeleton/src/skeleton.mjs");
var _skeletonItemMjs = require("./components/skeleton/src/skeleton-item.mjs");
var _indexMjs53 = require("./components/skeleton/index.mjs");
var _indexMjs54 = require("./components/slider/index.mjs");
var _spaceMjs = require("./components/space/src/space.mjs");
var _useSpaceMjs = require("./components/space/src/use-space.mjs");
var _indexMjs55 = require("./components/space/index.mjs");
var _indexMjs56 = require("./components/steps/index.mjs");
var _switchMjs = require("./components/switch/src/switch.mjs");
var _indexMjs57 = require("./components/switch/index.mjs");
var _indexMjs58 = require("./components/table/index.mjs");
var _tabsMjs = require("./components/tabs/src/tabs.mjs");
var _tabBarMjs = require("./components/tabs/src/tab-bar.mjs");
var _tabNavMjs = require("./components/tabs/src/tab-nav.mjs");
var _tabPaneMjs = require("./components/tabs/src/tab-pane.mjs");
var _indexMjs59 = require("./components/tabs/index.mjs");
var _tagMjs = require("./components/tag/src/tag.mjs");
var _indexMjs60 = require("./components/tag/index.mjs");
var _dateUtilsMjs = require("./components/time-picker/src/common/date-utils.mjs");
var _constantMjs = require("./components/time-picker/src/common/constant.mjs");
var _propsMjs = require("./components/time-picker/src/common/props.mjs");
var _pickerMjs = require("./components/time-picker/src/common/picker.mjs");
var _pickerMjsDefault = parcelHelpers.interopDefault(_pickerMjs);
var _panelTimePickMjs = require("./components/time-picker/src/time-picker-com/panel-time-pick.mjs");
var _panelTimePickMjsDefault = parcelHelpers.interopDefault(_panelTimePickMjs);
var _indexMjs61 = require("./components/time-picker/index.mjs");
var _indexMjs62 = require("./components/time-select/index.mjs");
var _timelineItemMjs = require("./components/timeline/src/timeline-item.mjs");
var _indexMjs63 = require("./components/timeline/index.mjs");
var _tooltipMjs = require("./components/tooltip/src/tooltip.mjs");
var _tokensMjs2 = require("./components/tooltip/src/tokens.mjs");
var _indexMjs64 = require("./components/tooltip/index.mjs");
var _eventMjs = require("./constants/event.mjs");
var _indexMjs65 = require("./components/transfer/index.mjs");
var _indexMjs66 = require("./components/tree/index.mjs");
var _indexMjs67 = require("./components/tree-v2/index.mjs");
var _indexMjs68 = require("./components/upload/index.mjs");
var _fixedSizeListMjs = require("./components/virtual-list/src/components/fixed-size-list.mjs");
var _fixedSizeListMjsDefault = parcelHelpers.interopDefault(_fixedSizeListMjs);
var _dynamicSizeListMjs = require("./components/virtual-list/src/components/dynamic-size-list.mjs");
var _dynamicSizeListMjsDefault = parcelHelpers.interopDefault(_dynamicSizeListMjs);
var _fixedSizeGridMjs = require("./components/virtual-list/src/components/fixed-size-grid.mjs");
var _fixedSizeGridMjsDefault = parcelHelpers.interopDefault(_fixedSizeGridMjs);
var _dynamicSizeGridMjs = require("./components/virtual-list/src/components/dynamic-size-grid.mjs");
var _dynamicSizeGridMjsDefault = parcelHelpers.interopDefault(_dynamicSizeGridMjs);
var _propsMjs1 = require("./components/virtual-list/src/props.mjs");
var _indexMjs69 = require("./components/infinite-scroll/index.mjs");
var _indexMjs70 = require("./components/loading/index.mjs");
var _messageMjs = require("./components/message/src/message.mjs");
var _indexMjs71 = require("./components/message/index.mjs");
var _indexMjs72 = require("./components/message-box/index.mjs");
var _notificationMjs = require("./components/notification/src/notification.mjs");
var _indexMjs73 = require("./components/notification/index.mjs");
var _indexMjs74 = require("./components/popover/index.mjs");
var _indexMjs75 = require("./directives/click-outside/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs75);
var _indexMjs76 = require("./directives/repeat-click/index.mjs");
var _indexMjsDefault1 = parcelHelpers.interopDefault(_indexMjs76);
var _indexMjs77 = require("./directives/trap-focus/index.mjs");
var _indexMjsDefault2 = parcelHelpers.interopDefault(_indexMjs77);
var _indexMjs78 = require("./directives/mousewheel/index.mjs");
var _indexMjsDefault3 = parcelHelpers.interopDefault(_indexMjs78);
var _indexMjs79 = require("./directives/resize/index.mjs");
var _indexMjsDefault4 = parcelHelpers.interopDefault(_indexMjs79);
var _indexMjs80 = require("./hooks/use-attrs/index.mjs");
var _indexMjs81 = require("./hooks/use-common-props/index.mjs");
var _indexMjs82 = require("./hooks/use-deprecated/index.mjs");
var _indexMjs83 = require("./hooks/use-draggable/index.mjs");
var _indexMjs84 = require("./hooks/use-focus/index.mjs");
var _indexMjs85 = require("./hooks/use-form-item/index.mjs");
var _indexMjs86 = require("./hooks/use-global-config/index.mjs");
var _indexMjs87 = require("./hooks/use-locale/index.mjs");
var _indexMjs88 = require("./hooks/use-lockscreen/index.mjs");
var _indexMjs89 = require("./hooks/use-modal/index.mjs");
var _indexMjs90 = require("./hooks/use-model-toggle/index.mjs");
var _indexMjs91 = require("./hooks/use-prevent-global/index.mjs");
var _indexMjs92 = require("./hooks/use-prop/index.mjs");
var _indexMjs93 = require("./hooks/use-restore-active/index.mjs");
var _indexMjs94 = require("./hooks/use-same-target/index.mjs");
var _indexMjs95 = require("./hooks/use-teleport/index.mjs");
var _indexMjs96 = require("./hooks/use-throttle-render/index.mjs");
var _indexMjs97 = require("./hooks/use-timeout/index.mjs");
var _indexMjs98 = require("./hooks/use-transition-fallthrough/index.mjs");
var _indexMjs99 = require("./hooks/use-id/index.mjs");
var _indexMjs100 = require("./hooks/use-escape-keydown/index.mjs");
var _indexMjs101 = require("./hooks/use-popper-container/index.mjs");
var _indexMjs102 = require("./hooks/use-intermediate-render/index.mjs");
var _indexMjs103 = require("./hooks/use-delayed-toggle/index.mjs");
var _indexMjs104 = require("./hooks/use-forward-ref/index.mjs");
var _indexMjs105 = require("./hooks/use-namespace/index.mjs");
var _indexMjs106 = require("./hooks/use-z-index/index.mjs");
var _formMjs = require("./tokens/form.mjs");
var _buttonMjs1 = require("./tokens/button.mjs");
var _breadcrumbMjs1 = require("./tokens/breadcrumb.mjs");
var _paginationMjs1 = require("./tokens/pagination.mjs");
var _configProviderMjs1 = require("./tokens/config-provider.mjs");
var _radioMjs1 = require("./tokens/radio.mjs");
var _tabsMjs1 = require("./tokens/tabs.mjs");
var _scrollbarMjs1 = require("./tokens/scrollbar.mjs");
const install = _defaultsMjsDefault.default.install;
const version = _defaultsMjsDefault.default.version;

},{"./defaults.mjs":"gTUP8","./components/index.mjs":"d9xVn","./directives/index.mjs":"aRbJ2","./hooks/index.mjs":"1Ansp","./tokens/index.mjs":"wVNQi","./make-installer.mjs":"jRkIS","./components/affix/src/affix.mjs":"31RpQ","./components/affix/index.mjs":"fMcKf","./components/alert/src/alert.mjs":"bmmdq","./components/alert/index.mjs":"jX4vK","./components/autocomplete/index.mjs":"lnNbL","./components/avatar/src/avatar.mjs":"aSZOT","./components/avatar/index.mjs":"edhpQ","./components/backtop/src/backtop.mjs":"9ygQ4","./components/backtop/index.mjs":"iA9M1","./components/badge/src/badge.mjs":"4pSua","./components/badge/index.mjs":"gvyeW","./components/breadcrumb/src/breadcrumb.mjs":"iV9UH","./components/breadcrumb/src/breadcrumb-item.mjs":"5U0qo","./components/breadcrumb/index.mjs":"6p9GR","./components/button/src/button.mjs":"8GILO","./components/button/index.mjs":"64Ym1","./components/calendar/src/calendar.mjs":"4X2do","./components/calendar/index.mjs":"iyUgV","./components/card/src/card.mjs":"a9FEd","./components/card/index.mjs":"ftRFC","./components/carousel/index.mjs":"DjiER","./components/cascader/index.mjs":"hgxNT","./components/cascader-panel/src/types.mjs":"5MNj5","./components/cascader-panel/src/config.mjs":"8uFuI","./components/cascader-panel/index.mjs":"cvCE6","./components/check-tag/src/check-tag.mjs":"fL3TX","./components/check-tag/index.mjs":"2yvIi","./components/checkbox/index.mjs":"jMNjD","./components/col/src/col.mjs":"hxnIP","./components/col/index.mjs":"iutZ4","./components/collapse/index.mjs":"2aUAi","./components/collapse-transition/index.mjs":"kOsra","./components/color-picker/index.mjs":"kWiGH","./components/config-provider/src/config-provider.mjs":"jXq22","./components/config-provider/index.mjs":"5LcSW","./components/container/index.mjs":"7nKg2","./components/date-picker/index.mjs":"fdWz7","./components/descriptions/index.mjs":"aXmMH","./components/dialog/src/use-dialog.mjs":"kcxXl","./components/dialog/src/dialog.mjs":"imlUB","./components/dialog/index.mjs":"iXu3z","./components/divider/src/divider.mjs":"X6LID","./components/divider/index.mjs":"8bcJq","./components/drawer/src/drawer.mjs":"6GsxM","./components/drawer/index.mjs":"DJoCd","./components/dropdown/src/dropdown.mjs":"7C9Hj","./components/dropdown/src/tokens.mjs":"ghjhG","./components/dropdown/index.mjs":"dk8yW","./components/empty/src/empty.mjs":"6dOm6","./components/empty/index.mjs":"5bPkj","./components/form/index.mjs":"hQT2m","./components/icon/src/icon.mjs":"buNkD","./components/icon/index.mjs":"hnNTG","./components/image/src/image.mjs":"hhtmC","./components/image/index.mjs":"hFVHx","./components/image-viewer/src/image-viewer.mjs":"kIWgu","./components/image-viewer/index.mjs":"39t5l","./components/input/src/input.mjs":"8Zju5","./components/input/index.mjs":"18eQI","./components/input-number/src/input-number.mjs":"hcBfX","./components/input-number/index.mjs":"1U2Gu","./components/link/src/link.mjs":"cyxqy","./components/link/index.mjs":"18DrN","./components/menu/src/menu.mjs":"5fjO6","./components/menu/src/menu-item.mjs":"5FnwZ","./components/menu/src/menu-item-group.mjs":"foLPD","./components/menu/src/sub-menu.mjs":"d2lRI","./components/menu/index.mjs":"5wfdz","./components/overlay/src/overlay.mjs":"fWAgM","./components/overlay/index.mjs":"2HJvE","./components/page-header/src/page-header.mjs":"wnNZL","./components/page-header/index.mjs":"cmyvF","./components/pagination/src/pagination.mjs":"3DWdA","./components/pagination/index.mjs":"ep8iT","./components/popconfirm/src/popconfirm.mjs":"PeZMy","./components/popconfirm/index.mjs":"ds8jY","./components/popper/src/arrow.mjs":"fjUPr","./components/popper/src/trigger.mjs":"3POmC","./components/popper/src/content.mjs":"lN2o5","./components/popper/src/deprecation.mjs":"jm0Kb","./components/popper/src/popper.mjs":"lCFux","./components/popper/src/tokens.mjs":"cbHZm","./components/popper/index.mjs":"kIV7g","./components/progress/src/progress.mjs":"iea9L","./components/progress/index.mjs":"9ijV7","./components/radio/src/radio.mjs":"gDfxw","./components/radio/src/radio-group.mjs":"ifp6r","./components/radio/src/radio-button.mjs":"eTDbS","./components/radio/index.mjs":"fekfn","./components/rate/src/rate.mjs":"eT6Re","./components/rate/index.mjs":"8o4Y1","./components/result/src/result.mjs":"lxN2C","./components/result/index.mjs":"lHyTs","./components/row/src/row.mjs":"f4k9l","./components/row/index.mjs":"7Vl2s","./components/scrollbar/src/util.mjs":"eBQCF","./components/scrollbar/src/scrollbar.mjs":"123QS","./components/scrollbar/src/thumb.mjs":"gZPgI","./components/scrollbar/index.mjs":"kXLHt","./components/select/src/token.mjs":"cOSZy","./components/select/index.mjs":"llDRW","./components/select-v2/src/token.mjs":"lk8V6","./components/select-v2/index.mjs":"lUvDZ","./components/skeleton/src/skeleton.mjs":"9BfJP","./components/skeleton/src/skeleton-item.mjs":"3Kx1r","./components/skeleton/index.mjs":"2N5x8","./components/slider/index.mjs":"6YyBo","./components/space/src/space.mjs":"5tyjs","./components/space/src/use-space.mjs":"gYCpP","./components/space/index.mjs":"fdm11","./components/steps/index.mjs":"9fit0","./components/switch/src/switch.mjs":"77sPp","./components/switch/index.mjs":"aErYv","./components/table/index.mjs":"imp1h","./components/tabs/src/tabs.mjs":"e8i7v","./components/tabs/src/tab-bar.mjs":"dhrbU","./components/tabs/src/tab-nav.mjs":"6DFds","./components/tabs/src/tab-pane.mjs":"hD9Q9","./components/tabs/index.mjs":"3MxUG","./components/tag/src/tag.mjs":"i4Ov7","./components/tag/index.mjs":"96fQG","./components/time-picker/src/common/date-utils.mjs":"3CJdm","./components/time-picker/src/common/constant.mjs":"b75g0","./components/time-picker/src/common/props.mjs":"gx1qH","./components/time-picker/src/common/picker.mjs":"3jAyz","./components/time-picker/src/time-picker-com/panel-time-pick.mjs":"351Kw","./components/time-picker/index.mjs":"4TaeO","./components/time-select/index.mjs":"k6X13","./components/timeline/src/timeline-item.mjs":"6SEpi","./components/timeline/index.mjs":"2CPF0","./components/tooltip/src/tooltip.mjs":"7LVFi","./components/tooltip/src/tokens.mjs":"a6G79","./components/tooltip/index.mjs":"kiwBC","./constants/event.mjs":"92xVn","./components/transfer/index.mjs":"baYrE","./components/tree/index.mjs":"bpXS0","./components/tree-v2/index.mjs":"eqslC","./components/upload/index.mjs":"fvmYn","./components/virtual-list/src/components/fixed-size-list.mjs":"eaMZD","./components/virtual-list/src/components/dynamic-size-list.mjs":"ggHfi","./components/virtual-list/src/components/fixed-size-grid.mjs":"fyL0k","./components/virtual-list/src/components/dynamic-size-grid.mjs":"9Fq2m","./components/virtual-list/src/props.mjs":"2CLE6","./components/infinite-scroll/index.mjs":"fffis","./components/loading/index.mjs":"9QQSv","./components/message/src/message.mjs":"exwnb","./components/message/index.mjs":"hqiSY","./components/message-box/index.mjs":"lPFAH","./components/notification/src/notification.mjs":"9l71J","./components/notification/index.mjs":"a0vte","./components/popover/index.mjs":"cnet0","./directives/click-outside/index.mjs":"cdlLW","./directives/repeat-click/index.mjs":"3krgJ","./directives/trap-focus/index.mjs":"lw3sX","./directives/mousewheel/index.mjs":"5NhJf","./directives/resize/index.mjs":"dLlY9","./hooks/use-attrs/index.mjs":"3W2Zt","./hooks/use-common-props/index.mjs":"05czU","./hooks/use-deprecated/index.mjs":"4fitg","./hooks/use-draggable/index.mjs":"3SWUw","./hooks/use-focus/index.mjs":"8V0bg","./hooks/use-form-item/index.mjs":"jSs21","./hooks/use-global-config/index.mjs":"jLlCF","./hooks/use-locale/index.mjs":"c1HoA","./hooks/use-lockscreen/index.mjs":"f9Ur8","./hooks/use-modal/index.mjs":"klFTZ","./hooks/use-model-toggle/index.mjs":"97z8S","./hooks/use-prevent-global/index.mjs":"3Sy0W","./hooks/use-prop/index.mjs":"2C7KS","./hooks/use-restore-active/index.mjs":"9OlL1","./hooks/use-same-target/index.mjs":"duu8u","./hooks/use-teleport/index.mjs":"fVzv0","./hooks/use-throttle-render/index.mjs":"azm2F","./hooks/use-timeout/index.mjs":"61vlm","./hooks/use-transition-fallthrough/index.mjs":"fyWbH","./hooks/use-id/index.mjs":"jWUTV","./hooks/use-escape-keydown/index.mjs":"5NOQk","./hooks/use-popper-container/index.mjs":"hz53M","./hooks/use-intermediate-render/index.mjs":"lDx6c","./hooks/use-delayed-toggle/index.mjs":"jbu1G","./hooks/use-forward-ref/index.mjs":"eMx3i","./hooks/use-namespace/index.mjs":"a1pcf","./hooks/use-z-index/index.mjs":"7aKZA","./tokens/form.mjs":"2r4O0","./tokens/button.mjs":"guqr8","./tokens/breadcrumb.mjs":"5AKMw","./tokens/pagination.mjs":"9NXrn","./tokens/config-provider.mjs":"ko1P7","./tokens/radio.mjs":"3tXVv","./tokens/tabs.mjs":"kNnQs","./tokens/scrollbar.mjs":"1zNPP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gTUP8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>installer
);
var _makeInstallerMjs = require("./make-installer.mjs");
var _componentMjs = require("./component.mjs");
var _componentMjsDefault = parcelHelpers.interopDefault(_componentMjs);
var _pluginMjs = require("./plugin.mjs");
var _pluginMjsDefault = parcelHelpers.interopDefault(_pluginMjs);
var installer = _makeInstallerMjs.makeInstaller([
    ..._componentMjsDefault.default,
    ..._pluginMjsDefault.default
]);

},{"./make-installer.mjs":"jRkIS","./component.mjs":"eTopt","./plugin.mjs":"j9kKF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jRkIS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeInstaller", ()=>makeInstaller
);
var _indexMjs = require("./hooks/index.mjs");
var _versionMjs = require("./version.mjs");
var _indexMjs1 = require("./hooks/use-global-config/index.mjs");
const INSTALLED_KEY = Symbol("INSTALLED_KEY");
const makeInstaller = (components = [])=>{
    const install = (app, options = {
    })=>{
        if (app[INSTALLED_KEY]) return;
        app[INSTALLED_KEY] = true;
        components.forEach((c)=>app.use(c)
        );
        _indexMjs1.provideGlobalConfig(options, app, true);
    };
    return {
        version: _versionMjs.version,
        install
    };
};

},{"./hooks/index.mjs":"1Ansp","./version.mjs":"3V5nN","./hooks/use-global-config/index.mjs":"jLlCF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Ansp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useAttrs", ()=>_indexMjs.useAttrs
);
parcelHelpers.export(exports, "useDisabled", ()=>_indexMjs1.useDisabled
);
parcelHelpers.export(exports, "useSize", ()=>_indexMjs1.useSize
);
parcelHelpers.export(exports, "useSizeProp", ()=>_indexMjs1.useSizeProp
);
parcelHelpers.export(exports, "useDeprecated", ()=>_indexMjs2.useDeprecated
);
parcelHelpers.export(exports, "useDraggable", ()=>_indexMjs3.useDraggable
);
parcelHelpers.export(exports, "useFocus", ()=>_indexMjs4.useFocus
);
parcelHelpers.export(exports, "useFormItem", ()=>_indexMjs5.useFormItem
);
parcelHelpers.export(exports, "provideGlobalConfig", ()=>_indexMjs6.provideGlobalConfig
);
parcelHelpers.export(exports, "useGlobalConfig", ()=>_indexMjs6.useGlobalConfig
);
parcelHelpers.export(exports, "buildLocaleContext", ()=>_indexMjs7.buildLocaleContext
);
parcelHelpers.export(exports, "buildTranslator", ()=>_indexMjs7.buildTranslator
);
parcelHelpers.export(exports, "translate", ()=>_indexMjs7.translate
);
parcelHelpers.export(exports, "useLocale", ()=>_indexMjs7.useLocale
);
parcelHelpers.export(exports, "useLockscreen", ()=>_indexMjs8.useLockscreen
);
parcelHelpers.export(exports, "useModal", ()=>_indexMjs9.useModal
);
parcelHelpers.export(exports, "createModelToggleComposable", ()=>_indexMjs10.createModelToggleComposable
);
parcelHelpers.export(exports, "useModelToggle", ()=>_indexMjs10.useModelToggle
);
parcelHelpers.export(exports, "useModelToggleEmits", ()=>_indexMjs10.useModelToggleEmits
);
parcelHelpers.export(exports, "useModelToggleProps", ()=>_indexMjs10.useModelToggleProps
);
parcelHelpers.export(exports, "usePreventGlobal", ()=>_indexMjs11.usePreventGlobal
);
parcelHelpers.export(exports, "useProp", ()=>_indexMjs12.useProp
);
parcelHelpers.export(exports, "useRestoreActive", ()=>_indexMjs13.useRestoreActive
);
parcelHelpers.export(exports, "useSameTarget", ()=>_indexMjs14.useSameTarget
);
parcelHelpers.export(exports, "useTeleport", ()=>_indexMjs15.useTeleport
);
parcelHelpers.export(exports, "useThrottleRender", ()=>_indexMjs16.useThrottleRender
);
parcelHelpers.export(exports, "useTimeout", ()=>_indexMjs17.useTimeout
);
parcelHelpers.export(exports, "useTransitionFallthrough", ()=>_indexMjs18.useTransitionFallthrough
);
parcelHelpers.export(exports, "useTransitionFallthroughEmits", ()=>_indexMjs18.useTransitionFallthroughEmits
);
parcelHelpers.export(exports, "ID_INJECTION_KEY", ()=>_indexMjs19.ID_INJECTION_KEY
);
parcelHelpers.export(exports, "useId", ()=>_indexMjs19.useId
);
parcelHelpers.export(exports, "useEscapeKeydown", ()=>_indexMjs20.useEscapeKeydown
);
parcelHelpers.export(exports, "POPPER_CONTAINER_ID", ()=>_indexMjs21.POPPER_CONTAINER_ID
);
parcelHelpers.export(exports, "POPPER_CONTAINER_SELECTOR", ()=>_indexMjs21.POPPER_CONTAINER_SELECTOR
);
parcelHelpers.export(exports, "usePopperContainer", ()=>_indexMjs21.usePopperContainer
);
parcelHelpers.export(exports, "useDelayedRender", ()=>_indexMjs22.useDelayedRender
);
parcelHelpers.export(exports, "useDelayedToggle", ()=>_indexMjs23.useDelayedToggle
);
parcelHelpers.export(exports, "useDelayedToggleProps", ()=>_indexMjs23.useDelayedToggleProps
);
parcelHelpers.export(exports, "FORWARD_REF_INJECTION_KEY", ()=>_indexMjs24.FORWARD_REF_INJECTION_KEY
);
parcelHelpers.export(exports, "useForwardRef", ()=>_indexMjs24.useForwardRef
);
parcelHelpers.export(exports, "useForwardRefDirective", ()=>_indexMjs24.useForwardRefDirective
);
parcelHelpers.export(exports, "useNamespace", ()=>_indexMjs25.useNamespace
);
parcelHelpers.export(exports, "useZIndex", ()=>_indexMjs26.useZIndex
);
var _indexMjs = require("./use-attrs/index.mjs");
var _indexMjs1 = require("./use-common-props/index.mjs");
var _indexMjs2 = require("./use-deprecated/index.mjs");
var _indexMjs3 = require("./use-draggable/index.mjs");
var _indexMjs4 = require("./use-focus/index.mjs");
var _indexMjs5 = require("./use-form-item/index.mjs");
var _indexMjs6 = require("./use-global-config/index.mjs");
var _indexMjs7 = require("./use-locale/index.mjs");
var _indexMjs8 = require("./use-lockscreen/index.mjs");
var _indexMjs9 = require("./use-modal/index.mjs");
var _indexMjs10 = require("./use-model-toggle/index.mjs");
var _indexMjs11 = require("./use-prevent-global/index.mjs");
var _indexMjs12 = require("./use-prop/index.mjs");
var _indexMjs13 = require("./use-restore-active/index.mjs");
var _indexMjs14 = require("./use-same-target/index.mjs");
var _indexMjs15 = require("./use-teleport/index.mjs");
var _indexMjs16 = require("./use-throttle-render/index.mjs");
var _indexMjs17 = require("./use-timeout/index.mjs");
var _indexMjs18 = require("./use-transition-fallthrough/index.mjs");
var _indexMjs19 = require("./use-id/index.mjs");
var _indexMjs20 = require("./use-escape-keydown/index.mjs");
var _indexMjs21 = require("./use-popper-container/index.mjs");
var _indexMjs22 = require("./use-intermediate-render/index.mjs");
var _indexMjs23 = require("./use-delayed-toggle/index.mjs");
var _indexMjs24 = require("./use-forward-ref/index.mjs");
var _indexMjs25 = require("./use-namespace/index.mjs");
var _indexMjs26 = require("./use-z-index/index.mjs");

},{"./use-attrs/index.mjs":"3W2Zt","./use-common-props/index.mjs":"05czU","./use-deprecated/index.mjs":"4fitg","./use-draggable/index.mjs":"3SWUw","./use-focus/index.mjs":"8V0bg","./use-form-item/index.mjs":"jSs21","./use-global-config/index.mjs":"jLlCF","./use-locale/index.mjs":"c1HoA","./use-lockscreen/index.mjs":"f9Ur8","./use-modal/index.mjs":"klFTZ","./use-model-toggle/index.mjs":"97z8S","./use-prevent-global/index.mjs":"3Sy0W","./use-prop/index.mjs":"2C7KS","./use-restore-active/index.mjs":"9OlL1","./use-same-target/index.mjs":"duu8u","./use-teleport/index.mjs":"fVzv0","./use-throttle-render/index.mjs":"azm2F","./use-timeout/index.mjs":"61vlm","./use-transition-fallthrough/index.mjs":"fyWbH","./use-id/index.mjs":"jWUTV","./use-escape-keydown/index.mjs":"5NOQk","./use-popper-container/index.mjs":"hz53M","./use-intermediate-render/index.mjs":"lDx6c","./use-delayed-toggle/index.mjs":"jbu1G","./use-forward-ref/index.mjs":"eMx3i","./use-namespace/index.mjs":"a1pcf","./use-z-index/index.mjs":"7aKZA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3W2Zt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useAttrs", ()=>useAttrs
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../utils/index.mjs");
var _errorMjs = require("../../utils/error.mjs");
const DEFAULT_EXCLUDE_KEYS = [
    "class",
    "style"
];
const LISTENER_PREFIX = /^on[A-Z]/;
const useAttrs = (params = {
})=>{
    const { excludeListeners =false , excludeKeys =[]  } = params;
    const allExcludeKeys = excludeKeys.concat(DEFAULT_EXCLUDE_KEYS);
    const instance = _vue.getCurrentInstance();
    if (!instance) {
        _errorMjs.debugWarn("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function");
        return _vue.computed(()=>({
            })
        );
    }
    return _vue.computed(()=>{
        var _a;
        return _lodashUnified.fromPairs(Object.entries((_a = instance.proxy) == null ? void 0 : _a.$attrs).filter(([key])=>!allExcludeKeys.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))
        ));
    });
};

},{"vue":"gzxs9","lodash-unified":"4Oj4p","../../utils/index.mjs":"dsdeP","../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Oj4p":[function(require,module,exports) {
module.exports = require('lodash');

},{"lodash":"3qBDj"}],"3qBDj":[function(require,module,exports) {
var global = arguments[3];
(function() {
    /** Used as a safe reference for `undefined` in pre-ES5 environments. */ var undefined;
    /** Used as the semantic version number. */ var VERSION = '4.17.21';
    /** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
    /** Error message constants. */ var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.', FUNC_ERROR_TEXT = 'Expected a function', INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';
    /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
    /** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;
    /** Used as the internal argument placeholder. */ var PLACEHOLDER = '__lodash_placeholder__';
    /** Used to compose bitmasks for cloning. */ var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    /** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    /** Used to compose bitmasks for function metadata. */ var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    /** Used as default options for `_.truncate`. */ var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';
    /** Used to detect hot functions by number of calls within a span of milliseconds. */ var HOT_COUNT = 800, HOT_SPAN = 16;
    /** Used to indicate the type of lazy iteratees. */ var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    /** Used as references for various `Number` constants. */ var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, NAN = 0 / 0;
    /** Used as references for the maximum length and index of an array. */ var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    /** Used to associate wrap methods with their bit flags. */ var wrapFlags = [
        [
            'ary',
            WRAP_ARY_FLAG
        ],
        [
            'bind',
            WRAP_BIND_FLAG
        ],
        [
            'bindKey',
            WRAP_BIND_KEY_FLAG
        ],
        [
            'curry',
            WRAP_CURRY_FLAG
        ],
        [
            'curryRight',
            WRAP_CURRY_RIGHT_FLAG
        ],
        [
            'flip',
            WRAP_FLIP_FLAG
        ],
        [
            'partial',
            WRAP_PARTIAL_FLAG
        ],
        [
            'partialRight',
            WRAP_PARTIAL_RIGHT_FLAG
        ],
        [
            'rearg',
            WRAP_REARG_FLAG
        ]
    ];
    /** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', asyncTag = '[object AsyncFunction]', boolTag = '[object Boolean]', dateTag = '[object Date]', domExcTag = '[object DOMException]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', nullTag = '[object Null]', objectTag = '[object Object]', promiseTag = '[object Promise]', proxyTag = '[object Proxy]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', undefinedTag = '[object Undefined]', weakMapTag = '[object WeakMap]', weakSetTag = '[object WeakSet]';
    var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
    /** Used to match empty string literals in compiled template source. */ var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    /** Used to match HTML entities and HTML characters. */ var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    /** Used to match template delimiters. */ var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    /** Used to match property names within property paths. */ var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    /** Used to match leading whitespace. */ var reTrimStart = /^\s+/;
    /** Used to match a single whitespace character. */ var reWhitespace = /\s/;
    /** Used to match wrap detail comments. */ var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    /** Used to match words composed of alphanumeric characters. */ var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */ var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    /** Used to match backslashes in property paths. */ var reEscapeChar = /\\(\\)?/g;
    /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */ var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    /** Used to match `RegExp` flags from their coerced string values. */ var reFlags = /\w*$/;
    /** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    /** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
    /** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
    /** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
    /** Used to match Latin Unicode letters (excluding mathematical operators). */ var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    /** Used to ensure capturing order of template delimiters. */ var reNoMatch = /($^)/;
    /** Used to match unescaped characters in compiled string literals. */ var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    /** Used to compose unicode character classes. */ var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f', reComboHalfMarksRange = '\\ufe20-\\ufe2f', rsComboSymbolsRange = '\\u20d0-\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = '\\u2700-\\u27bf', rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff', rsMathOpRange = '\\xac\\xb1\\xd7\\xf7', rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf', rsPunctuationRange = '\\u2000-\\u206f', rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000', rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde', rsVarRange = '\\ufe0e\\ufe0f', rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    /** Used to compose unicode capture groups. */ var rsApos = "['\u2019]", rsAstral = '[' + rsAstralRange + ']', rsBreak = '[' + rsBreakRange + ']', rsCombo = '[' + rsComboRange + ']', rsDigits = '\\d+', rsDingbat = '[' + rsDingbatRange + ']', rsLower = '[' + rsLowerRange + ']', rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsUpper = '[' + rsUpperRange + ']', rsZWJ = '\\u200d';
    /** Used to compose unicode regexes. */ var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')', rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')', rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?', rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?', reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [
        rsNonAstral,
        rsRegional,
        rsSurrPair
    ].join('|') + ')' + rsOptVar + reOptMod + ')*', rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])', rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = '(?:' + [
        rsDingbat,
        rsRegional,
        rsSurrPair
    ].join('|') + ')' + rsSeq, rsSymbol = '(?:' + [
        rsNonAstral + rsCombo + '?',
        rsCombo,
        rsRegional,
        rsSurrPair,
        rsAstral
    ].join('|') + ')';
    /** Used to match apostrophes. */ var reApos = RegExp(rsApos, 'g');
    /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */ var reComboMark = RegExp(rsCombo, 'g');
    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */ var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
    /** Used to match complex or compound words. */ var reUnicodeWord = RegExp([
        rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [
            rsBreak,
            rsUpper,
            '$'
        ].join('|') + ')',
        rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [
            rsBreak,
            rsUpper + rsMiscLower,
            '$'
        ].join('|') + ')',
        rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
        rsUpper + '+' + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
    ].join('|'), 'g');
    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */ var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
    /** Used to detect strings that need a more robust regexp to match words. */ var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    /** Used to assign default `context` object properties. */ var contextProps = [
        'Array',
        'Buffer',
        'DataView',
        'Date',
        'Error',
        'Float32Array',
        'Float64Array',
        'Function',
        'Int8Array',
        'Int16Array',
        'Int32Array',
        'Map',
        'Math',
        'Object',
        'Promise',
        'RegExp',
        'Set',
        'String',
        'Symbol',
        'TypeError',
        'Uint8Array',
        'Uint8ClampedArray',
        'Uint16Array',
        'Uint32Array',
        'WeakMap',
        '_',
        'clearTimeout',
        'isFinite',
        'parseInt',
        'setTimeout'
    ];
    /** Used to make template sourceURLs easier to identify. */ var templateCounter = -1;
    /** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {
    };
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /** Used to identify `toStringTag` values supported by `_.clone`. */ var cloneableTags = {
    };
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    /** Used to map Latin Unicode letters to basic Latin letters. */ var deburredLetters = {
        // Latin-1 Supplement block.
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcc': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xec': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss',
        // Latin Extended-A block.
        '\u0100': 'A',
        '\u0102': 'A',
        '\u0104': 'A',
        '\u0101': 'a',
        '\u0103': 'a',
        '\u0105': 'a',
        '\u0106': 'C',
        '\u0108': 'C',
        '\u010a': 'C',
        '\u010c': 'C',
        '\u0107': 'c',
        '\u0109': 'c',
        '\u010b': 'c',
        '\u010d': 'c',
        '\u010e': 'D',
        '\u0110': 'D',
        '\u010f': 'd',
        '\u0111': 'd',
        '\u0112': 'E',
        '\u0114': 'E',
        '\u0116': 'E',
        '\u0118': 'E',
        '\u011a': 'E',
        '\u0113': 'e',
        '\u0115': 'e',
        '\u0117': 'e',
        '\u0119': 'e',
        '\u011b': 'e',
        '\u011c': 'G',
        '\u011e': 'G',
        '\u0120': 'G',
        '\u0122': 'G',
        '\u011d': 'g',
        '\u011f': 'g',
        '\u0121': 'g',
        '\u0123': 'g',
        '\u0124': 'H',
        '\u0126': 'H',
        '\u0125': 'h',
        '\u0127': 'h',
        '\u0128': 'I',
        '\u012a': 'I',
        '\u012c': 'I',
        '\u012e': 'I',
        '\u0130': 'I',
        '\u0129': 'i',
        '\u012b': 'i',
        '\u012d': 'i',
        '\u012f': 'i',
        '\u0131': 'i',
        '\u0134': 'J',
        '\u0135': 'j',
        '\u0136': 'K',
        '\u0137': 'k',
        '\u0138': 'k',
        '\u0139': 'L',
        '\u013b': 'L',
        '\u013d': 'L',
        '\u013f': 'L',
        '\u0141': 'L',
        '\u013a': 'l',
        '\u013c': 'l',
        '\u013e': 'l',
        '\u0140': 'l',
        '\u0142': 'l',
        '\u0143': 'N',
        '\u0145': 'N',
        '\u0147': 'N',
        '\u014a': 'N',
        '\u0144': 'n',
        '\u0146': 'n',
        '\u0148': 'n',
        '\u014b': 'n',
        '\u014c': 'O',
        '\u014e': 'O',
        '\u0150': 'O',
        '\u014d': 'o',
        '\u014f': 'o',
        '\u0151': 'o',
        '\u0154': 'R',
        '\u0156': 'R',
        '\u0158': 'R',
        '\u0155': 'r',
        '\u0157': 'r',
        '\u0159': 'r',
        '\u015a': 'S',
        '\u015c': 'S',
        '\u015e': 'S',
        '\u0160': 'S',
        '\u015b': 's',
        '\u015d': 's',
        '\u015f': 's',
        '\u0161': 's',
        '\u0162': 'T',
        '\u0164': 'T',
        '\u0166': 'T',
        '\u0163': 't',
        '\u0165': 't',
        '\u0167': 't',
        '\u0168': 'U',
        '\u016a': 'U',
        '\u016c': 'U',
        '\u016e': 'U',
        '\u0170': 'U',
        '\u0172': 'U',
        '\u0169': 'u',
        '\u016b': 'u',
        '\u016d': 'u',
        '\u016f': 'u',
        '\u0171': 'u',
        '\u0173': 'u',
        '\u0174': 'W',
        '\u0175': 'w',
        '\u0176': 'Y',
        '\u0177': 'y',
        '\u0178': 'Y',
        '\u0179': 'Z',
        '\u017b': 'Z',
        '\u017d': 'Z',
        '\u017a': 'z',
        '\u017c': 'z',
        '\u017e': 'z',
        '\u0132': 'IJ',
        '\u0133': 'ij',
        '\u0152': 'Oe',
        '\u0153': 'oe',
        '\u0149': "'n",
        '\u017f': 's'
    };
    /** Used to map characters to HTML entities. */ var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
    };
    /** Used to map HTML entities to characters. */ var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'"
    };
    /** Used to escape characters for inclusion in compiled string literals. */ var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
    };
    /** Built-in method references without a dependency on `root`. */ var freeParseFloat = parseFloat, freeParseInt = parseInt;
    /** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
    /** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
    /** Detect free variable `exports`. */ var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */ var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */ var nodeUtil = function() {
        try {
            // Use `util.types` for Node.js 10+.
            var types = freeModule && freeModule.require && freeModule.require('util').types;
            if (types) return types;
            // Legacy `process.binding('util')` for Node.js < 10.
            return freeProcess && freeProcess.binding && freeProcess.binding('util');
        } catch (e) {
        }
    }();
    /* Node.js helper references. */ var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */ function apply(func, thisArg, args) {
        switch(args.length){
            case 0:
                return func.call(thisArg);
            case 1:
                return func.call(thisArg, args[0]);
            case 2:
                return func.call(thisArg, args[0], args[1]);
            case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
    }
    /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */ function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while(++index < length){
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
    }
    /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */ function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while(++index < length){
            if (iteratee(array[index], index, array) === false) break;
        }
        return array;
    }
    /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */ function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while(length--){
            if (iteratee(array[length], length, array) === false) break;
        }
        return array;
    }
    /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */ function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while(++index < length){
            if (!predicate(array[index], index, array)) return false;
        }
        return true;
    }
    /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */ function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while(++index < length){
            var value = array[index];
            if (predicate(value, index, array)) result[resIndex++] = value;
        }
        return result;
    }
    /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */ function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
    }
    /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */ function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while(++index < length){
            if (comparator(value, array[index])) return true;
        }
        return false;
    }
    /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */ function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while(++index < length)result[index] = iteratee(array[index], index, array);
        return result;
    }
    /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */ function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while(++index < length)array[offset + index] = values[index];
        return array;
    }
    /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */ function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) accumulator = array[++index];
        while(++index < length)accumulator = iteratee(accumulator, array[index], index, array);
        return accumulator;
    }
    /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */ function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) accumulator = array[--length];
        while(length--)accumulator = iteratee(accumulator, array[length], length, array);
        return accumulator;
    }
    /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */ function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while(++index < length){
            if (predicate(array[index], index, array)) return true;
        }
        return false;
    }
    /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */ var asciiSize = baseProperty('length');
    /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */ function asciiToArray(string) {
        return string.split('');
    }
    /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */ function asciiWords(string) {
        return string.match(reAsciiWord) || [];
    }
    /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */ function baseFindKey(collection1, predicate, eachFunc) {
        var result;
        eachFunc(collection1, function(value, key, collection) {
            if (predicate(value, key, collection)) {
                result = key;
                return false;
            }
        });
        return result;
    }
    /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while(fromRight ? index-- : ++index < length){
            if (predicate(array[index], index, array)) return index;
        }
        return -1;
    }
    /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */ function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */ function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while(++index < length){
            if (comparator(array[index], value)) return index;
        }
        return -1;
    }
    /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */ function baseIsNaN(value) {
        return value !== value;
    }
    /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */ function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
    }
    /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */ function baseProperty(key) {
        return function(object) {
            return object == null ? undefined : object[key];
        };
    }
    /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */ function basePropertyOf(object) {
        return function(key) {
            return object == null ? undefined : object[key];
        };
    }
    /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */ function baseReduce(collection2, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection2, function(value, index, collection) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
    }
    /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */ function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while(length--)array[length] = array[length].value;
        return array;
    }
    /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */ function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while(++index < length){
            var current = iteratee(array[index]);
            if (current !== undefined) result = result === undefined ? current : result + current;
        }
        return result;
    }
    /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */ function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while(++index < n)result[index] = iteratee(index);
        return result;
    }
    /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */ function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
            return [
                key,
                object[key]
            ];
        });
    }
    /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */ function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
    }
    /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */ function baseUnary(func) {
        return function(value) {
            return func(value);
        };
    }
    /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */ function baseValues(object, props) {
        return arrayMap(props, function(key) {
            return object[key];
        });
    }
    /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */ function cacheHas(cache, key) {
        return cache.has(key);
    }
    /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */ function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while(++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1);
        return index;
    }
    /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */ function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while((index--) && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1);
        return index;
    }
    /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */ function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while(length--)if (array[length] === placeholder) ++result;
        return result;
    }
    /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */ var deburrLetter = basePropertyOf(deburredLetters);
    /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */ var escapeHtmlChar = basePropertyOf(htmlEscapes);
    /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */ function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
    }
    /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */ function getValue(object, key) {
        return object == null ? undefined : object[key];
    }
    /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */ function hasUnicode(string) {
        return reHasUnicode.test(string);
    }
    /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */ function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
    }
    /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */ function iteratorToArray(iterator) {
        var data, result = [];
        while(!(data = iterator.next()).done)result.push(data.value);
        return result;
    }
    /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */ function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
            result[++index] = [
                key,
                value
            ];
        });
        return result;
    }
    /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */ function overArg(func, transform) {
        return function(arg) {
            return func(transform(arg));
        };
    }
    /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */ function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while(++index < length){
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
                array[index] = PLACEHOLDER;
                result[resIndex++] = index;
            }
        }
        return result;
    }
    /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */ function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
            result[++index] = value;
        });
        return result;
    }
    /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */ function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
            result[++index] = [
                value,
                value
            ];
        });
        return result;
    }
    /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */ function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while(++index < length){
            if (array[index] === value) return index;
        }
        return -1;
    }
    /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */ function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while(index--){
            if (array[index] === value) return index;
        }
        return index;
    }
    /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */ function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */ function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */ function trimmedEndIndex(string) {
        var index = string.length;
        while(index-- && reWhitespace.test(string.charAt(index)));
        return index;
    }
    /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */ var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */ function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while(reUnicode.test(string))++result;
        return result;
    }
    /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */ function unicodeToArray(string) {
        return string.match(reUnicode) || [];
    }
    /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */ function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
    }
    /*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */ var runInContext1 = function runInContext(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        /** Built-in constructor references. */ var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        /** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
        /** Used to detect overreaching core-js shims. */ var coreJsData = context['__core-js_shared__'];
        /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
        /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
        /** Used to generate unique IDs. */ var idCounter = 0;
        /** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
            return uid ? 'Symbol(src)_1.' + uid : '';
        }();
        /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */ var nativeObjectToString = objectProto.toString;
        /** Used to infer the `Object` constructor. */ var objectCtorString = funcToString.call(Object);
        /** Used to restore the original `_` reference in `_.noConflict`. */ var oldDash = root._;
        /** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        /** Built-in value references. */ var Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined, symIterator = Symbol ? Symbol.iterator : undefined, symToStringTag = Symbol ? Symbol.toStringTag : undefined;
        var defineProperty = function() {
            try {
                var func = getNative(Object, 'defineProperty');
                func({
                }, '', {
                });
                return func;
            } catch (e) {
            }
        }();
        /** Mocked built-ins. */ var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse;
        /* Built-in method references that are verified to be native. */ var DataView = getNative(context, 'DataView'), Map = getNative(context, 'Map'), Promise = getNative(context, 'Promise'), Set = getNative(context, 'Set'), WeakMap = getNative(context, 'WeakMap'), nativeCreate = getNative(Object, 'create');
        /** Used to store function metadata. */ var metaMap = WeakMap && new WeakMap;
        /** Used to lookup unminified function names. */ var realNames = {
        };
        /** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
        /** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
        /*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */ function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                if (value instanceof LodashWrapper) return value;
                if (hasOwnProperty.call(value, '__wrapped__')) return wrapperClone(value);
            }
            return new LodashWrapper(value);
        }
        /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */ var baseCreate = function() {
            function object() {
            }
            return function(proto) {
                if (!isObject(proto)) return {
                };
                if (objectCreate) return objectCreate(proto);
                object.prototype = proto;
                var result = new object;
                object.prototype = undefined;
                return result;
            };
        }();
        /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */ function baseLodash() {
        // No operation performed.
        }
        /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */ function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined;
        }
        /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */ lodash.templateSettings = {
            /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */ 'escape': reEscape,
            /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */ 'evaluate': reEvaluate,
            /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */ 'interpolate': reInterpolate,
            /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */ 'variable': '',
            /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */ 'imports': {
                /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */ '_': lodash
            }
        };
        // Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        /*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */ function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
        }
        /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */ function lazyClone() {
            var result = new LazyWrapper(this.__wrapped__);
            result.__actions__ = copyArray(this.__actions__);
            result.__dir__ = this.__dir__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = copyArray(this.__iteratees__);
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = copyArray(this.__views__);
            return result;
        }
        /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */ function lazyReverse() {
            if (this.__filtered__) {
                var result = new LazyWrapper(this);
                result.__dir__ = -1;
                result.__filtered__ = true;
            } else {
                result = this.clone();
                result.__dir__ *= -1;
            }
            return result;
        }
        /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */ function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) return baseWrapperValue(array, this.__actions__);
            var result = [];
            outer: while((length--) && resIndex < takeCount){
                index += dir;
                var iterIndex = -1, value = array[index];
                while(++iterIndex < iterLength){
                    var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                    if (type == LAZY_MAP_FLAG) value = computed;
                    else if (!computed) {
                        if (type == LAZY_FILTER_FLAG) continue outer;
                        else break outer;
                    }
                }
                result[resIndex++] = value;
            }
            return result;
        }
        // Ensure `LazyWrapper` is an instance of `baseLodash`.
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        /*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */ function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while(++index < length){
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */ function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {
            };
            this.size = 0;
        }
        /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */ function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
        }
        /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */ function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
        }
        /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */ function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
        }
        /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */ function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
        }
        // Add methods to `Hash`.
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        /*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */ function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while(++index < length){
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */ function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
        }
        /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */ function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) return false;
            var lastIndex = data.length - 1;
            if (index == lastIndex) data.pop();
            else splice.call(data, index, 1);
            --this.size;
            return true;
        }
        /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */ function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
        }
        /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */ function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
        }
        /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */ function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
                ++this.size;
                data.push([
                    key,
                    value
                ]);
            } else data[index][1] = value;
            return this;
        }
        // Add methods to `ListCache`.
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        /*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */ function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while(++index < length){
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */ function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
                'hash': new Hash,
                'map': new (Map || ListCache),
                'string': new Hash
            };
        }
        /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */ function mapCacheDelete(key) {
            var result = getMapData(this, key)['delete'](key);
            this.size -= result ? 1 : 0;
            return result;
        }
        /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */ function mapCacheGet(key) {
            return getMapData(this, key).get(key);
        }
        /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */ function mapCacheHas(key) {
            return getMapData(this, key).has(key);
        }
        /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */ function mapCacheSet(key, value) {
            var data = getMapData(this, key), size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
        }
        // Add methods to `MapCache`.
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        /*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */ function SetCache(values) {
            var index = -1, length = values == null ? 0 : values.length;
            this.__data__ = new MapCache;
            while(++index < length)this.add(values[index]);
        }
        /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */ function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
        }
        /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */ function setCacheHas(value) {
            return this.__data__.has(value);
        }
        // Add methods to `SetCache`.
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        /*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */ function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
        }
        /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */ function stackClear() {
            this.__data__ = new ListCache;
            this.size = 0;
        }
        /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */ function stackDelete(key) {
            var data = this.__data__, result = data['delete'](key);
            this.size = data.size;
            return result;
        }
        /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */ function stackGet(key) {
            return this.__data__.get(key);
        }
        /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */ function stackHas(key) {
            return this.__data__.has(key);
        }
        /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */ function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
                var pairs = data.__data__;
                if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([
                        key,
                        value
                    ]);
                    this.size = ++data.size;
                    return this;
                }
                data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
        }
        // Add methods to `Stack`.
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        /*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */ function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
            for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
            isIndex(key, length)))) result.push(key);
            return result;
        }
        /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */ function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined;
        }
        /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */ function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */ function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
        }
        /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */ function assignMergeValue(object, key, value) {
            if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) baseAssignValue(object, key, value);
        }
        /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */ function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) baseAssignValue(object, key, value);
        }
        /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */ function assocIndexOf(array, key) {
            var length = array.length;
            while(length--){
                if (eq(array[length][0], key)) return length;
            }
            return -1;
        }
        /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */ function baseAggregator(collection3, setter, iteratee, accumulator) {
            baseEach(collection3, function(value, key, collection) {
                setter(accumulator, value, iteratee(value), collection);
            });
            return accumulator;
        }
        /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */ function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
        }
        /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */ function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
        }
        /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */ function baseAssignValue(object, key, value) {
            if (key == '__proto__' && defineProperty) defineProperty(object, key, {
                'configurable': true,
                'enumerable': true,
                'value': value,
                'writable': true
            });
            else object[key] = value;
        }
        /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */ function baseAt(object, paths) {
            var index = -1, length = paths.length, result = Array(length), skip = object == null;
            while(++index < length)result[index] = skip ? undefined : get(object, paths[index]);
            return result;
        }
        /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */ function baseClamp(number, lower, upper) {
            if (number === number) {
                if (upper !== undefined) number = number <= upper ? number : upper;
                if (lower !== undefined) number = number >= lower ? number : lower;
            }
            return number;
        }
        /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */ function baseClone(value, bitmask, customizer, key1, object, stack) {
            var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) result = object ? customizer(value, key1, object, stack) : customizer(value);
            if (result !== undefined) return result;
            if (!isObject(value)) return value;
            var isArr = isArray(value);
            if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) return copyArray(value, result);
            } else {
                var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                if (isBuffer(value)) return cloneBuffer(value, isDeep);
                if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    result = isFlat || isFunc ? {
                    } : initCloneObject(value);
                    if (!isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                } else {
                    if (!cloneableTags[tag]) return object ? value : {
                    };
                    result = initCloneByTag(value, tag, isDeep);
                }
            }
            // Check for circular references and return its corresponding clone.
            stack || (stack = new Stack);
            var stacked = stack.get(value);
            if (stacked) return stacked;
            stack.set(value, result);
            if (isSet(value)) value.forEach(function(subValue) {
                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
            else if (isMap(value)) value.forEach(function(subValue, key) {
                result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined : keysFunc(value);
            arrayEach(props || value, function(subValue, key) {
                if (props) {
                    key = subValue;
                    subValue = value[key];
                }
                // Recursively populate clone (susceptible to call stack limits).
                assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
            return result;
        }
        /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */ function baseConforms(source) {
            var props = keys(source);
            return function(object) {
                return baseConformsTo(object, source, props);
            };
        }
        /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */ function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) return !length;
            object = Object(object);
            while(length--){
                var key = props[length], predicate = source[key], value = object[key];
                if (value === undefined && !(key in object) || !predicate(value)) return false;
            }
            return true;
        }
        /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */ function baseDelay(func, wait, args) {
            if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, wait);
        }
        /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */ function baseDifference(array, values, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
            if (!length) return result;
            if (iteratee) values = arrayMap(values, baseUnary(iteratee));
            if (comparator) {
                includes = arrayIncludesWith;
                isCommon = false;
            } else if (values.length >= LARGE_ARRAY_SIZE) {
                includes = cacheHas;
                isCommon = false;
                values = new SetCache(values);
            }
            outer: while(++index < length){
                var value = array[index], computed = iteratee == null ? value : iteratee(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                    var valuesIndex = valuesLength;
                    while(valuesIndex--){
                        if (values[valuesIndex] === computed) continue outer;
                    }
                    result.push(value);
                } else if (!includes(values, computed, comparator)) result.push(value);
            }
            return result;
        }
        /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */ var baseEach = createBaseEach(baseForOwn);
        /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */ var baseEachRight = createBaseEach(baseForOwnRight, true);
        /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */ function baseEvery(collection4, predicate) {
            var result = true;
            baseEach(collection4, function(value, index, collection) {
                result = !!predicate(value, index, collection);
                return result;
            });
            return result;
        }
        /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */ function baseExtremum(array, iteratee, comparator) {
            var index = -1, length = array.length;
            while(++index < length){
                var value = array[index], current = iteratee(value);
                if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) var computed = current, result = value;
            }
            return result;
        }
        /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */ function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) start = -start > length ? 0 : length + start;
            end = end === undefined || end > length ? length : toInteger(end);
            if (end < 0) end += length;
            end = start > end ? 0 : toLength(end);
            while(start < end)array[start++] = value;
            return array;
        }
        /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */ function baseFilter(collection5, predicate) {
            var result = [];
            baseEach(collection5, function(value, index, collection) {
                if (predicate(value, index, collection)) result.push(value);
            });
            return result;
        }
        /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */ function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result || (result = []);
            while(++index < length){
                var value = array[index];
                if (depth > 0 && predicate(value)) {
                    if (depth > 1) // Recursively flatten arrays (susceptible to call stack limits).
                    baseFlatten(value, depth - 1, predicate, isStrict, result);
                    else arrayPush(result, value);
                } else if (!isStrict) result[result.length] = value;
            }
            return result;
        }
        /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */ var baseFor = createBaseFor();
        /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */ var baseForRight = createBaseFor(true);
        /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */ function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
        }
        /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */ function baseForOwnRight(object, iteratee) {
            return object && baseForRight(object, iteratee, keys);
        }
        /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */ function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
                return isFunction(object[key]);
            });
        }
        /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */ function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while(object != null && index < length)object = object[toKey(path[index++])];
            return index && index == length ? object : undefined;
        }
        /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */ function baseGetTag(value) {
            if (value == null) return value === undefined ? undefinedTag : nullTag;
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */ function baseGt(value, other) {
            return value > other;
        }
        /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */ function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
        }
        /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */ function baseHasIn(object, key) {
            return object != null && key in Object(object);
        }
        /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */ function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */ function baseIntersection(arrays, iteratee, comparator) {
            var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
            while(othIndex--){
                var array = arrays[othIndex];
                if (othIndex && iteratee) array = arrayMap(array, baseUnary(iteratee));
                maxLength = nativeMin(array.length, maxLength);
                caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer: while(++index < length && result.length < maxLength){
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                    othIndex = othLength;
                    while(--othIndex){
                        var cache = caches[othIndex];
                        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) continue outer;
                    }
                    if (seen) seen.push(computed);
                    result.push(value);
                }
            }
            return result;
        }
        /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */ function baseInverter(object1, setter, iteratee, accumulator) {
            baseForOwn(object1, function(value, key, object) {
                setter(accumulator, iteratee(value), key, object);
            });
            return accumulator;
        }
        /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */ function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent1(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined : apply(func, object, args);
        }
        /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */ function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */ function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */ function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */ function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) return true;
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) return value !== value && other !== other;
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */ function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
                if (!isBuffer(other)) return false;
                objIsArr = true;
                objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
                stack || (stack = new Stack);
                return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
                if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new Stack);
                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                }
            }
            if (!isSameTag) return false;
            stack || (stack = new Stack);
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */ function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
        }
        /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */ function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) return !length;
            object = Object(object);
            while(index--){
                var data = matchData[index];
                if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
            }
            while(++index < length){
                data = matchData[index];
                var key = data[0], objValue = object[key], srcValue = data[1];
                if (noCustomizer && data[2]) {
                    if (objValue === undefined && !(key in object)) return false;
                } else {
                    var stack = new Stack;
                    if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) return false;
                }
            }
            return true;
        }
        /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */ function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) return false;
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
        }
        /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */ function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */ function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
        }
        /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */ function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */ function baseIteratee(value) {
            // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
            // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
            if (typeof value == 'function') return value;
            if (value == null) return identity;
            if (typeof value == 'object') return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            return property(value);
        }
        /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */ function baseKeys(object) {
            if (!isPrototype(object)) return nativeKeys(object);
            var result = [];
            for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != 'constructor') result.push(key);
            return result;
        }
        /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */ function baseKeysIn(object) {
            if (!isObject(object)) return nativeKeysIn(object);
            var isProto = isPrototype(object), result = [];
            for(var key in object)if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) result.push(key);
            return result;
        }
        /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */ function baseLt(value, other) {
            return value < other;
        }
        /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */ function baseMap(collection6, iteratee) {
            var index = -1, result = isArrayLike(collection6) ? Array(collection6.length) : [];
            baseEach(collection6, function(value, key, collection) {
                result[++index] = iteratee(value, key, collection);
            });
            return result;
        }
        /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */ function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            return function(object) {
                return object === source || baseIsMatch(object, source, matchData);
            };
        }
        /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */ function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) return matchesStrictComparable(toKey(path), srcValue);
            return function(object) {
                var objValue = get(object, path);
                return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
        }
        /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */ function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) return;
            baseFor(source, function(srcValue, key) {
                stack || (stack = new Stack);
                if (isObject(srcValue)) baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                else {
                    var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;
                    if (newValue === undefined) newValue = srcValue;
                    assignMergeValue(object, key, newValue);
                }
            }, keysIn);
        }
        /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */ function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
                assignMergeValue(object, key, stacked);
                return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
            var isCommon = newValue === undefined;
            if (isCommon) {
                var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                newValue = srcValue;
                if (isArr || isBuff || isTyped) {
                    if (isArray(objValue)) newValue = objValue;
                    else if (isArrayLikeObject(objValue)) newValue = copyArray(objValue);
                    else if (isBuff) {
                        isCommon = false;
                        newValue = cloneBuffer(srcValue, true);
                    } else if (isTyped) {
                        isCommon = false;
                        newValue = cloneTypedArray(srcValue, true);
                    } else newValue = [];
                } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    newValue = objValue;
                    if (isArguments(objValue)) newValue = toPlainObject(objValue);
                    else if (!isObject(objValue) || isFunction(objValue)) newValue = initCloneObject(srcValue);
                } else isCommon = false;
            }
            if (isCommon) {
                // Recursively merge objects and arrays (susceptible to call stack limits).
                stack.set(srcValue, newValue);
                mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                stack['delete'](srcValue);
            }
            assignMergeValue(object, key, newValue);
        }
        /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */ function baseNth(array, n) {
            var length = array.length;
            if (!length) return;
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined;
        }
        /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */ function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) iteratees = arrayMap(iteratees, function(iteratee) {
                if (isArray(iteratee)) return function(value) {
                    return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                };
                return iteratee;
            });
            else iteratees = [
                identity
            ];
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result = baseMap(collection, function(value, key, collection) {
                var criteria = arrayMap(iteratees, function(iteratee) {
                    return iteratee(value);
                });
                return {
                    'criteria': criteria,
                    'index': ++index,
                    'value': value
                };
            });
            return baseSortBy(result, function(object, other) {
                return compareMultiple(object, other, orders);
            });
        }
        /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */ function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
                return hasIn(object, path);
            });
        }
        /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */ function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result = {
            };
            while(++index < length){
                var path = paths[index], value = baseGet(object, path);
                if (predicate(value, path)) baseSet(result, castPath(path, object), value);
            }
            return result;
        }
        /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */ function basePropertyDeep(path) {
            return function(object) {
                return baseGet(object, path);
            };
        }
        /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */ function basePullAll(array, values, iteratee, comparator) {
            var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
            if (array === values) values = copyArray(values);
            if (iteratee) seen = arrayMap(array, baseUnary(iteratee));
            while(++index < length){
                var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
                while((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1){
                    if (seen !== array) splice.call(seen, fromIndex, 1);
                    splice.call(array, fromIndex, 1);
                }
            }
            return array;
        }
        /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */ function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while(length--){
                var index = indexes[length];
                if (length == lastIndex || index !== previous) {
                    var previous = index;
                    if (isIndex(index)) splice.call(array, index, 1);
                    else baseUnset(array, index);
                }
            }
            return array;
        }
        /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */ function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */ function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
            while(length--){
                result[fromRight ? length : ++index] = start;
                start += step;
            }
            return result;
        }
        /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */ function baseRepeat(string, n) {
            var result = '';
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) return result;
            // Leverage the exponentiation by squaring algorithm for a faster repeat.
            // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
            do {
                if (n % 2) result += string;
                n = nativeFloor(n / 2);
                if (n) string += string;
            }while (n)
            return result;
        }
        /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */ function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + '');
        }
        /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */ function baseSample(collection) {
            return arraySample(values1(collection));
        }
        /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */ function baseSampleSize(collection, n) {
            var array = values1(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */ function baseSet(object, path, value, customizer) {
            if (!isObject(object)) return object;
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while(nested != null && ++index < length){
                var key = toKey(path[index]), newValue = value;
                if (key === '__proto__' || key === 'constructor' || key === 'prototype') return object;
                if (index != lastIndex) {
                    var objValue = nested[key];
                    newValue = customizer ? customizer(objValue, key, nested) : undefined;
                    if (newValue === undefined) newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {
                    };
                }
                assignValue(nested, key, newValue);
                nested = nested[key];
            }
            return object;
        }
        /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */ var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
        };
        /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */ var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, 'toString', {
                'configurable': true,
                'enumerable': false,
                'value': constant(string),
                'writable': true
            });
        };
        /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */ function baseShuffle(collection) {
            return shuffleSelf(values1(collection));
        }
        /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */ function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) start = -start > length ? 0 : length + start;
            end = end > length ? length : end;
            if (end < 0) end += length;
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);
            while(++index < length)result[index] = array[index + start];
            return result;
        }
        /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */ function baseSome(collection7, predicate) {
            var result;
            baseEach(collection7, function(value, index, collection) {
                result = predicate(value, index, collection);
                return !result;
            });
            return !!result;
        }
        /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */ function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                while(low < high){
                    var mid = low + high >>> 1, computed = array[mid];
                    if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) low = mid + 1;
                    else high = mid;
                }
                return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
        }
        /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */ function baseSortedIndexBy(array, value, iteratee, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) return 0;
            value = iteratee(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined;
            while(low < high){
                var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                if (valIsNaN) var setLow = retHighest || othIsReflexive;
                else if (valIsUndefined) setLow = othIsReflexive && (retHighest || othIsDefined);
                else if (valIsNull) setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                else if (valIsSymbol) setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                else if (othIsNull || othIsSymbol) setLow = false;
                else setLow = retHighest ? computed <= value : computed < value;
                if (setLow) low = mid + 1;
                else high = mid;
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
        }
        /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */ function baseSortedUniq(array, iteratee) {
            var index = -1, length = array.length, resIndex = 0, result = [];
            while(++index < length){
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                if (!index || !eq(computed, seen)) {
                    var seen = computed;
                    result[resIndex++] = value === 0 ? 0 : value;
                }
            }
            return result;
        }
        /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */ function baseToNumber(value) {
            if (typeof value == 'number') return value;
            if (isSymbol(value)) return NAN;
            return +value;
        }
        /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */ function baseToString(value) {
            // Exit early for strings to avoid a performance hit in some environments.
            if (typeof value == 'string') return value;
            if (isArray(value)) // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + '';
            if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : '';
            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
        }
        /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */ function baseUniq(array, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
            if (comparator) {
                isCommon = false;
                includes = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
                var set = iteratee ? null : createSet(array);
                if (set) return setToArray(set);
                isCommon = false;
                includes = cacheHas;
                seen = new SetCache;
            } else seen = iteratee ? [] : result;
            outer: while(++index < length){
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                    var seenIndex = seen.length;
                    while(seenIndex--){
                        if (seen[seenIndex] === computed) continue outer;
                    }
                    if (iteratee) seen.push(computed);
                    result.push(value);
                } else if (!includes(seen, computed, comparator)) {
                    if (seen !== result) seen.push(computed);
                    result.push(value);
                }
            }
            return result;
        }
        /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */ function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent1(object, path);
            return object == null || delete object[toKey(last(path))];
        }
        /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */ function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */ function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while((fromRight ? index-- : ++index < length) && predicate(array[index], index, array));
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */ function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) result2 = result2.value();
            return arrayReduce(actions, function(result, action) {
                return action.func.apply(action.thisArg, arrayPush([
                    result
                ], action.args));
            }, result2);
        }
        /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */ function baseXor(arrays, iteratee, comparator) {
            var length = arrays.length;
            if (length < 2) return length ? baseUniq(arrays[0]) : [];
            var index = -1, result = Array(length);
            while(++index < length){
                var array = arrays[index], othIndex = -1;
                while(++othIndex < length)if (othIndex != index) result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
            }
            return baseUniq(baseFlatten(result, 1), iteratee, comparator);
        }
        /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */ function baseZipObject(props, values, assignFunc) {
            var index = -1, length = props.length, valsLength = values.length, result = {
            };
            while(++index < length){
                var value = index < valsLength ? values[index] : undefined;
                assignFunc(result, props[index], value);
            }
            return result;
        }
        /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */ function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
        }
        /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */ function castFunction(value) {
            return typeof value == 'function' ? value : identity;
        }
        /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */ function castPath(value, object) {
            if (isArray(value)) return value;
            return isKey(value, object) ? [
                value
            ] : stringToPath(toString(value));
        }
        /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */ var castRest = baseRest;
        /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */ function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
        }
        /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */ var clearTimeout = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
        };
        /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */ function cloneBuffer(buffer, isDeep) {
            if (isDeep) return buffer.slice();
            var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result);
            return result;
        }
        /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */ function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
        }
        /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */ function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */ function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
        }
        /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */ function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {
            };
        }
        /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */ function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */ function compareAscending(value, other) {
            if (value !== other) {
                var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
                if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
            }
            return 0;
        }
        /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */ function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while(++index < length){
                var result = compareAscending(objCriteria[index], othCriteria[index]);
                if (result) {
                    if (index >= ordersLength) return result;
                    var order = orders[index];
                    return result * (order == 'desc' ? -1 : 1);
                }
            }
            // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
            // that causes it, under certain circumstances, to provide the same value for
            // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
            // for more details.
            //
            // This also ensures a stable sort in V8 and other engines.
            // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
            return object.index - other.index;
        }
        /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */ function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
            while(++leftIndex < leftLength)result[leftIndex] = partials[leftIndex];
            while(++argsIndex < holdersLength)if (isUncurried || argsIndex < argsLength) result[holders[argsIndex]] = args[argsIndex];
            while(rangeLength--)result[leftIndex++] = args[argsIndex++];
            return result;
        }
        /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */ function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
            while(++argsIndex < rangeLength)result[argsIndex] = args[argsIndex];
            var offset = argsIndex;
            while(++rightIndex < rightLength)result[offset + rightIndex] = partials[rightIndex];
            while(++holdersIndex < holdersLength)if (isUncurried || argsIndex < argsLength) result[offset + holders[holdersIndex]] = args[argsIndex++];
            return result;
        }
        /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */ function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            while(++index < length)array[index] = source[index];
            return array;
        }
        /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */ function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {
            });
            var index = -1, length = props.length;
            while(++index < length){
                var key = props[index];
                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
                if (newValue === undefined) newValue = source[key];
                if (isNew) baseAssignValue(object, key, newValue);
                else assignValue(object, key, newValue);
            }
            return object;
        }
        /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */ function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
        }
        /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */ function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
        }
        /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */ function createAggregator(setter, initializer) {
            return function(collection, iteratee) {
                var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {
                };
                return func(collection, setter, getIteratee(iteratee, 2), accumulator);
            };
        }
        /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */ function createAssigner(assigner) {
            return baseRest(function(object, sources) {
                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined : customizer;
                    length = 1;
                }
                object = Object(object);
                while(++index < length){
                    var source = sources[index];
                    if (source) assigner(object, source, index, customizer);
                }
                return object;
            });
        }
        /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */ function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
                if (collection == null) return collection;
                if (!isArrayLike(collection)) return eachFunc(collection, iteratee);
                var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                while(fromRight ? index-- : ++index < length){
                    if (iteratee(iterable[index], index, iterable) === false) break;
                }
                return collection;
            };
        }
        /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */ function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
                var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                while(length--){
                    var key = props[fromRight ? length : ++index];
                    if (iteratee(iterable[key], key, iterable) === false) break;
                }
                return object;
            };
        }
        /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */ function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
        }
        /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */ function createCaseFirst(methodName) {
            return function(string) {
                string = toString(string);
                var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
                var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
                return chr[methodName]() + trailing;
            };
        }
        /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */ function createCompounder(callback) {
            return function(string) {
                return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
            };
        }
        /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */ function createCtor(Ctor) {
            return function() {
                // Use a `switch` statement to work with class constructors. See
                // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                // for more details.
                var args = arguments;
                switch(args.length){
                    case 0:
                        return new Ctor;
                    case 1:
                        return new Ctor(args[0]);
                    case 2:
                        return new Ctor(args[0], args[1]);
                    case 3:
                        return new Ctor(args[0], args[1], args[2]);
                    case 4:
                        return new Ctor(args[0], args[1], args[2], args[3]);
                    case 5:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                    case 6:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                    case 7:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                }
                var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                // Mimic the constructor's `return` behavior.
                // See https://es5.github.io/#x13.2.2 for more details.
                return isObject(result) ? result : thisBinding;
            };
        }
        /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */ function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
                var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
                while(index--)args[index] = arguments[index];
                var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                length -= holders.length;
                if (length < arity) return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return apply(fn, this, args);
            }
            return wrapper;
        }
        /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */ function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
                var iterable = Object(collection);
                if (!isArrayLike(collection)) {
                    var iteratee = getIteratee(predicate, 3);
                    collection = keys(collection);
                    predicate = function(key) {
                        return iteratee(iterable[key], key, iterable);
                    };
                }
                var index = findIndexFunc(collection, predicate, fromIndex);
                return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
            };
        }
        /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */ function createFlow(fromRight) {
            return flatRest(function(funcs) {
                var length = funcs.length, index1 = length, prereq = LodashWrapper.prototype.thru;
                if (fromRight) funcs.reverse();
                while(index1--){
                    var func = funcs[index1];
                    if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
                    if (prereq && !wrapper && getFuncName(func) == 'wrapper') var wrapper = new LodashWrapper([], true);
                }
                index1 = wrapper ? index1 : length;
                while(++index1 < length){
                    func = funcs[index1];
                    var funcName = getFuncName(func), data = funcName == 'wrapper' ? getData(func) : undefined;
                    if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                    else wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
                return function() {
                    var args = arguments, value = args[0];
                    if (wrapper && args.length == 1 && isArray(value)) return wrapper.plant(value).value();
                    var index = 0, result = length ? funcs[index].apply(this, args) : value;
                    while(++index < length)result = funcs[index].call(this, result);
                    return result;
                };
            });
        }
        /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */ function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);
            function wrapper() {
                var length = arguments.length, args = Array(length), index = length;
                while(index--)args[index] = arguments[index];
                if (isCurried) var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                if (partials) args = composeArgs(args, partials, holders, isCurried);
                if (partialsRight) args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                length -= holdersCount;
                if (isCurried && length < arity) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
                }
                var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                length = args.length;
                if (argPos) args = reorder(args, argPos);
                else if (isFlip && length > 1) args.reverse();
                if (isAry && ary < length) args.length = ary;
                if (this && this !== root && this instanceof wrapper) fn = Ctor || createCtor(fn);
                return fn.apply(thisBinding, args);
            }
            return wrapper;
        }
        /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */ function createInverter(setter, toIteratee) {
            return function(object, iteratee) {
                return baseInverter(object, setter, toIteratee(iteratee), {
                });
            };
        }
        /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */ function createMathOperation(operator, defaultValue) {
            return function(value, other) {
                var result;
                if (value === undefined && other === undefined) return defaultValue;
                if (value !== undefined) result = value;
                if (other !== undefined) {
                    if (result === undefined) return other;
                    if (typeof value == 'string' || typeof other == 'string') {
                        value = baseToString(value);
                        other = baseToString(other);
                    } else {
                        value = baseToNumber(value);
                        other = baseToNumber(other);
                    }
                    result = operator(value, other);
                }
                return result;
            };
        }
        /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */ function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
                iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                return baseRest(function(args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function(iteratee) {
                        return apply(iteratee, thisArg, args);
                    });
                });
            });
        }
        /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */ function createPadding(length, chars) {
            chars = chars === undefined ? ' ' : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) return charsLength ? baseRepeat(chars, length) : chars;
            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
        }
        /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */ function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
                var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                while(++leftIndex < leftLength)args[leftIndex] = partials[leftIndex];
                while(argsLength--)args[leftIndex++] = arguments[++argsIndex];
                return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
        }
        /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */ function createRange(fromRight) {
            return function(start, end, step) {
                if (step && typeof step != 'number' && isIterateeCall(start, end, step)) end = step = undefined;
                // Ensure the sign of `-0` is preserved.
                start = toFinite(start);
                if (end === undefined) {
                    end = start;
                    start = 0;
                } else end = toFinite(end);
                step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
                return baseRange(start, end, step, fromRight);
            };
        }
        /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */ function createRelationalOperation(operator) {
            return function(value, other) {
                if (!(typeof value == 'string' && typeof other == 'string')) {
                    value = toNumber(value);
                    other = toNumber(other);
                }
                return operator(value, other);
            };
        }
        /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */ function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            var newData = [
                func,
                bitmask,
                thisArg,
                newPartials,
                newHolders,
                newPartialsRight,
                newHoldersRight,
                argPos,
                ary,
                arity
            ];
            var result = wrapFunc.apply(undefined, newData);
            if (isLaziable(func)) setData(result, newData);
            result.placeholder = placeholder;
            return setWrapToString(result, func, bitmask);
        }
        /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */ function createRound(methodName) {
            var func = Math[methodName];
            return function(number, precision) {
                number = toNumber(number);
                precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                if (precision && nativeIsFinite(number)) {
                    // Shift with exponential notation to avoid floating-point issues.
                    // See [MDN](https://mdn.io/round#Examples) for more details.
                    var pair = (toString(number) + 'e').split('e'), value = func(pair[0] + 'e' + (+pair[1] + precision));
                    pair = (toString(value) + 'e').split('e');
                    return +(pair[0] + 'e' + (+pair[1] - precision));
                }
                return func(number);
            };
        }
        /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */ var createSet = !(Set && 1 / setToArray(new Set([
            ,
            -0
        ]))[1] == INFINITY) ? noop : function(values) {
            return new Set(values);
        };
        /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */ function createToPairs(keysFunc) {
            return function(object) {
                var tag = getTag(object);
                if (tag == mapTag) return mapToArray(object);
                if (tag == setTag) return setToPairs(object);
                return baseToPairs(object, keysFunc(object));
            };
        }
        /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */ function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
            var length = partials ? partials.length : 0;
            if (!length) {
                bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                partials = holders = undefined;
            }
            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
            arity = arity === undefined ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                var partialsRight = partials, holdersRight = holders;
                partials = holders = undefined;
            }
            var data = isBindKey ? undefined : getData(func);
            var newData = [
                func,
                bitmask,
                thisArg,
                partials,
                holders,
                partialsRight,
                holdersRight,
                argPos,
                ary,
                arity
            ];
            if (data) mergeData(newData, data);
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            if (!bitmask || bitmask == WRAP_BIND_FLAG) var result = createBind(func, bitmask, thisArg);
            else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) result = createCurry(func, bitmask, arity);
            else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) result = createPartial(func, bitmask, thisArg, partials);
            else result = createHybrid.apply(undefined, newData);
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result, newData), func, bitmask);
        }
        /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */ function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) return srcValue;
            return objValue;
        }
        /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */ function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
                // Recursively merge objects and arrays (susceptible to call stack limits).
                stack.set(srcValue, objValue);
                baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
                stack['delete'](srcValue);
            }
            return objValue;
        }
        /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */ function customOmitClone(value) {
            return isPlainObject(value) ? undefined : value;
        }
        /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */ function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
            // Check that cyclic values are equal.
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
            var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined;
            stack.set(array, other);
            stack.set(other, array);
            // Ignore non-index properties.
            while(++index < arrLength){
                var arrValue = array[index], othValue1 = other[index];
                if (customizer) var compared = isPartial ? customizer(othValue1, arrValue, index, other, array, stack) : customizer(arrValue, othValue1, index, array, other, stack);
                if (compared !== undefined) {
                    if (compared) continue;
                    result = false;
                    break;
                }
                // Recursively compare arrays (susceptible to call stack limits).
                if (seen) {
                    if (!arraySome(other, function(othValue, othIndex) {
                        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
                    })) {
                        result = false;
                        break;
                    }
                } else if (!(arrValue === othValue1 || equalFunc(arrValue, othValue1, bitmask, customizer, stack))) {
                    result = false;
                    break;
                }
            }
            stack['delete'](array);
            stack['delete'](other);
            return result;
        }
        /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */ function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch(tag){
                case dataViewTag:
                    if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
                    object = object.buffer;
                    other = other.buffer;
                case arrayBufferTag:
                    if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) return false;
                    return true;
                case boolTag:
                case dateTag:
                case numberTag:
                    // Coerce booleans to `1` or `0` and dates to milliseconds.
                    // Invalid dates are coerced to `NaN`.
                    return eq(+object, +other);
                case errorTag:
                    return object.name == other.name && object.message == other.message;
                case regexpTag:
                case stringTag:
                    // Coerce regexes to strings and treat strings, primitives and objects,
                    // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                    // for more details.
                    return object == other + '';
                case mapTag:
                    var convert = mapToArray;
                case setTag:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                    convert || (convert = setToArray);
                    if (object.size != other.size && !isPartial) return false;
                    // Assume cyclic values are equal.
                    var stacked = stack.get(object);
                    if (stacked) return stacked == other;
                    bitmask |= COMPARE_UNORDERED_FLAG;
                    // Recursively compare objects (susceptible to call stack limits).
                    stack.set(object, other);
                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                    stack['delete'](object);
                    return result;
                case symbolTag:
                    if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
            return false;
        }
        /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */ function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) return false;
            var index = objLength;
            while(index--){
                var key = objProps[index];
                if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return false;
            }
            // Check that cyclic values are equal.
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) return objStacked == other && othStacked == object;
            var result = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while(++index < objLength){
                key = objProps[index];
                var objValue = object[key], othValue = other[key];
                if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                // Recursively compare objects (susceptible to call stack limits).
                if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                    result = false;
                    break;
                }
                skipCtor || (skipCtor = key == 'constructor');
            }
            if (result && !skipCtor) {
                var objCtor = object.constructor, othCtor = other.constructor;
                // Non `Object` object instances with different constructors are not equal.
                if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) result = false;
            }
            stack['delete'](object);
            stack['delete'](other);
            return result;
        }
        /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */ function flatRest(func) {
            return setToString(overRest(func, undefined, flatten), func + '');
        }
        /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */ function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
        }
        /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */ function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */ var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
        };
        /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */ function getFuncName(func) {
            var result = func.name + '', array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0;
            while(length--){
                var data = array[length], otherFunc = data.func;
                if (otherFunc == null || otherFunc == func) return data.name;
            }
            return result;
        }
        /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */ function getHolder(func) {
            var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
            return object.placeholder;
        }
        /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */ function getIteratee() {
            var result = lodash.iteratee || iteratee1;
            result = result === iteratee1 ? baseIteratee : result;
            return arguments.length ? result(arguments[0], arguments[1]) : result;
        }
        /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */ function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
        }
        /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */ function getMatchData(object) {
            var result = keys(object), length = result.length;
            while(length--){
                var key = result[length], value = object[key];
                result[length] = [
                    key,
                    value,
                    isStrictComparable(value)
                ];
            }
            return result;
        }
        /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */ function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
        }
        /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */ function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
                value[symToStringTag] = undefined;
                var unmasked = true;
            } catch (e) {
            }
            var result = nativeObjectToString.call(value);
            if (unmasked) {
                if (isOwn) value[symToStringTag] = tag;
                else delete value[symToStringTag];
            }
            return result;
        }
        /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */ var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) return [];
            object = Object(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
                return propertyIsEnumerable.call(object, symbol);
            });
        };
        /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */ var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result = [];
            while(object){
                arrayPush(result, getSymbols(object));
                object = getPrototype(object);
            }
            return result;
        };
        /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */ var getTag = baseGetTag;
        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) getTag = function(value) {
            var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : '';
            if (ctorString) switch(ctorString){
                case dataViewCtorString:
                    return dataViewTag;
                case mapCtorString:
                    return mapTag;
                case promiseCtorString:
                    return promiseTag;
                case setCtorString:
                    return setTag;
                case weakMapCtorString:
                    return weakMapTag;
            }
            return result;
        };
        /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */ function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while(++index < length){
                var data = transforms[index], size = data.size;
                switch(data.type){
                    case 'drop':
                        start += size;
                        break;
                    case 'dropRight':
                        end -= size;
                        break;
                    case 'take':
                        end = nativeMin(end, start + size);
                        break;
                    case 'takeRight':
                        start = nativeMax(start, end - size);
                        break;
                }
            }
            return {
                'start': start,
                'end': end
            };
        }
        /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */ function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
        }
        /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */ function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result = false;
            while(++index < length){
                var key = toKey(path[index]);
                if (!(result = object != null && hasFunc(object, key))) break;
                object = object[key];
            }
            if (result || ++index != length) return result;
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */ function initCloneArray(array) {
            var length = array.length, result = new array.constructor(length);
            // Add properties assigned by `RegExp#exec`.
            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                result.index = array.index;
                result.input = array.input;
            }
            return result;
        }
        /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */ function initCloneObject(object) {
            return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {
            };
        }
        /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */ function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch(tag){
                case arrayBufferTag:
                    return cloneArrayBuffer(object);
                case boolTag:
                case dateTag:
                    return new Ctor(+object);
                case dataViewTag:
                    return cloneDataView(object, isDeep);
                case float32Tag:
                case float64Tag:
                case int8Tag:
                case int16Tag:
                case int32Tag:
                case uint8Tag:
                case uint8ClampedTag:
                case uint16Tag:
                case uint32Tag:
                    return cloneTypedArray(object, isDeep);
                case mapTag:
                    return new Ctor;
                case numberTag:
                case stringTag:
                    return new Ctor(object);
                case regexpTag:
                    return cloneRegExp(object);
                case setTag:
                    return new Ctor;
                case symbolTag:
                    return cloneSymbol(object);
            }
        }
        /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */ function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) return source;
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
            details = details.join(length > 2 ? ', ' : ' ');
            return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
        }
        /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */ function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */ function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */ function isIterateeCall(value, index, object) {
            if (!isObject(object)) return false;
            var type = typeof index;
            if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) return eq(object[index], value);
            return false;
        }
        /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */ function isKey(value, object) {
            if (isArray(value)) return false;
            var type = typeof value;
            if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) return true;
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
        }
        /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */ function isKeyable(value) {
            var type = typeof value;
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
        }
        /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */ function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) return false;
            if (func === other) return true;
            var data = getData(other);
            return !!data && func === data[0];
        }
        /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */ function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
        }
        /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */ var isMaskable = coreJsData ? isFunction : stubFalse;
        /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */ function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
            return value === proto;
        }
        /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */ function isStrictComparable(value) {
            return value === value && !isObject(value);
        }
        /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */ function matchesStrictComparable(key, srcValue) {
            return function(object) {
                if (object == null) return false;
                return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
            };
        }
        /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */ function memoizeCapped(func) {
            var result = memoize(func, function(key) {
                if (cache.size === MAX_MEMOIZE_SIZE) cache.clear();
                return key;
            });
            var cache = result.cache;
            return result;
        }
        /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */ function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            // Exit early if metadata can't be merged.
            if (!(isCommon || isCombo)) return data;
            // Use source `thisArg` if available.
            if (srcBitmask & WRAP_BIND_FLAG) {
                data[2] = source[2];
                // Set when currying a bound function.
                newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            // Compose partial arguments.
            var value = source[3];
            if (value) {
                var partials = data[3];
                data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            // Compose partial right arguments.
            value = source[5];
            if (value) {
                partials = data[5];
                data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            // Use source `argPos` if available.
            value = source[7];
            if (value) data[7] = value;
            // Use source `ary` if it's smaller.
            if (srcBitmask & WRAP_ARY_FLAG) data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            // Use source `arity` if one is not provided.
            if (data[9] == null) data[9] = source[9];
            // Use source `func` and merge bitmasks.
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
        }
        /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */ function nativeKeysIn(object) {
            var result = [];
            if (object != null) for(var key in Object(object))result.push(key);
            return result;
        }
        /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */ function objectToString(value) {
            return nativeObjectToString.call(value);
        }
        /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */ function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
            return function() {
                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                while(++index < length)array[index] = args[start + index];
                index = -1;
                var otherArgs = Array(start + 1);
                while(++index < start)otherArgs[index] = args[index];
                otherArgs[start] = transform(array);
                return apply(func, this, otherArgs);
            };
        }
        /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */ function parent1(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */ function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while(length--){
                var index = indexes[length];
                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
        }
        /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */ function safeGet(object, key) {
            if (key === 'constructor' && typeof object[key] === 'function') return;
            if (key == '__proto__') return;
            return object[key];
        }
        /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */ var setData = shortOut(baseSetData);
        /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */ var setTimeout = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
        };
        /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */ var setToString = shortOut(baseSetToString);
        /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */ function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + '';
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */ function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) return arguments[0];
                } else count = 0;
                return func.apply(undefined, arguments);
            };
        }
        /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */ function shuffleSelf(array, size) {
            var index = -1, length = array.length, lastIndex = length - 1;
            size = size === undefined ? length : size;
            while(++index < size){
                var rand = baseRandom(index, lastIndex), value = array[rand];
                array[rand] = array[index];
                array[index] = value;
            }
            array.length = size;
            return array;
        }
        /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */ var stringToPath = memoizeCapped(function(string) {
            var result = [];
            if (string.charCodeAt(0) === 46 /* . */ ) result.push('');
            string.replace(rePropName, function(match, number, quote, subString) {
                result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
            });
            return result;
        });
        /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */ function toKey(value) {
            if (typeof value == 'string' || isSymbol(value)) return value;
            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
        }
        /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */ function toSource(func) {
            if (func != null) {
                try {
                    return funcToString.call(func);
                } catch (e) {
                }
                try {
                    return func + '';
                } catch (e1) {
                }
            }
            return '';
        }
        /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */ function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
                var value = '_.' + pair[0];
                if (bitmask & pair[1] && !arrayIncludes(details, value)) details.push(value);
            });
            return details.sort();
        }
        /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */ function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) return wrapper.clone();
            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result.__actions__ = copyArray(wrapper.__actions__);
            result.__index__ = wrapper.__index__;
            result.__values__ = wrapper.__values__;
            return result;
        }
        /*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */ function chunk(array, size, guard) {
            if (guard ? isIterateeCall(array, size, guard) : size === undefined) size = 1;
            else size = nativeMax(toInteger(size), 0);
            var length = array == null ? 0 : array.length;
            if (!length || size < 1) return [];
            var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
            while(index < length)result[resIndex++] = baseSlice(array, index, index += size);
            return result;
        }
        /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */ function compact(array) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
            while(++index < length){
                var value = array[index];
                if (value) result[resIndex++] = value;
            }
            return result;
        }
        /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */ function concat() {
            var length = arguments.length;
            if (!length) return [];
            var args = Array(length - 1), array = arguments[0], index = length;
            while(index--)args[index - 1] = arguments[index];
            return arrayPush(isArray(array) ? copyArray(array) : [
                array
            ], baseFlatten(args, 1));
        }
        /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */ var difference = baseRest(function(array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
        });
        /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */ var differenceBy = baseRest(function(array, values) {
            var iteratee = last(values);
            if (isArrayLikeObject(iteratee)) iteratee = undefined;
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
        });
        /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */ var differenceWith = baseRest(function(array, values) {
            var comparator = last(values);
            if (isArrayLikeObject(comparator)) comparator = undefined;
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
        });
        /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */ function drop(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) return [];
            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
        }
        /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */ function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) return [];
            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */ function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */ function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */ function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) return [];
            if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                start = 0;
                end = length;
            }
            return baseFill(array, value, start, end);
        }
        /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */ function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) return -1;
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) index = nativeMax(length + index, 0);
            return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */ function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) return -1;
            var index = length - 1;
            if (fromIndex !== undefined) {
                index = toInteger(fromIndex);
                index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */ function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
        }
        /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */ function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
        }
        /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */ function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) return [];
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
        }
        /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */ function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result = {
            };
            while(++index < length){
                var pair = pairs[index];
                result[pair[0]] = pair[1];
            }
            return result;
        }
        /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */ function head(array) {
            return array && array.length ? array[0] : undefined;
        }
        /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */ function indexOf1(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) return -1;
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) index = nativeMax(length + index, 0);
            return baseIndexOf(array, value, index);
        }
        /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */ function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
        }
        /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */ var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */ var intersectionBy = baseRest(function(arrays) {
            var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee === last(mapped)) iteratee = undefined;
            else mapped.pop();
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
        });
        /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */ var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == 'function' ? comparator : undefined;
            if (comparator) mapped.pop();
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
        });
        /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */ function join(array, separator) {
            return array == null ? '' : nativeJoin.call(array, separator);
        }
        /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */ function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined;
        }
        /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */ function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) return -1;
            var index = length;
            if (fromIndex !== undefined) {
                index = toInteger(fromIndex);
                index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */ function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined;
        }
        /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */ var pull = baseRest(pullAll);
        /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */ function pullAll(array, values) {
            return array && array.length && values && values.length ? basePullAll(array, values) : array;
        }
        /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */ function pullAllBy(array, values, iteratee) {
            return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
        }
        /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */ function pullAllWith(array, values, comparator) {
            return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
        }
        /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */ var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
                return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result;
        });
        /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */ function remove(array, predicate) {
            var result = [];
            if (!(array && array.length)) return result;
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while(++index < length){
                var value = array[index];
                if (predicate(value, index, array)) {
                    result.push(value);
                    indexes.push(index);
                }
            }
            basePullAt(array, indexes);
            return result;
        }
        /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */ function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
        }
        /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */ function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) return [];
            if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                start = 0;
                end = length;
            } else {
                start = start == null ? 0 : toInteger(start);
                end = end === undefined ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
        }
        /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */ function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
        }
        /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */ function sortedIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
        }
        /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */ function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
                var index = baseSortedIndex(array, value);
                if (index < length && eq(array[index], value)) return index;
            }
            return -1;
        }
        /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */ function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
        }
        /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */ function sortedLastIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
        }
        /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */ function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
                var index = baseSortedIndex(array, value, true) - 1;
                if (eq(array[index], value)) return index;
            }
            return -1;
        }
        /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */ function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
        }
        /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */ function sortedUniqBy(array, iteratee) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
        }
        /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */ function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
        }
        /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */ function take(array, n, guard) {
            if (!(array && array.length)) return [];
            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */ function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) return [];
            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
        }
        /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */ function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */ function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */ var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */ var unionBy = baseRest(function(arrays) {
            var iteratee = last(arrays);
            if (isArrayLikeObject(iteratee)) iteratee = undefined;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
        });
        /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */ var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == 'function' ? comparator : undefined;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
        });
        /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */ function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
        }
        /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */ function uniqBy(array, iteratee) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
        }
        /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */ function uniqWith(array, comparator) {
            comparator = typeof comparator == 'function' ? comparator : undefined;
            return array && array.length ? baseUniq(array, undefined, comparator) : [];
        }
        /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */ function unzip(array) {
            if (!(array && array.length)) return [];
            var length = 0;
            array = arrayFilter(array, function(group) {
                if (isArrayLikeObject(group)) {
                    length = nativeMax(group.length, length);
                    return true;
                }
            });
            return baseTimes(length, function(index) {
                return arrayMap(array, baseProperty(index));
            });
        }
        /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */ function unzipWith(array, iteratee) {
            if (!(array && array.length)) return [];
            var result = unzip(array);
            if (iteratee == null) return result;
            return arrayMap(result, function(group) {
                return apply(iteratee, undefined, group);
            });
        }
        /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */ var without = baseRest(function(array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, values) : [];
        });
        /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */ var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */ var xorBy = baseRest(function(arrays) {
            var iteratee = last(arrays);
            if (isArrayLikeObject(iteratee)) iteratee = undefined;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
        });
        /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */ var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == 'function' ? comparator : undefined;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
        });
        /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */ var zip = baseRest(unzip);
        /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */ function zipObject(props, values) {
            return baseZipObject(props || [], values || [], assignValue);
        }
        /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */ function zipObjectDeep(props, values) {
            return baseZipObject(props || [], values || [], baseSet);
        }
        /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */ var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
            iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
            return unzipWith(arrays, iteratee);
        });
        /*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */ function chain1(value) {
            var result = lodash(value);
            result.__chain__ = true;
            return result;
        }
        /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */ function tap(value, interceptor) {
            interceptor(value);
            return value;
        }
        /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */ function thru(value, interceptor) {
            return interceptor(value);
        }
        /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */ var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) return this.thru(interceptor);
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
                'func': thru,
                'args': [
                    interceptor
                ],
                'thisArg': undefined
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
                if (length && !array.length) array.push(undefined);
                return array;
            });
        });
        /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */ function wrapperChain() {
            return chain1(this);
        }
        /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */ function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
        }
        /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */ function wrapperNext() {
            if (this.__values__ === undefined) this.__values__ = toArray(this.value());
            var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
            return {
                'done': done,
                'value': value
            };
        }
        /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */ function wrapperToIterator() {
            return this;
        }
        /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */ function wrapperPlant(value) {
            var result, parent = this;
            while(parent instanceof baseLodash){
                var clone = wrapperClone(parent);
                clone.__index__ = 0;
                clone.__values__ = undefined;
                if (result) previous.__wrapped__ = clone;
                else result = clone;
                var previous = clone;
                parent = parent.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result;
        }
        /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */ function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
                var wrapped = value;
                if (this.__actions__.length) wrapped = new LazyWrapper(this);
                wrapped = wrapped.reverse();
                wrapped.__actions__.push({
                    'func': thru,
                    'args': [
                        reverse
                    ],
                    'thisArg': undefined
                });
                return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
        }
        /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */ function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        /*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */ var countBy = createAggregator(function(result, value, key) {
            if (hasOwnProperty.call(result, key)) ++result[key];
            else baseAssignValue(result, key, 1);
        });
        /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */ function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) predicate = undefined;
            return func(collection, getIteratee(predicate, 3));
        }
        /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */ function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
        }
        /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */ var find = createFind(findIndex);
        /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */ var findLast = createFind(findLastIndex);
        /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */ function flatMap(collection, iteratee) {
            return baseFlatten(map1(collection, iteratee), 1);
        }
        /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */ function flatMapDeep(collection, iteratee) {
            return baseFlatten(map1(collection, iteratee), INFINITY);
        }
        /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */ function flatMapDepth(collection, iteratee, depth) {
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(map1(collection, iteratee), depth);
        }
        /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */ function forEach(collection, iteratee) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee, 3));
        }
        /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */ function forEachRight(collection, iteratee) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee, 3));
        }
        /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */ var groupBy = createAggregator(function(result, value, key) {
            if (hasOwnProperty.call(result, key)) result[key].push(value);
            else baseAssignValue(result, key, [
                value
            ]);
        });
        /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */ function includes1(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values1(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) fromIndex = nativeMax(length + fromIndex, 0);
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */ var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == 'function', result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value) {
                result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result;
        });
        /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */ var keyBy = createAggregator(function(result, value, key) {
            baseAssignValue(result, key, value);
        });
        /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */ function map1(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee, 3));
        }
        /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */ function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) return [];
            if (!isArray(iteratees)) iteratees = iteratees == null ? [] : [
                iteratees
            ];
            orders = guard ? undefined : orders;
            if (!isArray(orders)) orders = orders == null ? [] : [
                orders
            ];
            return baseOrderBy(collection, iteratees, orders);
        }
        /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */ var partition = createAggregator(function(result, value, key) {
            result[key ? 0 : 1].push(value);
        }, function() {
            return [
                [],
                []
            ];
        });
        /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */ function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }
        /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */ function reduceRight(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }
        /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */ function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
        }
        /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */ function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
        }
        /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */ function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined) n = 1;
            else n = toInteger(n);
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
        }
        /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */ function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
        }
        /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */ function size1(collection) {
            if (collection == null) return 0;
            if (isArrayLike(collection)) return isString(collection) ? stringSize(collection) : collection.length;
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) return collection.size;
            return baseKeys(collection).length;
        }
        /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */ function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) predicate = undefined;
            return func(collection, getIteratee(predicate, 3));
        }
        /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */ var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) return [];
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) iteratees = [];
            else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) iteratees = [
                iteratees[0]
            ];
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        /*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */ var now = ctxNow || function() {
            return root.Date.now();
        };
        /*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */ function after(n, func) {
            if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
            n = toInteger(n);
            return function() {
                if (--n < 1) return func.apply(this, arguments);
            };
        }
        /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */ function ary1(func, n, guard) {
            n = guard ? undefined : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */ function before(n, func) {
            var result;
            if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
            n = toInteger(n);
            return function() {
                if (--n > 0) result = func.apply(this, arguments);
                if (n <= 1) func = undefined;
                return result;
            };
        }
        /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */ var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, getHolder(bind));
                bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
        });
        /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */ var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, getHolder(bindKey));
                bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
        });
        /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */ function curry(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curry.placeholder;
            return result;
        }
        /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */ function curryRight(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryRight.placeholder;
            return result;
        }
        /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */ function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
                leading = !!options.leading;
                maxing = 'maxWait' in options;
                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                trailing = 'trailing' in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
                var args = lastArgs, thisArg = lastThis;
                lastArgs = lastThis = undefined;
                lastInvokeTime = time;
                result = func.apply(thisArg, args);
                return result;
            }
            function leadingEdge(time) {
                // Reset any `maxWait` timer.
                lastInvokeTime = time;
                // Start the timer for the trailing edge.
                timerId = setTimeout(timerExpired, wait);
                // Invoke the leading edge.
                return leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                // Either this is the first call, activity has stopped and we're at the
                // trailing edge, the system time has gone backwards and we're treating
                // it as the trailing edge, or we've hit the `maxWait` limit.
                return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
                var time = now();
                if (shouldInvoke(time)) return trailingEdge(time);
                // Restart the timer.
                timerId = setTimeout(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
                timerId = undefined;
                // Only invoke if we have `lastArgs` which means `func` has been
                // debounced at least once.
                if (trailing && lastArgs) return invokeFunc(time);
                lastArgs = lastThis = undefined;
                return result;
            }
            function cancel() {
                if (timerId !== undefined) clearTimeout(timerId);
                lastInvokeTime = 0;
                lastArgs = lastCallTime = lastThis = timerId = undefined;
            }
            function flush() {
                return timerId === undefined ? result : trailingEdge(now());
            }
            function debounced() {
                var time = now(), isInvoking = shouldInvoke(time);
                lastArgs = arguments;
                lastThis = this;
                lastCallTime = time;
                if (isInvoking) {
                    if (timerId === undefined) return leadingEdge(lastCallTime);
                    if (maxing) {
                        // Handle invocations in a tight loop.
                        clearTimeout(timerId);
                        timerId = setTimeout(timerExpired, wait);
                        return invokeFunc(lastCallTime);
                    }
                }
                if (timerId === undefined) timerId = setTimeout(timerExpired, wait);
                return result;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
        }
        /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */ var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
        });
        /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */ var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
        });
        /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */ function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
        }
        /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */ function memoize(func, resolver) {
            if (typeof func != 'function' || resolver != null && typeof resolver != 'function') throw new TypeError(FUNC_ERROR_TEXT);
            var memoized = function() {
                var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                if (cache.has(key)) return cache.get(key);
                var result = func.apply(this, args);
                memoized.cache = cache.set(key, result) || cache;
                return result;
            };
            memoized.cache = new (memoize.Cache || MapCache);
            return memoized;
        }
        // Expose `MapCache`.
        memoize.Cache = MapCache;
        /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */ function negate(predicate) {
            if (typeof predicate != 'function') throw new TypeError(FUNC_ERROR_TEXT);
            return function() {
                var args = arguments;
                switch(args.length){
                    case 0:
                        return !predicate.call(this);
                    case 1:
                        return !predicate.call(this, args[0]);
                    case 2:
                        return !predicate.call(this, args[0], args[1]);
                    case 3:
                        return !predicate.call(this, args[0], args[1], args[2]);
                }
                return !predicate.apply(this, args);
            };
        }
        /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */ function once(func) {
            return before(2, func);
        }
        /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */ var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
                var index = -1, length = nativeMin(args.length, funcsLength);
                while(++index < length)args[index] = transforms[index].call(this, args[index]);
                return apply(func, this, args);
            });
        });
        /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */ var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
        });
        /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */ var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
        });
        /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */ var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
        });
        /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */ function rest(func, start) {
            if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
            start = start === undefined ? start : toInteger(start);
            return baseRest(func, start);
        }
        /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */ function spread(func, start) {
            if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
                var array = args[start], otherArgs = castSlice(args, 0, start);
                if (array) arrayPush(otherArgs, array);
                return apply(func, this, otherArgs);
            });
        }
        /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */ function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
            if (isObject(options)) {
                leading = 'leading' in options ? !!options.leading : leading;
                trailing = 'trailing' in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
                'leading': leading,
                'maxWait': wait,
                'trailing': trailing
            });
        }
        /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */ function unary(func) {
            return ary1(func, 1);
        }
        /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */ function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
        }
        /*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */ function castArray() {
            if (!arguments.length) return [];
            var value = arguments[0];
            return isArray(value) ? value : [
                value
            ];
        }
        /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */ function clone1(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */ function cloneWith(value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */ function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */ function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */ function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
        }
        /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */ function eq(value, other) {
            return value === other || value !== value && other !== other;
        }
        /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */ var gt = createRelationalOperation(baseGt);
        /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */ var gte = createRelationalOperation(function(value, other) {
            return value >= other;
        });
        /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */ var isArguments = baseIsArguments(function() {
            return arguments;
        }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        };
        /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */ var isArray = Array.isArray;
        /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */ var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */ function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
        }
        /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */ function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
        }
        /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */ function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */ var isBuffer = nativeIsBuffer || stubFalse;
        /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */ var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */ function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */ function isEmpty(value) {
            if (value == null) return true;
            if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) return !value.length;
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) return !value.size;
            if (isPrototype(value)) return !baseKeys(value).length;
            for(var key in value){
                if (hasOwnProperty.call(value, key)) return false;
            }
            return true;
        }
        /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */ function isEqual(value, other) {
            return baseIsEqual(value, other);
        }
        /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */ function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
        }
        /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */ function isError(value) {
            if (!isObjectLike(value)) return false;
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
        }
        /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */ function isFinite(value) {
            return typeof value == 'number' && nativeIsFinite(value);
        }
        /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */ function isFunction(value) {
            if (!isObject(value)) return false;
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 9 which returns 'object' for typed arrays and other constructors.
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */ function isInteger(value) {
            return typeof value == 'number' && value == toInteger(value);
        }
        /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */ function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */ function isObject(value) {
            var type = typeof value;
            return value != null && (type == 'object' || type == 'function');
        }
        /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */ function isObjectLike(value) {
            return value != null && typeof value == 'object';
        }
        /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */ var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */ function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */ function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */ function isNaN(value) {
            // An `NaN` primitive is the only value that is not equal to itself.
            // Perform the `toStringTag` check first to avoid errors with some
            // ActiveX objects in IE.
            return isNumber(value) && value != +value;
        }
        /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */ function isNative(value) {
            if (isMaskable(value)) throw new Error(CORE_ERROR_TEXT);
            return baseIsNative(value);
        }
        /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */ function isNull(value) {
            return value === null;
        }
        /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */ function isNil(value) {
            return value == null;
        }
        /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */ function isNumber(value) {
            return typeof value == 'number' || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */ function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) return false;
            var proto = getPrototype(value);
            if (proto === null) return true;
            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */ var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */ function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */ var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */ function isString(value) {
            return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */ function isSymbol(value) {
            return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */ var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */ function isUndefined(value) {
            return value === undefined;
        }
        /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */ function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */ function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */ var lt = createRelationalOperation(baseLt);
        /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */ var lte = createRelationalOperation(function(value, other) {
            return value <= other;
        });
        /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */ function toArray(value) {
            if (!value) return [];
            if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value);
            if (symIterator && value[symIterator]) return iteratorToArray(value[symIterator]());
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values1;
            return func(value);
        }
        /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */ function toFinite(value) {
            if (!value) return value === 0 ? value : 0;
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
                var sign = value < 0 ? -1 : 1;
                return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
        }
        /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */ function toInteger(value) {
            var result = toFinite(value), remainder = result % 1;
            return result === result ? remainder ? result - remainder : result : 0;
        }
        /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */ function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */ function toNumber(value) {
            if (typeof value == 'number') return value;
            if (isSymbol(value)) return NAN;
            if (isObject(value)) {
                var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
                value = isObject(other) ? other + '' : other;
            }
            if (typeof value != 'string') return value === 0 ? value : +value;
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */ function toPlainObject(value) {
            return copyObject(value, keysIn(value));
        }
        /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */ function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */ function toString(value) {
            return value == null ? '' : baseToString(value);
        }
        /*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */ var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
                copyObject(source, keys(source), object);
                return;
            }
            for(var key in source)if (hasOwnProperty.call(source, key)) assignValue(object, key, source[key]);
        });
        /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */ var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
        });
        /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */ var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
        });
        /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */ var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
        });
        /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */ var at = flatRest(baseAt);
        /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */ function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties == null ? result : baseAssign(result, properties);
        }
        /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */ var defaults = baseRest(function(object, sources) {
            object = Object(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) length = 1;
            while(++index < length){
                var source = sources[index];
                var props = keysIn(source);
                var propsIndex = -1;
                var propsLength = props.length;
                while(++propsIndex < propsLength){
                    var key = props[propsIndex];
                    var value = object[key];
                    if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) object[key] = source[key];
                }
            }
            return object;
        });
        /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */ var defaultsDeep = baseRest(function(args) {
            args.push(undefined, customDefaultsMerge);
            return apply(mergeWith, undefined, args);
        });
        /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */ function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */ function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */ function forIn(object, iteratee) {
            return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
        }
        /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */ function forInRight(object, iteratee) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
        }
        /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */ function forOwn(object, iteratee) {
            return object && baseForOwn(object, getIteratee(iteratee, 3));
        }
        /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */ function forOwnRight(object, iteratee) {
            return object && baseForOwnRight(object, getIteratee(iteratee, 3));
        }
        /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */ function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
        }
        /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */ function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */ function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
        }
        /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */ function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
        }
        /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */ function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
        }
        /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */ var invert = createInverter(function(result, value, key) {
            if (value != null && typeof value.toString != 'function') value = nativeObjectToString.call(value);
            result[value] = key;
        }, constant(identity));
        /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */ var invertBy = createInverter(function(result, value, key) {
            if (value != null && typeof value.toString != 'function') value = nativeObjectToString.call(value);
            if (hasOwnProperty.call(result, value)) result[value].push(key);
            else result[value] = [
                key
            ];
        }, getIteratee);
        /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */ var invoke = baseRest(baseInvoke);
        /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */ function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */ function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */ function mapKeys(object2, iteratee) {
            var result = {
            };
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object2, function(value, key, object) {
                baseAssignValue(result, iteratee(value, key, object), value);
            });
            return result;
        }
        /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */ function mapValues(object3, iteratee) {
            var result = {
            };
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object3, function(value, key, object) {
                baseAssignValue(result, key, iteratee(value, key, object));
            });
            return result;
        }
        /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */ var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
        });
        /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */ var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
        });
        /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */ var omit = flatRest(function(object, paths) {
            var result = {
            };
            if (object == null) return result;
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
                path = castPath(path, object);
                isDeep || (isDeep = path.length > 1);
                return path;
            });
            copyObject(object, getAllKeysIn(object), result);
            if (isDeep) result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            var length = paths.length;
            while(length--)baseUnset(result, paths[length]);
            return result;
        });
        /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */ function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
        }
        /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */ var pick = flatRest(function(object, paths) {
            return object == null ? {
            } : basePick(object, paths);
        });
        /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */ function pickBy(object, predicate) {
            if (object == null) return {
            };
            var props = arrayMap(getAllKeysIn(object), function(prop) {
                return [
                    prop
                ];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
                return predicate(value, path[0]);
            });
        }
        /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */ function result1(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            // Ensure the loop is entered when path is empty.
            if (!length) {
                length = 1;
                object = undefined;
            }
            while(++index < length){
                var value = object == null ? undefined : object[toKey(path[index])];
                if (value === undefined) {
                    index = length;
                    value = defaultValue;
                }
                object = isFunction(value) ? value.call(object) : value;
            }
            return object;
        }
        /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */ function set1(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
        }
        /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */ function setWith(object, path, value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return object == null ? object : baseSet(object, path, value, customizer);
        }
        /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */ var toPairs = createToPairs(keys);
        /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */ var toPairsIn = createToPairs(keysIn);
        /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */ function transform1(object4, iteratee, accumulator) {
            var isArr = isArray(object4), isArrLike = isArr || isBuffer(object4) || isTypedArray(object4);
            iteratee = getIteratee(iteratee, 4);
            if (accumulator == null) {
                var Ctor = object4 && object4.constructor;
                if (isArrLike) accumulator = isArr ? new Ctor : [];
                else if (isObject(object4)) accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object4)) : {
                };
                else accumulator = {
                };
            }
            (isArrLike ? arrayEach : baseForOwn)(object4, function(value, index, object) {
                return iteratee(accumulator, value, index, object);
            });
            return accumulator;
        }
        /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */ function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
        }
        /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */ function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */ function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */ function values1(object) {
            return object == null ? [] : baseValues(object, keys(object));
        }
        /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */ function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
        }
        /*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */ function clamp(number, lower, upper) {
            if (upper === undefined) {
                upper = lower;
                lower = undefined;
            }
            if (upper !== undefined) {
                upper = toNumber(upper);
                upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined) {
                lower = toNumber(lower);
                lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
        }
        /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */ function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined) {
                end = start;
                start = 0;
            } else end = toFinite(end);
            number = toNumber(number);
            return baseInRange(number, start, end);
        }
        /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */ function random(lower, upper, floating) {
            if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) upper = floating = undefined;
            if (floating === undefined) {
                if (typeof upper == 'boolean') {
                    floating = upper;
                    upper = undefined;
                } else if (typeof lower == 'boolean') {
                    floating = lower;
                    lower = undefined;
                }
            }
            if (lower === undefined && upper === undefined) {
                lower = 0;
                upper = 1;
            } else {
                lower = toFinite(lower);
                if (upper === undefined) {
                    upper = lower;
                    lower = 0;
                } else upper = toFinite(upper);
            }
            if (lower > upper) {
                var temp = lower;
                lower = upper;
                upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
                var rand = nativeRandom();
                return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
            }
            return baseRandom(lower, upper);
        }
        /*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */ var camelCase = createCompounder(function(result, word, index) {
            word = word.toLowerCase();
            return result + (index ? capitalize(word) : word);
        });
        /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */ function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
        }
        /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dÃ©jÃ  vu');
     * // => 'deja vu'
     */ function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
        }
        /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */ function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
        }
        /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */ function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */ function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
        }
        /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */ var kebabCase = createCompounder(function(result, word, index) {
            return result + (index ? '-' : '') + word.toLowerCase();
        });
        /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */ var lowerCase = createCompounder(function(result, word, index) {
            return result + (index ? ' ' : '') + word.toLowerCase();
        });
        /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */ var lowerFirst = createCaseFirst('toLowerCase');
        /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */ function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) return string;
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */ function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */ function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */ function parseInt(string, radix, guard) {
            if (guard || radix == null) radix = 0;
            else if (radix) radix = +radix;
            return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
        }
        /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */ function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined) n = 1;
            else n = toInteger(n);
            return baseRepeat(toString(string), n);
        }
        /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */ function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */ var snakeCase = createCompounder(function(result, word, index) {
            return result + (index ? '_' : '') + word.toLowerCase();
        });
        /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */ function split(string, separator, limit) {
            if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) separator = limit = undefined;
            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) return [];
            string = toString(string);
            if (string && (typeof separator == 'string' || separator != null && !isRegExp(separator))) {
                separator = baseToString(separator);
                if (!separator && hasUnicode(string)) return castSlice(stringToArray(string), 0, limit);
            }
            return string.split(separator, limit);
        }
        /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */ var startCase = createCompounder(function(result, word, index) {
            return result + (index ? ' ' : '') + upperFirst(word);
        });
        /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */ function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
        }
        /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */ function template(string, options, guard) {
            // Based on John Resig's `tmpl` implementation
            // (http://ejohn.org/blog/javascript-micro-templating/)
            // and Laura Doktorova's doT.js (https://github.com/olado/doT).
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) options = undefined;
            string = toString(string);
            options = assignInWith({
            }, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({
            }, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            // Compile the regexp to match each delimiter.
            var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
            // Use a sourceURL for easier debugging.
            // The sourceURL gets injected into the source that's eval-ed, so be careful
            // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
            // and escape the comment, thus injecting code that gets evaled.
            var sourceURL = '//# sourceURL=' + (hasOwnProperty.call(options, 'sourceURL') ? (options.sourceURL + '').replace(/\s/g, ' ') : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue);
                // Escape characters that can't be included in string literals.
                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                // Replace delimiters with snippets.
                if (escapeValue) {
                    isEscaping = true;
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                }
                if (interpolateValue) source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                index = offset + match.length;
                // The JS engine embedded in Adobe products needs `match` returned in
                // order to produce the correct `offset` value.
                return match;
            });
            source += "';\n";
            // If `variable` is not specified wrap a with-statement around the generated
            // code to add the data object to the top of the scope chain.
            var variable = hasOwnProperty.call(options, 'variable') && options.variable;
            if (!variable) source = 'with (obj) {\n' + source + '\n}\n';
            else if (reForbiddenIdentifierChars.test(variable)) throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
            // Cleanup code by stripping empty strings.
            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
            // Frame code as the function body.
            source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
            var result = attempt(function() {
                return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
            });
            // Provide the compiled function's source by its `toString` method or
            // the `source` property as a convenience for inlining compiled templates.
            result.source = source;
            if (isError(result)) throw result;
            return result;
        }
        /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */ function toLower(value) {
            return toString(value).toLowerCase();
        }
        /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */ function toUpper(value) {
            return toString(value).toUpperCase();
        }
        /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */ function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) return baseTrim(string);
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join('');
        }
        /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */ function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) return string.slice(0, trimmedEndIndex(string) + 1);
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join('');
        }
        /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */ function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) return string.replace(reTrimStart, '');
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join('');
        }
        /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */ function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
                var separator = 'separator' in options ? options.separator : separator;
                length = 'length' in options ? toInteger(options.length) : length;
                omission = 'omission' in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
                var strSymbols = stringToArray(string);
                strLength = strSymbols.length;
            }
            if (length >= strLength) return string;
            var end = length - stringSize(omission);
            if (end < 1) return omission;
            var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);
            if (separator === undefined) return result + omission;
            if (strSymbols) end += result.length - end;
            if (isRegExp(separator)) {
                if (string.slice(end).search(separator)) {
                    var match, substring = result;
                    if (!separator.global) separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                    separator.lastIndex = 0;
                    while(match = separator.exec(substring))var newEnd = match.index;
                    result = result.slice(0, newEnd === undefined ? end : newEnd);
                }
            } else if (string.indexOf(baseToString(separator), end) != end) {
                var index = result.lastIndexOf(separator);
                if (index > -1) result = result.slice(0, index);
            }
            return result + omission;
        }
        /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */ function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */ var upperCase = createCompounder(function(result, word, index) {
            return result + (index ? ' ' : '') + word.toUpperCase();
        });
        /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */ var upperFirst = createCaseFirst('toUpperCase');
        /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */ function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined : pattern;
            if (pattern === undefined) return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            return string.match(pattern) || [];
        }
        /*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */ var attempt = baseRest(function(func, args) {
            try {
                return apply(func, undefined, args);
            } catch (e) {
                return isError(e) ? e : new Error(e);
            }
        });
        /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */ var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
                key = toKey(key);
                baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
        });
        /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */ function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
                if (typeof pair[1] != 'function') throw new TypeError(FUNC_ERROR_TEXT);
                return [
                    toIteratee(pair[0]),
                    pair[1]
                ];
            });
            return baseRest(function(args) {
                var index = -1;
                while(++index < length){
                    var pair = pairs[index];
                    if (apply(pair[0], this, args)) return apply(pair[1], this, args);
                }
            });
        }
        /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */ function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */ function constant(value) {
            return function() {
                return value;
            };
        }
        /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */ function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
        }
        /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */ var flow = createFlow();
        /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */ var flowRight = createFlow(true);
        /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */ function identity(value) {
            return value;
        }
        /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */ function iteratee1(func) {
            return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */ function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */ function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */ var method = baseRest(function(path, args) {
            return function(object) {
                return baseInvoke(object, path, args);
            };
        });
        /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */ var methodOf = baseRest(function(object, args) {
            return function(path) {
                return baseInvoke(object, path, args);
            };
        });
        /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */ function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                options = source;
                source = object;
                object = this;
                methodNames = baseFunctions(source, keys(source));
            }
            var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
                var func = source[methodName];
                object[methodName] = func;
                if (isFunc) object.prototype[methodName] = function() {
                    var chainAll = this.__chain__;
                    if (chain || chainAll) {
                        var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                        actions.push({
                            'func': func,
                            'args': arguments,
                            'thisArg': object
                        });
                        result.__chain__ = chainAll;
                        return result;
                    }
                    return func.apply(object, arrayPush([
                        this.value()
                    ], arguments));
                };
            });
            return object;
        }
        /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */ function noConflict() {
            if (root._ === this) root._ = oldDash;
            return this;
        }
        /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */ function noop() {
        // No operation performed.
        }
        /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */ function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
                return baseNth(args, n);
            });
        }
        /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */ var over = createOver(arrayMap);
        /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */ var overEvery = createOver(arrayEvery);
        /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */ var overSome = createOver(arraySome);
        /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */ function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */ function propertyOf(object) {
            return function(path) {
                return object == null ? undefined : baseGet(object, path);
            };
        }
        /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */ var range = createRange();
        /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */ var rangeRight = createRange(true);
        /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */ function stubArray() {
            return [];
        }
        /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */ function stubFalse() {
            return false;
        }
        /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */ function stubObject() {
            return {
            };
        }
        /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */ function stubString() {
            return '';
        }
        /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */ function stubTrue() {
            return true;
        }
        /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */ function times(n, iteratee) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) return [];
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee = getIteratee(iteratee);
            n -= MAX_ARRAY_LENGTH;
            var result = baseTimes(length, iteratee);
            while(++index < n)iteratee(index);
            return result;
        }
        /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */ function toPath(value) {
            if (isArray(value)) return arrayMap(value, toKey);
            return isSymbol(value) ? [
                value
            ] : copyArray(stringToPath(toString(value)));
        }
        /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */ function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
        }
        /*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */ var add = createMathOperation(function(augend, addend) {
            return augend + addend;
        }, 0);
        /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */ var ceil = createRound('ceil');
        /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */ var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
        }, 1);
        /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */ var floor = createRound('floor');
        /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */ function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
        }
        /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */ function maxBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
        }
        /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */ function mean(array) {
            return baseMean(array, identity);
        }
        /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */ function meanBy(array, iteratee) {
            return baseMean(array, getIteratee(iteratee, 2));
        }
        /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */ function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
        }
        /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */ function minBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
        }
        /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */ var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
        }, 1);
        /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */ var round = createRound('round');
        /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */ var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
        }, 0);
        /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */ function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
        }
        /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */ function sumBy(array, iteratee) {
            return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
        }
        /*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
        lodash.after = after;
        lodash.ary = ary1;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain1;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee1;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map1;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set1;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform1;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values1;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        // Add aliases.
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        // Add methods to `lodash.prototype`.
        mixin(lodash, lodash);
        /*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone1;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes1;
        lodash.indexOf = indexOf1;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result1;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.sample = sample;
        lodash.size = size1;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        // Add aliases.
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
            var source = {
            };
            baseForOwn(lodash, function(func, methodName) {
                if (!hasOwnProperty.call(lodash.prototype, methodName)) source[methodName] = func;
            });
            return source;
        }(), {
            'chain': false
        });
        /*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */ lodash.VERSION = VERSION;
        // Assign default placeholders.
        arrayEach([
            'bind',
            'bindKey',
            'curry',
            'curryRight',
            'partial',
            'partialRight'
        ], function(methodName) {
            lodash[methodName].placeholder = lodash;
        });
        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
        arrayEach([
            'drop',
            'take'
        ], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
                n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                if (result.__filtered__) result.__takeCount__ = nativeMin(n, result.__takeCount__);
                else result.__views__.push({
                    'size': nativeMin(n, MAX_ARRAY_LENGTH),
                    'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                });
                return result;
            };
            LazyWrapper.prototype[methodName + 'Right'] = function(n) {
                return this.reverse()[methodName](n).reverse();
            };
        });
        // Add `LazyWrapper` methods that accept an `iteratee` value.
        arrayEach([
            'filter',
            'map',
            'takeWhile'
        ], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee) {
                var result = this.clone();
                result.__iteratees__.push({
                    'iteratee': getIteratee(iteratee, 3),
                    'type': type
                });
                result.__filtered__ = result.__filtered__ || isFilter;
                return result;
            };
        });
        // Add `LazyWrapper` methods for `_.head` and `_.last`.
        arrayEach([
            'head',
            'last'
        ], function(methodName, index) {
            var takeName = 'take' + (index ? 'Right' : '');
            LazyWrapper.prototype[methodName] = function() {
                return this[takeName](1).value()[0];
            };
        });
        // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
        arrayEach([
            'initial',
            'tail'
        ], function(methodName, index) {
            var dropName = 'drop' + (index ? '' : 'Right');
            LazyWrapper.prototype[methodName] = function() {
                return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
        });
        LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == 'function') return new LazyWrapper(this);
            return this.map(function(value) {
                return baseInvoke(value, path, args);
            });
        });
        LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result = this;
            if (result.__filtered__ && (start > 0 || end < 0)) return new LazyWrapper(result);
            if (start < 0) result = result.takeRight(-start);
            else if (start) result = result.drop(start);
            if (end !== undefined) {
                end = toInteger(end);
                result = end < 0 ? result.dropRight(-end) : result.take(end - start);
            }
            return result;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
        };
        // Add `LazyWrapper` methods to `lodash.prototype`.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) return;
            lodash.prototype[methodName] = function() {
                var value1 = this.__wrapped__, args = isTaker ? [
                    1
                ] : arguments, isLazy = value1 instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value1);
                var interceptor = function(value) {
                    var result = lodashFunc.apply(lodash, arrayPush([
                        value
                    ], args));
                    return isTaker && chainAll ? result[0] : result;
                };
                if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) // Avoid lazy use if the iteratee has a "length" value other than `1`.
                isLazy = useLazy = false;
                var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                if (!retUnwrapped && useLazy) {
                    value1 = onlyLazy ? value1 : new LazyWrapper(this);
                    var result3 = func.apply(value1, args);
                    result3.__actions__.push({
                        'func': thru,
                        'args': [
                            interceptor
                        ],
                        'thisArg': undefined
                    });
                    return new LodashWrapper(result3, chainAll);
                }
                if (isUnwrapped && onlyLazy) return func.apply(this, args);
                result3 = this.thru(interceptor);
                return isUnwrapped ? isTaker ? result3.value()[0] : result3.value() : result3;
            };
        });
        // Add `Array` methods to `lodash.prototype`.
        arrayEach([
            'pop',
            'push',
            'shift',
            'sort',
            'splice',
            'unshift'
        ], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
                var args = arguments;
                if (retUnwrapped && !this.__chain__) {
                    var value = this.value();
                    return func.apply(isArray(value) ? value : [], args);
                }
                return this[chainName](function(value) {
                    return func.apply(isArray(value) ? value : [], args);
                });
            };
        });
        // Map minified method names to their real names.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
                var key = lodashFunc.name + '';
                if (!hasOwnProperty.call(realNames, key)) realNames[key] = [];
                realNames[key].push({
                    'name': methodName,
                    'func': lodashFunc
                });
            }
        });
        realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [
            {
                'name': 'wrapper',
                'func': undefined
            }
        ];
        // Add methods to `LazyWrapper`.
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        // Add chain sequence methods to the `lodash` wrapper.
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        // Add lazy aliases.
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) lodash.prototype[symIterator] = wrapperToIterator;
        return lodash;
    };
    /*--------------------------------------------------------------------------*/ // Export lodash.
    var _ = runInContext1();
    // Some AMD build optimizers, like r.js, check for condition patterns like:
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        // Expose Lodash on the global object to prevent errors when Lodash is
        // loaded by a script tag in the presence of an AMD loader.
        // See http://requirejs.org/docs/errors.html#mismatch for more details.
        // Use `_.noConflict` to remove Lodash from the global object.
        root._ = _;
        // Define as an anonymous module so, through path mapping, it can be
        // referenced as the "underscore" module.
        define(function() {
            return _;
        });
    } else if (freeModule) {
        // Export for Node.js.
        (freeModule.exports = _)._ = _;
        // Export for CommonJS support.
        freeExports._ = _;
    } else // Export to the global object.
    root._ = _;
}).call(this);

},{}],"dsdeP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cubic", ()=>_animationMjs.cubic
);
parcelHelpers.export(exports, "easeInOutCubic", ()=>_animationMjs.easeInOutCubic
);
parcelHelpers.export(exports, "castArray", ()=>_arraysMjs.castArray
);
parcelHelpers.export(exports, "unique", ()=>_arraysMjs.unique
);
parcelHelpers.export(exports, "isFirefox", ()=>_browserMjs.isFirefox
);
parcelHelpers.export(exports, "debugWarn", ()=>_errorMjs.debugWarn
);
parcelHelpers.export(exports, "throwError", ()=>_errorMjs.throwError
);
parcelHelpers.export(exports, "isKorean", ()=>_i18NMjs.isKorean
);
parcelHelpers.export(exports, "entriesOf", ()=>_objectsMjs.entriesOf
);
parcelHelpers.export(exports, "getPropByPath", ()=>_objectsMjs.getPropByPath
);
parcelHelpers.export(exports, "keysOf", ()=>_objectsMjs.keysOf
);
parcelHelpers.export(exports, "cAF", ()=>_rafMjs.cAF
);
parcelHelpers.export(exports, "rAF", ()=>_rafMjs.rAF
);
parcelHelpers.export(exports, "generateId", ()=>_randMjs.generateId
);
parcelHelpers.export(exports, "getRandomInt", ()=>_randMjs.getRandomInt
);
parcelHelpers.export(exports, "escapeStringRegexp", ()=>_stringsMjs.escapeStringRegexp
);
parcelHelpers.export(exports, "isEmpty", ()=>_typesMjs.isEmpty
);
parcelHelpers.export(exports, "isUndefined", ()=>_typesMjs.isUndefined
);
parcelHelpers.export(exports, "mutable", ()=>_typescriptMjs.mutable
);
parcelHelpers.export(exports, "attemptFocus", ()=>_ariaMjs.attemptFocus
);
parcelHelpers.export(exports, "focusNode", ()=>_ariaMjs.focusNode
);
parcelHelpers.export(exports, "getSibling", ()=>_ariaMjs.getSibling
);
parcelHelpers.export(exports, "isFocusable", ()=>_ariaMjs.isFocusable
);
parcelHelpers.export(exports, "isLeaf", ()=>_ariaMjs.isLeaf
);
parcelHelpers.export(exports, "isVisible", ()=>_ariaMjs.isVisible
);
parcelHelpers.export(exports, "obtainAllFocusableElements", ()=>_ariaMjs.obtainAllFocusableElements
);
parcelHelpers.export(exports, "triggerEvent", ()=>_ariaMjs.triggerEvent
);
parcelHelpers.export(exports, "composeEventHandlers", ()=>_eventMjs.composeEventHandlers
);
parcelHelpers.export(exports, "off", ()=>_eventMjs.off
);
parcelHelpers.export(exports, "on", ()=>_eventMjs.on
);
parcelHelpers.export(exports, "once", ()=>_eventMjs.once
);
parcelHelpers.export(exports, "whenMouse", ()=>_eventMjs.whenMouse
);
parcelHelpers.export(exports, "getClientXY", ()=>_positionMjs.getClientXY
);
parcelHelpers.export(exports, "getOffsetTop", ()=>_positionMjs.getOffsetTop
);
parcelHelpers.export(exports, "getOffsetTopDistance", ()=>_positionMjs.getOffsetTopDistance
);
parcelHelpers.export(exports, "isInContainer", ()=>_positionMjs.isInContainer
);
parcelHelpers.export(exports, "addResizeListener", ()=>_resizeEventMjs.addResizeListener
);
parcelHelpers.export(exports, "removeResizeListener", ()=>_resizeEventMjs.removeResizeListener
);
parcelHelpers.export(exports, "getScrollBarWidth", ()=>_scrollMjs.getScrollBarWidth
);
parcelHelpers.export(exports, "getScrollContainer", ()=>_scrollMjs.getScrollContainer
);
parcelHelpers.export(exports, "isScroll", ()=>_scrollMjs.isScroll
);
parcelHelpers.export(exports, "scrollIntoView", ()=>_scrollMjs.scrollIntoView
);
parcelHelpers.export(exports, "addClass", ()=>_styleMjs.addClass
);
parcelHelpers.export(exports, "classNameToArray", ()=>_styleMjs.classNameToArray
);
parcelHelpers.export(exports, "getStyle", ()=>_styleMjs.getStyle
);
parcelHelpers.export(exports, "hasClass", ()=>_styleMjs.hasClass
);
parcelHelpers.export(exports, "removeClass", ()=>_styleMjs.removeClass
);
parcelHelpers.export(exports, "removeStyle", ()=>_styleMjs.removeStyle
);
parcelHelpers.export(exports, "setStyle", ()=>_styleMjs.setStyle
);
parcelHelpers.export(exports, "changeGlobalNodesTarget", ()=>_globalNodeMjs.changeGlobalNodesTarget
);
parcelHelpers.export(exports, "createGlobalNode", ()=>_globalNodeMjs.createGlobalNode
);
parcelHelpers.export(exports, "removeGlobalNode", ()=>_globalNodeMjs.removeGlobalNode
);
parcelHelpers.export(exports, "CloseComponents", ()=>_iconMjs.CloseComponents
);
parcelHelpers.export(exports, "TypeComponents", ()=>_iconMjs.TypeComponents
);
parcelHelpers.export(exports, "TypeComponentsMap", ()=>_iconMjs.TypeComponentsMap
);
parcelHelpers.export(exports, "ValidateComponentsMap", ()=>_iconMjs.ValidateComponentsMap
);
parcelHelpers.export(exports, "iconPropType", ()=>_iconMjs.iconPropType
);
parcelHelpers.export(exports, "withInstall", ()=>_installMjs.withInstall
);
parcelHelpers.export(exports, "withInstallFunction", ()=>_installMjs.withInstallFunction
);
parcelHelpers.export(exports, "withNoopInstall", ()=>_installMjs.withNoopInstall
);
parcelHelpers.export(exports, "buildProp", ()=>_propsMjs.buildProp
);
parcelHelpers.export(exports, "buildProps", ()=>_propsMjs.buildProps
);
parcelHelpers.export(exports, "definePropType", ()=>_propsMjs.definePropType
);
parcelHelpers.export(exports, "propKey", ()=>_propsMjs.propKey
);
parcelHelpers.export(exports, "composeRefs", ()=>_refsMjs.composeRefs
);
parcelHelpers.export(exports, "addUnit", ()=>_styleMjs1.addUnit
);
parcelHelpers.export(exports, "isValidComponentSize", ()=>_validatorMjs.isValidComponentSize
);
parcelHelpers.export(exports, "isValidDatePickType", ()=>_validatorMjs.isValidDatePickType
);
parcelHelpers.export(exports, "PatchFlags", ()=>_vnodeMjs.PatchFlags
);
parcelHelpers.export(exports, "getFirstValidNode", ()=>_vnodeMjs.getFirstValidNode
);
parcelHelpers.export(exports, "getNormalizedProps", ()=>_vnodeMjs.getNormalizedProps
);
parcelHelpers.export(exports, "isComment", ()=>_vnodeMjs.isComment
);
parcelHelpers.export(exports, "isFragment", ()=>_vnodeMjs.isFragment
);
parcelHelpers.export(exports, "isTemplate", ()=>_vnodeMjs.isTemplate
);
parcelHelpers.export(exports, "isText", ()=>_vnodeMjs.isText
);
parcelHelpers.export(exports, "isValidElementNode", ()=>_vnodeMjs.isValidElementNode
);
parcelHelpers.export(exports, "renderBlock", ()=>_vnodeMjs.renderBlock
);
parcelHelpers.export(exports, "renderIf", ()=>_vnodeMjs.renderIf
);
parcelHelpers.export(exports, "camelize", ()=>_shared.camelize
);
parcelHelpers.export(exports, "capitalize", ()=>_shared.capitalize
);
parcelHelpers.export(exports, "hasOwn", ()=>_shared.hasOwn
);
parcelHelpers.export(exports, "hyphenate", ()=>_shared.hyphenate
);
parcelHelpers.export(exports, "isArray", ()=>_shared.isArray
);
parcelHelpers.export(exports, "isDate", ()=>_shared.isDate
);
parcelHelpers.export(exports, "isFunction", ()=>_shared.isFunction
);
parcelHelpers.export(exports, "isObject", ()=>_shared.isObject
);
parcelHelpers.export(exports, "isPromise", ()=>_shared.isPromise
);
parcelHelpers.export(exports, "isString", ()=>_shared.isString
);
parcelHelpers.export(exports, "isSymbol", ()=>_shared.isSymbol
);
parcelHelpers.export(exports, "kebabCase", ()=>_shared.hyphenate
);
parcelHelpers.export(exports, "isBoolean", ()=>_core.isBoolean
);
parcelHelpers.export(exports, "isNumber", ()=>_core.isNumber
);
parcelHelpers.export(exports, "isVNode", ()=>_vue.isVNode
);
var _indexMjs = require("./dom/index.mjs");
var _indexMjs1 = require("./vue/index.mjs");
var _animationMjs = require("./animation.mjs");
var _arraysMjs = require("./arrays.mjs");
var _browserMjs = require("./browser.mjs");
var _errorMjs = require("./error.mjs");
var _i18NMjs = require("./i18n.mjs");
var _objectsMjs = require("./objects.mjs");
var _rafMjs = require("./raf.mjs");
var _randMjs = require("./rand.mjs");
var _stringsMjs = require("./strings.mjs");
var _typesMjs = require("./types.mjs");
var _typescriptMjs = require("./typescript.mjs");
var _ariaMjs = require("./dom/aria.mjs");
var _eventMjs = require("./dom/event.mjs");
var _positionMjs = require("./dom/position.mjs");
var _resizeEventMjs = require("./dom/resize-event.mjs");
var _scrollMjs = require("./dom/scroll.mjs");
var _styleMjs = require("./dom/style.mjs");
var _globalNodeMjs = require("./vue/global-node.mjs");
var _iconMjs = require("./vue/icon.mjs");
var _installMjs = require("./vue/install.mjs");
var _propsMjs = require("./vue/props.mjs");
var _refsMjs = require("./vue/refs.mjs");
var _styleMjs1 = require("./vue/style.mjs");
var _validatorMjs = require("./vue/validator.mjs");
var _vnodeMjs = require("./vue/vnode.mjs");
var _shared = require("@vue/shared");
var _core = require("@vueuse/core");
var _vue = require("vue");

},{"./dom/index.mjs":"iyppA","./vue/index.mjs":"dBprX","./animation.mjs":"kaKZY","./arrays.mjs":"e9h0v","./browser.mjs":"9TDf1","./error.mjs":"2zPBN","./i18n.mjs":"5xQne","./objects.mjs":"1tXXV","./raf.mjs":"apnDl","./rand.mjs":"6d823","./strings.mjs":"hK6FY","./types.mjs":"4VsDK","./typescript.mjs":"bRl53","./dom/aria.mjs":"6roYP","./dom/event.mjs":"fnXSh","./dom/position.mjs":"cYzxx","./dom/resize-event.mjs":"TzEEU","./dom/scroll.mjs":"hpitc","./dom/style.mjs":"cA8Mp","./vue/global-node.mjs":"f1gd1","./vue/icon.mjs":"3YbE5","./vue/install.mjs":"4TMmv","./vue/props.mjs":"cpwWK","./vue/refs.mjs":"iuyFi","./vue/style.mjs":"pODHb","./vue/validator.mjs":"4UnBa","./vue/vnode.mjs":"ljPKw","@vue/shared":"3SM3y","@vueuse/core":"eEHP9","vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iyppA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "attemptFocus", ()=>_ariaMjs.attemptFocus
);
parcelHelpers.export(exports, "focusNode", ()=>_ariaMjs.focusNode
);
parcelHelpers.export(exports, "getSibling", ()=>_ariaMjs.getSibling
);
parcelHelpers.export(exports, "isFocusable", ()=>_ariaMjs.isFocusable
);
parcelHelpers.export(exports, "isLeaf", ()=>_ariaMjs.isLeaf
);
parcelHelpers.export(exports, "isVisible", ()=>_ariaMjs.isVisible
);
parcelHelpers.export(exports, "obtainAllFocusableElements", ()=>_ariaMjs.obtainAllFocusableElements
);
parcelHelpers.export(exports, "triggerEvent", ()=>_ariaMjs.triggerEvent
);
parcelHelpers.export(exports, "composeEventHandlers", ()=>_eventMjs.composeEventHandlers
);
parcelHelpers.export(exports, "off", ()=>_eventMjs.off
);
parcelHelpers.export(exports, "on", ()=>_eventMjs.on
);
parcelHelpers.export(exports, "once", ()=>_eventMjs.once
);
parcelHelpers.export(exports, "whenMouse", ()=>_eventMjs.whenMouse
);
parcelHelpers.export(exports, "getClientXY", ()=>_positionMjs.getClientXY
);
parcelHelpers.export(exports, "getOffsetTop", ()=>_positionMjs.getOffsetTop
);
parcelHelpers.export(exports, "getOffsetTopDistance", ()=>_positionMjs.getOffsetTopDistance
);
parcelHelpers.export(exports, "isInContainer", ()=>_positionMjs.isInContainer
);
parcelHelpers.export(exports, "addResizeListener", ()=>_resizeEventMjs.addResizeListener
);
parcelHelpers.export(exports, "removeResizeListener", ()=>_resizeEventMjs.removeResizeListener
);
parcelHelpers.export(exports, "getScrollBarWidth", ()=>_scrollMjs.getScrollBarWidth
);
parcelHelpers.export(exports, "getScrollContainer", ()=>_scrollMjs.getScrollContainer
);
parcelHelpers.export(exports, "isScroll", ()=>_scrollMjs.isScroll
);
parcelHelpers.export(exports, "scrollIntoView", ()=>_scrollMjs.scrollIntoView
);
parcelHelpers.export(exports, "addClass", ()=>_styleMjs.addClass
);
parcelHelpers.export(exports, "classNameToArray", ()=>_styleMjs.classNameToArray
);
parcelHelpers.export(exports, "getStyle", ()=>_styleMjs.getStyle
);
parcelHelpers.export(exports, "hasClass", ()=>_styleMjs.hasClass
);
parcelHelpers.export(exports, "removeClass", ()=>_styleMjs.removeClass
);
parcelHelpers.export(exports, "removeStyle", ()=>_styleMjs.removeStyle
);
parcelHelpers.export(exports, "setStyle", ()=>_styleMjs.setStyle
);
var _ariaMjs = require("./aria.mjs");
var _eventMjs = require("./event.mjs");
var _positionMjs = require("./position.mjs");
var _resizeEventMjs = require("./resize-event.mjs");
var _scrollMjs = require("./scroll.mjs");
var _styleMjs = require("./style.mjs");

},{"./aria.mjs":"6roYP","./event.mjs":"fnXSh","./position.mjs":"cYzxx","./resize-event.mjs":"TzEEU","./scroll.mjs":"hpitc","./style.mjs":"cA8Mp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6roYP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "attemptFocus", ()=>attemptFocus
);
parcelHelpers.export(exports, "focusNode", ()=>focusNode
);
parcelHelpers.export(exports, "getSibling", ()=>getSibling
);
parcelHelpers.export(exports, "isFocusable", ()=>isFocusable
);
parcelHelpers.export(exports, "isLeaf", ()=>isLeaf
);
parcelHelpers.export(exports, "isVisible", ()=>isVisible
);
parcelHelpers.export(exports, "obtainAllFocusableElements", ()=>obtainAllFocusableElements
);
parcelHelpers.export(exports, "triggerEvent", ()=>triggerEvent
);
const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
const isVisible = (element)=>{
    const computed = getComputedStyle(element);
    return computed.position === "fixed" ? false : element.offsetParent !== null;
};
const obtainAllFocusableElements = (element)=>{
    return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item)=>isFocusable(item) && isVisible(item)
    );
};
const isFocusable = (element)=>{
    if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) return true;
    if (element.disabled) return false;
    switch(element.nodeName){
        case "A":
            return !!element.href && element.rel !== "ignore";
        case "INPUT":
            return !(element.type === "hidden" || element.type === "file");
        case "BUTTON":
        case "SELECT":
        case "TEXTAREA":
            return true;
        default:
            return false;
    }
};
const attemptFocus = (element)=>{
    var _a;
    if (!isFocusable(element)) return false;
    (_a = element.focus) == null || _a.call(element);
    return document.activeElement === element;
};
const triggerEvent = function(elm, name, ...opts) {
    let eventName;
    if (name.includes("mouse") || name.includes("click")) eventName = "MouseEvents";
    else if (name.includes("key")) eventName = "KeyboardEvent";
    else eventName = "HTMLEvents";
    const evt = document.createEvent(eventName);
    evt.initEvent(name, ...opts);
    elm.dispatchEvent(evt);
    return elm;
};
const isLeaf = (el)=>!el.getAttribute("aria-owns")
;
const getSibling = (el, distance, elClass)=>{
    const { parentNode  } = el;
    if (!parentNode) return null;
    const siblings = parentNode.querySelectorAll(elClass);
    const index = Array.prototype.indexOf.call(siblings, el);
    return siblings[index + distance] || null;
};
const focusNode = (el)=>{
    if (!el) return;
    el.focus();
    !isLeaf(el) && el.click();
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fnXSh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "composeEventHandlers", ()=>composeEventHandlers
);
parcelHelpers.export(exports, "off", ()=>off
);
parcelHelpers.export(exports, "on", ()=>on
);
parcelHelpers.export(exports, "once", ()=>once
);
parcelHelpers.export(exports, "whenMouse", ()=>whenMouse
);
const on = (element, event, handler, useCapture = false)=>{
    if (element && event && handler) element == null || element.addEventListener(event, handler, useCapture);
};
const off = (element, event, handler, useCapture = false)=>{
    if (element && event && handler) element == null || element.removeEventListener(event, handler, useCapture);
};
const once = (el, event, fn)=>{
    const listener = function(...args) {
        if (fn) fn.apply(this, args);
        off(el, event, listener);
    };
    on(el, event, listener);
};
const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented =true  } = {
})=>{
    const handleEvent = (event)=>{
        const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
        if (checkForDefaultPrevented === false || !shouldPrevent) return oursHandler == null ? void 0 : oursHandler(event);
    };
    return handleEvent;
};
const whenMouse = (handler)=>{
    return (e)=>e.pointerType === "mouse" ? handler(e) : void 0
    ;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cYzxx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getClientXY", ()=>getClientXY
);
parcelHelpers.export(exports, "getOffsetTop", ()=>getOffsetTop
);
parcelHelpers.export(exports, "getOffsetTopDistance", ()=>getOffsetTopDistance
);
parcelHelpers.export(exports, "isInContainer", ()=>isInContainer
);
var _core = require("@vueuse/core");
const isInContainer = (el, container)=>{
    if (!_core.isClient || !el || !container) return false;
    const elRect = el.getBoundingClientRect();
    let containerRect;
    if (container instanceof Element) containerRect = container.getBoundingClientRect();
    else containerRect = {
        top: 0,
        right: window.innerWidth,
        bottom: window.innerHeight,
        left: 0
    };
    return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
};
const getOffsetTop = (el)=>{
    let offset = 0;
    let parent = el;
    while(parent){
        offset += parent.offsetTop;
        parent = parent.offsetParent;
    }
    return offset;
};
const getOffsetTopDistance = (el, containerEl)=>{
    return Math.abs(getOffsetTop(el) - getOffsetTop(containerEl));
};
const getClientXY = (event)=>{
    let clientX;
    let clientY;
    if (event.type === "touchend") {
        clientY = event.changedTouches[0].clientY;
        clientX = event.changedTouches[0].clientX;
    } else if (event.type.startsWith("touch")) {
        clientY = event.touches[0].clientY;
        clientX = event.touches[0].clientX;
    } else {
        clientY = event.clientY;
        clientX = event.clientX;
    }
    return {
        clientX,
        clientY
    };
};

},{"@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eEHP9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultMagicKeysAliasMap", ()=>DefaultMagicKeysAliasMap
);
parcelHelpers.export(exports, "StorageSerializers", ()=>StorageSerializers
);
parcelHelpers.export(exports, "SwipeDirection", ()=>SwipeDirection
);
parcelHelpers.export(exports, "TransitionPresets", ()=>TransitionPresets
);
parcelHelpers.export(exports, "asyncComputed", ()=>asyncComputed
);
parcelHelpers.export(exports, "autoResetRef", ()=>autoResetRef
);
parcelHelpers.export(exports, "breakpointsAntDesign", ()=>breakpointsAntDesign
);
parcelHelpers.export(exports, "breakpointsBootstrapV5", ()=>breakpointsBootstrapV5
);
parcelHelpers.export(exports, "breakpointsQuasar", ()=>breakpointsQuasar
);
parcelHelpers.export(exports, "breakpointsSematic", ()=>breakpointsSematic
);
parcelHelpers.export(exports, "breakpointsTailwind", ()=>breakpointsTailwind
);
parcelHelpers.export(exports, "breakpointsVuetify", ()=>breakpointsVuetify
);
parcelHelpers.export(exports, "computedInject", ()=>computedInject
);
parcelHelpers.export(exports, "createFetch", ()=>createFetch
);
parcelHelpers.export(exports, "createUnrefFn", ()=>createUnrefFn
);
parcelHelpers.export(exports, "defaultDocument", ()=>defaultDocument
);
parcelHelpers.export(exports, "defaultLocation", ()=>defaultLocation
);
parcelHelpers.export(exports, "defaultNavigator", ()=>defaultNavigator
);
parcelHelpers.export(exports, "defaultWindow", ()=>defaultWindow
);
parcelHelpers.export(exports, "getSSRHandler", ()=>getSSRHandler
);
parcelHelpers.export(exports, "onClickOutside", ()=>onClickOutside
);
parcelHelpers.export(exports, "onKeyDown", ()=>onKeyDown
);
parcelHelpers.export(exports, "onKeyPressed", ()=>onKeyPressed
);
parcelHelpers.export(exports, "onKeyStroke", ()=>onKeyStroke
);
parcelHelpers.export(exports, "onKeyUp", ()=>onKeyUp
);
parcelHelpers.export(exports, "onLongPress", ()=>onLongPress
);
parcelHelpers.export(exports, "onStartTyping", ()=>onStartTyping
);
parcelHelpers.export(exports, "setSSRHandler", ()=>setSSRHandler
);
parcelHelpers.export(exports, "templateRef", ()=>templateRef
);
parcelHelpers.export(exports, "unrefElement", ()=>unrefElement
);
parcelHelpers.export(exports, "useActiveElement", ()=>useActiveElement
);
parcelHelpers.export(exports, "useAsyncQueue", ()=>useAsyncQueue
);
parcelHelpers.export(exports, "useAsyncState", ()=>useAsyncState
);
parcelHelpers.export(exports, "useBase64", ()=>useBase64
);
parcelHelpers.export(exports, "useBattery", ()=>useBattery
);
parcelHelpers.export(exports, "useBreakpoints", ()=>useBreakpoints
);
parcelHelpers.export(exports, "useBroadcastChannel", ()=>useBroadcastChannel
);
parcelHelpers.export(exports, "useBrowserLocation", ()=>useBrowserLocation
);
parcelHelpers.export(exports, "useCached", ()=>useCached
);
parcelHelpers.export(exports, "useClamp", ()=>useClamp
);
parcelHelpers.export(exports, "useClipboard", ()=>useClipboard
);
parcelHelpers.export(exports, "useColorMode", ()=>useColorMode
);
parcelHelpers.export(exports, "useConfirmDialog", ()=>useConfirmDialog
);
parcelHelpers.export(exports, "useCssVar", ()=>useCssVar
);
parcelHelpers.export(exports, "useCycleList", ()=>useCycleList
);
parcelHelpers.export(exports, "useDark", ()=>useDark
);
parcelHelpers.export(exports, "useDebouncedRefHistory", ()=>useDebouncedRefHistory
);
parcelHelpers.export(exports, "useDeviceMotion", ()=>useDeviceMotion
);
parcelHelpers.export(exports, "useDeviceOrientation", ()=>useDeviceOrientation
);
parcelHelpers.export(exports, "useDevicePixelRatio", ()=>useDevicePixelRatio
);
parcelHelpers.export(exports, "useDevicesList", ()=>useDevicesList
);
parcelHelpers.export(exports, "useDisplayMedia", ()=>useDisplayMedia
);
parcelHelpers.export(exports, "useDocumentVisibility", ()=>useDocumentVisibility
);
parcelHelpers.export(exports, "useDraggable", ()=>useDraggable
);
parcelHelpers.export(exports, "useElementBounding", ()=>useElementBounding
);
parcelHelpers.export(exports, "useElementByPoint", ()=>useElementByPoint
);
parcelHelpers.export(exports, "useElementHover", ()=>useElementHover
);
parcelHelpers.export(exports, "useElementSize", ()=>useElementSize
);
parcelHelpers.export(exports, "useElementVisibility", ()=>useElementVisibility
);
parcelHelpers.export(exports, "useEventBus", ()=>useEventBus
);
parcelHelpers.export(exports, "useEventListener", ()=>useEventListener
);
parcelHelpers.export(exports, "useEventSource", ()=>useEventSource
);
parcelHelpers.export(exports, "useEyeDropper", ()=>useEyeDropper
);
parcelHelpers.export(exports, "useFavicon", ()=>useFavicon
);
parcelHelpers.export(exports, "useFetch", ()=>useFetch
);
parcelHelpers.export(exports, "useFocus", ()=>useFocus
);
parcelHelpers.export(exports, "useFocusWithin", ()=>useFocusWithin
);
parcelHelpers.export(exports, "useFps", ()=>useFps
);
parcelHelpers.export(exports, "useFullscreen", ()=>useFullscreen
);
parcelHelpers.export(exports, "useGeolocation", ()=>useGeolocation
);
parcelHelpers.export(exports, "useIdle", ()=>useIdle
);
parcelHelpers.export(exports, "useInfiniteScroll", ()=>useInfiniteScroll
);
parcelHelpers.export(exports, "useIntersectionObserver", ()=>useIntersectionObserver
);
parcelHelpers.export(exports, "useKeyModifier", ()=>useKeyModifier
);
parcelHelpers.export(exports, "useLocalStorage", ()=>useLocalStorage
);
parcelHelpers.export(exports, "useMagicKeys", ()=>useMagicKeys
);
parcelHelpers.export(exports, "useManualRefHistory", ()=>useManualRefHistory
);
parcelHelpers.export(exports, "useMediaControls", ()=>useMediaControls
);
parcelHelpers.export(exports, "useMediaQuery", ()=>useMediaQuery
);
parcelHelpers.export(exports, "useMemoize", ()=>useMemoize
);
parcelHelpers.export(exports, "useMemory", ()=>useMemory
);
parcelHelpers.export(exports, "useMounted", ()=>useMounted
);
parcelHelpers.export(exports, "useMouse", ()=>useMouse
);
parcelHelpers.export(exports, "useMouseInElement", ()=>useMouseInElement
);
parcelHelpers.export(exports, "useMousePressed", ()=>useMousePressed
);
parcelHelpers.export(exports, "useMutationObserver", ()=>useMutationObserver
);
parcelHelpers.export(exports, "useNavigatorLanguage", ()=>useNavigatorLanguage
);
parcelHelpers.export(exports, "useNetwork", ()=>useNetwork
);
parcelHelpers.export(exports, "useNow", ()=>useNow
);
parcelHelpers.export(exports, "useOffsetPagination", ()=>useOffsetPagination
);
parcelHelpers.export(exports, "useOnline", ()=>useOnline
);
parcelHelpers.export(exports, "usePageLeave", ()=>usePageLeave
);
parcelHelpers.export(exports, "useParallax", ()=>useParallax
);
parcelHelpers.export(exports, "usePermission", ()=>usePermission
);
parcelHelpers.export(exports, "usePointer", ()=>usePointer
);
parcelHelpers.export(exports, "usePointerSwipe", ()=>usePointerSwipe
);
parcelHelpers.export(exports, "usePreferredColorScheme", ()=>usePreferredColorScheme
);
parcelHelpers.export(exports, "usePreferredDark", ()=>usePreferredDark
);
parcelHelpers.export(exports, "usePreferredLanguages", ()=>usePreferredLanguages
);
parcelHelpers.export(exports, "useRafFn", ()=>useRafFn
);
parcelHelpers.export(exports, "useRefHistory", ()=>useRefHistory
);
parcelHelpers.export(exports, "useResizeObserver", ()=>useResizeObserver
);
parcelHelpers.export(exports, "useScreenSafeArea", ()=>useScreenSafeArea
);
parcelHelpers.export(exports, "useScriptTag", ()=>useScriptTag
);
parcelHelpers.export(exports, "useScroll", ()=>useScroll
);
parcelHelpers.export(exports, "useScrollLock", ()=>useScrollLock
);
parcelHelpers.export(exports, "useSessionStorage", ()=>useSessionStorage
);
parcelHelpers.export(exports, "useShare", ()=>useShare
);
parcelHelpers.export(exports, "useSpeechRecognition", ()=>useSpeechRecognition
);
parcelHelpers.export(exports, "useSpeechSynthesis", ()=>useSpeechSynthesis
);
parcelHelpers.export(exports, "useStorage", ()=>useStorage
);
parcelHelpers.export(exports, "useStorageAsync", ()=>useStorageAsync
);
parcelHelpers.export(exports, "useStyleTag", ()=>useStyleTag
);
parcelHelpers.export(exports, "useSwipe", ()=>useSwipe
);
parcelHelpers.export(exports, "useTemplateRefsList", ()=>useTemplateRefsList
);
parcelHelpers.export(exports, "useTextSelection", ()=>useTextSelection
);
parcelHelpers.export(exports, "useThrottledRefHistory", ()=>useThrottledRefHistory
);
parcelHelpers.export(exports, "useTimeAgo", ()=>useTimeAgo
);
parcelHelpers.export(exports, "useTimestamp", ()=>useTimestamp
);
parcelHelpers.export(exports, "useTitle", ()=>useTitle
);
parcelHelpers.export(exports, "useTransition", ()=>useTransition
);
parcelHelpers.export(exports, "useUrlSearchParams", ()=>useUrlSearchParams
);
parcelHelpers.export(exports, "useUserMedia", ()=>useUserMedia
);
parcelHelpers.export(exports, "useVModel", ()=>useVModel
);
parcelHelpers.export(exports, "useVModels", ()=>useVModels
);
parcelHelpers.export(exports, "useVibrate", ()=>useVibrate
);
parcelHelpers.export(exports, "useVirtualList", ()=>useVirtualList
);
parcelHelpers.export(exports, "useWakeLock", ()=>useWakeLock
);
parcelHelpers.export(exports, "useWebNotification", ()=>useWebNotification
);
parcelHelpers.export(exports, "useWebSocket", ()=>useWebSocket
);
parcelHelpers.export(exports, "useWebWorker", ()=>useWebWorker
);
parcelHelpers.export(exports, "useWebWorkerFn", ()=>useWebWorkerFn
);
parcelHelpers.export(exports, "useWindowFocus", ()=>useWindowFocus
);
parcelHelpers.export(exports, "useWindowScroll", ()=>useWindowScroll
);
parcelHelpers.export(exports, "useWindowSize", ()=>useWindowSize
);
var _shared = require("@vueuse/shared");
var _vueDemi = require("vue-demi");
var _core = require("@vueuse/core");
parcelHelpers.exportAll(_shared, exports);
var global = arguments[3];
function asyncComputed(evaluationCallback, initialState1, optionsOrRef) {
    let options;
    if (_vueDemi.isRef(optionsOrRef)) options = {
        evaluating: optionsOrRef
    };
    else options = optionsOrRef || {
    };
    const { lazy =false , evaluating , onError =_shared.noop  } = options;
    const started = _vueDemi.ref(!lazy);
    const current = _vueDemi.ref(initialState1);
    let counter = 0;
    _vueDemi.watchEffect(async (onInvalidate)=>{
        if (!started.value) return;
        counter++;
        const counterAtBeginning = counter;
        let hasFinished = false;
        if (evaluating) Promise.resolve().then(()=>{
            evaluating.value = true;
        });
        try {
            const result = await evaluationCallback((cancelCallback)=>{
                onInvalidate(()=>{
                    if (evaluating) evaluating.value = false;
                    if (!hasFinished) cancelCallback();
                });
            });
            if (counterAtBeginning === counter) current.value = result;
        } catch (e) {
            onError(e);
        } finally{
            if (evaluating) evaluating.value = false;
            hasFinished = true;
        }
    });
    if (lazy) return _vueDemi.computed(()=>{
        started.value = true;
        return current.value;
    });
    else return current;
}
function autoResetRef(defaultValue, afterMs = 10000) {
    return _vueDemi.customRef((track, trigger)=>{
        let value = defaultValue;
        let timer;
        const resetAfter = ()=>setTimeout(()=>{
                value = defaultValue;
                trigger();
            }, _vueDemi.unref(afterMs))
        ;
        return {
            get () {
                track();
                return value;
            },
            set (newValue) {
                value = newValue;
                trigger();
                clearTimeout(timer);
                timer = resetAfter();
            }
        };
    });
}
function computedInject(key, options, defaultSource, treatDefaultAsFactory) {
    let source = _vueDemi.inject(key);
    if (defaultSource) source = _vueDemi.inject(key, defaultSource);
    if (treatDefaultAsFactory) source = _vueDemi.inject(key, defaultSource, treatDefaultAsFactory);
    if (typeof options === "function") return _vueDemi.computed((ctx)=>options(source, ctx)
    );
    else return _vueDemi.computed({
        get: (ctx)=>options.get(source, ctx)
        ,
        set: options.set
    });
}
const createUnrefFn = (fn)=>{
    return function(...args) {
        return fn.apply(this, args.map((i)=>_vueDemi.unref(i)
        ));
    };
};
function unrefElement(elRef) {
    var _a1;
    const plain = _vueDemi.unref(elRef);
    return (_a1 = plain == null ? void 0 : plain.$el) != null ? _a1 : plain;
}
const defaultWindow = _shared.isClient ? window : void 0;
const defaultDocument = _shared.isClient ? window.document : void 0;
const defaultNavigator = _shared.isClient ? window.navigator : void 0;
const defaultLocation = _shared.isClient ? window.location : void 0;
function useEventListener(...args) {
    let target;
    let event;
    let listener;
    let options;
    if (_shared.isString(args[0])) {
        [event, listener, options] = args;
        target = defaultWindow;
    } else [target, event, listener, options] = args;
    if (!target) return _shared.noop;
    let cleanup = _shared.noop;
    const stopWatch = _vueDemi.watch(()=>_vueDemi.unref(target)
    , (el)=>{
        cleanup();
        if (!el) return;
        el.addEventListener(event, listener, options);
        cleanup = ()=>{
            el.removeEventListener(event, listener, options);
            cleanup = _shared.noop;
        };
    }, {
        immediate: true,
        flush: "post"
    });
    const stop = ()=>{
        stopWatch();
        cleanup();
    };
    _shared.tryOnScopeDispose(stop);
    return stop;
}
function onClickOutside(target, handler, options = {
}) {
    const { window =defaultWindow , ignore  } = options;
    if (!window) return;
    const shouldListen = _vueDemi.ref(true);
    const listener = (event)=>{
        const el = unrefElement(target);
        const composedPath = event.composedPath();
        if (!el || el === event.target || composedPath.includes(el) || !shouldListen.value) return;
        if (ignore && ignore.length > 0) {
            if (ignore.some((target2)=>{
                const el2 = unrefElement(target2);
                return el2 && (event.target === el2 || composedPath.includes(el2));
            })) return;
        }
        handler(event);
    };
    const cleanup = [
        useEventListener(window, "click", listener, {
            passive: true,
            capture: true
        }),
        useEventListener(window, "pointerdown", (e)=>{
            const el = unrefElement(target);
            shouldListen.value = !!el && !e.composedPath().includes(el);
        }, {
            passive: true
        })
    ];
    const stop = ()=>cleanup.forEach((fn)=>fn()
        )
    ;
    return stop;
}
var __defProp$h = Object.defineProperty;
var __defProps$9 = Object.defineProperties;
var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$j = Object.getOwnPropertySymbols;
var __hasOwnProp$j = Object.prototype.hasOwnProperty;
var __propIsEnum$j = Object.prototype.propertyIsEnumerable;
var __defNormalProp$h = (obj, key, value)=>key in obj ? __defProp$h(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$h = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$j.call(b, prop)) __defNormalProp$h(a, prop, b[prop]);
    if (__getOwnPropSymbols$j) {
        for (var prop of __getOwnPropSymbols$j(b))if (__propIsEnum$j.call(b, prop)) __defNormalProp$h(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$9 = (a, b)=>__defProps$9(a, __getOwnPropDescs$9(b))
;
const createKeyPredicate = (keyFilter)=>{
    if (typeof keyFilter === "function") return keyFilter;
    else if (typeof keyFilter === "string") return (event)=>event.key === keyFilter
    ;
    else if (Array.isArray(keyFilter)) return (event)=>keyFilter.includes(event.key)
    ;
    else if (keyFilter) return ()=>true
    ;
    else return ()=>false
    ;
};
function onKeyStroke(key, handler, options = {
}) {
    const { target =defaultWindow , eventName ="keydown" , passive =false  } = options;
    const predicate = createKeyPredicate(key);
    const listener = (e)=>{
        if (predicate(e)) handler(e);
    };
    return useEventListener(target, eventName, listener, passive);
}
function onKeyDown(key, handler, options = {
}) {
    return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$h({
    }, options), {
        eventName: "keydown"
    }));
}
function onKeyPressed(key, handler, options = {
}) {
    return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$h({
    }, options), {
        eventName: "keypress"
    }));
}
function onKeyUp(key, handler, options = {
}) {
    return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$h({
    }, options), {
        eventName: "keyup"
    }));
}
const DEFAULT_DELAY = 500;
function onLongPress(target, handler, options) {
    const elementRef = _vueDemi.computed(()=>_core.unrefElement(target)
    );
    let timeout = null;
    function clear() {
        if (timeout != null) {
            clearTimeout(timeout);
            timeout = null;
        }
    }
    function onDown(ev) {
        var _a2;
        clear();
        timeout = setTimeout(()=>handler(ev)
        , (_a2 = options == null ? void 0 : options.delay) != null ? _a2 : DEFAULT_DELAY);
    }
    _core.useEventListener(elementRef, "pointerdown", onDown);
    _core.useEventListener(elementRef, "pointerup", clear);
    _core.useEventListener(elementRef, "pointerleave", clear);
}
const isFocusedElementEditable = ()=>{
    const { activeElement , body  } = document;
    if (!activeElement) return false;
    if (activeElement === body) return false;
    switch(activeElement.tagName){
        case "INPUT":
        case "TEXTAREA":
            return true;
    }
    return activeElement.hasAttribute("contenteditable");
};
const isTypedCharValid = ({ keyCode , metaKey , ctrlKey , altKey  })=>{
    if (metaKey || ctrlKey || altKey) return false;
    if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105) return true;
    if (keyCode >= 65 && keyCode <= 90) return true;
    return false;
};
function onStartTyping(callback, options = {
}) {
    const { document: document2 = defaultDocument  } = options;
    const keydown = (event)=>{
        !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);
    };
    if (document2) useEventListener(document2, "keydown", keydown, {
        passive: true
    });
}
function templateRef(key, initialValue = null) {
    const instance = _vueDemi.getCurrentInstance();
    let _trigger = ()=>{
    };
    const element = _vueDemi.customRef((track, trigger)=>{
        _trigger = trigger;
        return {
            get () {
                var _a3, _b1;
                track();
                return (_b1 = (_a3 = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a3.$refs[key]) != null ? _b1 : initialValue;
            },
            set () {
            }
        };
    });
    _shared.tryOnMounted(_trigger);
    _vueDemi.onUpdated(_trigger);
    return element;
}
function useActiveElement(options = {
}) {
    const { window =defaultWindow  } = options;
    const counter = _vueDemi.ref(0);
    if (window) {
        useEventListener(window, "blur", ()=>counter.value += 1
        , true);
        useEventListener(window, "focus", ()=>counter.value += 1
        , true);
    }
    return _vueDemi.computed(()=>{
        counter.value;
        return window == null ? void 0 : window.document.activeElement;
    });
}
function useAsyncQueue(tasks, options = {
}) {
    const { interrupt =true , onError =_shared.noop , onFinished =_shared.noop  } = options;
    const promiseState = {
        pending: "pending",
        rejected: "rejected",
        fulfilled: "fulfilled"
    };
    const initialResult = Array.from(new Array(tasks.length), ()=>({
            state: promiseState.pending,
            data: null
        })
    );
    const result = _vueDemi.reactive(initialResult);
    const activeIndex = _vueDemi.ref(-1);
    if (!tasks || tasks.length === 0) {
        onFinished();
        return {
            activeIndex,
            result
        };
    }
    function updateResult(state, res) {
        activeIndex.value++;
        result[activeIndex.value].data = res;
        result[activeIndex.value].state = state;
    }
    tasks.reduce((prev, curr)=>{
        return prev.then((prevRes)=>{
            var _a4;
            if (((_a4 = result[activeIndex.value]) == null ? void 0 : _a4.state) === promiseState.rejected && interrupt) {
                onFinished();
                return;
            }
            return curr(prevRes).then((currentRes)=>{
                updateResult(promiseState.fulfilled, currentRes);
                activeIndex.value === tasks.length - 1 && onFinished();
                return currentRes;
            });
        }).catch((e)=>{
            updateResult(promiseState.rejected, e);
            onError();
            return e;
        });
    }, Promise.resolve());
    return {
        activeIndex,
        result
    };
}
function useAsyncState(promise, initialState2, options) {
    const { immediate =true , delay =0 , onError =_shared.noop , resetOnExecute =true , shallow =true  } = options != null ? options : {
    };
    const state = shallow ? _vueDemi.shallowRef(initialState2) : _vueDemi.ref(initialState2);
    const isReady = _vueDemi.ref(false);
    const isLoading = _vueDemi.ref(false);
    const error = _vueDemi.ref(void 0);
    async function execute(delay2 = 0, ...args) {
        if (resetOnExecute) state.value = initialState2;
        error.value = void 0;
        isReady.value = false;
        isLoading.value = true;
        if (delay2 > 0) await _shared.promiseTimeout(delay2);
        const _promise = typeof promise === "function" ? promise(...args) : promise;
        try {
            const data = await _promise;
            state.value = data;
            isReady.value = true;
        } catch (e) {
            error.value = e;
            onError(e);
        }
        isLoading.value = false;
        return state.value;
    }
    if (immediate) execute(delay);
    return {
        state,
        isReady,
        isLoading,
        error,
        execute
    };
}
function useBase64(target, options) {
    const base64 = _vueDemi.ref("");
    const promise = _vueDemi.ref();
    function execute() {
        if (!_shared.isClient) return;
        promise.value = new Promise((resolve, reject)=>{
            try {
                const _target = _vueDemi.unref(target);
                if (_target === void 0 || _target === null) resolve("");
                else if (typeof _target === "string") resolve(blobToBase64(new Blob([
                    _target
                ], {
                    type: "text/plain"
                })));
                else if (_target instanceof Blob) resolve(blobToBase64(_target));
                else if (_target instanceof ArrayBuffer) resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));
                else if (_target instanceof HTMLCanvasElement) resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
                else if (_target instanceof HTMLImageElement) {
                    const img = _target.cloneNode(false);
                    img.crossOrigin = "Anonymous";
                    imgLoaded(img).then(()=>{
                        const canvas = document.createElement("canvas");
                        const ctx = canvas.getContext("2d");
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
                    }).catch(reject);
                } else reject(new Error("target is unsupported types"));
            } catch (error) {
                reject(error);
            }
        });
        promise.value.then((res)=>base64.value = res
        );
        return promise.value;
    }
    _vueDemi.watch(target, execute, {
        immediate: true
    });
    return {
        base64,
        promise,
        execute
    };
}
function imgLoaded(img) {
    return new Promise((resolve, reject)=>{
        if (!img.complete) {
            img.onload = ()=>{
                resolve();
            };
            img.onerror = reject;
        } else resolve();
    });
}
function blobToBase64(blob) {
    return new Promise((resolve, reject)=>{
        const fr = new FileReader();
        fr.onload = (e)=>{
            resolve(e.target.result);
        };
        fr.onerror = reject;
        fr.readAsDataURL(blob);
    });
}
function useBattery({ navigator =defaultNavigator  } = {
}) {
    const events1 = [
        "chargingchange",
        "chargingtimechange",
        "dischargingtimechange",
        "levelchange"
    ];
    const isSupported = navigator && "getBattery" in navigator;
    const charging = _vueDemi.ref(false);
    const chargingTime = _vueDemi.ref(0);
    const dischargingTime = _vueDemi.ref(0);
    const level = _vueDemi.ref(1);
    let battery;
    function updateBatteryInfo() {
        charging.value = this.charging;
        chargingTime.value = this.chargingTime || 0;
        dischargingTime.value = this.dischargingTime || 0;
        level.value = this.level;
    }
    if (isSupported) navigator.getBattery().then((_battery)=>{
        battery = _battery;
        updateBatteryInfo.call(battery);
        for (const event of events1)useEventListener(battery, event, updateBatteryInfo, {
            passive: true
        });
    });
    return {
        isSupported,
        charging,
        chargingTime,
        dischargingTime,
        level
    };
}
function useMediaQuery(query, options = {
}) {
    const { window =defaultWindow  } = options;
    let mediaQuery;
    const matches = _vueDemi.ref(false);
    const update = ()=>{
        if (!window) return;
        if (!mediaQuery) mediaQuery = window.matchMedia(query);
        matches.value = mediaQuery.matches;
    };
    _shared.tryOnMounted(()=>{
        update();
        if (!mediaQuery) return;
        if ("addEventListener" in mediaQuery) mediaQuery.addEventListener("change", update);
        else mediaQuery.addListener(update);
        _shared.tryOnScopeDispose(()=>{
            if ("removeEventListener" in update) mediaQuery.removeEventListener("change", update);
            else mediaQuery.removeListener(update);
        });
    });
    return matches;
}
const breakpointsTailwind = {
    "sm": 640,
    "md": 768,
    "lg": 1024,
    "xl": 1280,
    "2xl": 1536
};
const breakpointsBootstrapV5 = {
    sm: 576,
    md: 768,
    lg: 992,
    xl: 1200,
    xxl: 1400
};
const breakpointsVuetify = {
    xs: 600,
    sm: 960,
    md: 1264,
    lg: 1904
};
const breakpointsAntDesign = {
    xs: 480,
    sm: 576,
    md: 768,
    lg: 992,
    xl: 1200,
    xxl: 1600
};
const breakpointsQuasar = {
    xs: 600,
    sm: 1024,
    md: 1440,
    lg: 1920
};
const breakpointsSematic = {
    mobileS: 320,
    mobileM: 375,
    mobileL: 425,
    tablet: 768,
    laptop: 1024,
    laptopL: 1440,
    desktop4K: 2560
};
var __defProp$g = Object.defineProperty;
var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
var __hasOwnProp$i = Object.prototype.hasOwnProperty;
var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
var __defNormalProp$g = (obj, key, value)=>key in obj ? __defProp$g(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$g = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$i.call(b, prop)) __defNormalProp$g(a, prop, b[prop]);
    if (__getOwnPropSymbols$i) {
        for (var prop of __getOwnPropSymbols$i(b))if (__propIsEnum$i.call(b, prop)) __defNormalProp$g(a, prop, b[prop]);
    }
    return a;
};
function useBreakpoints(breakpoints, options = {
}) {
    function getValue1(k, delta) {
        let v = breakpoints[k];
        if (delta != null) v = _shared.increaseWithUnit(v, delta);
        if (typeof v === "number") v = `${v}px`;
        return v;
    }
    const { window =defaultWindow  } = options;
    function match(query) {
        if (!window) return false;
        return window.matchMedia(query).matches;
    }
    const greater = (k)=>{
        return useMediaQuery(`(min-width: ${getValue1(k)})`, options);
    };
    const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k)=>{
        Object.defineProperty(shortcuts, k, {
            get: ()=>greater(k)
            ,
            enumerable: true,
            configurable: true
        });
        return shortcuts;
    }, {
    });
    return __spreadValues$g({
        greater,
        smaller (k) {
            return useMediaQuery(`(max-width: ${getValue1(k, -0.1)})`, options);
        },
        between (a, b) {
            return useMediaQuery(`(min-width: ${getValue1(a)}) and (max-width: ${getValue1(b, -0.1)})`, options);
        },
        isGreater (k) {
            return match(`(min-width: ${getValue1(k)})`);
        },
        isSmaller (k) {
            return match(`(max-width: ${getValue1(k, -0.1)})`);
        },
        isInBetween (a, b) {
            return match(`(min-width: ${getValue1(a)}) and (max-width: ${getValue1(b, -0.1)})`);
        }
    }, shortcutMethods);
}
const useBroadcastChannel = (options)=>{
    const { name , window =defaultWindow  } = options;
    const isSupported = window && "BroadcastChannel" in window;
    const isClosed = _vueDemi.ref(false);
    const channel = _vueDemi.ref();
    const data = _vueDemi.ref();
    const error = _vueDemi.ref(null);
    const post = (data2)=>{
        if (channel.value) channel.value.postMessage(data2);
    };
    const close = ()=>{
        if (channel.value) channel.value.close();
        isClosed.value = true;
    };
    if (isSupported) _shared.tryOnMounted(()=>{
        error.value = null;
        channel.value = new BroadcastChannel(name);
        channel.value.addEventListener("message", (e)=>{
            data.value = e.data;
        }, {
            passive: true
        });
        channel.value.addEventListener("messageerror", (e)=>{
            error.value = e;
        }, {
            passive: true
        });
        channel.value.addEventListener("close", ()=>{
            isClosed.value = true;
        });
    });
    _shared.tryOnScopeDispose(()=>{
        close();
    });
    return {
        isSupported,
        channel,
        data,
        post,
        close,
        error,
        isClosed
    };
};
function useBrowserLocation({ window =defaultWindow  } = {
}) {
    const buildState = (trigger)=>{
        const { state: state2 , length  } = (window == null ? void 0 : window.history) || {
        };
        const { hash , host , hostname , href , origin , pathname , port , protocol , search  } = (window == null ? void 0 : window.location) || {
        };
        return {
            trigger,
            state: state2,
            length,
            hash,
            host,
            hostname,
            href,
            origin,
            pathname,
            port,
            protocol,
            search
        };
    };
    const state = _vueDemi.ref(buildState("load"));
    if (window) {
        useEventListener(window, "popstate", ()=>state.value = buildState("popstate")
        , {
            passive: true
        });
        useEventListener(window, "hashchange", ()=>state.value = buildState("hashchange")
        , {
            passive: true
        });
    }
    return state;
}
function useCached(refValue, comparator = (a, b)=>a === b
, watchOptions) {
    const cachedValue = _vueDemi.ref(refValue.value);
    _vueDemi.watch(()=>refValue.value
    , (value)=>{
        if (!comparator(value, cachedValue.value)) cachedValue.value = value;
    }, watchOptions);
    return cachedValue;
}
function useClamp(value, min, max) {
    const _value = _vueDemi.ref(value);
    return _vueDemi.computed({
        get () {
            return _shared.clamp(_value.value, _vueDemi.unref(min), _vueDemi.unref(max));
        },
        set (value2) {
            _value.value = _shared.clamp(value2, _vueDemi.unref(min), _vueDemi.unref(max));
        }
    });
}
function useClipboard(options = {
}) {
    const { navigator =defaultNavigator , read =false , source , copiedDuring =1500  } = options;
    const events2 = [
        "copy",
        "cut"
    ];
    const isSupported = Boolean(navigator && "clipboard" in navigator);
    const text = _vueDemi.ref("");
    const copied = _vueDemi.ref(false);
    const timeout = _shared.useTimeoutFn(()=>copied.value = false
    , copiedDuring);
    function updateText() {
        navigator.clipboard.readText().then((value)=>{
            text.value = value;
        });
    }
    if (isSupported && read) for (const event of events2)useEventListener(event, updateText);
    async function copy(value = _vueDemi.unref(source)) {
        if (isSupported && value != null) {
            await navigator.clipboard.writeText(value);
            text.value = value;
            copied.value = true;
            timeout.start();
        }
    }
    return {
        isSupported,
        text,
        copied,
        copy
    };
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {
};
const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {
};
const handlers = _global[globalKey];
function getSSRHandler(key, fallback) {
    return handlers[key] || fallback;
}
function setSSRHandler(key, fn) {
    handlers[key] = fn;
}
function guessSerializerType(rawInit) {
    return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
    boolean: {
        read: (v)=>v === "true"
        ,
        write: (v)=>String(v)
    },
    object: {
        read: (v)=>JSON.parse(v)
        ,
        write: (v)=>JSON.stringify(v)
    },
    number: {
        read: (v)=>Number.parseFloat(v)
        ,
        write: (v)=>String(v)
    },
    any: {
        read: (v)=>v
        ,
        write: (v)=>String(v)
    },
    string: {
        read: (v)=>v
        ,
        write: (v)=>String(v)
    },
    map: {
        read: (v)=>new Map(JSON.parse(v))
        ,
        write: (v)=>JSON.stringify(Array.from(v.entries()))
    },
    set: {
        read: (v)=>new Set(JSON.parse(v))
        ,
        write: (v)=>JSON.stringify(Array.from(v.entries()))
    }
};
function useStorage(key, initialValue, storage, options = {
}) {
    var _a5;
    const { flush ="pre" , deep =true , listenToStorageChanges =true , writeDefaults =true , shallow , window =defaultWindow , eventFilter , onError =(e)=>{
        console.error(e);
    }  } = options;
    const rawInit = _vueDemi.unref(initialValue);
    const type = guessSerializerType(rawInit);
    const data = (shallow ? _vueDemi.shallowRef : _vueDemi.ref)(initialValue);
    const serializer = (_a5 = options.serializer) != null ? _a5 : StorageSerializers[type];
    if (!storage) try {
        storage = getSSRHandler("getDefaultStorage", ()=>{
            var _a2;
            return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
        })();
    } catch (e1) {
        onError(e1);
    }
    function read(event) {
        if (!storage || event && event.key !== key) return;
        try {
            const rawValue = event ? event.newValue : storage.getItem(key);
            if (rawValue == null) {
                data.value = rawInit;
                if (writeDefaults && rawInit !== null) storage.setItem(key, serializer.write(rawInit));
            } else if (typeof rawValue !== "string") data.value = rawValue;
            else data.value = serializer.read(rawValue);
        } catch (e) {
            onError(e);
        }
    }
    read();
    if (window && listenToStorageChanges) useEventListener(window, "storage", (e)=>setTimeout(()=>read(e)
        , 0)
    );
    if (storage) _shared.watchWithFilter(data, ()=>{
        try {
            if (data.value == null) storage.removeItem(key);
            else storage.setItem(key, serializer.write(data.value));
        } catch (e) {
            onError(e);
        }
    }, {
        flush,
        deep,
        eventFilter
    });
    return data;
}
function usePreferredDark(options) {
    return useMediaQuery("(prefers-color-scheme: dark)", options);
}
var __defProp$f = Object.defineProperty;
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$f = (obj, key, value)=>key in obj ? __defProp$f(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$f = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$h.call(b, prop)) __defNormalProp$f(a, prop, b[prop]);
    if (__getOwnPropSymbols$h) {
        for (var prop of __getOwnPropSymbols$h(b))if (__propIsEnum$h.call(b, prop)) __defNormalProp$f(a, prop, b[prop]);
    }
    return a;
};
function useColorMode(options = {
}) {
    const { selector ="html" , attribute ="class" , window =defaultWindow , storage , storageKey ="vueuse-color-scheme" , listenToStorageChanges =true , storageRef  } = options;
    const modes = __spreadValues$f({
        auto: "",
        light: "light",
        dark: "dark"
    }, options.modes || {
    });
    const preferredDark = usePreferredDark({
        window
    });
    const preferredMode = _vueDemi.computed(()=>preferredDark.value ? "dark" : "light"
    );
    const store = storageRef || (storageKey == null ? _vueDemi.ref("auto") : useStorage(storageKey, "auto", storage, {
        window,
        listenToStorageChanges
    }));
    const state = _vueDemi.computed({
        get () {
            return store.value === "auto" ? preferredMode.value : store.value;
        },
        set (v) {
            store.value = v;
        }
    });
    const updateHTMLAttrs = getSSRHandler("updateHTMLAttrs", (selector2, attribute2, value)=>{
        const el = window == null ? void 0 : window.document.querySelector(selector2);
        if (!el) return;
        if (attribute2 === "class") {
            const current = value.split(/\s/g);
            Object.values(modes).flatMap((i)=>(i || "").split(/\s/g)
            ).filter(Boolean).forEach((v)=>{
                if (current.includes(v)) el.classList.add(v);
                else el.classList.remove(v);
            });
        } else el.setAttribute(attribute2, value);
    });
    function defaultOnChanged(mode) {
        var _a6;
        updateHTMLAttrs(selector, attribute, (_a6 = modes[mode]) != null ? _a6 : mode);
    }
    function onChanged(mode) {
        if (options.onChanged) options.onChanged(mode, defaultOnChanged);
        else defaultOnChanged(mode);
    }
    _vueDemi.watch(state, onChanged, {
        flush: "post",
        immediate: true
    });
    _shared.tryOnMounted(()=>onChanged(state.value)
    );
    return state;
}
function useConfirmDialog(revealed = _vueDemi.ref(false)) {
    const confirmHook = _shared.createEventHook();
    const cancelHook = _shared.createEventHook();
    const revealHook = _shared.createEventHook();
    let _resolve = _shared.noop;
    const reveal = (data)=>{
        revealHook.trigger(data);
        revealed.value = true;
        return new Promise((resolve)=>{
            _resolve = resolve;
        });
    };
    const confirm = (data)=>{
        revealed.value = false;
        confirmHook.trigger(data);
        _resolve({
            data,
            isCanceled: false
        });
    };
    const cancel = (data)=>{
        revealed.value = false;
        cancelHook.trigger(data);
        _resolve({
            data,
            isCanceled: true
        });
    };
    return {
        isRevealed: _vueDemi.computed(()=>revealed.value
        ),
        reveal,
        confirm,
        cancel,
        onReveal: revealHook.on,
        onConfirm: confirmHook.on,
        onCancel: cancelHook.on
    };
}
function useCssVar(prop, target, { window =defaultWindow  } = {
}) {
    const variable = _vueDemi.ref("");
    const elRef = _vueDemi.computed(()=>{
        var _a7;
        return unrefElement(target) || ((_a7 = window == null ? void 0 : window.document) == null ? void 0 : _a7.documentElement);
    });
    _vueDemi.watch([
        elRef,
        ()=>_vueDemi.unref(prop)
    ], ([el, prop2])=>{
        if (el && window) variable.value = window.getComputedStyle(el).getPropertyValue(prop2);
    }, {
        immediate: true
    });
    _vueDemi.watch(variable, (val)=>{
        var _a8;
        if ((_a8 = elRef.value) == null ? void 0 : _a8.style) elRef.value.style.setProperty(_vueDemi.unref(prop), val);
    });
    return variable;
}
function useCycleList(list, options) {
    const state = _vueDemi.shallowRef((options == null ? void 0 : options.initialValue) || list[0]);
    const index = _vueDemi.computed({
        get () {
            var _a9;
            let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, list) : list.indexOf(state.value);
            if (index2 < 0) index2 = (_a9 = options == null ? void 0 : options.fallbackIndex) != null ? _a9 : 0;
            return index2;
        },
        set (v) {
            set(v);
        }
    });
    function set(i) {
        const length = list.length;
        const index2 = (i % length + length) % length;
        const value = list[index2];
        state.value = value;
        return value;
    }
    function shift(delta = 1) {
        return set(index.value + delta);
    }
    function next(n = 1) {
        return shift(n);
    }
    function prev(n = 1) {
        return shift(-n);
    }
    return {
        state,
        index,
        next,
        prev
    };
}
var __defProp$e = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$e = (obj, key, value)=>key in obj ? __defProp$e(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$e = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$g.call(b, prop)) __defNormalProp$e(a, prop, b[prop]);
    if (__getOwnPropSymbols$g) {
        for (var prop of __getOwnPropSymbols$g(b))if (__propIsEnum$g.call(b, prop)) __defNormalProp$e(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$8 = (a, b)=>__defProps$8(a, __getOwnPropDescs$8(b))
;
function useDark(options = {
}) {
    const { valueDark ="dark" , valueLight ="" , window =defaultWindow  } = options;
    const mode = useColorMode(__spreadProps$8(__spreadValues$e({
    }, options), {
        onChanged: (mode2, defaultHandler)=>{
            var _a10;
            if (options.onChanged) (_a10 = options.onChanged) == null || _a10.call(options, mode2 === "dark");
            else defaultHandler(mode2);
        },
        modes: {
            dark: valueDark,
            light: valueLight
        }
    }));
    const preferredDark = usePreferredDark({
        window
    });
    const isDark = _vueDemi.computed({
        get () {
            return mode.value === "dark";
        },
        set (v) {
            if (v === preferredDark.value) mode.value = "auto";
            else mode.value = v ? "dark" : "light";
        }
    });
    return isDark;
}
const fnClone = (v)=>JSON.parse(JSON.stringify(v))
;
const fnBypass = (v)=>v
;
const fnSetSource = (source, value)=>source.value = value
;
function defaultDump(clone) {
    return clone ? _shared.isFunction(clone) ? clone : fnClone : fnBypass;
}
function defaultParse(clone) {
    return clone ? _shared.isFunction(clone) ? clone : fnClone : fnBypass;
}
function useManualRefHistory(source, options = {
}) {
    const { clone =false , dump =defaultDump(clone) , parse =defaultParse(clone) , setSource =fnSetSource  } = options;
    function _createHistoryRecord() {
        return _vueDemi.markRaw({
            snapshot: dump(source.value),
            timestamp: _shared.timestamp()
        });
    }
    const last = _vueDemi.ref(_createHistoryRecord());
    const undoStack = _vueDemi.ref([]);
    const redoStack = _vueDemi.ref([]);
    const _setSource = (record)=>{
        setSource(source, parse(record.snapshot));
        last.value = record;
    };
    const commit = ()=>{
        undoStack.value.unshift(last.value);
        last.value = _createHistoryRecord();
        if (options.capacity && undoStack.value.length > options.capacity) undoStack.value.splice(options.capacity, Infinity);
        if (redoStack.value.length) redoStack.value.splice(0, redoStack.value.length);
    };
    const clear = ()=>{
        undoStack.value.splice(0, undoStack.value.length);
        redoStack.value.splice(0, redoStack.value.length);
    };
    const undo = ()=>{
        const state = undoStack.value.shift();
        if (state) {
            redoStack.value.unshift(last.value);
            _setSource(state);
        }
    };
    const redo = ()=>{
        const state = redoStack.value.shift();
        if (state) {
            undoStack.value.unshift(last.value);
            _setSource(state);
        }
    };
    const reset = ()=>{
        _setSource(last.value);
    };
    const history = _vueDemi.computed(()=>[
            last.value,
            ...undoStack.value
        ]
    );
    const canUndo = _vueDemi.computed(()=>undoStack.value.length > 0
    );
    const canRedo = _vueDemi.computed(()=>redoStack.value.length > 0
    );
    return {
        source,
        undoStack,
        redoStack,
        last,
        history,
        canUndo,
        canRedo,
        clear,
        commit,
        reset,
        undo,
        redo
    };
}
var __defProp$d = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$d = (obj, key, value)=>key in obj ? __defProp$d(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$d = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$f.call(b, prop)) __defNormalProp$d(a, prop, b[prop]);
    if (__getOwnPropSymbols$f) {
        for (var prop of __getOwnPropSymbols$f(b))if (__propIsEnum$f.call(b, prop)) __defNormalProp$d(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$7 = (a, b)=>__defProps$7(a, __getOwnPropDescs$7(b))
;
function useRefHistory(source, options = {
}) {
    const { deep =false , flush ="pre" , eventFilter  } = options;
    const { eventFilter: composedFilter , pause , resume: resumeTracking , isActive: isTracking  } = _shared.pausableFilter(eventFilter);
    const { ignoreUpdates , ignorePrevAsyncUpdates , stop  } = _shared.ignorableWatch(source, commit, {
        deep,
        flush,
        eventFilter: composedFilter
    });
    function setSource(source2, value) {
        ignorePrevAsyncUpdates();
        ignoreUpdates(()=>{
            source2.value = value;
        });
    }
    const manualHistory = useManualRefHistory(source, __spreadProps$7(__spreadValues$d({
    }, options), {
        clone: options.clone || deep,
        setSource
    }));
    const { clear , commit: manualCommit  } = manualHistory;
    function commit() {
        ignorePrevAsyncUpdates();
        manualCommit();
    }
    function resume(commitNow) {
        resumeTracking();
        if (commitNow) commit();
    }
    function batch(fn) {
        let canceled = false;
        const cancel = ()=>canceled = true
        ;
        ignoreUpdates(()=>{
            fn(cancel);
        });
        if (!canceled) commit();
    }
    function dispose() {
        stop();
        clear();
    }
    return __spreadProps$7(__spreadValues$d({
    }, manualHistory), {
        isTracking,
        pause,
        resume,
        commit,
        batch,
        dispose
    });
}
var __defProp$c = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
var __hasOwnProp$e = Object.prototype.hasOwnProperty;
var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
var __defNormalProp$c = (obj, key, value)=>key in obj ? __defProp$c(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$c = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$e.call(b, prop)) __defNormalProp$c(a, prop, b[prop]);
    if (__getOwnPropSymbols$e) {
        for (var prop of __getOwnPropSymbols$e(b))if (__propIsEnum$e.call(b, prop)) __defNormalProp$c(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$6 = (a, b)=>__defProps$6(a, __getOwnPropDescs$6(b))
;
function useDebouncedRefHistory(source, options = {
}) {
    const filter = options.debounce ? _shared.debounceFilter(options.debounce) : void 0;
    const history = useRefHistory(source, __spreadProps$6(__spreadValues$c({
    }, options), {
        eventFilter: filter
    }));
    return __spreadValues$c({
    }, history);
}
function useDeviceMotion(options = {
}) {
    const { window =defaultWindow , eventFilter =_shared.bypassFilter  } = options;
    const acceleration = _vueDemi.ref({
        x: null,
        y: null,
        z: null
    });
    const rotationRate = _vueDemi.ref({
        alpha: null,
        beta: null,
        gamma: null
    });
    const interval = _vueDemi.ref(0);
    const accelerationIncludingGravity = _vueDemi.ref({
        x: null,
        y: null,
        z: null
    });
    if (window) {
        const onDeviceMotion = _shared.createFilterWrapper(eventFilter, (event)=>{
            acceleration.value = event.acceleration;
            accelerationIncludingGravity.value = event.accelerationIncludingGravity;
            rotationRate.value = event.rotationRate;
            interval.value = event.interval;
        });
        useEventListener(window, "devicemotion", onDeviceMotion);
    }
    return {
        acceleration,
        accelerationIncludingGravity,
        rotationRate,
        interval
    };
}
function useDeviceOrientation(options = {
}) {
    const { window =defaultWindow  } = options;
    const isSupported = Boolean(window && "DeviceOrientationEvent" in window);
    const isAbsolute = _vueDemi.ref(false);
    const alpha = _vueDemi.ref(null);
    const beta = _vueDemi.ref(null);
    const gamma = _vueDemi.ref(null);
    if (window && isSupported) useEventListener(window, "deviceorientation", (event)=>{
        isAbsolute.value = event.absolute;
        alpha.value = event.alpha;
        beta.value = event.beta;
        gamma.value = event.gamma;
    });
    return {
        isSupported,
        isAbsolute,
        alpha,
        beta,
        gamma
    };
}
const DEVICE_PIXEL_RATIO_SCALES = [
    1,
    1.325,
    1.4,
    1.5,
    1.8,
    2,
    2.4,
    2.5,
    2.75,
    3,
    3.5,
    4
];
function useDevicePixelRatio({ window =defaultWindow  } = {
}) {
    if (!window) return {
        pixelRatio: _vueDemi.ref(1)
    };
    const pixelRatio = _vueDemi.ref(window.devicePixelRatio);
    const handleDevicePixelRatio = ()=>{
        pixelRatio.value = window.devicePixelRatio;
    };
    useEventListener(window, "resize", handleDevicePixelRatio, {
        passive: true
    });
    DEVICE_PIXEL_RATIO_SCALES.forEach((dppx)=>{
        const mqlMin = useMediaQuery(`screen and (min-resolution: ${dppx}dppx)`);
        const mqlMax = useMediaQuery(`screen and (max-resolution: ${dppx}dppx)`);
        _vueDemi.watch([
            mqlMin,
            mqlMax
        ], handleDevicePixelRatio);
    });
    return {
        pixelRatio
    };
}
function usePermission(permissionDesc, options = {
}) {
    const { controls =false , navigator =defaultNavigator  } = options;
    const isSupported = Boolean(navigator && "permissions" in navigator);
    let permissionStatus;
    const desc = typeof permissionDesc === "string" ? {
        name: permissionDesc
    } : permissionDesc;
    const state = _vueDemi.ref();
    const onChange = ()=>{
        if (permissionStatus) state.value = permissionStatus.state;
    };
    const query = _shared.createSingletonPromise(async ()=>{
        if (!isSupported) return;
        if (!permissionStatus) try {
            permissionStatus = await navigator.permissions.query(desc);
            useEventListener(permissionStatus, "change", onChange);
            onChange();
        } catch (e) {
            state.value = "prompt";
        }
        return permissionStatus;
    });
    query();
    if (controls) return {
        state,
        isSupported,
        query
    };
    else return state;
}
function useDevicesList(options = {
}) {
    const { navigator =defaultNavigator , requestPermissions =false , constraints ={
        audio: true,
        video: true
    } , onUpdated  } = options;
    const devices = _vueDemi.ref([]);
    const videoInputs = _vueDemi.computed(()=>devices.value.filter((i)=>i.kind === "videoinput"
        )
    );
    const audioInputs = _vueDemi.computed(()=>devices.value.filter((i)=>i.kind === "audioinput"
        )
    );
    const audioOutputs = _vueDemi.computed(()=>devices.value.filter((i)=>i.kind === "audiooutput"
        )
    );
    let isSupported = false;
    const permissionGranted = _vueDemi.ref(false);
    async function update() {
        if (!isSupported) return;
        devices.value = await navigator.mediaDevices.enumerateDevices();
        onUpdated == null || onUpdated(devices.value);
    }
    async function ensurePermissions() {
        if (!isSupported) return false;
        if (permissionGranted.value) return true;
        const { state , query  } = usePermission("camera", {
            controls: true
        });
        await query();
        if (state.value !== "granted") {
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            stream.getTracks().forEach((t)=>t.stop()
            );
            update();
            permissionGranted.value = true;
        } else permissionGranted.value = true;
        return permissionGranted.value;
    }
    if (navigator) {
        isSupported = Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);
        if (isSupported) {
            if (requestPermissions) ensurePermissions();
            useEventListener(navigator.mediaDevices, "devicechange", update);
            update();
        }
    }
    return {
        devices,
        ensurePermissions,
        permissionGranted,
        videoInputs,
        audioInputs,
        audioOutputs,
        isSupported
    };
}
function useDisplayMedia(options = {
}) {
    var _a11, _b2;
    const enabled = _vueDemi.ref((_a11 = options.enabled) != null ? _a11 : false);
    const video = options.video;
    const audio = options.audio;
    const { navigator =defaultNavigator  } = options;
    const isSupported = Boolean((_b2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _b2.getDisplayMedia);
    const constraint = {
        audio,
        video
    };
    const stream = _vueDemi.shallowRef();
    async function _start() {
        if (!isSupported || stream.value) return;
        stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);
        return stream.value;
    }
    async function _stop() {
        var _a2;
        (_a2 = stream.value) == null || _a2.getTracks().forEach((t)=>t.stop()
        );
        stream.value = void 0;
    }
    function stop() {
        _stop();
        enabled.value = false;
    }
    async function start() {
        await _start();
        if (stream.value) enabled.value = true;
        return stream.value;
    }
    _vueDemi.watch(enabled, (v)=>{
        if (v) _start();
        else _stop();
    }, {
        immediate: true
    });
    return {
        isSupported,
        stream,
        start,
        stop,
        enabled
    };
}
function useDocumentVisibility({ document =defaultDocument  } = {
}) {
    if (!document) return _vueDemi.ref("visible");
    const visibility = _vueDemi.ref(document.visibilityState);
    useEventListener(document, "visibilitychange", ()=>{
        visibility.value = document.visibilityState;
    });
    return visibility;
}
var __defProp$b = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
var __hasOwnProp$d = Object.prototype.hasOwnProperty;
var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$b = (obj, key, value)=>key in obj ? __defProp$b(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$b = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$d.call(b, prop)) __defNormalProp$b(a, prop, b[prop]);
    if (__getOwnPropSymbols$d) {
        for (var prop of __getOwnPropSymbols$d(b))if (__propIsEnum$d.call(b, prop)) __defNormalProp$b(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$5 = (a, b)=>__defProps$5(a, __getOwnPropDescs$5(b))
;
function useDraggable(target, options = {
}) {
    var _a12, _b3;
    const draggingElement = (_a12 = options.draggingElement) != null ? _a12 : defaultWindow;
    const position = _vueDemi.ref((_b3 = options.initialValue) != null ? _b3 : {
        x: 0,
        y: 0
    });
    const pressedDelta = _vueDemi.ref();
    const filterEvent = (e)=>{
        if (options.pointerTypes) return options.pointerTypes.includes(e.pointerType);
        return true;
    };
    const preventDefault1 = (e)=>{
        if (_vueDemi.unref(options.preventDefault)) e.preventDefault();
    };
    const start = (e)=>{
        var _a2;
        if (!filterEvent(e)) return;
        if (_vueDemi.unref(options.exact) && e.target !== _vueDemi.unref(target)) return;
        const rect = _vueDemi.unref(target).getBoundingClientRect();
        const pos = {
            x: e.pageX - rect.left,
            y: e.pageY - rect.top
        };
        if (((_a2 = options.onStart) == null ? void 0 : _a2.call(options, pos, e)) === false) return;
        pressedDelta.value = pos;
        preventDefault1(e);
    };
    const move = (e)=>{
        var _a2;
        if (!filterEvent(e)) return;
        if (!pressedDelta.value) return;
        position.value = {
            x: e.pageX - pressedDelta.value.x,
            y: e.pageY - pressedDelta.value.y
        };
        (_a2 = options.onMove) == null || _a2.call(options, position.value, e);
        preventDefault1(e);
    };
    const end = (e)=>{
        var _a2;
        if (!filterEvent(e)) return;
        if (!pressedDelta.value) return;
        pressedDelta.value = void 0;
        (_a2 = options.onEnd) == null || _a2.call(options, position.value, e);
        preventDefault1(e);
    };
    if (_shared.isClient) {
        useEventListener(target, "pointerdown", start, true);
        useEventListener(draggingElement, "pointermove", move, true);
        useEventListener(draggingElement, "pointerup", end, true);
    }
    return __spreadProps$5(__spreadValues$b({
    }, _shared.toRefs(position)), {
        position,
        isDragging: _vueDemi.computed(()=>!!pressedDelta.value
        ),
        style: _vueDemi.computed(()=>`left:${position.value.x}px;top:${position.value.y}px;`
        )
    });
}
var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
var __hasOwnProp$c = Object.prototype.hasOwnProperty;
var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
var __objRest$2 = (source, exclude)=>{
    var target = {
    };
    for(var prop in source)if (__hasOwnProp$c.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$c) {
        for (var prop of __getOwnPropSymbols$c(source))if (exclude.indexOf(prop) < 0 && __propIsEnum$c.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
function useResizeObserver(target, callback, options = {
}) {
    const _a13 = options, { window =defaultWindow  } = _a13, observerOptions = __objRest$2(_a13, [
        "window"
    ]);
    let observer;
    const isSupported = window && "ResizeObserver" in window;
    const cleanup = ()=>{
        if (observer) {
            observer.disconnect();
            observer = void 0;
        }
    };
    const stopWatch = _vueDemi.watch(()=>unrefElement(target)
    , (el)=>{
        cleanup();
        if (isSupported && window && el) {
            observer = new window.ResizeObserver(callback);
            observer.observe(el, observerOptions);
        }
    }, {
        immediate: true,
        flush: "post"
    });
    const stop = ()=>{
        cleanup();
        stopWatch();
    };
    _shared.tryOnScopeDispose(stop);
    return {
        isSupported,
        stop
    };
}
function useElementBounding(target) {
    const height = _vueDemi.ref(0);
    const bottom = _vueDemi.ref(0);
    const left = _vueDemi.ref(0);
    const right = _vueDemi.ref(0);
    const top = _vueDemi.ref(0);
    const width = _vueDemi.ref(0);
    const x = _vueDemi.ref(0);
    const y = _vueDemi.ref(0);
    function update() {
        const el = unrefElement(target);
        if (!el) {
            height.value = 0;
            bottom.value = 0;
            left.value = 0;
            right.value = 0;
            top.value = 0;
            width.value = 0;
            x.value = 0;
            y.value = 0;
            return;
        }
        const rect = el.getBoundingClientRect();
        height.value = rect.height;
        bottom.value = rect.bottom;
        left.value = rect.left;
        right.value = rect.right;
        top.value = rect.top;
        width.value = rect.width;
        x.value = rect.x;
        y.value = rect.y;
    }
    useEventListener("scroll", update, true);
    useResizeObserver(target, update);
    _vueDemi.watch(()=>unrefElement(target)
    , (ele)=>!ele && update()
    );
    return {
        height,
        bottom,
        left,
        right,
        top,
        width,
        x,
        y,
        update
    };
}
function useRafFn(fn, options = {
}) {
    const { immediate =true , window =defaultWindow  } = options;
    const isActive = _vueDemi.ref(false);
    function loop() {
        if (!isActive.value || !window) return;
        fn();
        window.requestAnimationFrame(loop);
    }
    function resume() {
        if (!isActive.value && window) {
            isActive.value = true;
            loop();
        }
    }
    function pause() {
        isActive.value = false;
    }
    if (immediate) resume();
    _shared.tryOnScopeDispose(pause);
    return {
        isActive,
        pause,
        resume
    };
}
var __defProp$a = Object.defineProperty;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key, value)=>key in obj ? __defProp$a(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$a = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$b.call(b, prop)) __defNormalProp$a(a, prop, b[prop]);
    if (__getOwnPropSymbols$b) {
        for (var prop of __getOwnPropSymbols$b(b))if (__propIsEnum$b.call(b, prop)) __defNormalProp$a(a, prop, b[prop]);
    }
    return a;
};
function useElementByPoint(options) {
    const element = _vueDemi.ref(null);
    const { x , y  } = options;
    const controls = useRafFn(()=>{
        element.value = document.elementFromPoint(_vueDemi.unref(x), _vueDemi.unref(y));
    });
    return __spreadValues$a({
        element
    }, controls);
}
function useElementHover(el) {
    const isHovered = _vueDemi.ref(false);
    useEventListener(el, "mouseenter", ()=>isHovered.value = true
    );
    useEventListener(el, "mouseleave", ()=>isHovered.value = false
    );
    return isHovered;
}
function useElementSize(target, initialSize = {
    width: 0,
    height: 0
}, options = {
}) {
    const width = _vueDemi.ref(initialSize.width);
    const height = _vueDemi.ref(initialSize.height);
    useResizeObserver(target, ([entry])=>{
        width.value = entry.contentRect.width;
        height.value = entry.contentRect.height;
    }, options);
    _vueDemi.watch(()=>unrefElement(target)
    , (ele)=>{
        width.value = ele ? initialSize.width : 0;
        height.value = ele ? initialSize.height : 0;
    });
    return {
        width,
        height
    };
}
function useElementVisibility(element, { window =defaultWindow , scrollTarget  } = {
}) {
    const elementIsVisible = _vueDemi.ref(false);
    const testBounding = ()=>{
        if (!window) return;
        const document = window.document;
        if (!element.value) elementIsVisible.value = false;
        else {
            const rect = element.value.getBoundingClientRect();
            elementIsVisible.value = rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.left <= (window.innerWidth || document.documentElement.clientWidth) && rect.bottom >= 0 && rect.right >= 0;
        }
    };
    _shared.tryOnMounted(testBounding);
    if (window) _shared.tryOnMounted(()=>useEventListener((scrollTarget == null ? void 0 : scrollTarget.value) || window, "scroll", testBounding, {
            capture: false,
            passive: true
        })
    );
    return elementIsVisible;
}
const events = /* @__PURE__ */ new Map();
function useEventBus(key) {
    const scope = _vueDemi.getCurrentScope();
    function on(listener) {
        const listeners = events.get(key) || [];
        listeners.push(listener);
        events.set(key, listeners);
        const _off = ()=>off(listener)
        ;
        scope == null || scope.cleanups.push(_off);
        return _off;
    }
    function once(listener) {
        function _listener(...args) {
            off(_listener);
            listener(...args);
        }
        return on(_listener);
    }
    function off(listener) {
        const listeners = events.get(key);
        if (!listeners) return;
        const index = listeners.indexOf(listener);
        if (index > -1) listeners.splice(index, 1);
        if (!listeners.length) events.delete(key);
    }
    function reset() {
        events.delete(key);
    }
    function emit(event) {
        var _a14;
        (_a14 = events.get(key)) == null || _a14.forEach((v)=>v(event)
        );
    }
    return {
        on,
        once,
        off,
        emit,
        reset
    };
}
function useEventSource(url, events3 = [], options = {
}) {
    const event = _vueDemi.ref(null);
    const data = _vueDemi.ref(null);
    const status = _vueDemi.ref("CONNECTING");
    const eventSource = _vueDemi.ref(null);
    const error = _vueDemi.ref(null);
    const { withCredentials =false  } = options;
    const close = ()=>{
        if (eventSource.value) {
            eventSource.value.close();
            eventSource.value = null;
            status.value = "CLOSED";
        }
    };
    const es = new EventSource(url, {
        withCredentials
    });
    eventSource.value = es;
    es.onopen = ()=>{
        status.value = "OPEN";
        error.value = null;
    };
    es.onerror = (e)=>{
        status.value = "CLOSED";
        error.value = e;
    };
    es.onmessage = (e)=>{
        event.value = null;
        data.value = e.data;
    };
    for (const event_name of events3)useEventListener(es, event_name, (e)=>{
        event.value = event_name;
        data.value = e.data || null;
    });
    _shared.tryOnScopeDispose(()=>{
        close();
    });
    return {
        eventSource,
        event,
        data,
        status,
        error,
        close
    };
}
function useEyeDropper(options = {
}) {
    const { initialValue =""  } = options;
    const isSupported = Boolean(typeof window !== "undefined" && "EyeDropper" in window);
    const sRGBHex = _vueDemi.ref(initialValue);
    async function open(openOptions) {
        if (!isSupported) return;
        const eyeDropper = new window.EyeDropper();
        const result = await eyeDropper.open(openOptions);
        sRGBHex.value = result.sRGBHex;
        return result;
    }
    return {
        isSupported,
        sRGBHex,
        open
    };
}
function useFavicon(newIcon = null, options = {
}) {
    const { baseUrl ="" , rel ="icon" , document =defaultDocument  } = options;
    const favicon = _vueDemi.isRef(newIcon) ? newIcon : _vueDemi.ref(newIcon);
    const applyIcon = (icon)=>{
        document == null || document.head.querySelectorAll(`link[rel*="${rel}"]`).forEach((el)=>el.href = `${baseUrl}${icon}`
        );
    };
    _vueDemi.watch(favicon, (i, o)=>{
        if (_shared.isString(i) && i !== o) applyIcon(i);
    }, {
        immediate: true
    });
    return favicon;
}
var __defProp$9 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value)=>key in obj ? __defProp$9(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$9 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$a.call(b, prop)) __defNormalProp$9(a, prop, b[prop]);
    if (__getOwnPropSymbols$a) {
        for (var prop of __getOwnPropSymbols$a(b))if (__propIsEnum$a.call(b, prop)) __defNormalProp$9(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$4 = (a, b)=>__defProps$4(a, __getOwnPropDescs$4(b))
;
const payloadMapping = {
    json: "application/json",
    text: "text/plain",
    formData: "multipart/form-data"
};
function isFetchOptions(obj) {
    return _shared.containsProp(obj, "immediate", "refetch", "initialData", "timeout", "beforeFetch", "afterFetch", "onFetchError");
}
function headersToObject(headers) {
    if (headers instanceof Headers) return Object.fromEntries([
        ...headers.entries()
    ]);
    return headers;
}
function createFetch(config = {
}) {
    const _options = config.options || {
    };
    const _fetchOptions = config.fetchOptions || {
    };
    function useFactoryFetch(url, ...args) {
        const computedUrl = _vueDemi.computed(()=>config.baseUrl ? joinPaths(_vueDemi.unref(config.baseUrl), _vueDemi.unref(url)) : _vueDemi.unref(url)
        );
        let options = _options;
        let fetchOptions = _fetchOptions;
        if (args.length > 0) {
            if (isFetchOptions(args[0])) options = __spreadValues$9(__spreadValues$9({
            }, options), args[0]);
            else fetchOptions = __spreadProps$4(__spreadValues$9(__spreadValues$9({
            }, fetchOptions), args[0]), {
                headers: __spreadValues$9(__spreadValues$9({
                }, headersToObject(fetchOptions.headers) || {
                }), headersToObject(args[0].headers) || {
                })
            });
        }
        if (args.length > 1 && isFetchOptions(args[1])) options = __spreadValues$9(__spreadValues$9({
        }, options), args[1]);
        return useFetch(computedUrl, fetchOptions, options);
    }
    return useFactoryFetch;
}
function useFetch(url, ...args) {
    var _a15;
    const supportsAbort = typeof AbortController === "function";
    let fetchOptions = {
    };
    let options = {
        immediate: true,
        refetch: false,
        timeout: 0
    };
    const config = {
        method: "get",
        type: "text",
        payload: void 0
    };
    if (args.length > 0) {
        if (isFetchOptions(args[0])) options = __spreadValues$9(__spreadValues$9({
        }, options), args[0]);
        else fetchOptions = args[0];
    }
    if (args.length > 1) {
        if (isFetchOptions(args[1])) options = __spreadValues$9(__spreadValues$9({
        }, options), args[1]);
    }
    const { fetch =(_a15 = defaultWindow) == null ? void 0 : _a15.fetch , initialData , timeout  } = options;
    const responseEvent = _shared.createEventHook();
    const errorEvent = _shared.createEventHook();
    const finallyEvent = _shared.createEventHook();
    const isFinished = _vueDemi.ref(false);
    const isFetching = _vueDemi.ref(false);
    const aborted = _vueDemi.ref(false);
    const statusCode = _vueDemi.ref(null);
    const response = _vueDemi.shallowRef(null);
    const error = _vueDemi.ref(null);
    const data = _vueDemi.shallowRef(initialData);
    const canAbort = _vueDemi.computed(()=>supportsAbort && isFetching.value
    );
    let controller;
    let timer;
    const abort = ()=>{
        if (supportsAbort && controller) controller.abort();
    };
    const loading = (isLoading)=>{
        isFetching.value = isLoading;
        isFinished.value = !isLoading;
    };
    if (timeout) timer = _shared.useTimeoutFn(abort, timeout, {
        immediate: false
    });
    const execute = async (throwOnFailed = false)=>{
        var _a2;
        loading(true);
        error.value = null;
        statusCode.value = null;
        aborted.value = false;
        controller = void 0;
        if (supportsAbort) {
            controller = new AbortController();
            controller.signal.onabort = ()=>aborted.value = true
            ;
            fetchOptions = __spreadProps$4(__spreadValues$9({
            }, fetchOptions), {
                signal: controller.signal
            });
        }
        const defaultFetchOptions = {
            method: config.method,
            headers: {
            }
        };
        if (config.payload) {
            const headers = headersToObject(defaultFetchOptions.headers);
            if (config.payloadType) headers["Content-Type"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;
            defaultFetchOptions.body = config.payloadType === "json" ? JSON.stringify(_vueDemi.unref(config.payload)) : _vueDemi.unref(config.payload);
        }
        let isCanceled = false;
        const context = {
            url: _vueDemi.unref(url),
            options: fetchOptions,
            cancel: ()=>{
                isCanceled = true;
            }
        };
        if (options.beforeFetch) Object.assign(context, await options.beforeFetch(context));
        if (isCanceled || !fetch) {
            loading(false);
            return Promise.resolve(null);
        }
        let responseData = null;
        if (timer) timer.start();
        return new Promise((resolve, reject)=>{
            var _a3;
            fetch(context.url, __spreadProps$4(__spreadValues$9(__spreadValues$9({
            }, defaultFetchOptions), context.options), {
                headers: __spreadValues$9(__spreadValues$9({
                }, headersToObject(defaultFetchOptions.headers)), headersToObject((_a3 = context.options) == null ? void 0 : _a3.headers))
            })).then(async (fetchResponse)=>{
                response.value = fetchResponse;
                statusCode.value = fetchResponse.status;
                responseData = await fetchResponse[config.type]();
                if (options.afterFetch) ({ data: responseData  } = await options.afterFetch({
                    data: responseData,
                    response: fetchResponse
                }));
                data.value = responseData;
                if (!fetchResponse.ok) throw new Error(fetchResponse.statusText);
                responseEvent.trigger(fetchResponse);
                return resolve(fetchResponse);
            }).catch(async (fetchError)=>{
                let errorData = fetchError.message || fetchError.name;
                if (options.onFetchError) ({ data: responseData , error: errorData  } = await options.onFetchError({
                    data: responseData,
                    error: fetchError
                }));
                data.value = responseData;
                error.value = errorData;
                errorEvent.trigger(fetchError);
                if (throwOnFailed) return reject(fetchError);
                return resolve(null);
            }).finally(()=>{
                loading(false);
                if (timer) timer.stop();
                finallyEvent.trigger(null);
            });
        });
    };
    _vueDemi.watch(()=>[
            _vueDemi.unref(url),
            _vueDemi.unref(options.refetch)
        ]
    , ()=>_vueDemi.unref(options.refetch) && execute()
    , {
        deep: true
    });
    const shell = {
        isFinished,
        statusCode,
        response,
        error,
        data,
        isFetching,
        canAbort,
        aborted,
        abort,
        execute,
        onFetchResponse: responseEvent.on,
        onFetchError: errorEvent.on,
        onFetchFinally: finallyEvent.on,
        get: setMethod("get"),
        put: setMethod("put"),
        post: setMethod("post"),
        delete: setMethod("delete"),
        patch: setMethod("patch"),
        head: setMethod("head"),
        options: setMethod("options"),
        json: setType("json"),
        text: setType("text"),
        blob: setType("blob"),
        arrayBuffer: setType("arrayBuffer"),
        formData: setType("formData")
    };
    function setMethod(method) {
        return (payload, payloadType)=>{
            if (!isFetching.value) {
                config.method = method;
                config.payload = payload;
                config.payloadType = payloadType;
                if (_vueDemi.isRef(config.payload)) _vueDemi.watch(()=>[
                        _vueDemi.unref(config.payload),
                        _vueDemi.unref(options.refetch)
                    ]
                , ()=>_vueDemi.unref(options.refetch) && execute()
                , {
                    deep: true
                });
                if (!payloadType && _vueDemi.unref(payload) && Object.getPrototypeOf(_vueDemi.unref(payload)) === Object.prototype) config.payloadType = "json";
                return shell;
            }
            return void 0;
        };
    }
    function waitUntilFinished() {
        return new Promise((resolve, reject)=>{
            _shared.until(isFinished).toBe(true).then(()=>resolve(shell)
            ).catch((error2)=>reject(error2)
            );
        });
    }
    function setType(type) {
        return ()=>{
            if (!isFetching.value) {
                config.type = type;
                return __spreadProps$4(__spreadValues$9({
                }, shell), {
                    then (onFulfilled, onRejected) {
                        return waitUntilFinished().then(onFulfilled, onRejected);
                    }
                });
            }
            return void 0;
        };
    }
    if (options.immediate) setTimeout(execute, 0);
    return __spreadProps$4(__spreadValues$9({
    }, shell), {
        then (onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
        }
    });
}
function joinPaths(start, end) {
    if (!start.endsWith("/") && !end.startsWith("/")) return `${start}/${end}`;
    return `${start}${end}`;
}
function useFocus(options = {
}) {
    const { initialValue =false  } = options;
    const activeElement = useActiveElement(options);
    const target = _vueDemi.computed(()=>unrefElement(options.target)
    );
    const focused = _vueDemi.computed({
        get () {
            return activeElement.value === target.value;
        },
        set (value) {
            var _a16, _b4;
            if (!value && focused.value) (_a16 = target.value) == null || _a16.blur();
            if (value && !focused.value) (_b4 = target.value) == null || _b4.focus();
        }
    });
    _vueDemi.watch(target, ()=>{
        focused.value = initialValue;
    }, {
        immediate: true,
        flush: "post"
    });
    return {
        focused
    };
}
function useFocusWithin(target, options = {
}) {
    const activeElement = useActiveElement(options);
    const targetElement = _vueDemi.computed(()=>unrefElement(target)
    );
    const focused = _vueDemi.computed(()=>targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false
    );
    return {
        focused
    };
}
function useFps(options) {
    var _a17;
    const fps = _vueDemi.ref(0);
    if (typeof performance === "undefined") return fps;
    const every = (_a17 = options == null ? void 0 : options.every) != null ? _a17 : 10;
    let last = performance.now();
    let ticks = 0;
    useRafFn(()=>{
        ticks += 1;
        if (ticks >= every) {
            const now = performance.now();
            const diff = now - last;
            fps.value = Math.round(1000 / (diff / ticks));
            last = now;
            ticks = 0;
        }
    });
    return fps;
}
const functionsMap = [
    [
        "requestFullscreen",
        "exitFullscreen",
        "fullscreenElement",
        "fullscreenEnabled",
        "fullscreenchange",
        "fullscreenerror"
    ],
    [
        "webkitRequestFullscreen",
        "webkitExitFullscreen",
        "webkitFullscreenElement",
        "webkitFullscreenEnabled",
        "webkitfullscreenchange",
        "webkitfullscreenerror"
    ],
    [
        "webkitRequestFullScreen",
        "webkitCancelFullScreen",
        "webkitCurrentFullScreenElement",
        "webkitCancelFullScreen",
        "webkitfullscreenchange",
        "webkitfullscreenerror"
    ],
    [
        "mozRequestFullScreen",
        "mozCancelFullScreen",
        "mozFullScreenElement",
        "mozFullScreenEnabled",
        "mozfullscreenchange",
        "mozfullscreenerror"
    ],
    [
        "msRequestFullscreen",
        "msExitFullscreen",
        "msFullscreenElement",
        "msFullscreenEnabled",
        "MSFullscreenChange",
        "MSFullscreenError"
    ]
];
function useFullscreen(target, options = {
}) {
    const { document =defaultDocument  } = options;
    const targetRef = target || (document == null ? void 0 : document.querySelector("html"));
    const isFullscreen = _vueDemi.ref(false);
    let isSupported = false;
    let map = functionsMap[0];
    if (!document) isSupported = false;
    else {
        for (const m of functionsMap)if (m[1] in document) {
            map = m;
            isSupported = true;
            break;
        }
    }
    const [REQUEST, EXIT, ELEMENT, , EVENT] = map;
    async function exit() {
        if (!isSupported) return;
        if (document == null ? void 0 : document[ELEMENT]) await document[EXIT]();
        isFullscreen.value = false;
    }
    async function enter() {
        if (!isSupported) return;
        await exit();
        const target2 = unrefElement(targetRef);
        if (target2) {
            await target2[REQUEST]();
            isFullscreen.value = true;
        }
    }
    async function toggle() {
        if (isFullscreen.value) await exit();
        else await enter();
    }
    if (document) useEventListener(document, EVENT, ()=>{
        isFullscreen.value = !!(document == null ? void 0 : document[ELEMENT]);
    }, false);
    return {
        isSupported,
        isFullscreen,
        enter,
        exit,
        toggle
    };
}
function useGeolocation(options = {
}) {
    const { enableHighAccuracy =true , maximumAge =30000 , timeout =27000 , navigator =defaultNavigator  } = options;
    const isSupported = navigator && "geolocation" in navigator;
    const locatedAt = _vueDemi.ref(null);
    const error = _vueDemi.ref(null);
    const coords = _vueDemi.ref({
        accuracy: 0,
        latitude: Infinity,
        longitude: Infinity,
        altitude: null,
        altitudeAccuracy: null,
        heading: null,
        speed: null
    });
    function updatePosition(position) {
        locatedAt.value = position.timestamp;
        coords.value = position.coords;
        error.value = null;
    }
    let watcher;
    if (isSupported) watcher = navigator.geolocation.watchPosition(updatePosition, (err)=>error.value = err
    , {
        enableHighAccuracy,
        maximumAge,
        timeout
    });
    _shared.tryOnScopeDispose(()=>{
        if (watcher && navigator) navigator.geolocation.clearWatch(watcher);
    });
    return {
        isSupported,
        coords,
        locatedAt,
        error
    };
}
const defaultEvents$1 = [
    "mousemove",
    "mousedown",
    "resize",
    "keydown",
    "touchstart",
    "wheel"
];
const oneMinute = 60000;
function useIdle(timeout = oneMinute, options = {
}) {
    const { initialState: initialState3 = false , listenForVisibilityChange =true , events: events4 = defaultEvents$1 , window =defaultWindow , eventFilter =_shared.throttleFilter(50)  } = options;
    const idle = _vueDemi.ref(initialState3);
    const lastActive = _vueDemi.ref(_shared.timestamp());
    let timer;
    const onEvent = _shared.createFilterWrapper(eventFilter, ()=>{
        idle.value = false;
        lastActive.value = _shared.timestamp();
        clearTimeout(timer);
        timer = setTimeout(()=>idle.value = true
        , timeout);
    });
    if (window) {
        const document = window.document;
        for (const event of events4)useEventListener(window, event, onEvent, {
            passive: true
        });
        if (listenForVisibilityChange) useEventListener(document, "visibilitychange", ()=>{
            if (!document.hidden) onEvent();
        });
    }
    timer = setTimeout(()=>idle.value = true
    , timeout);
    return {
        idle,
        lastActive
    };
}
function useScroll(element, options = {
}) {
    const { throttle =0 , idle =200 , onStop =_shared.noop , onScroll =_shared.noop , offset ={
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    } , eventListenerOptions ={
        capture: false,
        passive: true
    }  } = options;
    const x = _vueDemi.ref(0);
    const y = _vueDemi.ref(0);
    const isScrolling = _vueDemi.ref(false);
    const arrivedState = _vueDemi.reactive({
        left: true,
        right: false,
        top: true,
        bottom: false
    });
    const directions = _vueDemi.reactive({
        left: false,
        right: false,
        top: false,
        bottom: false
    });
    if (element) {
        const onScrollEnd = _shared.useDebounceFn((e)=>{
            isScrolling.value = false;
            directions.left = false;
            directions.right = false;
            directions.top = false;
            directions.bottom = false;
            onStop(e);
        }, throttle + idle);
        const onScrollHandler = (e)=>{
            const eventTarget = e.target === document ? e.target.documentElement : e.target;
            const scrollLeft = eventTarget.scrollLeft;
            directions.left = scrollLeft < x.value;
            directions.right = scrollLeft > x.value;
            arrivedState.left = scrollLeft <= 0 + (offset.left || 0);
            arrivedState.right = scrollLeft + eventTarget.clientWidth >= eventTarget.scrollWidth - (offset.right || 0);
            x.value = scrollLeft;
            const scrollTop = eventTarget.scrollTop;
            directions.top = scrollTop < y.value;
            directions.bottom = scrollTop > y.value;
            arrivedState.top = scrollTop <= 0 + (offset.top || 0);
            arrivedState.bottom = scrollTop + eventTarget.clientHeight >= eventTarget.scrollHeight - (offset.bottom || 0);
            y.value = scrollTop;
            isScrolling.value = true;
            onScrollEnd(e);
            onScroll(e);
        };
        useEventListener(element, "scroll", throttle ? _shared.useThrottleFn(onScrollHandler, throttle) : onScrollHandler, eventListenerOptions);
    }
    return {
        x,
        y,
        isScrolling,
        arrivedState,
        directions
    };
}
var __defProp$8 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value)=>key in obj ? __defProp$8(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$8 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$9.call(b, prop)) __defNormalProp$8(a, prop, b[prop]);
    if (__getOwnPropSymbols$9) {
        for (var prop of __getOwnPropSymbols$9(b))if (__propIsEnum$9.call(b, prop)) __defNormalProp$8(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$3 = (a, b)=>__defProps$3(a, __getOwnPropDescs$3(b))
;
function useInfiniteScroll(element, onLoadMore, options = {
}) {
    var _a18;
    const state = _vueDemi.reactive(useScroll(element, __spreadProps$3(__spreadValues$8({
    }, options), {
        offset: __spreadValues$8({
            bottom: (_a18 = options.distance) != null ? _a18 : 0
        }, options.offset)
    })));
    _vueDemi.watch(()=>state.arrivedState.bottom
    , (v)=>{
        if (v) onLoadMore(state);
    });
}
function useIntersectionObserver(target, callback, options = {
}) {
    const { root , rootMargin ="0px" , threshold =0.1 , window =defaultWindow  } = options;
    const isSupported = window && "IntersectionObserver" in window;
    let cleanup = _shared.noop;
    const stopWatch = isSupported ? _vueDemi.watch(()=>({
            el: unrefElement(target),
            root: unrefElement(root)
        })
    , ({ el , root: root2  })=>{
        cleanup();
        if (!el) return;
        const observer = new window.IntersectionObserver(callback, {
            root: root2,
            rootMargin,
            threshold
        });
        observer.observe(el);
        cleanup = ()=>{
            observer.disconnect();
            cleanup = _shared.noop;
        };
    }, {
        immediate: true,
        flush: "post"
    }) : _shared.noop;
    const stop = ()=>{
        cleanup();
        stopWatch();
    };
    _shared.tryOnScopeDispose(stop);
    return {
        isSupported,
        stop
    };
}
const defaultEvents = [
    "mousedown",
    "mouseup",
    "keydown",
    "keyup"
];
function useKeyModifier(modifier, options = {
}) {
    const { events: events5 = defaultEvents , document =defaultDocument , initial =null  } = options;
    const state = _vueDemi.ref(initial);
    if (document) events5.forEach((listenerEvent)=>{
        useEventListener(document, listenerEvent, (evt)=>{
            state.value = evt.getModifierState(modifier);
        });
    });
    return state;
}
function useLocalStorage(key, initialValue, options = {
}) {
    const { window =defaultWindow  } = options;
    return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);
}
const DefaultMagicKeysAliasMap = {
    ctrl: "control",
    command: "meta",
    cmd: "meta",
    option: "alt",
    up: "arrowup",
    down: "arrowdown",
    left: "arrowleft",
    right: "arrowright"
};
function useMagicKeys(options = {
}) {
    const { reactive: useReactive = false , target =defaultWindow , aliasMap =DefaultMagicKeysAliasMap , passive =true , onEventFired =_shared.noop  } = options;
    const current = _vueDemi.reactive(/* @__PURE__ */ new Set());
    const obj = {
        toJSON () {
            return {
            };
        },
        current
    };
    const refs = useReactive ? _vueDemi.reactive(obj) : obj;
    function updateRefs(e, value) {
        var _a19, _b5;
        const key = (_a19 = e.key) == null ? void 0 : _a19.toLowerCase();
        const code = (_b5 = e.code) == null ? void 0 : _b5.toLowerCase();
        const values = [
            code,
            key
        ].filter(Boolean);
        if (code) {
            if (value) current.add(e.code);
            else current.delete(e.code);
        }
        for (const key2 of values)if (key2 in refs) {
            if (useReactive) refs[key2] = value;
            else refs[key2].value = value;
        }
    }
    if (target) {
        useEventListener(target, "keydown", (e)=>{
            updateRefs(e, true);
            return onEventFired(e);
        }, {
            passive
        });
        useEventListener(target, "keyup", (e)=>{
            updateRefs(e, false);
            return onEventFired(e);
        }, {
            passive
        });
    }
    const proxy = new Proxy(refs, {
        get (target2, prop, rec) {
            if (typeof prop !== "string") return Reflect.get(target2, prop, rec);
            prop = prop.toLowerCase();
            if (prop in aliasMap) prop = aliasMap[prop];
            if (!(prop in refs)) {
                if (/[+_-]/.test(prop)) {
                    const keys1 = prop.split(/[+_-]/g).map((i)=>i.trim()
                    );
                    refs[prop] = _vueDemi.computed(()=>keys1.every((key)=>_vueDemi.unref(proxy[key])
                        )
                    );
                } else refs[prop] = _vueDemi.ref(false);
            }
            const r = Reflect.get(target2, prop, rec);
            return useReactive ? _vueDemi.unref(r) : r;
        }
    });
    return proxy;
}
var __defProp$7 = Object.defineProperty;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value)=>key in obj ? __defProp$7(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$7 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$8.call(b, prop)) __defNormalProp$7(a, prop, b[prop]);
    if (__getOwnPropSymbols$8) {
        for (var prop of __getOwnPropSymbols$8(b))if (__propIsEnum$8.call(b, prop)) __defNormalProp$7(a, prop, b[prop]);
    }
    return a;
};
function usingElRef(source, cb) {
    if (_vueDemi.unref(source)) cb(_vueDemi.unref(source));
}
function timeRangeToArray(timeRanges) {
    let ranges = [];
    for(let i = 0; i < timeRanges.length; ++i)ranges = [
        ...ranges,
        [
            timeRanges.start(i),
            timeRanges.end(i)
        ]
    ];
    return ranges;
}
function tracksToArray(tracks) {
    return Array.from(tracks).map(({ label , kind , language , mode , activeCues , cues , inBandMetadataTrackDispatchType  }, id)=>({
            id,
            label,
            kind,
            language,
            mode,
            activeCues,
            cues,
            inBandMetadataTrackDispatchType
        })
    );
}
const defaultOptions = {
    src: "",
    tracks: []
};
function useMediaControls(target, options = {
}) {
    options = __spreadValues$7(__spreadValues$7({
    }, defaultOptions), options);
    const { document =defaultDocument  } = options;
    const currentTime = _vueDemi.ref(0);
    const duration = _vueDemi.ref(0);
    const seeking = _vueDemi.ref(false);
    const volume = _vueDemi.ref(1);
    const waiting = _vueDemi.ref(false);
    const ended = _vueDemi.ref(false);
    const playing = _vueDemi.ref(false);
    const rate = _vueDemi.ref(1);
    const stalled = _vueDemi.ref(false);
    const buffered = _vueDemi.ref([]);
    const tracks = _vueDemi.ref([]);
    const selectedTrack = _vueDemi.ref(-1);
    const isPictureInPicture = _vueDemi.ref(false);
    const muted = _vueDemi.ref(false);
    const supportsPictureInPicture = document && "pictureInPictureEnabled" in document;
    const sourceErrorEvent = _shared.createEventHook();
    const disableTrack = (track)=>{
        usingElRef(target, (el)=>{
            if (track) {
                const id = _shared.isNumber(track) ? track : track.id;
                el.textTracks[id].mode = "disabled";
            } else for(let i = 0; i < el.textTracks.length; ++i)el.textTracks[i].mode = "disabled";
            selectedTrack.value = -1;
        });
    };
    const enableTrack = (track, disableTracks = true)=>{
        usingElRef(target, (el)=>{
            const id = _shared.isNumber(track) ? track : track.id;
            if (disableTracks) disableTrack();
            el.textTracks[id].mode = "showing";
            selectedTrack.value = id;
        });
    };
    const togglePictureInPicture = ()=>{
        return new Promise((resolve, reject)=>{
            usingElRef(target, async (el)=>{
                if (supportsPictureInPicture) {
                    if (!isPictureInPicture.value) el.requestPictureInPicture().then(resolve).catch(reject);
                    else document.exitPictureInPicture().then(resolve).catch(reject);
                }
            });
        });
    };
    _vueDemi.watchEffect(()=>{
        if (!document) return;
        const el = _vueDemi.unref(target);
        if (!el) return;
        const src = _vueDemi.unref(options.src);
        let sources = [];
        if (!src) return;
        if (_shared.isString(src)) sources = [
            {
                src
            }
        ];
        else if (Array.isArray(src)) sources = src;
        else if (_shared.isObject(src)) sources = [
            src
        ];
        el.querySelectorAll("source").forEach((e)=>{
            e.removeEventListener("error", sourceErrorEvent.trigger);
            e.remove();
        });
        sources.forEach(({ src: src2 , type  })=>{
            const source = document.createElement("source");
            source.setAttribute("src", src2);
            source.setAttribute("type", type || "");
            source.addEventListener("error", sourceErrorEvent.trigger);
            el.appendChild(source);
        });
        el.load();
    });
    _shared.tryOnScopeDispose(()=>{
        const el = _vueDemi.unref(target);
        if (!el) return;
        el.querySelectorAll("source").forEach((e)=>e.removeEventListener("error", sourceErrorEvent.trigger)
        );
    });
    _vueDemi.watch(volume, (vol)=>{
        const el = _vueDemi.unref(target);
        if (!el) return;
        el.volume = vol;
    });
    _vueDemi.watch(muted, (mute)=>{
        const el = _vueDemi.unref(target);
        if (!el) return;
        el.muted = mute;
    });
    _vueDemi.watch(rate, (rate2)=>{
        const el = _vueDemi.unref(target);
        if (!el) return;
        el.playbackRate = rate2;
    });
    _vueDemi.watchEffect(()=>{
        if (!document) return;
        const textTracks = _vueDemi.unref(options.tracks);
        const el = _vueDemi.unref(target);
        if (!textTracks || !textTracks.length || !el) return;
        el.querySelectorAll("track").forEach((e)=>e.remove()
        );
        textTracks.forEach(({ default: isDefault , kind , label , src , srcLang  }, i)=>{
            const track = document.createElement("track");
            track.default = isDefault || false;
            track.kind = kind;
            track.label = label;
            track.src = src;
            track.srclang = srcLang;
            if (track.default) selectedTrack.value = i;
            el.appendChild(track);
        });
    });
    const { ignoreUpdates: ignoreCurrentTimeUpdates  } = _shared.ignorableWatch(currentTime, (time)=>{
        const el = _vueDemi.unref(target);
        if (!el) return;
        el.currentTime = time;
    });
    const { ignoreUpdates: ignorePlayingUpdates  } = _shared.ignorableWatch(playing, (isPlaying)=>{
        const el = _vueDemi.unref(target);
        if (!el) return;
        isPlaying ? el.play() : el.pause();
    });
    useEventListener(target, "timeupdate", ()=>ignoreCurrentTimeUpdates(()=>currentTime.value = _vueDemi.unref(target).currentTime
        )
    );
    useEventListener(target, "durationchange", ()=>duration.value = _vueDemi.unref(target).duration
    );
    useEventListener(target, "progress", ()=>buffered.value = timeRangeToArray(_vueDemi.unref(target).buffered)
    );
    useEventListener(target, "seeking", ()=>seeking.value = true
    );
    useEventListener(target, "seeked", ()=>seeking.value = false
    );
    useEventListener(target, "waiting", ()=>waiting.value = true
    );
    useEventListener(target, "playing", ()=>waiting.value = false
    );
    useEventListener(target, "ratechange", ()=>rate.value = _vueDemi.unref(target).playbackRate
    );
    useEventListener(target, "stalled", ()=>stalled.value = true
    );
    useEventListener(target, "ended", ()=>ended.value = true
    );
    useEventListener(target, "pause", ()=>ignorePlayingUpdates(()=>playing.value = false
        )
    );
    useEventListener(target, "play", ()=>ignorePlayingUpdates(()=>playing.value = true
        )
    );
    useEventListener(target, "enterpictureinpicture", ()=>isPictureInPicture.value = true
    );
    useEventListener(target, "leavepictureinpicture", ()=>isPictureInPicture.value = false
    );
    useEventListener(target, "volumechange", ()=>{
        const el = _vueDemi.unref(target);
        if (!el) return;
        volume.value = el.volume;
        muted.value = el.muted;
    });
    const listeners = [];
    const stop = _vueDemi.watch([
        target
    ], ()=>{
        const el = _vueDemi.unref(target);
        if (!el) return;
        stop();
        listeners[0] = useEventListener(el.textTracks, "addtrack", ()=>tracks.value = tracksToArray(el.textTracks)
        );
        listeners[1] = useEventListener(el.textTracks, "removetrack", ()=>tracks.value = tracksToArray(el.textTracks)
        );
        listeners[2] = useEventListener(el.textTracks, "change", ()=>tracks.value = tracksToArray(el.textTracks)
        );
    });
    _shared.tryOnScopeDispose(()=>listeners.forEach((listener)=>listener()
        )
    );
    return {
        currentTime,
        duration,
        waiting,
        seeking,
        ended,
        stalled,
        buffered,
        playing,
        rate,
        volume,
        muted,
        tracks,
        selectedTrack,
        enableTrack,
        disableTrack,
        supportsPictureInPicture,
        togglePictureInPicture,
        isPictureInPicture,
        onSourceError: sourceErrorEvent.on
    };
}
const getMapVue2Compat = ()=>{
    const data = _vueDemi.reactive({
    });
    return {
        get: (key)=>data[key]
        ,
        set: (key, value)=>_vueDemi.set(data, key, value)
        ,
        has: (key)=>Object.prototype.hasOwnProperty.call(data, key)
        ,
        delete: (key)=>_vueDemi.del(data, key)
        ,
        clear: ()=>{
            Object.keys(data).forEach((key)=>{
                _vueDemi.del(data, key);
            });
        }
    };
};
function useMemoize(resolver, options) {
    const initCache = ()=>{
        if (options == null ? void 0 : options.cache) return _vueDemi.reactive(options.cache);
        if (_vueDemi.isVue2) return getMapVue2Compat();
        return _vueDemi.reactive(/* @__PURE__ */ new Map());
    };
    const cache = initCache();
    const generateKey = (...args)=>(options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args)
    ;
    const _loadData = (key, ...args)=>{
        cache.set(key, resolver(...args));
        return cache.get(key);
    };
    const loadData = (...args)=>_loadData(generateKey(...args), ...args)
    ;
    const deleteData = (...args)=>{
        cache.delete(generateKey(...args));
    };
    const clearData = ()=>{
        cache.clear();
    };
    const memoized = (...args)=>{
        const key = generateKey(...args);
        if (cache.has(key)) return cache.get(key);
        return _loadData(key, ...args);
    };
    memoized.load = loadData;
    memoized.delete = deleteData;
    memoized.clear = clearData;
    memoized.generateKey = generateKey;
    memoized.cache = cache;
    return memoized;
}
function useMemory(options = {
}) {
    const memory = _vueDemi.ref();
    const isSupported = typeof performance !== "undefined" && "memory" in performance;
    if (isSupported) {
        const { interval =1000  } = options;
        _shared.useIntervalFn(()=>{
            memory.value = performance.memory;
        }, interval, {
            immediate: options.immediate,
            immediateCallback: options.immediateCallback
        });
    }
    return {
        isSupported,
        memory
    };
}
function useMounted() {
    const isMounted = _vueDemi.ref(false);
    _vueDemi.onMounted(()=>{
        isMounted.value = true;
    });
    return isMounted;
}
function useMouse(options = {
}) {
    const { type ="page" , touch =true , resetOnTouchEnds =false , initialValue ={
        x: 0,
        y: 0
    } , window =defaultWindow  } = options;
    const x = _vueDemi.ref(initialValue.x);
    const y = _vueDemi.ref(initialValue.y);
    const sourceType = _vueDemi.ref(null);
    const mouseHandler = (event)=>{
        if (type === "page") {
            x.value = event.pageX;
            y.value = event.pageY;
        } else if (type === "client") {
            x.value = event.clientX;
            y.value = event.clientY;
        }
        sourceType.value = "mouse";
    };
    const reset = ()=>{
        x.value = initialValue.x;
        y.value = initialValue.y;
    };
    const touchHandler = (event)=>{
        if (event.touches.length > 0) {
            const touch2 = event.touches[0];
            if (type === "page") {
                x.value = touch2.pageX;
                y.value = touch2.pageY;
            } else if (type === "client") {
                x.value = touch2.clientX;
                y.value = touch2.clientY;
            }
            sourceType.value = "touch";
        }
    };
    if (window) {
        useEventListener(window, "mousemove", mouseHandler, {
            passive: true
        });
        useEventListener(window, "dragover", mouseHandler, {
            passive: true
        });
        if (touch) {
            useEventListener(window, "touchstart", touchHandler, {
                passive: true
            });
            useEventListener(window, "touchmove", touchHandler, {
                passive: true
            });
            if (resetOnTouchEnds) useEventListener(window, "touchend", reset, {
                passive: true
            });
        }
    }
    return {
        x,
        y,
        sourceType
    };
}
function useMouseInElement(target, options = {
}) {
    const { handleOutside =true , window =defaultWindow  } = options;
    const { x , y , sourceType  } = useMouse(options);
    const targetRef = _vueDemi.ref(target != null ? target : window == null ? void 0 : window.document.body);
    const elementX = _vueDemi.ref(0);
    const elementY = _vueDemi.ref(0);
    const elementPositionX = _vueDemi.ref(0);
    const elementPositionY = _vueDemi.ref(0);
    const elementHeight = _vueDemi.ref(0);
    const elementWidth = _vueDemi.ref(0);
    const isOutside = _vueDemi.ref(false);
    let stop = ()=>{
    };
    if (window) stop = _vueDemi.watch([
        targetRef,
        x,
        y
    ], ()=>{
        const el = unrefElement(targetRef);
        if (!el) return;
        const { left , top , width , height  } = el.getBoundingClientRect();
        elementPositionX.value = left + window.pageXOffset;
        elementPositionY.value = top + window.pageYOffset;
        elementHeight.value = height;
        elementWidth.value = width;
        const elX = x.value - elementPositionX.value;
        const elY = y.value - elementPositionY.value;
        isOutside.value = elX < 0 || elY < 0 || elX > elementWidth.value || elY > elementHeight.value;
        if (handleOutside || !isOutside.value) {
            elementX.value = elX;
            elementY.value = elY;
        }
    }, {
        immediate: true
    });
    return {
        x,
        y,
        sourceType,
        elementX,
        elementY,
        elementPositionX,
        elementPositionY,
        elementHeight,
        elementWidth,
        isOutside,
        stop
    };
}
function useMousePressed(options = {
}) {
    const { touch =true , drag =true , initialValue =false , window =defaultWindow  } = options;
    const pressed = _vueDemi.ref(initialValue);
    const sourceType = _vueDemi.ref(null);
    if (!window) return {
        pressed,
        sourceType
    };
    const onPressed = (srcType)=>()=>{
            pressed.value = true;
            sourceType.value = srcType;
        }
    ;
    const onReleased = ()=>{
        pressed.value = false;
        sourceType.value = null;
    };
    const target = _vueDemi.computed(()=>unrefElement(options.target) || window
    );
    useEventListener(target, "mousedown", onPressed("mouse"), {
        passive: true
    });
    useEventListener(window, "mouseleave", onReleased, {
        passive: true
    });
    useEventListener(window, "mouseup", onReleased, {
        passive: true
    });
    if (drag) {
        useEventListener(target, "dragstart", onPressed("mouse"), {
            passive: true
        });
        useEventListener(window, "drop", onReleased, {
            passive: true
        });
        useEventListener(window, "dragend", onReleased, {
            passive: true
        });
    }
    if (touch) {
        useEventListener(target, "touchstart", onPressed("touch"), {
            passive: true
        });
        useEventListener(window, "touchend", onReleased, {
            passive: true
        });
        useEventListener(window, "touchcancel", onReleased, {
            passive: true
        });
    }
    return {
        pressed,
        sourceType
    };
}
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __objRest$1 = (source, exclude)=>{
    var target = {
    };
    for(var prop in source)if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$7) {
        for (var prop of __getOwnPropSymbols$7(source))if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
function useMutationObserver(target, callback, options = {
}) {
    const _a20 = options, { window =defaultWindow  } = _a20, mutationOptions = __objRest$1(_a20, [
        "window"
    ]);
    let observer;
    const isSupported = window && "IntersectionObserver" in window;
    const cleanup = ()=>{
        if (observer) {
            observer.disconnect();
            observer = void 0;
        }
    };
    const stopWatch = _vueDemi.watch(()=>unrefElement(target)
    , (el)=>{
        cleanup();
        if (isSupported && window && el) {
            observer = new window.MutationObserver(callback);
            observer.observe(el, mutationOptions);
        }
    }, {
        immediate: true
    });
    const stop = ()=>{
        cleanup();
        stopWatch();
    };
    _shared.tryOnScopeDispose(stop);
    return {
        isSupported,
        stop
    };
}
const useNavigatorLanguage = (options = {
})=>{
    const { window =defaultWindow  } = options;
    const navigator = window == null ? void 0 : window.navigator;
    const isSupported = Boolean(navigator && "language" in navigator);
    const language = _vueDemi.ref(navigator == null ? void 0 : navigator.language);
    useEventListener(window, "languagechange", ()=>{
        if (navigator) language.value = navigator.language;
    });
    return {
        isSupported,
        language
    };
};
function useNetwork(options = {
}) {
    const { window =defaultWindow  } = options;
    const navigator = window == null ? void 0 : window.navigator;
    const isSupported = Boolean(navigator && "connection" in navigator);
    const isOnline = _vueDemi.ref(true);
    const saveData = _vueDemi.ref(false);
    const offlineAt = _vueDemi.ref(void 0);
    const downlink = _vueDemi.ref(void 0);
    const downlinkMax = _vueDemi.ref(void 0);
    const rtt = _vueDemi.ref(void 0);
    const effectiveType = _vueDemi.ref(void 0);
    const type = _vueDemi.ref("unknown");
    const connection = isSupported && navigator.connection;
    function updateNetworkInformation() {
        if (!navigator) return;
        isOnline.value = navigator.onLine;
        offlineAt.value = isOnline.value ? void 0 : Date.now();
        if (connection) {
            downlink.value = connection.downlink;
            downlinkMax.value = connection.downlinkMax;
            effectiveType.value = connection.effectiveType;
            rtt.value = connection.rtt;
            saveData.value = connection.saveData;
            type.value = connection.type;
        }
    }
    if (window) {
        useEventListener(window, "offline", ()=>{
            isOnline.value = false;
            offlineAt.value = Date.now();
        });
        useEventListener(window, "online", ()=>{
            isOnline.value = true;
        });
    }
    if (connection) useEventListener(connection, "change", updateNetworkInformation, false);
    updateNetworkInformation();
    return {
        isSupported,
        isOnline,
        saveData,
        offlineAt,
        downlink,
        downlinkMax,
        effectiveType,
        rtt,
        type
    };
}
var __defProp$6 = Object.defineProperty;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value)=>key in obj ? __defProp$6(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$6 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$6.call(b, prop)) __defNormalProp$6(a, prop, b[prop]);
    if (__getOwnPropSymbols$6) {
        for (var prop of __getOwnPropSymbols$6(b))if (__propIsEnum$6.call(b, prop)) __defNormalProp$6(a, prop, b[prop]);
    }
    return a;
};
function useNow(options = {
}) {
    const { controls: exposeControls = false , interval ="requestAnimationFrame"  } = options;
    const now = _vueDemi.ref(new Date());
    const update = ()=>now.value = new Date()
    ;
    const controls = interval === "requestAnimationFrame" ? useRafFn(update, {
        immediate: true
    }) : _shared.useIntervalFn(update, interval, {
        immediate: true
    });
    if (exposeControls) return __spreadValues$6({
        now
    }, controls);
    else return now;
}
function useOffsetPagination(options) {
    const { total =Infinity , pageSize =10 , page =1 , onPageChange =_core.noop , onPageSizeChange =_core.noop , onPageCountChange =_core.noop  } = options;
    const currentPageSize = _core.useClamp(pageSize, 1, Infinity);
    const pageCount = _vueDemi.computed(()=>Math.ceil(_vueDemi.unref(total) / _vueDemi.unref(currentPageSize))
    );
    const currentPage = _core.useClamp(page, 1, pageCount);
    const isFirstPage = _vueDemi.computed(()=>currentPage.value === 1
    );
    const isLastPage = _vueDemi.computed(()=>currentPage.value === pageCount.value
    );
    if (_vueDemi.isRef(page)) _core.biSyncRef(page, currentPage);
    if (_vueDemi.isRef(pageSize)) _core.biSyncRef(pageSize, currentPageSize);
    function prev() {
        currentPage.value--;
    }
    function next() {
        currentPage.value++;
    }
    const returnValue = {
        currentPage,
        currentPageSize,
        pageCount,
        isFirstPage,
        isLastPage,
        prev,
        next
    };
    _vueDemi.watch(currentPage, ()=>{
        onPageChange(_vueDemi.reactive(returnValue));
    });
    _vueDemi.watch(currentPageSize, ()=>{
        onPageSizeChange(_vueDemi.reactive(returnValue));
    });
    _vueDemi.watch(pageCount, ()=>{
        onPageCountChange(_vueDemi.reactive(returnValue));
    });
    return returnValue;
}
function useOnline(options = {
}) {
    const { isOnline  } = useNetwork(options);
    return isOnline;
}
function usePageLeave(options = {
}) {
    const { window =defaultWindow  } = options;
    const isLeft = _vueDemi.ref(false);
    const handler = (event)=>{
        if (!window) return;
        event = event || window.event;
        const from = event.relatedTarget || event.toElement;
        isLeft.value = !from;
    };
    if (window) {
        useEventListener(window, "mouseout", handler, {
            passive: true
        });
        useEventListener(window.document, "mouseleave", handler, {
            passive: true
        });
        useEventListener(window.document, "mouseenter", handler, {
            passive: true
        });
    }
    return isLeft;
}
function useParallax(target, options = {
}) {
    const { deviceOrientationTiltAdjust =(i)=>i
     , deviceOrientationRollAdjust =(i)=>i
     , mouseTiltAdjust =(i)=>i
     , mouseRollAdjust =(i)=>i
     , window =defaultWindow  } = options;
    const orientation = _vueDemi.reactive(useDeviceOrientation({
        window
    }));
    const { elementX: x , elementY: y , elementWidth: width , elementHeight: height  } = useMouseInElement(target, {
        handleOutside: false,
        window
    });
    const source = _vueDemi.computed(()=>{
        if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) return "deviceOrientation";
        return "mouse";
    });
    const roll = _vueDemi.computed(()=>{
        if (source.value === "deviceOrientation") {
            const value = -orientation.beta / 90;
            return deviceOrientationRollAdjust(value);
        } else {
            const value = -(y.value - height.value / 2) / height.value;
            return mouseRollAdjust(value);
        }
    });
    const tilt = _vueDemi.computed(()=>{
        if (source.value === "deviceOrientation") {
            const value = orientation.gamma / 90;
            return deviceOrientationTiltAdjust(value);
        } else {
            const value = (x.value - width.value / 2) / width.value;
            return mouseTiltAdjust(value);
        }
    });
    return {
        roll,
        tilt,
        source
    };
}
var __defProp$5 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value)=>key in obj ? __defProp$5(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$5 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$5.call(b, prop)) __defNormalProp$5(a, prop, b[prop]);
    if (__getOwnPropSymbols$5) {
        for (var prop of __getOwnPropSymbols$5(b))if (__propIsEnum$5.call(b, prop)) __defNormalProp$5(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$2 = (a, b)=>__defProps$2(a, __getOwnPropDescs$2(b))
;
const defaultState = {
    x: 0,
    y: 0,
    pointerId: 0,
    pressure: 0,
    tiltX: 0,
    tiltY: 0,
    width: 0,
    height: 0,
    twist: 0,
    pointerType: null
};
const keys = /* @__PURE__ */ Object.keys(defaultState);
function usePointer(options = {
}) {
    const { target =defaultWindow  } = options;
    const isInside = _vueDemi.ref(false);
    const state = _vueDemi.ref(options.initialValue || {
    });
    Object.assign(state.value, defaultState, state.value);
    const handler = (event)=>{
        isInside.value = true;
        if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType)) return;
        state.value = _shared.objectPick(event, keys, false);
    };
    if (target) {
        useEventListener(target, "pointerdown", handler, {
            passive: true
        });
        useEventListener(target, "pointermove", handler, {
            passive: true
        });
        useEventListener(target, "pointerleave", ()=>isInside.value = false
        , {
            passive: true
        });
    }
    return __spreadProps$2(__spreadValues$5({
    }, _shared.toRefs(state)), {
        isInside
    });
}
var SwipeDirection = /* @__PURE__ */ ((SwipeDirection2)=>{
    SwipeDirection2["UP"] = "UP";
    SwipeDirection2["RIGHT"] = "RIGHT";
    SwipeDirection2["DOWN"] = "DOWN";
    SwipeDirection2["LEFT"] = "LEFT";
    SwipeDirection2["NONE"] = "NONE";
    return SwipeDirection2;
})(SwipeDirection || {
});
function useSwipe(target, options = {
}) {
    const { threshold =50 , onSwipe , onSwipeEnd , onSwipeStart , passive =true , window =defaultWindow  } = options;
    const coordsStart = _vueDemi.reactive({
        x: 0,
        y: 0
    });
    const coordsEnd = _vueDemi.reactive({
        x: 0,
        y: 0
    });
    const diffX = _vueDemi.computed(()=>coordsStart.x - coordsEnd.x
    );
    const diffY = _vueDemi.computed(()=>coordsStart.y - coordsEnd.y
    );
    const { max , abs  } = Math;
    const isThresholdExceeded = _vueDemi.computed(()=>max(abs(diffX.value), abs(diffY.value)) >= threshold
    );
    const isSwiping = _vueDemi.ref(false);
    const direction = _vueDemi.computed(()=>{
        if (!isThresholdExceeded.value) return "NONE" /* NONE */ ;
        if (abs(diffX.value) > abs(diffY.value)) return diffX.value > 0 ? "LEFT" /* LEFT */  : "RIGHT" /* RIGHT */ ;
        else return diffY.value > 0 ? "UP" /* UP */  : "DOWN" /* DOWN */ ;
    });
    const getTouchEventCoords = (e)=>[
            e.touches[0].clientX,
            e.touches[0].clientY
        ]
    ;
    const updateCoordsStart = (x, y)=>{
        coordsStart.x = x;
        coordsStart.y = y;
    };
    const updateCoordsEnd = (x, y)=>{
        coordsEnd.x = x;
        coordsEnd.y = y;
    };
    let listenerOptions;
    const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);
    if (!passive) listenerOptions = isPassiveEventSupported ? {
        passive: false,
        capture: true
    } : {
        capture: true
    };
    else listenerOptions = isPassiveEventSupported ? {
        passive: true
    } : {
        capture: false
    };
    const onTouchEnd = (e)=>{
        if (isSwiping.value) onSwipeEnd == null || onSwipeEnd(e, direction.value);
        isSwiping.value = false;
    };
    const stops = [
        useEventListener(target, "touchstart", (e)=>{
            if (listenerOptions.capture && !listenerOptions.passive) e.preventDefault();
            const [x, y] = getTouchEventCoords(e);
            updateCoordsStart(x, y);
            updateCoordsEnd(x, y);
            onSwipeStart == null || onSwipeStart(e);
        }, listenerOptions),
        useEventListener(target, "touchmove", (e)=>{
            const [x, y] = getTouchEventCoords(e);
            updateCoordsEnd(x, y);
            if (!isSwiping.value && isThresholdExceeded.value) isSwiping.value = true;
            if (isSwiping.value) onSwipe == null || onSwipe(e);
        }, listenerOptions),
        useEventListener(target, "touchend", onTouchEnd, listenerOptions),
        useEventListener(target, "touchcancel", onTouchEnd, listenerOptions)
    ];
    const stop = ()=>stops.forEach((s)=>s()
        )
    ;
    return {
        isPassiveEventSupported,
        isSwiping,
        direction,
        coordsStart,
        coordsEnd,
        lengthX: diffX,
        lengthY: diffY,
        stop
    };
}
function checkPassiveEventSupport(document) {
    if (!document) return false;
    let supportsPassive = false;
    const optionsBlock = {
        get passive () {
            supportsPassive = true;
            return false;
        }
    };
    document.addEventListener("x", _shared.noop, optionsBlock);
    document.removeEventListener("x", _shared.noop);
    return supportsPassive;
}
function usePointerSwipe(target, options = {
}) {
    const targetRef = _vueDemi.ref(target);
    const { threshold =50 , onSwipe , onSwipeEnd , onSwipeStart  } = options;
    const posStart = _vueDemi.reactive({
        x: 0,
        y: 0
    });
    const updatePosStart = (x, y)=>{
        posStart.x = x;
        posStart.y = y;
    };
    const posEnd = _vueDemi.reactive({
        x: 0,
        y: 0
    });
    const updatePosEnd = (x, y)=>{
        posEnd.x = x;
        posEnd.y = y;
    };
    const distanceX = _vueDemi.computed(()=>posStart.x - posEnd.x
    );
    const distanceY = _vueDemi.computed(()=>posStart.y - posEnd.y
    );
    const { max , abs  } = Math;
    const isThresholdExceeded = _vueDemi.computed(()=>max(abs(distanceX.value), abs(distanceY.value)) >= threshold
    );
    const isSwiping = _vueDemi.ref(false);
    const isPointerDown = _vueDemi.ref(false);
    const direction = _vueDemi.computed(()=>{
        if (!isThresholdExceeded.value) return SwipeDirection.NONE;
        if (abs(distanceX.value) > abs(distanceY.value)) return distanceX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;
        else return distanceY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;
    });
    const filterEvent = (e)=>{
        if (options.pointerTypes) return options.pointerTypes.includes(e.pointerType);
        return true;
    };
    const stops = [
        useEventListener(target, "pointerdown", (e)=>{
            var _a21, _b6;
            if (!filterEvent(e)) return;
            isPointerDown.value = true;
            (_b6 = (_a21 = targetRef.value) == null ? void 0 : _a21.style) == null || _b6.setProperty("touch-action", "none");
            const eventTarget = e.target;
            eventTarget == null || eventTarget.setPointerCapture(e.pointerId);
            const { clientX: x , clientY: y  } = e;
            updatePosStart(x, y);
            updatePosEnd(x, y);
            onSwipeStart == null || onSwipeStart(e);
        }),
        useEventListener(target, "pointermove", (e)=>{
            if (!filterEvent(e)) return;
            if (!isPointerDown.value) return;
            const { clientX: x , clientY: y  } = e;
            updatePosEnd(x, y);
            if (!isSwiping.value && isThresholdExceeded.value) isSwiping.value = true;
            if (isSwiping.value) onSwipe == null || onSwipe(e);
        }),
        useEventListener(target, "pointerup", (e)=>{
            var _a22, _b7;
            if (!filterEvent(e)) return;
            if (isSwiping.value) onSwipeEnd == null || onSwipeEnd(e, direction.value);
            isPointerDown.value = false;
            isSwiping.value = false;
            (_b7 = (_a22 = targetRef.value) == null ? void 0 : _a22.style) == null || _b7.setProperty("touch-action", "initial");
        })
    ];
    const stop = ()=>stops.forEach((s)=>s()
        )
    ;
    return {
        isSwiping: _vueDemi.readonly(isSwiping),
        direction: _vueDemi.readonly(direction),
        posStart: _vueDemi.readonly(posStart),
        posEnd: _vueDemi.readonly(posEnd),
        distanceX,
        distanceY,
        stop
    };
}
function usePreferredColorScheme(options) {
    const isLight = useMediaQuery("(prefers-color-scheme: light)", options);
    const isDark = useMediaQuery("(prefers-color-scheme: dark)", options);
    return _vueDemi.computed(()=>{
        if (isDark.value) return "dark";
        if (isLight.value) return "light";
        return "no-preference";
    });
}
function usePreferredLanguages(options = {
}) {
    const { window =defaultWindow  } = options;
    if (!window) return _vueDemi.ref([
        "en"
    ]);
    const navigator = window.navigator;
    const value = _vueDemi.ref(navigator.languages);
    useEventListener(window, "languagechange", ()=>{
        value.value = navigator.languages;
    });
    return value;
}
const topVarName = "--vueuse-safe-area-top";
const rightVarName = "--vueuse-safe-area-right";
const bottomVarName = "--vueuse-safe-area-bottom";
const leftVarName = "--vueuse-safe-area-left";
function useScreenSafeArea() {
    const top = _vueDemi.ref("");
    const right = _vueDemi.ref("");
    const bottom = _vueDemi.ref("");
    const left = _vueDemi.ref("");
    if (_shared.isClient) {
        const topCssVar = useCssVar(topVarName);
        const rightCssVar = useCssVar(rightVarName);
        const bottomCssVar = useCssVar(bottomVarName);
        const leftCssVar = useCssVar(leftVarName);
        topCssVar.value = "env(safe-area-inset-top, 0px)";
        rightCssVar.value = "env(safe-area-inset-right, 0px)";
        bottomCssVar.value = "env(safe-area-inset-bottom, 0px)";
        leftCssVar.value = "env(safe-area-inset-left, 0px)";
        update();
        useEventListener("resize", _shared.useDebounceFn(update));
    }
    function update() {
        top.value = getValue(topVarName);
        right.value = getValue(rightVarName);
        bottom.value = getValue(bottomVarName);
        left.value = getValue(leftVarName);
    }
    return {
        top,
        right,
        bottom,
        left,
        update
    };
}
function getValue(position) {
    return getComputedStyle(document.documentElement).getPropertyValue(position);
}
function useScriptTag(src, onLoaded = _shared.noop, options = {
}) {
    const { immediate =true , manual =false , type ="text/javascript" , async =true , crossOrigin , referrerPolicy , noModule , defer , document =defaultDocument , attrs ={
    }  } = options;
    const scriptTag = _vueDemi.ref(null);
    let _promise = null;
    const loadScript = (waitForScriptLoad)=>new Promise((resolve, reject)=>{
            const resolveWithElement = (el2)=>{
                scriptTag.value = el2;
                resolve(el2);
                return el2;
            };
            if (!document) {
                resolve(false);
                return;
            }
            let shouldAppend = false;
            let el = document.querySelector(`script[src="${src}"]`);
            if (!el) {
                el = document.createElement("script");
                el.type = type;
                el.async = async;
                el.src = _vueDemi.unref(src);
                if (defer) el.defer = defer;
                if (crossOrigin) el.crossOrigin = crossOrigin;
                if (noModule) el.noModule = noModule;
                if (referrerPolicy) el.referrerPolicy = referrerPolicy;
                for(const attr in attrs)el[attr] = attrs[attr];
                shouldAppend = true;
            } else if (el.hasAttribute("data-loaded")) resolveWithElement(el);
            el.addEventListener("error", (event)=>reject(event)
            );
            el.addEventListener("abort", (event)=>reject(event)
            );
            el.addEventListener("load", ()=>{
                el.setAttribute("data-loaded", "true");
                onLoaded(el);
                resolveWithElement(el);
            });
            if (shouldAppend) el = document.head.appendChild(el);
            if (!waitForScriptLoad) resolveWithElement(el);
        })
    ;
    const load = (waitForScriptLoad = true)=>{
        if (!_promise) _promise = loadScript(waitForScriptLoad);
        return _promise;
    };
    const unload = ()=>{
        if (!document) return;
        _promise = null;
        if (scriptTag.value) scriptTag.value = null;
        const el = document.querySelector(`script[src="${src}"]`);
        if (el) document.head.removeChild(el);
    };
    if (immediate && !manual) _shared.tryOnMounted(load);
    if (!manual) _shared.tryOnUnmounted(unload);
    return {
        scriptTag,
        load,
        unload
    };
}
var _a, _b;
function preventDefault(rawEvent) {
    const e = rawEvent || window.event;
    if (e.touches.length > 1) return true;
    if (e.preventDefault) e.preventDefault();
    return false;
}
const isIOS = _shared.isClient && (window == null ? void 0 : window.navigator) && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.platform) && /iP(ad|hone|od)/.test((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.platform);
function useScrollLock(element, initialState4 = false) {
    const isLocked = _vueDemi.ref(initialState4);
    let touchMoveListener = null;
    let initialOverflow;
    const lock = ()=>{
        const ele = _vueDemi.unref(element);
        if (!ele || isLocked.value) return;
        initialOverflow = ele.style.overflow;
        if (isIOS) touchMoveListener = useEventListener(document, "touchmove", preventDefault, {
            passive: false
        });
        ele.style.overflow = "hidden";
        isLocked.value = true;
    };
    const unlock = ()=>{
        const ele = _vueDemi.unref(element);
        if (!ele || !isLocked.value) return;
        isIOS && (touchMoveListener == null || touchMoveListener());
        ele.style.overflow = initialOverflow;
        isLocked.value = false;
    };
    return _vueDemi.computed({
        get () {
            return isLocked.value;
        },
        set (v) {
            if (v) lock();
            else unlock();
        }
    });
}
function useSessionStorage(key, initialValue, options = {
}) {
    const { window =defaultWindow  } = options;
    return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);
}
var __defProp$4 = Object.defineProperty;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value)=>key in obj ? __defProp$4(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$4 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$4.call(b, prop)) __defNormalProp$4(a, prop, b[prop]);
    if (__getOwnPropSymbols$4) {
        for (var prop of __getOwnPropSymbols$4(b))if (__propIsEnum$4.call(b, prop)) __defNormalProp$4(a, prop, b[prop]);
    }
    return a;
};
function useShare(shareOptions = {
}, options = {
}) {
    const { navigator =defaultNavigator  } = options;
    const _navigator = navigator;
    const isSupported = _navigator && "canShare" in _navigator;
    const share = async (overrideOptions = {
    })=>{
        if (isSupported) {
            const data = __spreadValues$4(__spreadValues$4({
            }, _vueDemi.unref(shareOptions)), _vueDemi.unref(overrideOptions));
            let granted = true;
            if (data.files && _navigator.canShare) granted = _navigator.canShare({
                files: data.files
            });
            if (granted) return _navigator.share(data);
        }
    };
    return {
        isSupported,
        share
    };
}
function useSpeechRecognition(options = {
}) {
    const { interimResults =true , continuous =true , window =defaultWindow  } = options;
    const lang = _vueDemi.ref(options.lang || "en-US");
    const isListening = _vueDemi.ref(false);
    const isFinal = _vueDemi.ref(false);
    const result = _vueDemi.ref("");
    const error = _vueDemi.shallowRef(void 0);
    const toggle = (value = !isListening.value)=>{
        isListening.value = value;
    };
    const start = ()=>{
        isListening.value = true;
    };
    const stop = ()=>{
        isListening.value = false;
    };
    const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);
    const isSupported = Boolean(SpeechRecognition);
    let recognition;
    if (isSupported) {
        recognition = new SpeechRecognition();
        recognition.continuous = continuous;
        recognition.interimResults = interimResults;
        recognition.lang = _vueDemi.unref(lang);
        recognition.onstart = ()=>{
            isFinal.value = false;
        };
        _vueDemi.watch(lang, (lang2)=>{
            if (recognition && !isListening.value) recognition.lang = lang2;
        });
        recognition.onresult = (event)=>{
            const transcript = Array.from(event.results).map((result2)=>{
                isFinal.value = result2.isFinal;
                return result2[0];
            }).map((result2)=>result2.transcript
            ).join("");
            result.value = transcript;
            error.value = void 0;
        };
        recognition.onerror = (event)=>{
            error.value = event;
        };
        recognition.onend = ()=>{
            isListening.value = false;
            recognition.lang = _vueDemi.unref(lang);
        };
        _vueDemi.watch(isListening, ()=>{
            if (isListening.value) recognition.start();
            else recognition.stop();
        });
    }
    _shared.tryOnScopeDispose(()=>{
        isListening.value = false;
    });
    return {
        isSupported,
        isListening,
        isFinal,
        recognition,
        result,
        error,
        toggle,
        start,
        stop
    };
}
function useSpeechSynthesis(text, options = {
}) {
    var _a23, _b8;
    const { pitch =1 , rate =1 , volume =1 , window =defaultWindow  } = options;
    const synth = window && window.speechSynthesis;
    const isSupported = Boolean(synth);
    const isPlaying = _vueDemi.ref(false);
    const status = _vueDemi.ref("init");
    const voiceInfo = {
        lang: ((_a23 = options.voice) == null ? void 0 : _a23.lang) || "default",
        name: ((_b8 = options.voice) == null ? void 0 : _b8.name) || ""
    };
    const spokenText = _vueDemi.ref(text || "");
    const lang = _vueDemi.ref(options.lang || "en-US");
    const error = _vueDemi.shallowRef(void 0);
    const toggle = (value = !isPlaying.value)=>{
        isPlaying.value = value;
    };
    const bindEventsForUtterance = (utterance2)=>{
        utterance2.lang = _vueDemi.unref(lang);
        options.voice && (utterance2.voice = options.voice);
        utterance2.pitch = pitch;
        utterance2.rate = rate;
        utterance2.volume = volume;
        utterance2.onstart = ()=>{
            isPlaying.value = true;
            status.value = "play";
        };
        utterance2.onpause = ()=>{
            isPlaying.value = false;
            status.value = "pause";
        };
        utterance2.onresume = ()=>{
            isPlaying.value = true;
            status.value = "play";
        };
        utterance2.onend = ()=>{
            isPlaying.value = false;
            status.value = "end";
        };
        utterance2.onerror = (event)=>{
            error.value = event;
        };
        utterance2.onend = ()=>{
            isPlaying.value = false;
            utterance2.lang = _vueDemi.unref(lang);
        };
    };
    const utterance = _vueDemi.computed(()=>{
        isPlaying.value = false;
        status.value = "init";
        const newUtterance = new SpeechSynthesisUtterance(spokenText.value);
        bindEventsForUtterance(newUtterance);
        return newUtterance;
    });
    const speak = ()=>{
        synth.cancel();
        utterance && synth.speak(utterance.value);
    };
    if (isSupported) {
        bindEventsForUtterance(utterance.value);
        _vueDemi.watch(lang, (lang2)=>{
            if (utterance.value && !isPlaying.value) utterance.value.lang = lang2;
        });
        _vueDemi.watch(isPlaying, ()=>{
            if (isPlaying.value) synth.resume();
            else synth.pause();
        });
    }
    _shared.tryOnScopeDispose(()=>{
        isPlaying.value = false;
    });
    return {
        isSupported,
        isPlaying,
        status,
        voiceInfo,
        utterance,
        error,
        toggle,
        speak
    };
}
function useStorageAsync(key, initialValue, storage, options = {
}) {
    var _a24;
    const { flush ="pre" , deep =true , listenToStorageChanges =true , writeDefaults =true , shallow , window =defaultWindow , eventFilter , onError =(e)=>{
        console.error(e);
    }  } = options;
    const rawInit = _vueDemi.unref(initialValue);
    const type = guessSerializerType(rawInit);
    const data = (shallow ? _vueDemi.shallowRef : _vueDemi.ref)(initialValue);
    const serializer = (_a24 = options.serializer) != null ? _a24 : StorageSerializers[type];
    if (!storage) try {
        storage = getSSRHandler("getDefaultStorage", ()=>{
            var _a2;
            return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
        })();
    } catch (e2) {
        onError(e2);
    }
    async function read(event) {
        if (!storage || event && event.key !== key) return;
        try {
            const rawValue = event ? event.newValue : await storage.getItem(key);
            if (rawValue == null) {
                data.value = rawInit;
                if (writeDefaults && rawInit !== null) await storage.setItem(key, await serializer.write(rawInit));
            } else data.value = await serializer.read(rawValue);
        } catch (e) {
            onError(e);
        }
    }
    read();
    if (window && listenToStorageChanges) useEventListener(window, "storage", (e)=>setTimeout(()=>read(e)
        , 0)
    );
    if (storage) _shared.watchWithFilter(data, async ()=>{
        try {
            if (data.value == null) await storage.removeItem(key);
            else await storage.setItem(key, await serializer.write(data.value));
        } catch (e) {
            onError(e);
        }
    }, {
        flush,
        deep,
        eventFilter
    });
    return data;
}
let _id = 0;
function useStyleTag(css, options = {
}) {
    const isLoaded = _vueDemi.ref(false);
    const { document =defaultDocument , immediate =true , manual =false , id =`vueuse_styletag_${++_id}`  } = options;
    const cssRef = _vueDemi.ref(css);
    let stop = ()=>{
    };
    const load = ()=>{
        if (!document) return;
        const el = document.getElementById(id) || document.createElement("style");
        el.type = "text/css";
        el.id = id;
        if (options.media) el.media = options.media;
        document.head.appendChild(el);
        if (isLoaded.value) return;
        stop = _vueDemi.watch(cssRef, (value)=>{
            el.innerText = value;
        }, {
            immediate: true
        });
        isLoaded.value = true;
    };
    const unload = ()=>{
        if (!document || !isLoaded.value) return;
        stop();
        document.head.removeChild(document.getElementById(id));
        isLoaded.value = false;
    };
    if (immediate && !manual) load();
    if (!manual) _shared.tryOnScopeDispose(unload);
    return {
        id,
        css: cssRef,
        unload,
        load,
        isLoaded: _vueDemi.readonly(isLoaded)
    };
}
function useTemplateRefsList() {
    const refs = _vueDemi.ref([]);
    refs.value.set = (el)=>{
        if (el) refs.value.push(el);
    };
    _vueDemi.onBeforeUpdate(()=>{
        refs.value.length = 0;
    });
    return refs;
}
var __defProp$3 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value)=>key in obj ? __defProp$3(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$3 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$3.call(b, prop)) __defNormalProp$3(a, prop, b[prop]);
    if (__getOwnPropSymbols$3) {
        for (var prop of __getOwnPropSymbols$3(b))if (__propIsEnum$3.call(b, prop)) __defNormalProp$3(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$1 = (a, b)=>__defProps$1(a, __getOwnPropDescs$1(b))
;
const initialRect = {
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    height: 0,
    width: 0
};
const initialState = __spreadValues$3({
    text: ""
}, initialRect);
function getRectFromSelection(selection) {
    if (!selection || selection.rangeCount < 1) return initialRect;
    const range = selection.getRangeAt(0);
    const { height , width , top , left , right , bottom  } = range.getBoundingClientRect();
    return {
        height,
        width,
        top,
        left,
        right,
        bottom
    };
}
function useTextSelection(element) {
    var _a25;
    const state = _vueDemi.ref(initialState);
    if (!((_a25 = defaultWindow) == null ? void 0 : _a25.getSelection)) return state;
    const onMouseup = ()=>{
        var _a2;
        const text = (_a2 = window.getSelection()) == null ? void 0 : _a2.toString();
        if (text) {
            const rect = getRectFromSelection(window.getSelection());
            state.value = __spreadProps$1(__spreadValues$3(__spreadValues$3({
            }, state.value), rect), {
                text
            });
        }
    };
    const onMousedown = ()=>{
        var _a2;
        state.value.text && (state.value = initialState);
        (_a2 = window.getSelection()) == null || _a2.removeAllRanges();
    };
    useEventListener(element != null ? element : document, "mouseup", onMouseup);
    useEventListener(document, "mousedown", onMousedown);
    return state;
}
var __defProp$2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value)=>key in obj ? __defProp$2(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$2 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);
    if (__getOwnPropSymbols$2) {
        for (var prop of __getOwnPropSymbols$2(b))if (__propIsEnum$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b))
;
function useThrottledRefHistory(source, options = {
}) {
    const { throttle =200 , trailing =true  } = options;
    const filter = _shared.throttleFilter(throttle, trailing);
    const history = useRefHistory(source, __spreadProps(__spreadValues$2({
    }, options), {
        eventFilter: filter
    }));
    return __spreadValues$2({
    }, history);
}
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value)=>key in obj ? __defProp$1(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$1 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);
    if (__getOwnPropSymbols$1) {
        for (var prop of __getOwnPropSymbols$1(b))if (__propIsEnum$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);
    }
    return a;
};
var __objRest = (source, exclude)=>{
    var target = {
    };
    for(var prop in source)if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$1) {
        for (var prop of __getOwnPropSymbols$1(source))if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
const UNITS = [
    {
        max: 60000,
        value: 1000,
        name: "second"
    },
    {
        max: 2760000,
        value: 60000,
        name: "minute"
    },
    {
        max: 72000000,
        value: 3600000,
        name: "hour"
    },
    {
        max: 518400000,
        value: 86400000,
        name: "day"
    },
    {
        max: 2419200000,
        value: 604800000,
        name: "week"
    },
    {
        max: 28512000000,
        value: 2592000000,
        name: "month"
    },
    {
        max: Infinity,
        value: 31536000000,
        name: "year"
    }
];
const DEFAULT_MESSAGES = {
    justNow: "just now",
    past: (n)=>n.match(/\d/) ? `${n} ago` : n
    ,
    future: (n)=>n.match(/\d/) ? `in ${n}` : n
    ,
    month: (n, past)=>n === 1 ? past ? "last month" : "next month" : `${n} month${n > 1 ? "s" : ""}`
    ,
    year: (n, past)=>n === 1 ? past ? "last year" : "next year" : `${n} year${n > 1 ? "s" : ""}`
    ,
    day: (n, past)=>n === 1 ? past ? "yesterday" : "tomorrow" : `${n} day${n > 1 ? "s" : ""}`
    ,
    week: (n, past)=>n === 1 ? past ? "last week" : "next week" : `${n} week${n > 1 ? "s" : ""}`
    ,
    hour: (n)=>`${n} hour${n > 1 ? "s" : ""}`
    ,
    minute: (n)=>`${n} minute${n > 1 ? "s" : ""}`
    ,
    second: (n)=>`${n} second${n > 1 ? "s" : ""}`
};
const DEFAULT_FORMATTER = (date)=>date.toISOString().slice(0, 10)
;
function useTimeAgo(time, options = {
}) {
    const { controls: exposeControls = false , max , updateInterval =30000 , messages =DEFAULT_MESSAGES , fullDateFormatter =DEFAULT_FORMATTER  } = options;
    const { abs , round  } = Math;
    const _a26 = useNow({
        interval: updateInterval,
        controls: true
    }), { now  } = _a26, controls = __objRest(_a26, [
        "now"
    ]);
    function getTimeago(from, now2) {
        var _a2;
        const diff = +now2 - +from;
        const absDiff = abs(diff);
        if (absDiff < 60000) return messages.justNow;
        if (typeof max === "number" && absDiff > max) return fullDateFormatter(new Date(from));
        if (typeof max === "string") {
            const unitMax = (_a2 = UNITS.find((i)=>i.name === max
            )) == null ? void 0 : _a2.max;
            if (unitMax && absDiff > unitMax) return fullDateFormatter(new Date(from));
        }
        for (const unit of UNITS){
            if (absDiff < unit.max) return format(diff, unit);
        }
    }
    function applyFormat(name, val, isPast) {
        const formatter = messages[name];
        if (typeof formatter === "function") return formatter(val, isPast);
        return formatter.replace("{0}", val.toString());
    }
    function format(diff, unit) {
        const val = round(abs(diff) / unit.value);
        const past = diff > 0;
        const str = applyFormat(unit.name, val, past);
        return applyFormat(past ? "past" : "future", str, past);
    }
    const timeAgo = _vueDemi.computed(()=>getTimeago(new Date(_vueDemi.unref(time)), _vueDemi.unref(now.value))
    );
    if (exposeControls) return __spreadValues$1({
        timeAgo
    }, controls);
    else return timeAgo;
}
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) {
        for (var prop of __getOwnPropSymbols(b))if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
function useTimestamp(options = {
}) {
    const { controls: exposeControls = false , offset =0 , immediate =true , interval ="requestAnimationFrame"  } = options;
    const ts = _vueDemi.ref(_shared.timestamp() + offset);
    const update = ()=>ts.value = _shared.timestamp() + offset
    ;
    const controls = interval === "requestAnimationFrame" ? useRafFn(update, {
        immediate
    }) : _shared.useIntervalFn(update, interval, {
        immediate
    });
    if (exposeControls) return __spreadValues({
        timestamp: ts
    }, controls);
    else return ts;
}
function useTitle(newTitle = null, options = {
}) {
    var _a27, _b9;
    const { document =defaultDocument , observe =false , titleTemplate ="%s"  } = options;
    const title = _vueDemi.ref((_a27 = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _a27 : null);
    _vueDemi.watch(title, (t, o)=>{
        if (_shared.isString(t) && t !== o && document) document.title = titleTemplate.replace("%s", t);
    }, {
        immediate: true
    });
    if (observe && document) useMutationObserver((_b9 = document.head) == null ? void 0 : _b9.querySelector("title"), ()=>{
        if (document && document.title !== title.value) title.value = titleTemplate.replace("%s", document.title);
    }, {
        childList: true
    });
    return title;
}
const TransitionPresets = {
    linear: _shared.identity,
    easeInSine: [
        0.12,
        0,
        0.39,
        0
    ],
    easeOutSine: [
        0.61,
        1,
        0.88,
        1
    ],
    easeInOutSine: [
        0.37,
        0,
        0.63,
        1
    ],
    easeInQuad: [
        0.11,
        0,
        0.5,
        0
    ],
    easeOutQuad: [
        0.5,
        1,
        0.89,
        1
    ],
    easeInOutQuad: [
        0.45,
        0,
        0.55,
        1
    ],
    easeInCubic: [
        0.32,
        0,
        0.67,
        0
    ],
    easeOutCubic: [
        0.33,
        1,
        0.68,
        1
    ],
    easeInOutCubic: [
        0.65,
        0,
        0.35,
        1
    ],
    easeInQuart: [
        0.5,
        0,
        0.75,
        0
    ],
    easeOutQuart: [
        0.25,
        1,
        0.5,
        1
    ],
    easeInOutQuart: [
        0.76,
        0,
        0.24,
        1
    ],
    easeInQuint: [
        0.64,
        0,
        0.78,
        0
    ],
    easeOutQuint: [
        0.22,
        1,
        0.36,
        1
    ],
    easeInOutQuint: [
        0.83,
        0,
        0.17,
        1
    ],
    easeInExpo: [
        0.7,
        0,
        0.84,
        0
    ],
    easeOutExpo: [
        0.16,
        1,
        0.3,
        1
    ],
    easeInOutExpo: [
        0.87,
        0,
        0.13,
        1
    ],
    easeInCirc: [
        0.55,
        0,
        1,
        0.45
    ],
    easeOutCirc: [
        0,
        0.55,
        0.45,
        1
    ],
    easeInOutCirc: [
        0.85,
        0,
        0.15,
        1
    ],
    easeInBack: [
        0.36,
        0,
        0.66,
        -0.56
    ],
    easeOutBack: [
        0.34,
        1.56,
        0.64,
        1
    ],
    easeInOutBack: [
        0.68,
        -0.6,
        0.32,
        1.6
    ]
};
function createEasingFunction([p0, p1, p2, p3]) {
    const a = (a1, a2)=>1 - 3 * a2 + 3 * a1
    ;
    const b = (a1, a2)=>3 * a2 - 6 * a1
    ;
    const c = (a1)=>3 * a1
    ;
    const calcBezier = (t, a1, a2)=>((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t
    ;
    const getSlope = (t, a1, a2)=>3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1)
    ;
    const getTforX = (x)=>{
        let aGuessT = x;
        for(let i = 0; i < 4; ++i){
            const currentSlope = getSlope(aGuessT, p0, p2);
            if (currentSlope === 0) return aGuessT;
            const currentX = calcBezier(aGuessT, p0, p2) - x;
            aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
    };
    return (x)=>p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3)
    ;
}
function useTransition(source, options = {
}) {
    const { delay =0 , disabled =false , duration =1000 , onFinished =_shared.noop , onStarted =_shared.noop , transition =_shared.identity  } = options;
    const currentTransition = _vueDemi.computed(()=>{
        const t = _vueDemi.unref(transition);
        return _shared.isFunction(t) ? t : createEasingFunction(t);
    });
    const sourceValue = _vueDemi.computed(()=>{
        const s = _vueDemi.unref(source);
        return _shared.isNumber(s) ? s : s.map(_vueDemi.unref);
    });
    const sourceVector = _vueDemi.computed(()=>_shared.isNumber(sourceValue.value) ? [
            sourceValue.value
        ] : sourceValue.value
    );
    const outputVector = _vueDemi.ref(sourceVector.value.slice(0));
    let currentDuration;
    let diffVector;
    let endAt;
    let startAt;
    let startVector;
    const { resume , pause  } = useRafFn(()=>{
        const now = Date.now();
        const progress = _shared.clamp(1 - (endAt - now) / currentDuration, 0, 1);
        outputVector.value = startVector.map((val, i)=>{
            var _a28;
            return val + ((_a28 = diffVector[i]) != null ? _a28 : 0) * currentTransition.value(progress);
        });
        if (progress >= 1) {
            pause();
            onFinished();
        }
    }, {
        immediate: false
    });
    const start = ()=>{
        pause();
        currentDuration = _vueDemi.unref(duration);
        diffVector = outputVector.value.map((n, i)=>{
            var _a29, _b10;
            return ((_a29 = sourceVector.value[i]) != null ? _a29 : 0) - ((_b10 = outputVector.value[i]) != null ? _b10 : 0);
        });
        startVector = outputVector.value.slice(0);
        startAt = Date.now();
        endAt = startAt + currentDuration;
        resume();
        onStarted();
    };
    const timeout = _shared.useTimeoutFn(start, delay, {
        immediate: false
    });
    _vueDemi.watch(sourceVector, ()=>{
        if (_vueDemi.unref(disabled)) outputVector.value = sourceVector.value.slice(0);
        else if (_vueDemi.unref(delay) <= 0) start();
        else timeout.start();
    }, {
        deep: true
    });
    return _vueDemi.computed(()=>{
        const targetVector = _vueDemi.unref(disabled) ? sourceVector : outputVector;
        return _shared.isNumber(sourceValue.value) ? targetVector.value[0] : targetVector.value;
    });
}
function useUrlSearchParams(mode = "history", options = {
}) {
    const { initialValue ={
    } , removeNullishValues =true , removeFalsyValues =false , window =defaultWindow  } = options;
    if (!window) return _vueDemi.reactive(initialValue);
    const state = _vueDemi.reactive(initialValue);
    function getRawParams() {
        if (mode === "history") return window.location.search || "";
        else if (mode === "hash") {
            const hash = window.location.hash || "";
            const index = hash.indexOf("?");
            return index > 0 ? hash.slice(index) : "";
        } else return (window.location.hash || "").replace(/^#/, "");
    }
    function constructQuery(params) {
        const stringified = params.toString();
        if (mode === "history") return `${stringified ? `?${stringified}` : ""}${location.hash || ""}`;
        if (mode === "hash-params") return `${location.search || ""}${stringified ? `#${stringified}` : ""}`;
        const hash = window.location.hash || "#";
        const index = hash.indexOf("?");
        if (index > 0) return `${hash.slice(0, index)}${stringified ? `?${stringified}` : ""}`;
        return `${hash}${stringified ? `?${stringified}` : ""}`;
    }
    function read() {
        return new URLSearchParams(getRawParams());
    }
    function updateState(params) {
        const unusedKeys = new Set(Object.keys(state));
        for (const key of params.keys()){
            const paramsForKey = params.getAll(key);
            state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || "";
            unusedKeys.delete(key);
        }
        Array.from(unusedKeys).forEach((key)=>delete state[key]
        );
    }
    const { pause , resume  } = _shared.pausableWatch(state, ()=>{
        const params = new URLSearchParams("");
        Object.keys(state).forEach((key)=>{
            const mapEntry = state[key];
            if (Array.isArray(mapEntry)) mapEntry.forEach((value)=>params.append(key, value)
            );
            else if (removeNullishValues && mapEntry == null) params.delete(key);
            else if (removeFalsyValues && !mapEntry) params.delete(key);
            else params.set(key, mapEntry);
        });
        write(params);
    }, {
        deep: true
    });
    function write(params, shouldUpdate) {
        pause();
        if (shouldUpdate) updateState(params);
        window.history.replaceState({
        }, "", window.location.pathname + constructQuery(params));
        resume();
    }
    function onChanged() {
        write(read(), true);
    }
    useEventListener(window, "popstate", onChanged, false);
    if (mode !== "history") useEventListener(window, "hashchange", onChanged, false);
    updateState(read());
    return state;
}
function useUserMedia(options = {
}) {
    var _a30, _b11, _c;
    const enabled = _vueDemi.ref((_a30 = options.enabled) != null ? _a30 : false);
    const autoSwitch = _vueDemi.ref((_b11 = options.autoSwitch) != null ? _b11 : true);
    const videoDeviceId = _vueDemi.ref(options.videoDeviceId);
    const audioDeviceId = _vueDemi.ref(options.audioDeviceId);
    const { navigator =defaultNavigator  } = options;
    const isSupported = Boolean((_c = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _c.getUserMedia);
    const stream = _vueDemi.shallowRef();
    function getDeviceOptions(device) {
        if (device.value === "none" || device.value === false) return false;
        if (device.value == null) return true;
        return {
            deviceId: device.value
        };
    }
    async function _start() {
        if (!isSupported || stream.value) return;
        stream.value = await navigator.mediaDevices.getUserMedia({
            video: getDeviceOptions(videoDeviceId),
            audio: getDeviceOptions(audioDeviceId)
        });
        return stream.value;
    }
    async function _stop() {
        var _a2;
        (_a2 = stream.value) == null || _a2.getTracks().forEach((t)=>t.stop()
        );
        stream.value = void 0;
    }
    function stop() {
        _stop();
        enabled.value = false;
    }
    async function start() {
        await _start();
        if (stream.value) enabled.value = true;
        return stream.value;
    }
    async function restart() {
        _stop();
        return await start();
    }
    _vueDemi.watch(enabled, (v)=>{
        if (v) _start();
        else _stop();
    }, {
        immediate: true
    });
    _vueDemi.watch([
        videoDeviceId,
        audioDeviceId
    ], ()=>{
        if (autoSwitch.value && stream.value) restart();
    }, {
        immediate: true
    });
    return {
        isSupported,
        stream,
        start,
        stop,
        restart,
        videoDeviceId,
        audioDeviceId,
        enabled,
        autoSwitch
    };
}
function useVModel(props, key, emit, options = {
}) {
    var _a31, _b12, _c;
    const { passive =false , eventName , deep =false  } = options;
    const vm = _vueDemi.getCurrentInstance();
    const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a31 = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a31.bind(vm));
    let event = eventName;
    if (!key) {
        if (_vueDemi.isVue2) {
            const modelOptions = (_c = (_b12 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b12.$options) == null ? void 0 : _c.model;
            key = (modelOptions == null ? void 0 : modelOptions.value) || "value";
            if (!eventName) event = (modelOptions == null ? void 0 : modelOptions.event) || "input";
        } else key = "modelValue";
    }
    event = eventName || event || `update:${key}`;
    if (passive) {
        const proxy = _vueDemi.ref(props[key]);
        _vueDemi.watch(()=>props[key]
        , (v)=>proxy.value = v
        );
        _vueDemi.watch(proxy, (v)=>{
            if (v !== props[key] || deep) _emit(event, v);
        }, {
            deep
        });
        return proxy;
    } else return _vueDemi.computed({
        get () {
            return props[key];
        },
        set (value) {
            _emit(event, value);
        }
    });
}
function useVModels(props, emit, options = {
}) {
    const ret = {
    };
    for(const key in props)ret[key] = useVModel(props, key, emit, options);
    return ret;
}
function useVibrate(options) {
    const { pattern =[] , interval =0 , navigator =defaultNavigator  } = options || {
    };
    const isSupported = typeof navigator !== "undefined" && "vibrate" in navigator;
    const patternRef = _vueDemi.ref(pattern);
    let intervalControls;
    const vibrate = (pattern2 = patternRef.value)=>{
        if (isSupported) navigator.vibrate(pattern2);
    };
    const stop = ()=>{
        if (isSupported) navigator.vibrate(0);
        intervalControls == null || intervalControls.pause();
    };
    if (interval > 0) intervalControls = _shared.useIntervalFn(vibrate, interval, {
        immediate: false,
        immediateCallback: false
    });
    return {
        isSupported,
        pattern,
        intervalControls,
        vibrate,
        stop
    };
}
function useVirtualList(list, options) {
    const containerRef = _vueDemi.ref();
    const size = useElementSize(containerRef);
    const currentList = _vueDemi.ref([]);
    const source = _vueDemi.shallowRef(list);
    const state = _vueDemi.ref({
        start: 0,
        end: 10
    });
    const { itemHeight , overscan =5  } = options;
    const getViewCapacity = (containerHeight)=>{
        if (typeof itemHeight === "number") return Math.ceil(containerHeight / itemHeight);
        const { start =0  } = state.value;
        let sum = 0;
        let capacity = 0;
        for(let i = start; i < source.value.length; i++){
            const height = itemHeight(i);
            sum += height;
            if (sum >= containerHeight) {
                capacity = i;
                break;
            }
        }
        return capacity - start;
    };
    const getOffset = (scrollTop)=>{
        if (typeof itemHeight === "number") return Math.floor(scrollTop / itemHeight) + 1;
        let sum = 0;
        let offset = 0;
        for(let i = 0; i < source.value.length; i++){
            const height = itemHeight(i);
            sum += height;
            if (sum >= scrollTop) {
                offset = i;
                break;
            }
        }
        return offset + 1;
    };
    const calculateRange = ()=>{
        const element = containerRef.value;
        if (element) {
            const offset = getOffset(element.scrollTop);
            const viewCapacity = getViewCapacity(element.clientHeight);
            const from = offset - overscan;
            const to = offset + viewCapacity + overscan;
            state.value = {
                start: from < 0 ? 0 : from,
                end: to > source.value.length ? source.value.length : to
            };
            currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index)=>({
                    data: ele,
                    index: index + state.value.start
                })
            );
        }
    };
    _vueDemi.watch([
        size.width,
        size.height,
        list
    ], ()=>{
        calculateRange();
    });
    const totalHeight = _vueDemi.computed(()=>{
        if (typeof itemHeight === "number") return source.value.length * itemHeight;
        return source.value.reduce((sum, _, index)=>sum + itemHeight(index)
        , 0);
    });
    const getDistanceTop = (index)=>{
        if (typeof itemHeight === "number") {
            const height2 = index * itemHeight;
            return height2;
        }
        const height = source.value.slice(0, index).reduce((sum, _, i)=>sum + itemHeight(i)
        , 0);
        return height;
    };
    const scrollTo = (index)=>{
        if (containerRef.value) {
            containerRef.value.scrollTop = getDistanceTop(index);
            calculateRange();
        }
    };
    const offsetTop = _vueDemi.computed(()=>getDistanceTop(state.value.start)
    );
    const wrapperProps = _vueDemi.computed(()=>{
        return {
            style: {
                width: "100%",
                height: `${totalHeight.value - offsetTop.value}px`,
                marginTop: `${offsetTop.value}px`
            }
        };
    });
    const containerStyle = {
        overflowY: "auto"
    };
    return {
        list: currentList,
        scrollTo,
        containerProps: {
            ref: containerRef,
            onScroll: ()=>{
                calculateRange();
            },
            style: containerStyle
        },
        wrapperProps
    };
}
const useWakeLock = (options = {
})=>{
    const { navigator =defaultNavigator , document =defaultDocument  } = options;
    let wakeLock;
    const isSupported = navigator && "wakeLock" in navigator;
    const isActive = _vueDemi.ref(false);
    async function onVisibilityChange() {
        if (!isSupported || !wakeLock) return;
        if (document && document.visibilityState === "visible") wakeLock = await navigator.wakeLock.request("screen");
        isActive.value = !wakeLock.released;
    }
    if (document) useEventListener(document, "visibilitychange", onVisibilityChange, {
        passive: true
    });
    async function request(type) {
        if (!isSupported) return;
        wakeLock = await navigator.wakeLock.request(type);
        isActive.value = !wakeLock.released;
    }
    async function release() {
        if (!isSupported || !wakeLock) return;
        await wakeLock.release();
        isActive.value = !wakeLock.released;
        wakeLock = null;
    }
    return {
        isSupported,
        isActive,
        request,
        release
    };
};
const useWebNotification = (defaultOptions1 = {
})=>{
    const { window =defaultWindow  } = defaultOptions1;
    const isSupported = !!window && "Notification" in window;
    const notification = _vueDemi.ref(null);
    const requestPermission = async ()=>{
        if (!isSupported) return;
        if ("permission" in Notification && Notification.permission !== "denied") await Notification.requestPermission();
    };
    const onClick = _shared.createEventHook();
    const onShow = _shared.createEventHook();
    const onError = _shared.createEventHook();
    const onClose = _shared.createEventHook();
    const show = async (overrides)=>{
        if (!isSupported) return;
        await requestPermission();
        const options = Object.assign({
        }, defaultOptions1, overrides);
        notification.value = new Notification(options.title || "", options);
        notification.value.onclick = (event)=>onClick.trigger(event)
        ;
        notification.value.onshow = (event)=>onShow.trigger(event)
        ;
        notification.value.onerror = (event)=>onError.trigger(event)
        ;
        notification.value.onclose = (event)=>onClose.trigger(event)
        ;
        return notification.value;
    };
    const close = ()=>{
        if (notification.value) notification.value.close();
        notification.value = null;
    };
    _shared.tryOnMounted(async ()=>{
        if (isSupported) await requestPermission();
    });
    _shared.tryOnScopeDispose(close);
    if (isSupported && window) {
        const document = window.document;
        useEventListener(document, "visibilitychange", (e)=>{
            e.preventDefault();
            if (document.visibilityState === "visible") close();
        });
    }
    return {
        isSupported,
        notification,
        show,
        close,
        onClick,
        onShow,
        onError,
        onClose
    };
};
function resolveNestedOptions(options) {
    if (options === true) return {
    };
    return options;
}
function useWebSocket(url, options = {
}) {
    const { onConnected , onDisconnected , onError , onMessage , immediate =true , autoClose =true , protocols =[]  } = options;
    const data = _vueDemi.ref(null);
    const status = _vueDemi.ref("CONNECTING");
    const wsRef = _vueDemi.ref();
    let heartbeatPause;
    let heartbeatResume;
    let explicitlyClosed = false;
    let retried = 0;
    let bufferedData = [];
    const close = (code = 1000, reason)=>{
        if (!wsRef.value) return;
        explicitlyClosed = true;
        heartbeatPause == null || heartbeatPause();
        wsRef.value.close(code, reason);
    };
    const _sendBuffer = ()=>{
        if (bufferedData.length && wsRef.value && status.value === "OPEN") {
            for (const buffer of bufferedData)wsRef.value.send(buffer);
            bufferedData = [];
        }
    };
    const send = (data2, useBuffer = true)=>{
        if (!wsRef.value || status.value !== "OPEN") {
            if (useBuffer) bufferedData.push(data2);
            return false;
        }
        _sendBuffer();
        wsRef.value.send(data2);
        return true;
    };
    const _init = ()=>{
        const ws = new WebSocket(url, protocols);
        wsRef.value = ws;
        status.value = "CONNECTING";
        explicitlyClosed = false;
        ws.onopen = ()=>{
            status.value = "OPEN";
            onConnected == null || onConnected(ws);
            heartbeatResume == null || heartbeatResume();
            _sendBuffer();
        };
        ws.onclose = (ev)=>{
            status.value = "CLOSED";
            wsRef.value = void 0;
            onDisconnected == null || onDisconnected(ws, ev);
            if (!explicitlyClosed && options.autoReconnect) {
                const { retries =-1 , delay =1000 , onFailed  } = resolveNestedOptions(options.autoReconnect);
                retried += 1;
                if (retries < 0 || retried < retries) setTimeout(_init, delay);
                else onFailed == null || onFailed();
            }
        };
        ws.onerror = (e)=>{
            onError == null || onError(ws, e);
        };
        ws.onmessage = (e)=>{
            data.value = e.data;
            onMessage == null || onMessage(ws, e);
        };
    };
    if (options.heartbeat) {
        const { message ="ping" , interval =1000  } = resolveNestedOptions(options.heartbeat);
        const { pause , resume  } = _shared.useIntervalFn(()=>send(message, false)
        , interval, {
            immediate: false
        });
        heartbeatPause = pause;
        heartbeatResume = resume;
    }
    if (immediate) _init();
    if (autoClose) {
        useEventListener(window, "beforeunload", ()=>close()
        );
        _shared.tryOnScopeDispose(close);
    }
    const open = ()=>{
        close();
        retried = 0;
        _init();
    };
    return {
        data,
        status,
        close,
        send,
        open,
        ws: wsRef
    };
}
function useWebWorker(url, workerOptions, options = {
}) {
    const { window =defaultWindow  } = options;
    const data = _vueDemi.ref(null);
    const worker = _vueDemi.shallowRef();
    const post = function post2(val) {
        if (!worker.value) return;
        worker.value.postMessage(val);
    };
    const terminate = function terminate2() {
        if (!worker.value) return;
        worker.value.terminate();
    };
    if (window) {
        worker.value = new window.Worker(url, workerOptions);
        worker.value.onmessage = (e)=>{
            data.value = e.data;
        };
        _shared.tryOnScopeDispose(()=>{
            if (worker.value) worker.value.terminate();
        });
    }
    return {
        data,
        post,
        terminate,
        worker
    };
}
const jobRunner = (userFunc)=>(e)=>{
        const userFuncArgs = e.data[0];
        return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result)=>{
            postMessage([
                "SUCCESS",
                result
            ]);
        }).catch((error)=>{
            postMessage([
                "ERROR",
                error
            ]);
        });
    }
;
const depsParser = (deps)=>{
    if (deps.length === 0) return "";
    const depsString = deps.map((dep)=>`'${dep}'`
    ).toString();
    return `importScripts(${depsString})`;
};
const createWorkerBlobUrl = (fn, deps)=>{
    const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;
    const blob = new Blob([
        blobCode
    ], {
        type: "text/javascript"
    });
    const url = URL.createObjectURL(blob);
    return url;
};
const useWebWorkerFn = (fn, options = {
})=>{
    const { dependencies =[] , timeout , window =defaultWindow  } = options;
    const worker = _vueDemi.ref();
    const workerStatus = _vueDemi.ref("PENDING");
    const promise = _vueDemi.ref({
    });
    const timeoutId = _vueDemi.ref();
    const workerTerminate = (status = "PENDING")=>{
        if (worker.value && worker.value._url && window) {
            worker.value.terminate();
            URL.revokeObjectURL(worker.value._url);
            promise.value = {
            };
            worker.value = void 0;
            window.clearTimeout(timeoutId.value);
            workerStatus.value = status;
        }
    };
    workerTerminate();
    _shared.tryOnScopeDispose(workerTerminate);
    const generateWorker = ()=>{
        const blobUrl = createWorkerBlobUrl(fn, dependencies);
        const newWorker = new Worker(blobUrl);
        newWorker._url = blobUrl;
        newWorker.onmessage = (e)=>{
            const { resolve =()=>{
            } , reject =()=>{
            }  } = promise.value;
            const [status, result] = e.data;
            switch(status){
                case "SUCCESS":
                    resolve(result);
                    workerTerminate(status);
                    break;
                default:
                    reject(result);
                    workerTerminate("ERROR");
                    break;
            }
        };
        newWorker.onerror = (e)=>{
            const { reject =()=>{
            }  } = promise.value;
            reject(e);
            workerTerminate("ERROR");
        };
        if (timeout) timeoutId.value = setTimeout(()=>workerTerminate("TIMEOUT_EXPIRED")
        , timeout);
        return newWorker;
    };
    const callWorker = (...fnArgs)=>new Promise((resolve, reject)=>{
            promise.value = {
                resolve,
                reject
            };
            worker.value && worker.value.postMessage([
                [
                    ...fnArgs
                ]
            ]);
            workerStatus.value = "RUNNING";
        })
    ;
    const workerFn = (...fnArgs)=>{
        if (workerStatus.value === "RUNNING") {
            console.error("[useWebWorkerFn] You can only run one instance of the worker at a time.");
            return Promise.reject();
        }
        worker.value = generateWorker();
        return callWorker(...fnArgs);
    };
    return {
        workerFn,
        workerStatus,
        workerTerminate
    };
};
function useWindowFocus({ window =defaultWindow  } = {
}) {
    if (!window) return _vueDemi.ref(false);
    const focused = _vueDemi.ref(window.document.hasFocus());
    useEventListener(window, "blur", ()=>{
        focused.value = false;
    });
    useEventListener(window, "focus", ()=>{
        focused.value = true;
    });
    return focused;
}
function useWindowScroll({ window =defaultWindow  } = {
}) {
    if (!window) return {
        x: _vueDemi.ref(0),
        y: _vueDemi.ref(0)
    };
    const x = _vueDemi.ref(window.pageXOffset);
    const y = _vueDemi.ref(window.pageYOffset);
    useEventListener("scroll", ()=>{
        x.value = window.pageXOffset;
        y.value = window.pageYOffset;
    }, {
        capture: false,
        passive: true
    });
    return {
        x,
        y
    };
}
function useWindowSize({ window =defaultWindow , initialWidth =Infinity , initialHeight =Infinity  } = {
}) {
    const width = _vueDemi.ref(initialWidth);
    const height = _vueDemi.ref(initialHeight);
    const update = ()=>{
        if (window) {
            width.value = window.innerWidth;
            height.value = window.innerHeight;
        }
    };
    update();
    _shared.tryOnMounted(update);
    useEventListener("resize", update, {
        passive: true
    });
    return {
        width,
        height
    };
}

},{"@vueuse/shared":"fP6cz","vue-demi":"DhtFX","@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fP6cz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "and", ()=>and
);
parcelHelpers.export(exports, "assert", ()=>assert
);
parcelHelpers.export(exports, "biSyncRef", ()=>biSyncRef
);
parcelHelpers.export(exports, "bypassFilter", ()=>bypassFilter
);
parcelHelpers.export(exports, "clamp", ()=>clamp
);
parcelHelpers.export(exports, "containsProp", ()=>containsProp
);
parcelHelpers.export(exports, "controlledComputed", ()=>controlledComputed
);
parcelHelpers.export(exports, "controlledRef", ()=>controlledRef
);
parcelHelpers.export(exports, "createEventHook", ()=>createEventHook
);
parcelHelpers.export(exports, "createFilterWrapper", ()=>createFilterWrapper
);
parcelHelpers.export(exports, "createGlobalState", ()=>createGlobalState
);
parcelHelpers.export(exports, "createReactiveFn", ()=>reactify
);
parcelHelpers.export(exports, "createSharedComposable", ()=>createSharedComposable
);
parcelHelpers.export(exports, "createSingletonPromise", ()=>createSingletonPromise
);
parcelHelpers.export(exports, "debounceFilter", ()=>debounceFilter
);
parcelHelpers.export(exports, "debouncedRef", ()=>useDebounce
);
parcelHelpers.export(exports, "debouncedWatch", ()=>debouncedWatch
);
parcelHelpers.export(exports, "eagerComputed", ()=>eagerComputed
);
parcelHelpers.export(exports, "extendRef", ()=>extendRef
);
parcelHelpers.export(exports, "get", ()=>get
);
parcelHelpers.export(exports, "identity", ()=>identity
);
parcelHelpers.export(exports, "ignorableWatch", ()=>ignorableWatch
);
parcelHelpers.export(exports, "increaseWithUnit", ()=>increaseWithUnit
);
parcelHelpers.export(exports, "invoke", ()=>invoke
);
parcelHelpers.export(exports, "isBoolean", ()=>isBoolean
);
parcelHelpers.export(exports, "isClient", ()=>isClient
);
parcelHelpers.export(exports, "isDef", ()=>isDef
);
parcelHelpers.export(exports, "isDefined", ()=>isDefined
);
parcelHelpers.export(exports, "isFunction", ()=>isFunction
);
parcelHelpers.export(exports, "isNumber", ()=>isNumber
);
parcelHelpers.export(exports, "isObject", ()=>isObject
);
parcelHelpers.export(exports, "isString", ()=>isString
);
parcelHelpers.export(exports, "isWindow", ()=>isWindow
);
parcelHelpers.export(exports, "makeDestructurable", ()=>makeDestructurable
);
parcelHelpers.export(exports, "noop", ()=>noop
);
parcelHelpers.export(exports, "not", ()=>not
);
parcelHelpers.export(exports, "now", ()=>now
);
parcelHelpers.export(exports, "objectPick", ()=>objectPick
);
parcelHelpers.export(exports, "or", ()=>or
);
parcelHelpers.export(exports, "pausableFilter", ()=>pausableFilter
);
parcelHelpers.export(exports, "pausableWatch", ()=>pausableWatch
);
parcelHelpers.export(exports, "promiseTimeout", ()=>promiseTimeout
);
parcelHelpers.export(exports, "rand", ()=>rand
);
parcelHelpers.export(exports, "reactify", ()=>reactify
);
parcelHelpers.export(exports, "reactifyObject", ()=>reactifyObject
);
parcelHelpers.export(exports, "reactivePick", ()=>reactivePick
);
parcelHelpers.export(exports, "refDefault", ()=>refDefault
);
parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "syncRef", ()=>syncRef
);
parcelHelpers.export(exports, "throttleFilter", ()=>throttleFilter
);
parcelHelpers.export(exports, "throttledRef", ()=>useThrottle
);
parcelHelpers.export(exports, "throttledWatch", ()=>throttledWatch
);
parcelHelpers.export(exports, "timestamp", ()=>timestamp
);
parcelHelpers.export(exports, "toReactive", ()=>toReactive
);
parcelHelpers.export(exports, "toRefs", ()=>toRefs
);
parcelHelpers.export(exports, "tryOnBeforeUnmount", ()=>tryOnBeforeUnmount
);
parcelHelpers.export(exports, "tryOnMounted", ()=>tryOnMounted
);
parcelHelpers.export(exports, "tryOnScopeDispose", ()=>tryOnScopeDispose
);
parcelHelpers.export(exports, "tryOnUnmounted", ()=>tryOnUnmounted
);
parcelHelpers.export(exports, "until", ()=>until
);
parcelHelpers.export(exports, "useCounter", ()=>useCounter
);
parcelHelpers.export(exports, "useDebounce", ()=>useDebounce
);
parcelHelpers.export(exports, "useDebounceFn", ()=>useDebounceFn
);
parcelHelpers.export(exports, "useInterval", ()=>useInterval
);
parcelHelpers.export(exports, "useIntervalFn", ()=>useIntervalFn
);
parcelHelpers.export(exports, "useLastChanged", ()=>useLastChanged
);
parcelHelpers.export(exports, "useThrottle", ()=>useThrottle
);
parcelHelpers.export(exports, "useThrottleFn", ()=>useThrottleFn
);
parcelHelpers.export(exports, "useTimeout", ()=>useTimeout
);
parcelHelpers.export(exports, "useTimeoutFn", ()=>useTimeoutFn
);
parcelHelpers.export(exports, "useToggle", ()=>useToggle
);
parcelHelpers.export(exports, "watchAtMost", ()=>watchAtMost
);
parcelHelpers.export(exports, "watchOnce", ()=>watchOnce
);
parcelHelpers.export(exports, "watchWithFilter", ()=>watchWithFilter
);
parcelHelpers.export(exports, "whenever", ()=>whenever
);
var _vueDemi = require("vue-demi");
function and(...args) {
    return _vueDemi.computed(()=>args.every((i)=>_vueDemi.unref(i)
        )
    );
}
function biSyncRef(a, b) {
    const flush = "sync";
    const stop1 = _vueDemi.watch(a, (newValue)=>{
        b.value = newValue;
    }, {
        flush,
        immediate: true
    });
    const stop2 = _vueDemi.watch(b, (newValue)=>{
        a.value = newValue;
    }, {
        flush,
        immediate: true
    });
    return ()=>{
        stop1();
        stop2();
    };
}
function controlledComputed(source, fn) {
    let v = void 0;
    let track;
    let trigger;
    const dirty = _vueDemi.ref(true);
    _vueDemi.watch(source, ()=>{
        dirty.value = true;
        trigger();
    }, {
        flush: "sync"
    });
    return _vueDemi.customRef((_track, _trigger)=>{
        track = _track;
        trigger = _trigger;
        return {
            get () {
                if (dirty.value) {
                    v = fn();
                    dirty.value = false;
                }
                track();
                return v;
            },
            set () {
            }
        };
    });
}
function __onlyVue3(name = "this function") {
    if (_vueDemi.isVue3) return;
    throw new Error(`[VueUse] ${name} is only works on Vue 3.`);
}
function extendRef(ref, extend, { enumerable =false , unwrap =true  } = {
}) {
    __onlyVue3();
    for (const [key, value] of Object.entries(extend)){
        if (key === "value") continue;
        if (_vueDemi.isRef(value) && unwrap) Object.defineProperty(ref, key, {
            get () {
                return value.value;
            },
            set (v) {
                value.value = v;
            },
            enumerable
        });
        else Object.defineProperty(ref, key, {
            value,
            enumerable
        });
    }
    return ref;
}
function controlledRef(initial, options = {
}) {
    let source = initial;
    let track;
    let trigger;
    const ref = _vueDemi.customRef((_track, _trigger)=>{
        track = _track;
        trigger = _trigger;
        return {
            get () {
                return get1();
            },
            set (v) {
                set1(v);
            }
        };
    });
    function get1(tracking = true) {
        if (tracking) track();
        return source;
    }
    function set1(value, triggering = true) {
        var _a, _b;
        if (value === source) return;
        const old = source;
        if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false) return;
        source = value;
        (_b = options.onChanged) == null || _b.call(options, value, old);
        if (triggering) trigger();
    }
    const untrackedGet = ()=>get1(false)
    ;
    const silentSet = (v)=>set1(v, false)
    ;
    const peek = ()=>get1(false)
    ;
    const lay = (v)=>set1(v, false)
    ;
    return extendRef(ref, {
        get: get1,
        set: set1,
        untrackedGet,
        silentSet,
        peek,
        lay
    }, {
        enumerable: true
    });
}
function createEventHook() {
    const fns = [];
    const off = (fn)=>{
        const index = fns.indexOf(fn);
        if (index !== -1) fns.splice(index, 1);
    };
    const on = (fn)=>{
        fns.push(fn);
        return {
            off: ()=>off(fn)
        };
    };
    const trigger = (param)=>{
        fns.forEach((fn)=>fn(param)
        );
    };
    return {
        on,
        off,
        trigger
    };
}
function createGlobalState(stateFactory) {
    let initialized = false;
    let state;
    const scope = _vueDemi.effectScope(true);
    return ()=>{
        if (!initialized) {
            state = scope.run(stateFactory);
            initialized = true;
        }
        return state;
    };
}
function reactify(fn) {
    return function(...args) {
        return _vueDemi.computed(()=>fn.apply(this, args.map((i)=>_vueDemi.unref(i)
            ))
        );
    };
}
function tryOnScopeDispose(fn) {
    if (_vueDemi.getCurrentScope()) {
        _vueDemi.onScopeDispose(fn);
        return true;
    }
    return false;
}
function createSharedComposable(composable) {
    let subscribers = 0;
    let state;
    let scope;
    const dispose = ()=>{
        subscribers -= 1;
        if (scope && subscribers <= 0) {
            scope.stop();
            state = void 0;
            scope = void 0;
        }
    };
    return (...args)=>{
        subscribers += 1;
        if (!state) {
            scope = _vueDemi.effectScope(true);
            state = scope.run(()=>composable(...args)
            );
        }
        tryOnScopeDispose(dispose);
        return state;
    };
}
const isClient = typeof window !== "undefined";
const isDef = (val)=>typeof val !== "undefined"
;
const assert = (condition, ...infos)=>{
    if (!condition) console.warn(...infos);
};
const toString = Object.prototype.toString;
const isBoolean = (val)=>typeof val === "boolean"
;
const isFunction = (val)=>typeof val === "function"
;
const isNumber = (val)=>typeof val === "number"
;
const isString = (val)=>typeof val === "string"
;
const isObject = (val)=>toString.call(val) === "[object Object]"
;
const isWindow = (val)=>typeof window !== "undefined" && toString.call(val) === "[object Window]"
;
const now = ()=>Date.now()
;
const timestamp = ()=>+Date.now()
;
const clamp = (n, min, max)=>Math.min(max, Math.max(min, n))
;
const noop = ()=>{
};
const rand = (min, max)=>{
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
};
function createFilterWrapper(filter, fn) {
    function wrapper(...args) {
        filter(()=>fn.apply(this, args)
        , {
            fn,
            thisArg: this,
            args
        });
    }
    return wrapper;
}
const bypassFilter = (invoke1)=>{
    return invoke1();
};
function debounceFilter(ms, options = {
}) {
    let timer;
    let maxTimer;
    const filter = (invoke2)=>{
        const duration = _vueDemi.unref(ms);
        const maxDuration = _vueDemi.unref(options.maxWait);
        if (timer) clearTimeout(timer);
        if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
                clearTimeout(maxTimer);
                maxTimer = null;
            }
            return invoke2();
        }
        if (maxDuration && !maxTimer) maxTimer = setTimeout(()=>{
            if (timer) clearTimeout(timer);
            maxTimer = null;
            invoke2();
        }, maxDuration);
        timer = setTimeout(()=>{
            if (maxTimer) clearTimeout(maxTimer);
            maxTimer = null;
            invoke2();
        }, duration);
    };
    return filter;
}
function throttleFilter(ms, trailing = true, leading = true) {
    let lastExec = 0;
    let timer;
    let preventLeading = !leading;
    const clear = ()=>{
        if (timer) {
            clearTimeout(timer);
            timer = void 0;
        }
    };
    const filter = (invoke3)=>{
        const duration = _vueDemi.unref(ms);
        const elapsed = Date.now() - lastExec;
        clear();
        if (duration <= 0) {
            lastExec = Date.now();
            return invoke3();
        }
        if (elapsed > duration) {
            lastExec = Date.now();
            if (preventLeading) preventLeading = false;
            else invoke3();
        }
        if (trailing) timer = setTimeout(()=>{
            lastExec = Date.now();
            if (!leading) preventLeading = true;
            clear();
            invoke3();
        }, duration);
        if (!leading && !timer) timer = setTimeout(()=>preventLeading = true
        , duration);
    };
    return filter;
}
function pausableFilter(extendFilter = bypassFilter) {
    const isActive = _vueDemi.ref(true);
    function pause() {
        isActive.value = false;
    }
    function resume() {
        isActive.value = true;
    }
    const eventFilter = (...args)=>{
        if (isActive.value) extendFilter(...args);
    };
    return {
        isActive,
        pause,
        resume,
        eventFilter
    };
}
function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
    return new Promise((resolve, reject)=>{
        if (throwOnTimeout) setTimeout(()=>reject(reason)
        , ms);
        else setTimeout(resolve, ms);
    });
}
function identity(arg) {
    return arg;
}
function createSingletonPromise(fn) {
    let _promise;
    function wrapper() {
        if (!_promise) _promise = fn();
        return _promise;
    }
    wrapper.reset = async ()=>{
        const _prev = _promise;
        _promise = void 0;
        if (_prev) await _prev;
    };
    return wrapper;
}
function invoke(fn) {
    return fn();
}
function containsProp(obj, ...props) {
    return props.some((k)=>k in obj
    );
}
function increaseWithUnit(target, delta) {
    var _a;
    if (typeof target === "number") return target + delta;
    const value = ((_a = target.match(/^-?[0-9]+\.?[0-9]*/)) == null ? void 0 : _a[0]) || "";
    const unit = target.slice(value.length);
    const result = parseFloat(value) + delta;
    if (Number.isNaN(result)) return target;
    return result + unit;
}
function objectPick(obj, keys, omitUndefined = false) {
    return keys.reduce((n, k)=>{
        if (k in obj) {
            if (!omitUndefined || (obj[k], false)) n[k] = obj[k];
        }
        return n;
    }, {
    });
}
function useDebounceFn(fn, ms = 200, options = {
}) {
    return createFilterWrapper(debounceFilter(ms, options), fn);
}
function useDebounce(value, ms = 200, options = {
}) {
    if (ms <= 0) return value;
    const debounced = _vueDemi.ref(value.value);
    const updater = useDebounceFn(()=>{
        debounced.value = value.value;
    }, ms, options);
    _vueDemi.watch(value, ()=>updater()
    );
    return debounced;
}
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude)=>{
    var target = {
    };
    for(var prop in source)if (__hasOwnProp$a.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$a) {
        for (var prop of __getOwnPropSymbols$a(source))if (exclude.indexOf(prop) < 0 && __propIsEnum$a.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
function watchWithFilter(source, cb, options = {
}) {
    const _a = options, { eventFilter =bypassFilter  } = _a, watchOptions = __objRest$5(_a, [
        "eventFilter"
    ]);
    return _vueDemi.watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
var __defProp$8 = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value)=>key in obj ? __defProp$8(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$8 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$9.call(b, prop)) __defNormalProp$8(a, prop, b[prop]);
    if (__getOwnPropSymbols$9) {
        for (var prop of __getOwnPropSymbols$9(b))if (__propIsEnum$9.call(b, prop)) __defNormalProp$8(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$5 = (a, b)=>__defProps$5(a, __getOwnPropDescs$5(b))
;
var __objRest$4 = (source, exclude)=>{
    var target = {
    };
    for(var prop in source)if (__hasOwnProp$9.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$9) {
        for (var prop of __getOwnPropSymbols$9(source))if (exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
function debouncedWatch(source, cb, options = {
}) {
    const _a = options, { debounce =0  } = _a, watchOptions = __objRest$4(_a, [
        "debounce"
    ]);
    return watchWithFilter(source, cb, __spreadProps$5(__spreadValues$8({
    }, watchOptions), {
        eventFilter: debounceFilter(debounce)
    }));
}
var __defProp$7 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value)=>key in obj ? __defProp$7(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$7 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$8.call(b, prop)) __defNormalProp$7(a, prop, b[prop]);
    if (__getOwnPropSymbols$8) {
        for (var prop of __getOwnPropSymbols$8(b))if (__propIsEnum$8.call(b, prop)) __defNormalProp$7(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$4 = (a, b)=>__defProps$4(a, __getOwnPropDescs$4(b))
;
function eagerComputed(fn, options) {
    var _a;
    const result = _vueDemi.shallowRef();
    _vueDemi.watchEffect(()=>{
        result.value = fn();
    }, __spreadProps$4(__spreadValues$7({
    }, options), {
        flush: (_a = options == null ? void 0 : options.flush) != null ? _a : "sync"
    }));
    return _vueDemi.readonly(result);
}
function get(obj, key) {
    if (key == null) return _vueDemi.unref(obj);
    return _vueDemi.unref(obj)[key];
}
var __defProp$6 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value)=>key in obj ? __defProp$6(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$6 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$7.call(b, prop)) __defNormalProp$6(a, prop, b[prop]);
    if (__getOwnPropSymbols$7) {
        for (var prop of __getOwnPropSymbols$7(b))if (__propIsEnum$7.call(b, prop)) __defNormalProp$6(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$3 = (a, b)=>__defProps$3(a, __getOwnPropDescs$3(b))
;
var __objRest$3 = (source, exclude)=>{
    var target = {
    };
    for(var prop in source)if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$7) {
        for (var prop of __getOwnPropSymbols$7(source))if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
function ignorableWatch(source, cb, options = {
}) {
    const _a = options, { eventFilter =bypassFilter  } = _a, watchOptions = __objRest$3(_a, [
        "eventFilter"
    ]);
    const filteredCb = createFilterWrapper(eventFilter, cb);
    let ignoreUpdates;
    let ignorePrevAsyncUpdates;
    let stop;
    if (watchOptions.flush === "sync") {
        const ignore = _vueDemi.ref(false);
        ignorePrevAsyncUpdates = ()=>{
        };
        ignoreUpdates = (updater)=>{
            ignore.value = true;
            updater();
            ignore.value = false;
        };
        stop = _vueDemi.watch(source, (...args)=>{
            if (!ignore.value) filteredCb(...args);
        }, watchOptions);
    } else {
        const disposables = [];
        const ignoreCounter = _vueDemi.ref(0);
        const syncCounter = _vueDemi.ref(0);
        ignorePrevAsyncUpdates = ()=>{
            ignoreCounter.value = syncCounter.value;
        };
        disposables.push(_vueDemi.watch(source, ()=>{
            syncCounter.value++;
        }, __spreadProps$3(__spreadValues$6({
        }, watchOptions), {
            flush: "sync"
        })));
        ignoreUpdates = (updater)=>{
            const syncCounterPrev = syncCounter.value;
            updater();
            ignoreCounter.value += syncCounter.value - syncCounterPrev;
        };
        disposables.push(_vueDemi.watch(source, (...args)=>{
            const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
            ignoreCounter.value = 0;
            syncCounter.value = 0;
            if (ignore) return;
            filteredCb(...args);
        }, watchOptions));
        stop = ()=>{
            disposables.forEach((fn)=>fn()
            );
        };
    }
    return {
        stop,
        ignoreUpdates,
        ignorePrevAsyncUpdates
    };
}
function isDefined(v) {
    return _vueDemi.unref(v) != null;
}
var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value)=>key in obj ? __defProp$5(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$5 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$6.call(b, prop)) __defNormalProp$5(a, prop, b[prop]);
    if (__getOwnPropSymbols$6) {
        for (var prop of __getOwnPropSymbols$6(b))if (__propIsEnum$6.call(b, prop)) __defNormalProp$5(a, prop, b[prop]);
    }
    return a;
};
function makeDestructurable(obj, arr) {
    if (typeof Symbol !== "undefined") {
        const clone = __spreadValues$5({
        }, obj);
        Object.defineProperty(clone, Symbol.iterator, {
            enumerable: false,
            value () {
                let index = 0;
                return {
                    next: ()=>({
                            value: arr[index++],
                            done: index > arr.length
                        })
                };
            }
        });
        return clone;
    } else return Object.assign([
        ...arr
    ], obj);
}
function not(v) {
    return _vueDemi.computed(()=>!_vueDemi.unref(v)
    );
}
function or(...args) {
    return _vueDemi.computed(()=>args.some((i)=>_vueDemi.unref(i)
        )
    );
}
var __defProp$4 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value)=>key in obj ? __defProp$4(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$4 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$5.call(b, prop)) __defNormalProp$4(a, prop, b[prop]);
    if (__getOwnPropSymbols$5) {
        for (var prop of __getOwnPropSymbols$5(b))if (__propIsEnum$5.call(b, prop)) __defNormalProp$4(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$2 = (a, b)=>__defProps$2(a, __getOwnPropDescs$2(b))
;
var __objRest$2 = (source, exclude)=>{
    var target = {
    };
    for(var prop in source)if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$5) {
        for (var prop of __getOwnPropSymbols$5(source))if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
function pausableWatch(source, cb, options = {
}) {
    const _a = options, { eventFilter: filter  } = _a, watchOptions = __objRest$2(_a, [
        "eventFilter"
    ]);
    const { eventFilter , pause , resume , isActive  } = pausableFilter(filter);
    const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$4({
    }, watchOptions), {
        eventFilter
    }));
    return {
        stop,
        pause,
        resume,
        isActive
    };
}
function reactifyObject(obj, optionsOrKeys = {
}) {
    let keys = [];
    if (Array.isArray(optionsOrKeys)) keys = optionsOrKeys;
    else {
        const { includeOwnProperties =true  } = optionsOrKeys;
        keys.push(...Object.keys(obj));
        if (includeOwnProperties) keys.push(...Object.getOwnPropertyNames(obj));
    }
    return Object.fromEntries(keys.map((key)=>{
        const value = obj[key];
        return [
            key,
            typeof value === "function" ? reactify(value.bind(obj)) : value
        ];
    }));
}
function reactivePick(obj, ...keys) {
    return _vueDemi.reactive(Object.fromEntries(keys.map((k)=>[
            k,
            _vueDemi.toRef(obj, k)
        ]
    )));
}
function refDefault(source, defaultValue) {
    return _vueDemi.computed({
        get () {
            var _a;
            return (_a = source.value) != null ? _a : defaultValue;
        },
        set (value) {
            source.value = value;
        }
    });
}
function set(...args) {
    if (args.length === 2) {
        const [ref, value] = args;
        ref.value = value;
    }
    if (args.length === 3) {
        if (_vueDemi.isVue2) _vueDemi.set(...args);
        else {
            const [target, key, value] = args;
            target[key] = value;
        }
    }
}
function syncRef(source, targets, { flush ="sync" , deep =false , immediate =true  } = {
}) {
    if (!Array.isArray(targets)) targets = [
        targets
    ];
    return _vueDemi.watch(source, (newValue)=>targets.forEach((target)=>target.value = newValue
        )
    , {
        flush,
        deep,
        immediate
    });
}
function useThrottleFn(fn, ms = 200, trailing = true, leading = true) {
    return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);
}
function useThrottle(value, delay = 200, trailing = true, leading = true) {
    if (delay <= 0) return value;
    const throttled = _vueDemi.ref(value.value);
    const updater = useThrottleFn(()=>{
        throttled.value = value.value;
    }, delay, trailing, leading);
    _vueDemi.watch(value, ()=>updater()
    );
    return throttled;
}
var __defProp$3 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value)=>key in obj ? __defProp$3(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$3 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$4.call(b, prop)) __defNormalProp$3(a, prop, b[prop]);
    if (__getOwnPropSymbols$4) {
        for (var prop of __getOwnPropSymbols$4(b))if (__propIsEnum$4.call(b, prop)) __defNormalProp$3(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps$1 = (a, b)=>__defProps$1(a, __getOwnPropDescs$1(b))
;
var __objRest$1 = (source, exclude)=>{
    var target = {
    };
    for(var prop in source)if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$4) {
        for (var prop of __getOwnPropSymbols$4(source))if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
function throttledWatch(source, cb, options = {
}) {
    const _a = options, { throttle =0 , trailing =true , leading =true  } = _a, watchOptions = __objRest$1(_a, [
        "throttle",
        "trailing",
        "leading"
    ]);
    return watchWithFilter(source, cb, __spreadProps$1(__spreadValues$3({
    }, watchOptions), {
        eventFilter: throttleFilter(throttle, trailing, leading)
    }));
}
function toReactive(objectRef) {
    if (!_vueDemi.isRef(objectRef)) return _vueDemi.reactive(objectRef);
    const proxy = new Proxy({
    }, {
        get (_, p, receiver) {
            return Reflect.get(objectRef.value, p, receiver);
        },
        set (_, p, value) {
            objectRef.value[p] = value;
            return true;
        },
        deleteProperty (_, p) {
            return Reflect.deleteProperty(objectRef.value, p);
        },
        has (_, p) {
            return Reflect.has(objectRef.value, p);
        },
        ownKeys () {
            return Object.keys(objectRef.value);
        },
        getOwnPropertyDescriptor () {
            return {
                enumerable: true,
                configurable: true
            };
        }
    });
    return _vueDemi.reactive(proxy);
}
var __defProp$2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value)=>key in obj ? __defProp$2(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$2 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$3.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);
    if (__getOwnPropSymbols$3) {
        for (var prop of __getOwnPropSymbols$3(b))if (__propIsEnum$3.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b))
;
function toRefs(objectRef) {
    if (!_vueDemi.isRef(objectRef)) return _vueDemi.toRefs(objectRef);
    const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {
    };
    for(const key in objectRef.value)result[key] = _vueDemi.customRef(()=>({
            get () {
                return objectRef.value[key];
            },
            set (v) {
                if (Array.isArray(objectRef.value)) {
                    const copy = [
                        ...objectRef.value
                    ];
                    copy[key] = v;
                    objectRef.value = copy;
                } else objectRef.value = __spreadProps(__spreadValues$2({
                }, objectRef.value), {
                    [key]: v
                });
            }
        })
    );
    return result;
}
function tryOnBeforeUnmount(fn) {
    if (_vueDemi.getCurrentInstance()) _vueDemi.onBeforeUnmount(fn);
}
function tryOnMounted(fn, sync = true) {
    if (_vueDemi.getCurrentInstance()) _vueDemi.onMounted(fn);
    else if (sync) fn();
    else _vueDemi.nextTick(fn);
}
function tryOnUnmounted(fn) {
    if (_vueDemi.getCurrentInstance()) _vueDemi.onUnmounted(fn);
}
function until(r) {
    let isNot = false;
    function toMatch(condition, { flush ="sync" , deep =false , timeout , throwOnTimeout  } = {
    }) {
        let stop = null;
        const watcher = new Promise((resolve)=>{
            stop = _vueDemi.watch(r, (v)=>{
                if (condition(v) === !isNot) {
                    stop == null || stop();
                    resolve();
                }
            }, {
                flush,
                deep,
                immediate: true
            });
        });
        const promises = [
            watcher
        ];
        if (timeout) promises.push(promiseTimeout(timeout, throwOnTimeout).finally(()=>{
            stop == null || stop();
        }));
        return Promise.race(promises);
    }
    function toBe(value, options) {
        return toMatch((v)=>v === _vueDemi.unref(value)
        , options);
    }
    function toBeTruthy(options) {
        return toMatch((v)=>Boolean(v)
        , options);
    }
    function toBeNull(options) {
        return toBe(null, options);
    }
    function toBeUndefined(options) {
        return toBe(void 0, options);
    }
    function toBeNaN(options) {
        return toMatch(Number.isNaN, options);
    }
    function toContains(value, options) {
        return toMatch((v)=>{
            const array = Array.from(v);
            return array.includes(value) || array.includes(_vueDemi.unref(value));
        }, options);
    }
    function changed(options) {
        return changedTimes(1, options);
    }
    function changedTimes(n = 1, options) {
        let count = -1;
        return toMatch(()=>{
            count += 1;
            return count >= n;
        }, options);
    }
    if (Array.isArray(_vueDemi.unref(r))) {
        const instance = {
            toMatch,
            toContains,
            changed,
            changedTimes,
            get not () {
                isNot = !isNot;
                return this;
            }
        };
        return instance;
    } else {
        const instance = {
            toMatch,
            toBe,
            toBeTruthy,
            toBeNull,
            toBeNaN,
            toBeUndefined,
            changed,
            changedTimes,
            get not () {
                isNot = !isNot;
                return this;
            }
        };
        return instance;
    }
}
function useCounter(initialValue = 0, options = {
}) {
    const count = _vueDemi.ref(initialValue);
    const { max =Infinity , min =-Infinity  } = options;
    const inc = (delta = 1)=>count.value = Math.min(max, count.value + delta)
    ;
    const dec = (delta = 1)=>count.value = Math.max(min, count.value - delta)
    ;
    const get2 = ()=>count.value
    ;
    const set2 = (val)=>count.value = val
    ;
    const reset = (val = initialValue)=>{
        initialValue = val;
        return set2(val);
    };
    return {
        count,
        inc,
        dec,
        get: get2,
        set: set2,
        reset
    };
}
function useIntervalFn(cb, interval = 1000, options = {
}) {
    const { immediate =true , immediateCallback =false  } = options;
    let timer = null;
    const isActive = _vueDemi.ref(false);
    function clean() {
        if (timer) {
            clearInterval(timer);
            timer = null;
        }
    }
    function pause() {
        isActive.value = false;
        clean();
    }
    function resume() {
        if (interval <= 0) return;
        isActive.value = true;
        if (immediateCallback) cb();
        clean();
        timer = setInterval(cb, _vueDemi.unref(interval));
    }
    if (immediate && isClient) resume();
    if (_vueDemi.isRef(interval)) {
        const stopWatch = _vueDemi.watch(interval, ()=>{
            if (immediate && isClient) resume();
        });
        tryOnScopeDispose(stopWatch);
    }
    tryOnScopeDispose(pause);
    return {
        isActive,
        pause,
        resume
    };
}
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value)=>key in obj ? __defProp$1(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues$1 = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$2.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);
    if (__getOwnPropSymbols$2) {
        for (var prop of __getOwnPropSymbols$2(b))if (__propIsEnum$2.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);
    }
    return a;
};
function useInterval(interval = 1000, options = {
}) {
    const { controls: exposeControls = false , immediate =true  } = options;
    const counter = _vueDemi.ref(0);
    const controls = useIntervalFn(()=>counter.value += 1
    , interval, {
        immediate
    });
    if (exposeControls) return __spreadValues$1({
        counter
    }, controls);
    else return counter;
}
function useLastChanged(source, options = {
}) {
    var _a;
    const ms = _vueDemi.ref((_a = options.initialValue) != null ? _a : null);
    _vueDemi.watch(source, ()=>ms.value = timestamp()
    , options);
    return ms;
}
function useTimeoutFn(cb, interval, options = {
}) {
    const { immediate =true  } = options;
    const isPending = _vueDemi.ref(false);
    let timer = null;
    function clear() {
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
    }
    function stop() {
        isPending.value = false;
        clear();
    }
    function start(...args) {
        clear();
        isPending.value = true;
        timer = setTimeout(()=>{
            isPending.value = false;
            timer = null;
            cb(...args);
        }, _vueDemi.unref(interval));
    }
    if (immediate) {
        isPending.value = true;
        if (isClient) start();
    }
    tryOnScopeDispose(stop);
    return {
        isPending,
        start,
        stop
    };
}
var __defProp = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp$1.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols$1) {
        for (var prop of __getOwnPropSymbols$1(b))if (__propIsEnum$1.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
function useTimeout(interval = 1000, options = {
}) {
    const { controls: exposeControls = false  } = options;
    const controls = useTimeoutFn(noop, interval, options);
    const ready = _vueDemi.computed(()=>!controls.isPending.value
    );
    if (exposeControls) return __spreadValues({
        ready
    }, controls);
    else return ready;
}
function useToggle(initialValue = false) {
    if (_vueDemi.isRef(initialValue)) return (value)=>{
        initialValue.value = typeof value === "boolean" ? value : !initialValue.value;
        return initialValue.value;
    };
    else {
        const boolean = _vueDemi.ref(initialValue);
        const toggle = (value)=>{
            boolean.value = typeof value === "boolean" ? value : !boolean.value;
            return boolean.value;
        };
        return [
            boolean,
            toggle
        ];
    }
}
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude)=>{
    var target = {
    };
    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols) {
        for (var prop of __getOwnPropSymbols(source))if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
function watchAtMost(source, cb, options) {
    const _a = options, { count  } = _a, watchOptions = __objRest(_a, [
        "count"
    ]);
    const current = _vueDemi.ref(0);
    const stop = watchWithFilter(source, (...args)=>{
        current.value += 1;
        if (current.value >= _vueDemi.unref(count)) _vueDemi.nextTick(()=>stop()
        );
        cb(...args);
    }, watchOptions);
    return {
        count: current,
        stop
    };
}
function watchOnce(source, cb, options) {
    const stop = _vueDemi.watch(source, (...args)=>{
        _vueDemi.nextTick(()=>stop()
        );
        return cb(...args);
    }, options);
}
function whenever(source, cb, options) {
    return _vueDemi.watch(source, (v, ov, onInvalidate)=>{
        if (v) cb(v, ov, onInvalidate);
    }, options);
}

},{"vue-demi":"DhtFX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"DhtFX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "del", ()=>del
);
parcelHelpers.export(exports, "Vue", ()=>_vue
);
parcelHelpers.export(exports, "Vue2", ()=>Vue2
);
parcelHelpers.export(exports, "isVue2", ()=>isVue2
);
parcelHelpers.export(exports, "isVue3", ()=>isVue3
);
parcelHelpers.export(exports, "install", ()=>install
);
var _vue = require("vue");
parcelHelpers.exportAll(_vue, exports);
var isVue2 = false;
var isVue3 = true;
var Vue2 = undefined;
function install() {
}
function set(target, key, val) {
    if (Array.isArray(target)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        return val;
    }
    target[key] = val;
    return val;
}
function del(target, key) {
    if (Array.isArray(target)) {
        target.splice(key, 1);
        return;
    }
    delete target[key];
}

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"TzEEU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addResizeListener", ()=>addResizeListener
);
parcelHelpers.export(exports, "removeResizeListener", ()=>removeResizeListener
);
var _core = require("@vueuse/core");
const resizeHandler = function(entries) {
    for (const entry of entries){
        const listeners = entry.target.__resizeListeners__ || [];
        if (listeners.length) listeners.forEach((fn)=>{
            fn();
        });
    }
};
const addResizeListener = function(element, fn) {
    if (!_core.isClient || !element) return;
    if (!element.__resizeListeners__) {
        element.__resizeListeners__ = [];
        element.__ro__ = new ResizeObserver(resizeHandler);
        element.__ro__.observe(element);
    }
    element.__resizeListeners__.push(fn);
};
const removeResizeListener = function(element, fn) {
    var _a;
    if (!element || !element.__resizeListeners__) return;
    element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
    if (!element.__resizeListeners__.length) (_a = element.__ro__) == null || _a.disconnect();
};

},{"@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hpitc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getScrollBarWidth", ()=>getScrollBarWidth
);
parcelHelpers.export(exports, "getScrollContainer", ()=>getScrollContainer
);
parcelHelpers.export(exports, "isScroll", ()=>isScroll
);
parcelHelpers.export(exports, "scrollIntoView", ()=>scrollIntoView
);
var _core = require("@vueuse/core");
var _styleMjs = require("./style.mjs");
const isScroll = (el, isVertical)=>{
    if (!_core.isClient) return false;
    const key = {
        undefined: "overflow",
        true: "overflow-y",
        false: "overflow-x"
    }[String(isVertical)];
    const overflow = _styleMjs.getStyle(el, key);
    return [
        "scroll",
        "auto",
        "overlay"
    ].some((s)=>overflow.includes(s)
    );
};
const getScrollContainer = (el, isVertical)=>{
    if (!_core.isClient) return;
    let parent = el;
    while(parent){
        if ([
            window,
            document,
            document.documentElement
        ].includes(parent)) return window;
        if (isScroll(parent, isVertical)) return parent;
        parent = parent.parentNode;
    }
    return parent;
};
let scrollBarWidth;
const getScrollBarWidth = ()=>{
    var _a;
    if (!_core.isClient) return 0;
    if (scrollBarWidth !== void 0) return scrollBarWidth;
    const outer = document.createElement("div");
    outer.className = "el-scrollbar__wrap";
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.position = "absolute";
    outer.style.top = "-9999px";
    document.body.appendChild(outer);
    const widthNoScroll = outer.offsetWidth;
    outer.style.overflow = "scroll";
    const inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);
    const widthWithScroll = inner.offsetWidth;
    (_a = outer.parentNode) == null || _a.removeChild(outer);
    scrollBarWidth = widthNoScroll - widthWithScroll;
    return scrollBarWidth;
};
function scrollIntoView(container, selected) {
    if (!_core.isClient) return;
    if (!selected) {
        container.scrollTop = 0;
        return;
    }
    const offsetParents = [];
    let pointer = selected.offsetParent;
    while(pointer !== null && container !== pointer && container.contains(pointer)){
        offsetParents.push(pointer);
        pointer = pointer.offsetParent;
    }
    const top = selected.offsetTop + offsetParents.reduce((prev, curr)=>prev + curr.offsetTop
    , 0);
    const bottom = top + selected.offsetHeight;
    const viewRectTop = container.scrollTop;
    const viewRectBottom = viewRectTop + container.clientHeight;
    if (top < viewRectTop) container.scrollTop = top;
    else if (bottom > viewRectBottom) container.scrollTop = bottom - container.clientHeight;
}

},{"@vueuse/core":"eEHP9","./style.mjs":"cA8Mp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cA8Mp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addClass", ()=>addClass
);
parcelHelpers.export(exports, "classNameToArray", ()=>classNameToArray
);
parcelHelpers.export(exports, "getStyle", ()=>getStyle
);
parcelHelpers.export(exports, "hasClass", ()=>hasClass
);
parcelHelpers.export(exports, "removeClass", ()=>removeClass
);
parcelHelpers.export(exports, "removeStyle", ()=>removeStyle
);
parcelHelpers.export(exports, "setStyle", ()=>setStyle
);
var _core = require("@vueuse/core");
var _typesMjs = require("../types.mjs");
var _stringsMjs = require("../strings.mjs");
var _objectsMjs = require("../objects.mjs");
var _shared = require("@vue/shared");
const classNameToArray = (cls = "")=>cls.split(" ").filter((item)=>!!item.trim()
    )
;
const hasClass = (el, cls)=>{
    if (!el || !cls) return false;
    if (cls.includes(" ")) throw new Error("className should not contain space.");
    return el.classList.contains(cls);
};
const addClass = (el, cls)=>{
    if (!el || !cls.trim()) return;
    el.classList.add(...classNameToArray(cls));
};
const removeClass = (el, cls)=>{
    if (!el || !cls.trim()) return;
    el.classList.remove(...classNameToArray(cls));
};
const getStyle = (element, styleName)=>{
    var _a;
    if (!_core.isClient || !element || !styleName) return "";
    let key = _shared.camelize(styleName);
    if (key === "float") key = "cssFloat";
    try {
        const style = element.style[styleName];
        if (style) return style;
        const computed = (_a = document.defaultView) == null ? void 0 : _a.getComputedStyle(element, "");
        return computed ? computed[styleName] : "";
    } catch (e) {
        return element.style[styleName];
    }
};
const setStyle = (element, styleName, value)=>{
    if (!element || !styleName) return;
    if (_shared.isObject(styleName)) _objectsMjs.entriesOf(styleName).forEach(([prop, value2])=>setStyle(element, prop, value2)
    );
    else {
        const key = _shared.camelize(styleName);
        element.style[key] = value;
    }
};
const removeStyle = (element, style)=>{
    if (!element || !style) return;
    if (_shared.isObject(style)) _objectsMjs.keysOf(style).forEach((prop)=>removeStyle(element, prop)
    );
    else setStyle(element, style, "");
};

},{"@vueuse/core":"eEHP9","../types.mjs":"4VsDK","../strings.mjs":"hK6FY","../objects.mjs":"1tXXV","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4VsDK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isArray", ()=>_shared.isArray
);
parcelHelpers.export(exports, "isDate", ()=>_shared.isDate
);
parcelHelpers.export(exports, "isFunction", ()=>_shared.isFunction
);
parcelHelpers.export(exports, "isObject", ()=>_shared.isObject
);
parcelHelpers.export(exports, "isPromise", ()=>_shared.isPromise
);
parcelHelpers.export(exports, "isString", ()=>_shared.isString
);
parcelHelpers.export(exports, "isSymbol", ()=>_shared.isSymbol
);
parcelHelpers.export(exports, "isBoolean", ()=>_core.isBoolean
);
parcelHelpers.export(exports, "isNumber", ()=>_core.isNumber
);
parcelHelpers.export(exports, "isVNode", ()=>_vue.isVNode
);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty
);
parcelHelpers.export(exports, "isUndefined", ()=>isUndefined
);
var _shared = require("@vue/shared");
var _core = require("@vueuse/core");
var _vue = require("vue");
const isUndefined = (val)=>val === void 0
;
const isEmpty = (val)=>!val && val !== 0 || _shared.isArray(val) && val.length === 0 || _shared.isObject(val) && !Object.keys(val).length
;

},{"@vue/shared":"3SM3y","@vueuse/core":"eEHP9","vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hK6FY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "camelize", ()=>_shared.camelize
);
parcelHelpers.export(exports, "capitalize", ()=>_shared.capitalize
);
parcelHelpers.export(exports, "hyphenate", ()=>_shared.hyphenate
);
parcelHelpers.export(exports, "kebabCase", ()=>_shared.hyphenate
);
parcelHelpers.export(exports, "escapeStringRegexp", ()=>escapeStringRegexp
);
var _shared = require("@vue/shared");
const escapeStringRegexp = (string = "")=>string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
;

},{"@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1tXXV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasOwn", ()=>_shared.hasOwn
);
parcelHelpers.export(exports, "entriesOf", ()=>entriesOf
);
parcelHelpers.export(exports, "getPropByPath", ()=>getPropByPath
);
parcelHelpers.export(exports, "keysOf", ()=>keysOf
);
var _shared = require("@vue/shared");
var _errorMjs = require("./error.mjs");
const SCOPE = "UtilV2/objects";
const keysOf = (arr)=>Object.keys(arr)
;
const entriesOf = (arr)=>Object.entries(arr)
;
function getPropByPath(obj, path, strict) {
    let tempObj = obj;
    let key, value;
    if (obj && _shared.hasOwn(obj, path)) {
        key = path;
        value = tempObj == null ? void 0 : tempObj[path];
    } else {
        path = path.replace(/\[(\w+)\]/g, ".$1");
        path = path.replace(/^\./, "");
        const keyArr = path.split(".");
        let i = 0;
        for(; i < keyArr.length - 1; i++){
            if (!tempObj && !strict) break;
            const key2 = keyArr[i];
            if (key2 in tempObj) tempObj = tempObj[key2];
            else {
                if (strict) _errorMjs.throwError(SCOPE, "Please transfer a valid prop path to form item!");
                break;
            }
        }
        key = keyArr[i];
        value = tempObj == null ? void 0 : tempObj[keyArr[i]];
    }
    return {
        o: tempObj,
        k: key,
        v: value
    };
}

},{"@vue/shared":"3SM3y","./error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2zPBN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "debugWarn", ()=>debugWarn
);
parcelHelpers.export(exports, "throwError", ()=>throwError
);
class ElementPlusError extends Error {
    constructor(m){
        super(m);
        this.name = "ElementPlusError";
    }
}
function throwError(scope, m) {
    throw new ElementPlusError(`[${scope}] ${m}`);
}
function debugWarn(scope, message) {
    console.warn(new ElementPlusError(`[${scope}] ${message}`));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dBprX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "changeGlobalNodesTarget", ()=>_globalNodeMjs.changeGlobalNodesTarget
);
parcelHelpers.export(exports, "createGlobalNode", ()=>_globalNodeMjs.createGlobalNode
);
parcelHelpers.export(exports, "removeGlobalNode", ()=>_globalNodeMjs.removeGlobalNode
);
parcelHelpers.export(exports, "CloseComponents", ()=>_iconMjs.CloseComponents
);
parcelHelpers.export(exports, "TypeComponents", ()=>_iconMjs.TypeComponents
);
parcelHelpers.export(exports, "TypeComponentsMap", ()=>_iconMjs.TypeComponentsMap
);
parcelHelpers.export(exports, "ValidateComponentsMap", ()=>_iconMjs.ValidateComponentsMap
);
parcelHelpers.export(exports, "iconPropType", ()=>_iconMjs.iconPropType
);
parcelHelpers.export(exports, "withInstall", ()=>_installMjs.withInstall
);
parcelHelpers.export(exports, "withInstallFunction", ()=>_installMjs.withInstallFunction
);
parcelHelpers.export(exports, "withNoopInstall", ()=>_installMjs.withNoopInstall
);
parcelHelpers.export(exports, "buildProp", ()=>_propsMjs.buildProp
);
parcelHelpers.export(exports, "buildProps", ()=>_propsMjs.buildProps
);
parcelHelpers.export(exports, "definePropType", ()=>_propsMjs.definePropType
);
parcelHelpers.export(exports, "propKey", ()=>_propsMjs.propKey
);
parcelHelpers.export(exports, "composeRefs", ()=>_refsMjs.composeRefs
);
parcelHelpers.export(exports, "addUnit", ()=>_styleMjs.addUnit
);
parcelHelpers.export(exports, "isValidComponentSize", ()=>_validatorMjs.isValidComponentSize
);
parcelHelpers.export(exports, "isValidDatePickType", ()=>_validatorMjs.isValidDatePickType
);
parcelHelpers.export(exports, "PatchFlags", ()=>_vnodeMjs.PatchFlags
);
parcelHelpers.export(exports, "getFirstValidNode", ()=>_vnodeMjs.getFirstValidNode
);
parcelHelpers.export(exports, "getNormalizedProps", ()=>_vnodeMjs.getNormalizedProps
);
parcelHelpers.export(exports, "isComment", ()=>_vnodeMjs.isComment
);
parcelHelpers.export(exports, "isFragment", ()=>_vnodeMjs.isFragment
);
parcelHelpers.export(exports, "isTemplate", ()=>_vnodeMjs.isTemplate
);
parcelHelpers.export(exports, "isText", ()=>_vnodeMjs.isText
);
parcelHelpers.export(exports, "isValidElementNode", ()=>_vnodeMjs.isValidElementNode
);
parcelHelpers.export(exports, "renderBlock", ()=>_vnodeMjs.renderBlock
);
parcelHelpers.export(exports, "renderIf", ()=>_vnodeMjs.renderIf
);
var _typescriptMjs = require("./typescript.mjs");
var _globalNodeMjs = require("./global-node.mjs");
var _iconMjs = require("./icon.mjs");
var _installMjs = require("./install.mjs");
var _propsMjs = require("./props.mjs");
var _refsMjs = require("./refs.mjs");
var _styleMjs = require("./style.mjs");
var _validatorMjs = require("./validator.mjs");
var _vnodeMjs = require("./vnode.mjs");

},{"./typescript.mjs":"kqulU","./global-node.mjs":"f1gd1","./icon.mjs":"3YbE5","./install.mjs":"4TMmv","./props.mjs":"cpwWK","./refs.mjs":"iuyFi","./style.mjs":"pODHb","./validator.mjs":"4UnBa","./vnode.mjs":"ljPKw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqulU":[function(require,module,exports) {

},{}],"f1gd1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "changeGlobalNodesTarget", ()=>changeGlobalNodesTarget
);
parcelHelpers.export(exports, "createGlobalNode", ()=>createGlobalNode
);
parcelHelpers.export(exports, "removeGlobalNode", ()=>removeGlobalNode
);
var _core = require("@vueuse/core");
const globalNodes = [];
let target = !_core.isClient ? void 0 : document.body;
function createGlobalNode(id) {
    const el = document.createElement("div");
    if (id !== void 0) el.setAttribute("id", id);
    target.appendChild(el);
    globalNodes.push(el);
    return el;
}
function removeGlobalNode(el) {
    globalNodes.splice(globalNodes.indexOf(el), 1);
    el.remove();
}
function changeGlobalNodesTarget(el) {
    if (el === target) return;
    target = el;
    globalNodes.forEach((el2)=>{
        if (el2.contains(target) === false) target.appendChild(el2);
    });
}

},{"@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3YbE5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CloseComponents", ()=>CloseComponents
);
parcelHelpers.export(exports, "TypeComponents", ()=>TypeComponents
);
parcelHelpers.export(exports, "TypeComponentsMap", ()=>TypeComponentsMap
);
parcelHelpers.export(exports, "ValidateComponentsMap", ()=>ValidateComponentsMap
);
parcelHelpers.export(exports, "iconPropType", ()=>iconPropType
);
var _iconsVue = require("@element-plus/icons-vue");
var _propsMjs = require("./props.mjs");
const iconPropType = _propsMjs.definePropType([
    String,
    Object,
    Function
]);
const CloseComponents = {
    Close: _iconsVue.Close
};
const TypeComponents = {
    Close: _iconsVue.Close,
    SuccessFilled: _iconsVue.SuccessFilled,
    InfoFilled: _iconsVue.InfoFilled,
    WarningFilled: _iconsVue.WarningFilled,
    CircleCloseFilled: _iconsVue.CircleCloseFilled
};
const TypeComponentsMap = {
    success: _iconsVue.SuccessFilled,
    warning: _iconsVue.WarningFilled,
    error: _iconsVue.CircleCloseFilled,
    info: _iconsVue.InfoFilled
};
const ValidateComponentsMap = {
    validating: _iconsVue.Loading,
    success: _iconsVue.CircleCheck,
    error: _iconsVue.CircleClose
};

},{"@element-plus/icons-vue":"b18uu","./props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b18uu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AddLocation", ()=>_addLocationMjsDefault.default
);
parcelHelpers.export(exports, "Aim", ()=>_aimMjsDefault.default
);
parcelHelpers.export(exports, "AlarmClock", ()=>_alarmClockMjsDefault.default
);
parcelHelpers.export(exports, "Apple", ()=>_appleMjsDefault.default
);
parcelHelpers.export(exports, "ArrowDownBold", ()=>_arrowDownBoldMjsDefault.default
);
parcelHelpers.export(exports, "ArrowDown", ()=>_arrowDownMjsDefault.default
);
parcelHelpers.export(exports, "ArrowLeftBold", ()=>_arrowLeftBoldMjsDefault.default
);
parcelHelpers.export(exports, "ArrowLeft", ()=>_arrowLeftMjsDefault.default
);
parcelHelpers.export(exports, "ArrowRightBold", ()=>_arrowRightBoldMjsDefault.default
);
parcelHelpers.export(exports, "ArrowRight", ()=>_arrowRightMjsDefault.default
);
parcelHelpers.export(exports, "ArrowUpBold", ()=>_arrowUpBoldMjsDefault.default
);
parcelHelpers.export(exports, "ArrowUp", ()=>_arrowUpMjsDefault.default
);
parcelHelpers.export(exports, "Avatar", ()=>_avatarMjsDefault.default
);
parcelHelpers.export(exports, "Back", ()=>_backMjsDefault.default
);
parcelHelpers.export(exports, "Baseball", ()=>_baseballMjsDefault.default
);
parcelHelpers.export(exports, "Basketball", ()=>_basketballMjsDefault.default
);
parcelHelpers.export(exports, "BellFilled", ()=>_bellFilledMjsDefault.default
);
parcelHelpers.export(exports, "Bell", ()=>_bellMjsDefault.default
);
parcelHelpers.export(exports, "Bicycle", ()=>_bicycleMjsDefault.default
);
parcelHelpers.export(exports, "BottomLeft", ()=>_bottomLeftMjsDefault.default
);
parcelHelpers.export(exports, "BottomRight", ()=>_bottomRightMjsDefault.default
);
parcelHelpers.export(exports, "Bottom", ()=>_bottomMjsDefault.default
);
parcelHelpers.export(exports, "Bowl", ()=>_bowlMjsDefault.default
);
parcelHelpers.export(exports, "Box", ()=>_boxMjsDefault.default
);
parcelHelpers.export(exports, "Briefcase", ()=>_briefcaseMjsDefault.default
);
parcelHelpers.export(exports, "BrushFilled", ()=>_brushFilledMjsDefault.default
);
parcelHelpers.export(exports, "Brush", ()=>_brushMjsDefault.default
);
parcelHelpers.export(exports, "Burger", ()=>_burgerMjsDefault.default
);
parcelHelpers.export(exports, "Calendar", ()=>_calendarMjsDefault.default
);
parcelHelpers.export(exports, "CameraFilled", ()=>_cameraFilledMjsDefault.default
);
parcelHelpers.export(exports, "Camera", ()=>_cameraMjsDefault.default
);
parcelHelpers.export(exports, "CaretBottom", ()=>_caretBottomMjsDefault.default
);
parcelHelpers.export(exports, "CaretLeft", ()=>_caretLeftMjsDefault.default
);
parcelHelpers.export(exports, "CaretRight", ()=>_caretRightMjsDefault.default
);
parcelHelpers.export(exports, "CaretTop", ()=>_caretTopMjsDefault.default
);
parcelHelpers.export(exports, "Cellphone", ()=>_cellphoneMjsDefault.default
);
parcelHelpers.export(exports, "ChatDotRound", ()=>_chatDotRoundMjsDefault.default
);
parcelHelpers.export(exports, "ChatDotSquare", ()=>_chatDotSquareMjsDefault.default
);
parcelHelpers.export(exports, "ChatLineRound", ()=>_chatLineRoundMjsDefault.default
);
parcelHelpers.export(exports, "ChatLineSquare", ()=>_chatLineSquareMjsDefault.default
);
parcelHelpers.export(exports, "ChatRound", ()=>_chatRoundMjsDefault.default
);
parcelHelpers.export(exports, "ChatSquare", ()=>_chatSquareMjsDefault.default
);
parcelHelpers.export(exports, "Check", ()=>_checkMjsDefault.default
);
parcelHelpers.export(exports, "Checked", ()=>_checkedMjsDefault.default
);
parcelHelpers.export(exports, "Cherry", ()=>_cherryMjsDefault.default
);
parcelHelpers.export(exports, "Chicken", ()=>_chickenMjsDefault.default
);
parcelHelpers.export(exports, "CircleCheckFilled", ()=>_circleCheckFilledMjsDefault.default
);
parcelHelpers.export(exports, "CircleCheck", ()=>_circleCheckMjsDefault.default
);
parcelHelpers.export(exports, "CircleCloseFilled", ()=>_circleCloseFilledMjsDefault.default
);
parcelHelpers.export(exports, "CircleClose", ()=>_circleCloseMjsDefault.default
);
parcelHelpers.export(exports, "CirclePlusFilled", ()=>_circlePlusFilledMjsDefault.default
);
parcelHelpers.export(exports, "CirclePlus", ()=>_circlePlusMjsDefault.default
);
parcelHelpers.export(exports, "Clock", ()=>_clockMjsDefault.default
);
parcelHelpers.export(exports, "CloseBold", ()=>_closeBoldMjsDefault.default
);
parcelHelpers.export(exports, "Close", ()=>_closeMjsDefault.default
);
parcelHelpers.export(exports, "Cloudy", ()=>_cloudyMjsDefault.default
);
parcelHelpers.export(exports, "CoffeeCup", ()=>_coffeeCupMjsDefault.default
);
parcelHelpers.export(exports, "Coffee", ()=>_coffeeMjsDefault.default
);
parcelHelpers.export(exports, "Coin", ()=>_coinMjsDefault.default
);
parcelHelpers.export(exports, "ColdDrink", ()=>_coldDrinkMjsDefault.default
);
parcelHelpers.export(exports, "CollectionTag", ()=>_collectionTagMjsDefault.default
);
parcelHelpers.export(exports, "Collection", ()=>_collectionMjsDefault.default
);
parcelHelpers.export(exports, "Comment", ()=>_commentMjsDefault.default
);
parcelHelpers.export(exports, "Compass", ()=>_compassMjsDefault.default
);
parcelHelpers.export(exports, "Connection", ()=>_connectionMjsDefault.default
);
parcelHelpers.export(exports, "Coordinate", ()=>_coordinateMjsDefault.default
);
parcelHelpers.export(exports, "CopyDocument", ()=>_copyDocumentMjsDefault.default
);
parcelHelpers.export(exports, "Cpu", ()=>_cpuMjsDefault.default
);
parcelHelpers.export(exports, "CreditCard", ()=>_creditCardMjsDefault.default
);
parcelHelpers.export(exports, "Crop", ()=>_cropMjsDefault.default
);
parcelHelpers.export(exports, "DArrowLeft", ()=>_dArrowLeftMjsDefault.default
);
parcelHelpers.export(exports, "DArrowRight", ()=>_dArrowRightMjsDefault.default
);
parcelHelpers.export(exports, "DCaret", ()=>_dCaretMjsDefault.default
);
parcelHelpers.export(exports, "DataAnalysis", ()=>_dataAnalysisMjsDefault.default
);
parcelHelpers.export(exports, "DataBoard", ()=>_dataBoardMjsDefault.default
);
parcelHelpers.export(exports, "DataLine", ()=>_dataLineMjsDefault.default
);
parcelHelpers.export(exports, "DeleteFilled", ()=>_deleteFilledMjsDefault.default
);
parcelHelpers.export(exports, "DeleteLocation", ()=>_deleteLocationMjsDefault.default
);
parcelHelpers.export(exports, "Delete", ()=>_deleteMjsDefault.default
);
parcelHelpers.export(exports, "Dessert", ()=>_dessertMjsDefault.default
);
parcelHelpers.export(exports, "Discount", ()=>_discountMjsDefault.default
);
parcelHelpers.export(exports, "DishDot", ()=>_dishDotMjsDefault.default
);
parcelHelpers.export(exports, "Dish", ()=>_dishMjsDefault.default
);
parcelHelpers.export(exports, "DocumentAdd", ()=>_documentAddMjsDefault.default
);
parcelHelpers.export(exports, "DocumentChecked", ()=>_documentCheckedMjsDefault.default
);
parcelHelpers.export(exports, "DocumentCopy", ()=>_documentCopyMjsDefault.default
);
parcelHelpers.export(exports, "DocumentDelete", ()=>_documentDeleteMjsDefault.default
);
parcelHelpers.export(exports, "DocumentRemove", ()=>_documentRemoveMjsDefault.default
);
parcelHelpers.export(exports, "Document", ()=>_documentMjsDefault.default
);
parcelHelpers.export(exports, "Download", ()=>_downloadMjsDefault.default
);
parcelHelpers.export(exports, "Drizzling", ()=>_drizzlingMjsDefault.default
);
parcelHelpers.export(exports, "EditPen", ()=>_editPenMjsDefault.default
);
parcelHelpers.export(exports, "Edit", ()=>_editMjsDefault.default
);
parcelHelpers.export(exports, "ElemeFilled", ()=>_elemeFilledMjsDefault.default
);
parcelHelpers.export(exports, "Eleme", ()=>_elemeMjsDefault.default
);
parcelHelpers.export(exports, "Expand", ()=>_expandMjsDefault.default
);
parcelHelpers.export(exports, "Failed", ()=>_failedMjsDefault.default
);
parcelHelpers.export(exports, "Female", ()=>_femaleMjsDefault.default
);
parcelHelpers.export(exports, "Files", ()=>_filesMjsDefault.default
);
parcelHelpers.export(exports, "Film", ()=>_filmMjsDefault.default
);
parcelHelpers.export(exports, "Filter", ()=>_filterMjsDefault.default
);
parcelHelpers.export(exports, "Finished", ()=>_finishedMjsDefault.default
);
parcelHelpers.export(exports, "FirstAidKit", ()=>_firstAidKitMjsDefault.default
);
parcelHelpers.export(exports, "Flag", ()=>_flagMjsDefault.default
);
parcelHelpers.export(exports, "Fold", ()=>_foldMjsDefault.default
);
parcelHelpers.export(exports, "FolderAdd", ()=>_folderAddMjsDefault.default
);
parcelHelpers.export(exports, "FolderChecked", ()=>_folderCheckedMjsDefault.default
);
parcelHelpers.export(exports, "FolderDelete", ()=>_folderDeleteMjsDefault.default
);
parcelHelpers.export(exports, "FolderOpened", ()=>_folderOpenedMjsDefault.default
);
parcelHelpers.export(exports, "FolderRemove", ()=>_folderRemoveMjsDefault.default
);
parcelHelpers.export(exports, "Folder", ()=>_folderMjsDefault.default
);
parcelHelpers.export(exports, "Food", ()=>_foodMjsDefault.default
);
parcelHelpers.export(exports, "Football", ()=>_footballMjsDefault.default
);
parcelHelpers.export(exports, "ForkSpoon", ()=>_forkSpoonMjsDefault.default
);
parcelHelpers.export(exports, "Fries", ()=>_friesMjsDefault.default
);
parcelHelpers.export(exports, "FullScreen", ()=>_fullScreenMjsDefault.default
);
parcelHelpers.export(exports, "GobletFull", ()=>_gobletFullMjsDefault.default
);
parcelHelpers.export(exports, "GobletSquareFull", ()=>_gobletSquareFullMjsDefault.default
);
parcelHelpers.export(exports, "GobletSquare", ()=>_gobletSquareMjsDefault.default
);
parcelHelpers.export(exports, "Goblet", ()=>_gobletMjsDefault.default
);
parcelHelpers.export(exports, "GoodsFilled", ()=>_goodsFilledMjsDefault.default
);
parcelHelpers.export(exports, "Goods", ()=>_goodsMjsDefault.default
);
parcelHelpers.export(exports, "Grape", ()=>_grapeMjsDefault.default
);
parcelHelpers.export(exports, "Grid", ()=>_gridMjsDefault.default
);
parcelHelpers.export(exports, "Guide", ()=>_guideMjsDefault.default
);
parcelHelpers.export(exports, "Headset", ()=>_headsetMjsDefault.default
);
parcelHelpers.export(exports, "HelpFilled", ()=>_helpFilledMjsDefault.default
);
parcelHelpers.export(exports, "Help", ()=>_helpMjsDefault.default
);
parcelHelpers.export(exports, "Histogram", ()=>_histogramMjsDefault.default
);
parcelHelpers.export(exports, "HomeFilled", ()=>_homeFilledMjsDefault.default
);
parcelHelpers.export(exports, "HotWater", ()=>_hotWaterMjsDefault.default
);
parcelHelpers.export(exports, "House", ()=>_houseMjsDefault.default
);
parcelHelpers.export(exports, "IceCreamRound", ()=>_iceCreamRoundMjsDefault.default
);
parcelHelpers.export(exports, "IceCreamSquare", ()=>_iceCreamSquareMjsDefault.default
);
parcelHelpers.export(exports, "IceCream", ()=>_iceCreamMjsDefault.default
);
parcelHelpers.export(exports, "IceDrink", ()=>_iceDrinkMjsDefault.default
);
parcelHelpers.export(exports, "IceTea", ()=>_iceTeaMjsDefault.default
);
parcelHelpers.export(exports, "InfoFilled", ()=>_infoFilledMjsDefault.default
);
parcelHelpers.export(exports, "Iphone", ()=>_iphoneMjsDefault.default
);
parcelHelpers.export(exports, "Key", ()=>_keyMjsDefault.default
);
parcelHelpers.export(exports, "KnifeFork", ()=>_knifeForkMjsDefault.default
);
parcelHelpers.export(exports, "Lightning", ()=>_lightningMjsDefault.default
);
parcelHelpers.export(exports, "Link", ()=>_linkMjsDefault.default
);
parcelHelpers.export(exports, "List", ()=>_listMjsDefault.default
);
parcelHelpers.export(exports, "Loading", ()=>_loadingMjsDefault.default
);
parcelHelpers.export(exports, "LocationFilled", ()=>_locationFilledMjsDefault.default
);
parcelHelpers.export(exports, "LocationInformation", ()=>_locationInformationMjsDefault.default
);
parcelHelpers.export(exports, "Location", ()=>_locationMjsDefault.default
);
parcelHelpers.export(exports, "Lock", ()=>_lockMjsDefault.default
);
parcelHelpers.export(exports, "Lollipop", ()=>_lollipopMjsDefault.default
);
parcelHelpers.export(exports, "MagicStick", ()=>_magicStickMjsDefault.default
);
parcelHelpers.export(exports, "Magnet", ()=>_magnetMjsDefault.default
);
parcelHelpers.export(exports, "Male", ()=>_maleMjsDefault.default
);
parcelHelpers.export(exports, "Management", ()=>_managementMjsDefault.default
);
parcelHelpers.export(exports, "MapLocation", ()=>_mapLocationMjsDefault.default
);
parcelHelpers.export(exports, "Medal", ()=>_medalMjsDefault.default
);
parcelHelpers.export(exports, "Menu", ()=>_menuMjsDefault.default
);
parcelHelpers.export(exports, "MessageBox", ()=>_messageBoxMjsDefault.default
);
parcelHelpers.export(exports, "Message", ()=>_messageMjsDefault.default
);
parcelHelpers.export(exports, "Mic", ()=>_micMjsDefault.default
);
parcelHelpers.export(exports, "Microphone", ()=>_microphoneMjsDefault.default
);
parcelHelpers.export(exports, "MilkTea", ()=>_milkTeaMjsDefault.default
);
parcelHelpers.export(exports, "Minus", ()=>_minusMjsDefault.default
);
parcelHelpers.export(exports, "Money", ()=>_moneyMjsDefault.default
);
parcelHelpers.export(exports, "Monitor", ()=>_monitorMjsDefault.default
);
parcelHelpers.export(exports, "MoonNight", ()=>_moonNightMjsDefault.default
);
parcelHelpers.export(exports, "Moon", ()=>_moonMjsDefault.default
);
parcelHelpers.export(exports, "MoreFilled", ()=>_moreFilledMjsDefault.default
);
parcelHelpers.export(exports, "More", ()=>_moreMjsDefault.default
);
parcelHelpers.export(exports, "MostlyCloudy", ()=>_mostlyCloudyMjsDefault.default
);
parcelHelpers.export(exports, "Mouse", ()=>_mouseMjsDefault.default
);
parcelHelpers.export(exports, "Mug", ()=>_mugMjsDefault.default
);
parcelHelpers.export(exports, "MuteNotification", ()=>_muteNotificationMjsDefault.default
);
parcelHelpers.export(exports, "Mute", ()=>_muteMjsDefault.default
);
parcelHelpers.export(exports, "NoSmoking", ()=>_noSmokingMjsDefault.default
);
parcelHelpers.export(exports, "Notebook", ()=>_notebookMjsDefault.default
);
parcelHelpers.export(exports, "Notification", ()=>_notificationMjsDefault.default
);
parcelHelpers.export(exports, "Odometer", ()=>_odometerMjsDefault.default
);
parcelHelpers.export(exports, "OfficeBuilding", ()=>_officeBuildingMjsDefault.default
);
parcelHelpers.export(exports, "Open", ()=>_openMjsDefault.default
);
parcelHelpers.export(exports, "Operation", ()=>_operationMjsDefault.default
);
parcelHelpers.export(exports, "Opportunity", ()=>_opportunityMjsDefault.default
);
parcelHelpers.export(exports, "Orange", ()=>_orangeMjsDefault.default
);
parcelHelpers.export(exports, "Paperclip", ()=>_paperclipMjsDefault.default
);
parcelHelpers.export(exports, "PartlyCloudy", ()=>_partlyCloudyMjsDefault.default
);
parcelHelpers.export(exports, "Pear", ()=>_pearMjsDefault.default
);
parcelHelpers.export(exports, "PhoneFilled", ()=>_phoneFilledMjsDefault.default
);
parcelHelpers.export(exports, "Phone", ()=>_phoneMjsDefault.default
);
parcelHelpers.export(exports, "PictureFilled", ()=>_pictureFilledMjsDefault.default
);
parcelHelpers.export(exports, "PictureRounded", ()=>_pictureRoundedMjsDefault.default
);
parcelHelpers.export(exports, "Picture", ()=>_pictureMjsDefault.default
);
parcelHelpers.export(exports, "PieChart", ()=>_pieChartMjsDefault.default
);
parcelHelpers.export(exports, "Place", ()=>_placeMjsDefault.default
);
parcelHelpers.export(exports, "Platform", ()=>_platformMjsDefault.default
);
parcelHelpers.export(exports, "Plus", ()=>_plusMjsDefault.default
);
parcelHelpers.export(exports, "Pointer", ()=>_pointerMjsDefault.default
);
parcelHelpers.export(exports, "Position", ()=>_positionMjsDefault.default
);
parcelHelpers.export(exports, "Postcard", ()=>_postcardMjsDefault.default
);
parcelHelpers.export(exports, "Pouring", ()=>_pouringMjsDefault.default
);
parcelHelpers.export(exports, "Present", ()=>_presentMjsDefault.default
);
parcelHelpers.export(exports, "PriceTag", ()=>_priceTagMjsDefault.default
);
parcelHelpers.export(exports, "Printer", ()=>_printerMjsDefault.default
);
parcelHelpers.export(exports, "Promotion", ()=>_promotionMjsDefault.default
);
parcelHelpers.export(exports, "QuestionFilled", ()=>_questionFilledMjsDefault.default
);
parcelHelpers.export(exports, "Rank", ()=>_rankMjsDefault.default
);
parcelHelpers.export(exports, "ReadingLamp", ()=>_readingLampMjsDefault.default
);
parcelHelpers.export(exports, "Reading", ()=>_readingMjsDefault.default
);
parcelHelpers.export(exports, "RefreshLeft", ()=>_refreshLeftMjsDefault.default
);
parcelHelpers.export(exports, "RefreshRight", ()=>_refreshRightMjsDefault.default
);
parcelHelpers.export(exports, "Refresh", ()=>_refreshMjsDefault.default
);
parcelHelpers.export(exports, "Refrigerator", ()=>_refrigeratorMjsDefault.default
);
parcelHelpers.export(exports, "RemoveFilled", ()=>_removeFilledMjsDefault.default
);
parcelHelpers.export(exports, "Remove", ()=>_removeMjsDefault.default
);
parcelHelpers.export(exports, "Right", ()=>_rightMjsDefault.default
);
parcelHelpers.export(exports, "ScaleToOriginal", ()=>_scaleToOriginalMjsDefault.default
);
parcelHelpers.export(exports, "School", ()=>_schoolMjsDefault.default
);
parcelHelpers.export(exports, "Scissor", ()=>_scissorMjsDefault.default
);
parcelHelpers.export(exports, "Search", ()=>_searchMjsDefault.default
);
parcelHelpers.export(exports, "Select", ()=>_selectMjsDefault.default
);
parcelHelpers.export(exports, "Sell", ()=>_sellMjsDefault.default
);
parcelHelpers.export(exports, "SemiSelect", ()=>_semiSelectMjsDefault.default
);
parcelHelpers.export(exports, "Service", ()=>_serviceMjsDefault.default
);
parcelHelpers.export(exports, "SetUp", ()=>_setUpMjsDefault.default
);
parcelHelpers.export(exports, "Setting", ()=>_settingMjsDefault.default
);
parcelHelpers.export(exports, "Share", ()=>_shareMjsDefault.default
);
parcelHelpers.export(exports, "Ship", ()=>_shipMjsDefault.default
);
parcelHelpers.export(exports, "Shop", ()=>_shopMjsDefault.default
);
parcelHelpers.export(exports, "ShoppingBag", ()=>_shoppingBagMjsDefault.default
);
parcelHelpers.export(exports, "ShoppingCartFull", ()=>_shoppingCartFullMjsDefault.default
);
parcelHelpers.export(exports, "ShoppingCart", ()=>_shoppingCartMjsDefault.default
);
parcelHelpers.export(exports, "Smoking", ()=>_smokingMjsDefault.default
);
parcelHelpers.export(exports, "Soccer", ()=>_soccerMjsDefault.default
);
parcelHelpers.export(exports, "SoldOut", ()=>_soldOutMjsDefault.default
);
parcelHelpers.export(exports, "SortDown", ()=>_sortDownMjsDefault.default
);
parcelHelpers.export(exports, "SortUp", ()=>_sortUpMjsDefault.default
);
parcelHelpers.export(exports, "Sort", ()=>_sortMjsDefault.default
);
parcelHelpers.export(exports, "Stamp", ()=>_stampMjsDefault.default
);
parcelHelpers.export(exports, "StarFilled", ()=>_starFilledMjsDefault.default
);
parcelHelpers.export(exports, "Star", ()=>_starMjsDefault.default
);
parcelHelpers.export(exports, "Stopwatch", ()=>_stopwatchMjsDefault.default
);
parcelHelpers.export(exports, "SuccessFilled", ()=>_successFilledMjsDefault.default
);
parcelHelpers.export(exports, "Sugar", ()=>_sugarMjsDefault.default
);
parcelHelpers.export(exports, "Suitcase", ()=>_suitcaseMjsDefault.default
);
parcelHelpers.export(exports, "Sunny", ()=>_sunnyMjsDefault.default
);
parcelHelpers.export(exports, "Sunrise", ()=>_sunriseMjsDefault.default
);
parcelHelpers.export(exports, "Sunset", ()=>_sunsetMjsDefault.default
);
parcelHelpers.export(exports, "SwitchButton", ()=>_switchButtonMjsDefault.default
);
parcelHelpers.export(exports, "Switch", ()=>_switchMjsDefault.default
);
parcelHelpers.export(exports, "TakeawayBox", ()=>_takeawayBoxMjsDefault.default
);
parcelHelpers.export(exports, "Ticket", ()=>_ticketMjsDefault.default
);
parcelHelpers.export(exports, "Tickets", ()=>_ticketsMjsDefault.default
);
parcelHelpers.export(exports, "Timer", ()=>_timerMjsDefault.default
);
parcelHelpers.export(exports, "ToiletPaper", ()=>_toiletPaperMjsDefault.default
);
parcelHelpers.export(exports, "Tools", ()=>_toolsMjsDefault.default
);
parcelHelpers.export(exports, "TopLeft", ()=>_topLeftMjsDefault.default
);
parcelHelpers.export(exports, "TopRight", ()=>_topRightMjsDefault.default
);
parcelHelpers.export(exports, "Top", ()=>_topMjsDefault.default
);
parcelHelpers.export(exports, "TrendCharts", ()=>_trendChartsMjsDefault.default
);
parcelHelpers.export(exports, "Trophy", ()=>_trophyMjsDefault.default
);
parcelHelpers.export(exports, "TurnOff", ()=>_turnOffMjsDefault.default
);
parcelHelpers.export(exports, "Umbrella", ()=>_umbrellaMjsDefault.default
);
parcelHelpers.export(exports, "Unlock", ()=>_unlockMjsDefault.default
);
parcelHelpers.export(exports, "UploadFilled", ()=>_uploadFilledMjsDefault.default
);
parcelHelpers.export(exports, "Upload", ()=>_uploadMjsDefault.default
);
parcelHelpers.export(exports, "UserFilled", ()=>_userFilledMjsDefault.default
);
parcelHelpers.export(exports, "User", ()=>_userMjsDefault.default
);
parcelHelpers.export(exports, "Van", ()=>_vanMjsDefault.default
);
parcelHelpers.export(exports, "VideoCameraFilled", ()=>_videoCameraFilledMjsDefault.default
);
parcelHelpers.export(exports, "VideoCamera", ()=>_videoCameraMjsDefault.default
);
parcelHelpers.export(exports, "VideoPause", ()=>_videoPauseMjsDefault.default
);
parcelHelpers.export(exports, "VideoPlay", ()=>_videoPlayMjsDefault.default
);
parcelHelpers.export(exports, "View", ()=>_viewMjsDefault.default
);
parcelHelpers.export(exports, "WalletFilled", ()=>_walletFilledMjsDefault.default
);
parcelHelpers.export(exports, "Wallet", ()=>_walletMjsDefault.default
);
parcelHelpers.export(exports, "WarningFilled", ()=>_warningFilledMjsDefault.default
);
parcelHelpers.export(exports, "Warning", ()=>_warningMjsDefault.default
);
parcelHelpers.export(exports, "Watch", ()=>_watchMjsDefault.default
);
parcelHelpers.export(exports, "Watermelon", ()=>_watermelonMjsDefault.default
);
parcelHelpers.export(exports, "WindPower", ()=>_windPowerMjsDefault.default
);
parcelHelpers.export(exports, "ZoomIn", ()=>_zoomInMjsDefault.default
);
parcelHelpers.export(exports, "ZoomOut", ()=>_zoomOutMjsDefault.default
);
var _addLocationMjs = require("./add-location.mjs");
var _addLocationMjsDefault = parcelHelpers.interopDefault(_addLocationMjs);
var _aimMjs = require("./aim.mjs");
var _aimMjsDefault = parcelHelpers.interopDefault(_aimMjs);
var _alarmClockMjs = require("./alarm-clock.mjs");
var _alarmClockMjsDefault = parcelHelpers.interopDefault(_alarmClockMjs);
var _appleMjs = require("./apple.mjs");
var _appleMjsDefault = parcelHelpers.interopDefault(_appleMjs);
var _arrowDownBoldMjs = require("./arrow-down-bold.mjs");
var _arrowDownBoldMjsDefault = parcelHelpers.interopDefault(_arrowDownBoldMjs);
var _arrowDownMjs = require("./arrow-down.mjs");
var _arrowDownMjsDefault = parcelHelpers.interopDefault(_arrowDownMjs);
var _arrowLeftBoldMjs = require("./arrow-left-bold.mjs");
var _arrowLeftBoldMjsDefault = parcelHelpers.interopDefault(_arrowLeftBoldMjs);
var _arrowLeftMjs = require("./arrow-left.mjs");
var _arrowLeftMjsDefault = parcelHelpers.interopDefault(_arrowLeftMjs);
var _arrowRightBoldMjs = require("./arrow-right-bold.mjs");
var _arrowRightBoldMjsDefault = parcelHelpers.interopDefault(_arrowRightBoldMjs);
var _arrowRightMjs = require("./arrow-right.mjs");
var _arrowRightMjsDefault = parcelHelpers.interopDefault(_arrowRightMjs);
var _arrowUpBoldMjs = require("./arrow-up-bold.mjs");
var _arrowUpBoldMjsDefault = parcelHelpers.interopDefault(_arrowUpBoldMjs);
var _arrowUpMjs = require("./arrow-up.mjs");
var _arrowUpMjsDefault = parcelHelpers.interopDefault(_arrowUpMjs);
var _avatarMjs = require("./avatar.mjs");
var _avatarMjsDefault = parcelHelpers.interopDefault(_avatarMjs);
var _backMjs = require("./back.mjs");
var _backMjsDefault = parcelHelpers.interopDefault(_backMjs);
var _baseballMjs = require("./baseball.mjs");
var _baseballMjsDefault = parcelHelpers.interopDefault(_baseballMjs);
var _basketballMjs = require("./basketball.mjs");
var _basketballMjsDefault = parcelHelpers.interopDefault(_basketballMjs);
var _bellFilledMjs = require("./bell-filled.mjs");
var _bellFilledMjsDefault = parcelHelpers.interopDefault(_bellFilledMjs);
var _bellMjs = require("./bell.mjs");
var _bellMjsDefault = parcelHelpers.interopDefault(_bellMjs);
var _bicycleMjs = require("./bicycle.mjs");
var _bicycleMjsDefault = parcelHelpers.interopDefault(_bicycleMjs);
var _bottomLeftMjs = require("./bottom-left.mjs");
var _bottomLeftMjsDefault = parcelHelpers.interopDefault(_bottomLeftMjs);
var _bottomRightMjs = require("./bottom-right.mjs");
var _bottomRightMjsDefault = parcelHelpers.interopDefault(_bottomRightMjs);
var _bottomMjs = require("./bottom.mjs");
var _bottomMjsDefault = parcelHelpers.interopDefault(_bottomMjs);
var _bowlMjs = require("./bowl.mjs");
var _bowlMjsDefault = parcelHelpers.interopDefault(_bowlMjs);
var _boxMjs = require("./box.mjs");
var _boxMjsDefault = parcelHelpers.interopDefault(_boxMjs);
var _briefcaseMjs = require("./briefcase.mjs");
var _briefcaseMjsDefault = parcelHelpers.interopDefault(_briefcaseMjs);
var _brushFilledMjs = require("./brush-filled.mjs");
var _brushFilledMjsDefault = parcelHelpers.interopDefault(_brushFilledMjs);
var _brushMjs = require("./brush.mjs");
var _brushMjsDefault = parcelHelpers.interopDefault(_brushMjs);
var _burgerMjs = require("./burger.mjs");
var _burgerMjsDefault = parcelHelpers.interopDefault(_burgerMjs);
var _calendarMjs = require("./calendar.mjs");
var _calendarMjsDefault = parcelHelpers.interopDefault(_calendarMjs);
var _cameraFilledMjs = require("./camera-filled.mjs");
var _cameraFilledMjsDefault = parcelHelpers.interopDefault(_cameraFilledMjs);
var _cameraMjs = require("./camera.mjs");
var _cameraMjsDefault = parcelHelpers.interopDefault(_cameraMjs);
var _caretBottomMjs = require("./caret-bottom.mjs");
var _caretBottomMjsDefault = parcelHelpers.interopDefault(_caretBottomMjs);
var _caretLeftMjs = require("./caret-left.mjs");
var _caretLeftMjsDefault = parcelHelpers.interopDefault(_caretLeftMjs);
var _caretRightMjs = require("./caret-right.mjs");
var _caretRightMjsDefault = parcelHelpers.interopDefault(_caretRightMjs);
var _caretTopMjs = require("./caret-top.mjs");
var _caretTopMjsDefault = parcelHelpers.interopDefault(_caretTopMjs);
var _cellphoneMjs = require("./cellphone.mjs");
var _cellphoneMjsDefault = parcelHelpers.interopDefault(_cellphoneMjs);
var _chatDotRoundMjs = require("./chat-dot-round.mjs");
var _chatDotRoundMjsDefault = parcelHelpers.interopDefault(_chatDotRoundMjs);
var _chatDotSquareMjs = require("./chat-dot-square.mjs");
var _chatDotSquareMjsDefault = parcelHelpers.interopDefault(_chatDotSquareMjs);
var _chatLineRoundMjs = require("./chat-line-round.mjs");
var _chatLineRoundMjsDefault = parcelHelpers.interopDefault(_chatLineRoundMjs);
var _chatLineSquareMjs = require("./chat-line-square.mjs");
var _chatLineSquareMjsDefault = parcelHelpers.interopDefault(_chatLineSquareMjs);
var _chatRoundMjs = require("./chat-round.mjs");
var _chatRoundMjsDefault = parcelHelpers.interopDefault(_chatRoundMjs);
var _chatSquareMjs = require("./chat-square.mjs");
var _chatSquareMjsDefault = parcelHelpers.interopDefault(_chatSquareMjs);
var _checkMjs = require("./check.mjs");
var _checkMjsDefault = parcelHelpers.interopDefault(_checkMjs);
var _checkedMjs = require("./checked.mjs");
var _checkedMjsDefault = parcelHelpers.interopDefault(_checkedMjs);
var _cherryMjs = require("./cherry.mjs");
var _cherryMjsDefault = parcelHelpers.interopDefault(_cherryMjs);
var _chickenMjs = require("./chicken.mjs");
var _chickenMjsDefault = parcelHelpers.interopDefault(_chickenMjs);
var _circleCheckFilledMjs = require("./circle-check-filled.mjs");
var _circleCheckFilledMjsDefault = parcelHelpers.interopDefault(_circleCheckFilledMjs);
var _circleCheckMjs = require("./circle-check.mjs");
var _circleCheckMjsDefault = parcelHelpers.interopDefault(_circleCheckMjs);
var _circleCloseFilledMjs = require("./circle-close-filled.mjs");
var _circleCloseFilledMjsDefault = parcelHelpers.interopDefault(_circleCloseFilledMjs);
var _circleCloseMjs = require("./circle-close.mjs");
var _circleCloseMjsDefault = parcelHelpers.interopDefault(_circleCloseMjs);
var _circlePlusFilledMjs = require("./circle-plus-filled.mjs");
var _circlePlusFilledMjsDefault = parcelHelpers.interopDefault(_circlePlusFilledMjs);
var _circlePlusMjs = require("./circle-plus.mjs");
var _circlePlusMjsDefault = parcelHelpers.interopDefault(_circlePlusMjs);
var _clockMjs = require("./clock.mjs");
var _clockMjsDefault = parcelHelpers.interopDefault(_clockMjs);
var _closeBoldMjs = require("./close-bold.mjs");
var _closeBoldMjsDefault = parcelHelpers.interopDefault(_closeBoldMjs);
var _closeMjs = require("./close.mjs");
var _closeMjsDefault = parcelHelpers.interopDefault(_closeMjs);
var _cloudyMjs = require("./cloudy.mjs");
var _cloudyMjsDefault = parcelHelpers.interopDefault(_cloudyMjs);
var _coffeeCupMjs = require("./coffee-cup.mjs");
var _coffeeCupMjsDefault = parcelHelpers.interopDefault(_coffeeCupMjs);
var _coffeeMjs = require("./coffee.mjs");
var _coffeeMjsDefault = parcelHelpers.interopDefault(_coffeeMjs);
var _coinMjs = require("./coin.mjs");
var _coinMjsDefault = parcelHelpers.interopDefault(_coinMjs);
var _coldDrinkMjs = require("./cold-drink.mjs");
var _coldDrinkMjsDefault = parcelHelpers.interopDefault(_coldDrinkMjs);
var _collectionTagMjs = require("./collection-tag.mjs");
var _collectionTagMjsDefault = parcelHelpers.interopDefault(_collectionTagMjs);
var _collectionMjs = require("./collection.mjs");
var _collectionMjsDefault = parcelHelpers.interopDefault(_collectionMjs);
var _commentMjs = require("./comment.mjs");
var _commentMjsDefault = parcelHelpers.interopDefault(_commentMjs);
var _compassMjs = require("./compass.mjs");
var _compassMjsDefault = parcelHelpers.interopDefault(_compassMjs);
var _connectionMjs = require("./connection.mjs");
var _connectionMjsDefault = parcelHelpers.interopDefault(_connectionMjs);
var _coordinateMjs = require("./coordinate.mjs");
var _coordinateMjsDefault = parcelHelpers.interopDefault(_coordinateMjs);
var _copyDocumentMjs = require("./copy-document.mjs");
var _copyDocumentMjsDefault = parcelHelpers.interopDefault(_copyDocumentMjs);
var _cpuMjs = require("./cpu.mjs");
var _cpuMjsDefault = parcelHelpers.interopDefault(_cpuMjs);
var _creditCardMjs = require("./credit-card.mjs");
var _creditCardMjsDefault = parcelHelpers.interopDefault(_creditCardMjs);
var _cropMjs = require("./crop.mjs");
var _cropMjsDefault = parcelHelpers.interopDefault(_cropMjs);
var _dArrowLeftMjs = require("./d-arrow-left.mjs");
var _dArrowLeftMjsDefault = parcelHelpers.interopDefault(_dArrowLeftMjs);
var _dArrowRightMjs = require("./d-arrow-right.mjs");
var _dArrowRightMjsDefault = parcelHelpers.interopDefault(_dArrowRightMjs);
var _dCaretMjs = require("./d-caret.mjs");
var _dCaretMjsDefault = parcelHelpers.interopDefault(_dCaretMjs);
var _dataAnalysisMjs = require("./data-analysis.mjs");
var _dataAnalysisMjsDefault = parcelHelpers.interopDefault(_dataAnalysisMjs);
var _dataBoardMjs = require("./data-board.mjs");
var _dataBoardMjsDefault = parcelHelpers.interopDefault(_dataBoardMjs);
var _dataLineMjs = require("./data-line.mjs");
var _dataLineMjsDefault = parcelHelpers.interopDefault(_dataLineMjs);
var _deleteFilledMjs = require("./delete-filled.mjs");
var _deleteFilledMjsDefault = parcelHelpers.interopDefault(_deleteFilledMjs);
var _deleteLocationMjs = require("./delete-location.mjs");
var _deleteLocationMjsDefault = parcelHelpers.interopDefault(_deleteLocationMjs);
var _deleteMjs = require("./delete.mjs");
var _deleteMjsDefault = parcelHelpers.interopDefault(_deleteMjs);
var _dessertMjs = require("./dessert.mjs");
var _dessertMjsDefault = parcelHelpers.interopDefault(_dessertMjs);
var _discountMjs = require("./discount.mjs");
var _discountMjsDefault = parcelHelpers.interopDefault(_discountMjs);
var _dishDotMjs = require("./dish-dot.mjs");
var _dishDotMjsDefault = parcelHelpers.interopDefault(_dishDotMjs);
var _dishMjs = require("./dish.mjs");
var _dishMjsDefault = parcelHelpers.interopDefault(_dishMjs);
var _documentAddMjs = require("./document-add.mjs");
var _documentAddMjsDefault = parcelHelpers.interopDefault(_documentAddMjs);
var _documentCheckedMjs = require("./document-checked.mjs");
var _documentCheckedMjsDefault = parcelHelpers.interopDefault(_documentCheckedMjs);
var _documentCopyMjs = require("./document-copy.mjs");
var _documentCopyMjsDefault = parcelHelpers.interopDefault(_documentCopyMjs);
var _documentDeleteMjs = require("./document-delete.mjs");
var _documentDeleteMjsDefault = parcelHelpers.interopDefault(_documentDeleteMjs);
var _documentRemoveMjs = require("./document-remove.mjs");
var _documentRemoveMjsDefault = parcelHelpers.interopDefault(_documentRemoveMjs);
var _documentMjs = require("./document.mjs");
var _documentMjsDefault = parcelHelpers.interopDefault(_documentMjs);
var _downloadMjs = require("./download.mjs");
var _downloadMjsDefault = parcelHelpers.interopDefault(_downloadMjs);
var _drizzlingMjs = require("./drizzling.mjs");
var _drizzlingMjsDefault = parcelHelpers.interopDefault(_drizzlingMjs);
var _editPenMjs = require("./edit-pen.mjs");
var _editPenMjsDefault = parcelHelpers.interopDefault(_editPenMjs);
var _editMjs = require("./edit.mjs");
var _editMjsDefault = parcelHelpers.interopDefault(_editMjs);
var _elemeFilledMjs = require("./eleme-filled.mjs");
var _elemeFilledMjsDefault = parcelHelpers.interopDefault(_elemeFilledMjs);
var _elemeMjs = require("./eleme.mjs");
var _elemeMjsDefault = parcelHelpers.interopDefault(_elemeMjs);
var _expandMjs = require("./expand.mjs");
var _expandMjsDefault = parcelHelpers.interopDefault(_expandMjs);
var _failedMjs = require("./failed.mjs");
var _failedMjsDefault = parcelHelpers.interopDefault(_failedMjs);
var _femaleMjs = require("./female.mjs");
var _femaleMjsDefault = parcelHelpers.interopDefault(_femaleMjs);
var _filesMjs = require("./files.mjs");
var _filesMjsDefault = parcelHelpers.interopDefault(_filesMjs);
var _filmMjs = require("./film.mjs");
var _filmMjsDefault = parcelHelpers.interopDefault(_filmMjs);
var _filterMjs = require("./filter.mjs");
var _filterMjsDefault = parcelHelpers.interopDefault(_filterMjs);
var _finishedMjs = require("./finished.mjs");
var _finishedMjsDefault = parcelHelpers.interopDefault(_finishedMjs);
var _firstAidKitMjs = require("./first-aid-kit.mjs");
var _firstAidKitMjsDefault = parcelHelpers.interopDefault(_firstAidKitMjs);
var _flagMjs = require("./flag.mjs");
var _flagMjsDefault = parcelHelpers.interopDefault(_flagMjs);
var _foldMjs = require("./fold.mjs");
var _foldMjsDefault = parcelHelpers.interopDefault(_foldMjs);
var _folderAddMjs = require("./folder-add.mjs");
var _folderAddMjsDefault = parcelHelpers.interopDefault(_folderAddMjs);
var _folderCheckedMjs = require("./folder-checked.mjs");
var _folderCheckedMjsDefault = parcelHelpers.interopDefault(_folderCheckedMjs);
var _folderDeleteMjs = require("./folder-delete.mjs");
var _folderDeleteMjsDefault = parcelHelpers.interopDefault(_folderDeleteMjs);
var _folderOpenedMjs = require("./folder-opened.mjs");
var _folderOpenedMjsDefault = parcelHelpers.interopDefault(_folderOpenedMjs);
var _folderRemoveMjs = require("./folder-remove.mjs");
var _folderRemoveMjsDefault = parcelHelpers.interopDefault(_folderRemoveMjs);
var _folderMjs = require("./folder.mjs");
var _folderMjsDefault = parcelHelpers.interopDefault(_folderMjs);
var _foodMjs = require("./food.mjs");
var _foodMjsDefault = parcelHelpers.interopDefault(_foodMjs);
var _footballMjs = require("./football.mjs");
var _footballMjsDefault = parcelHelpers.interopDefault(_footballMjs);
var _forkSpoonMjs = require("./fork-spoon.mjs");
var _forkSpoonMjsDefault = parcelHelpers.interopDefault(_forkSpoonMjs);
var _friesMjs = require("./fries.mjs");
var _friesMjsDefault = parcelHelpers.interopDefault(_friesMjs);
var _fullScreenMjs = require("./full-screen.mjs");
var _fullScreenMjsDefault = parcelHelpers.interopDefault(_fullScreenMjs);
var _gobletFullMjs = require("./goblet-full.mjs");
var _gobletFullMjsDefault = parcelHelpers.interopDefault(_gobletFullMjs);
var _gobletSquareFullMjs = require("./goblet-square-full.mjs");
var _gobletSquareFullMjsDefault = parcelHelpers.interopDefault(_gobletSquareFullMjs);
var _gobletSquareMjs = require("./goblet-square.mjs");
var _gobletSquareMjsDefault = parcelHelpers.interopDefault(_gobletSquareMjs);
var _gobletMjs = require("./goblet.mjs");
var _gobletMjsDefault = parcelHelpers.interopDefault(_gobletMjs);
var _goodsFilledMjs = require("./goods-filled.mjs");
var _goodsFilledMjsDefault = parcelHelpers.interopDefault(_goodsFilledMjs);
var _goodsMjs = require("./goods.mjs");
var _goodsMjsDefault = parcelHelpers.interopDefault(_goodsMjs);
var _grapeMjs = require("./grape.mjs");
var _grapeMjsDefault = parcelHelpers.interopDefault(_grapeMjs);
var _gridMjs = require("./grid.mjs");
var _gridMjsDefault = parcelHelpers.interopDefault(_gridMjs);
var _guideMjs = require("./guide.mjs");
var _guideMjsDefault = parcelHelpers.interopDefault(_guideMjs);
var _headsetMjs = require("./headset.mjs");
var _headsetMjsDefault = parcelHelpers.interopDefault(_headsetMjs);
var _helpFilledMjs = require("./help-filled.mjs");
var _helpFilledMjsDefault = parcelHelpers.interopDefault(_helpFilledMjs);
var _helpMjs = require("./help.mjs");
var _helpMjsDefault = parcelHelpers.interopDefault(_helpMjs);
var _histogramMjs = require("./histogram.mjs");
var _histogramMjsDefault = parcelHelpers.interopDefault(_histogramMjs);
var _homeFilledMjs = require("./home-filled.mjs");
var _homeFilledMjsDefault = parcelHelpers.interopDefault(_homeFilledMjs);
var _hotWaterMjs = require("./hot-water.mjs");
var _hotWaterMjsDefault = parcelHelpers.interopDefault(_hotWaterMjs);
var _houseMjs = require("./house.mjs");
var _houseMjsDefault = parcelHelpers.interopDefault(_houseMjs);
var _iceCreamRoundMjs = require("./ice-cream-round.mjs");
var _iceCreamRoundMjsDefault = parcelHelpers.interopDefault(_iceCreamRoundMjs);
var _iceCreamSquareMjs = require("./ice-cream-square.mjs");
var _iceCreamSquareMjsDefault = parcelHelpers.interopDefault(_iceCreamSquareMjs);
var _iceCreamMjs = require("./ice-cream.mjs");
var _iceCreamMjsDefault = parcelHelpers.interopDefault(_iceCreamMjs);
var _iceDrinkMjs = require("./ice-drink.mjs");
var _iceDrinkMjsDefault = parcelHelpers.interopDefault(_iceDrinkMjs);
var _iceTeaMjs = require("./ice-tea.mjs");
var _iceTeaMjsDefault = parcelHelpers.interopDefault(_iceTeaMjs);
var _infoFilledMjs = require("./info-filled.mjs");
var _infoFilledMjsDefault = parcelHelpers.interopDefault(_infoFilledMjs);
var _iphoneMjs = require("./iphone.mjs");
var _iphoneMjsDefault = parcelHelpers.interopDefault(_iphoneMjs);
var _keyMjs = require("./key.mjs");
var _keyMjsDefault = parcelHelpers.interopDefault(_keyMjs);
var _knifeForkMjs = require("./knife-fork.mjs");
var _knifeForkMjsDefault = parcelHelpers.interopDefault(_knifeForkMjs);
var _lightningMjs = require("./lightning.mjs");
var _lightningMjsDefault = parcelHelpers.interopDefault(_lightningMjs);
var _linkMjs = require("./link.mjs");
var _linkMjsDefault = parcelHelpers.interopDefault(_linkMjs);
var _listMjs = require("./list.mjs");
var _listMjsDefault = parcelHelpers.interopDefault(_listMjs);
var _loadingMjs = require("./loading.mjs");
var _loadingMjsDefault = parcelHelpers.interopDefault(_loadingMjs);
var _locationFilledMjs = require("./location-filled.mjs");
var _locationFilledMjsDefault = parcelHelpers.interopDefault(_locationFilledMjs);
var _locationInformationMjs = require("./location-information.mjs");
var _locationInformationMjsDefault = parcelHelpers.interopDefault(_locationInformationMjs);
var _locationMjs = require("./location.mjs");
var _locationMjsDefault = parcelHelpers.interopDefault(_locationMjs);
var _lockMjs = require("./lock.mjs");
var _lockMjsDefault = parcelHelpers.interopDefault(_lockMjs);
var _lollipopMjs = require("./lollipop.mjs");
var _lollipopMjsDefault = parcelHelpers.interopDefault(_lollipopMjs);
var _magicStickMjs = require("./magic-stick.mjs");
var _magicStickMjsDefault = parcelHelpers.interopDefault(_magicStickMjs);
var _magnetMjs = require("./magnet.mjs");
var _magnetMjsDefault = parcelHelpers.interopDefault(_magnetMjs);
var _maleMjs = require("./male.mjs");
var _maleMjsDefault = parcelHelpers.interopDefault(_maleMjs);
var _managementMjs = require("./management.mjs");
var _managementMjsDefault = parcelHelpers.interopDefault(_managementMjs);
var _mapLocationMjs = require("./map-location.mjs");
var _mapLocationMjsDefault = parcelHelpers.interopDefault(_mapLocationMjs);
var _medalMjs = require("./medal.mjs");
var _medalMjsDefault = parcelHelpers.interopDefault(_medalMjs);
var _menuMjs = require("./menu.mjs");
var _menuMjsDefault = parcelHelpers.interopDefault(_menuMjs);
var _messageBoxMjs = require("./message-box.mjs");
var _messageBoxMjsDefault = parcelHelpers.interopDefault(_messageBoxMjs);
var _messageMjs = require("./message.mjs");
var _messageMjsDefault = parcelHelpers.interopDefault(_messageMjs);
var _micMjs = require("./mic.mjs");
var _micMjsDefault = parcelHelpers.interopDefault(_micMjs);
var _microphoneMjs = require("./microphone.mjs");
var _microphoneMjsDefault = parcelHelpers.interopDefault(_microphoneMjs);
var _milkTeaMjs = require("./milk-tea.mjs");
var _milkTeaMjsDefault = parcelHelpers.interopDefault(_milkTeaMjs);
var _minusMjs = require("./minus.mjs");
var _minusMjsDefault = parcelHelpers.interopDefault(_minusMjs);
var _moneyMjs = require("./money.mjs");
var _moneyMjsDefault = parcelHelpers.interopDefault(_moneyMjs);
var _monitorMjs = require("./monitor.mjs");
var _monitorMjsDefault = parcelHelpers.interopDefault(_monitorMjs);
var _moonNightMjs = require("./moon-night.mjs");
var _moonNightMjsDefault = parcelHelpers.interopDefault(_moonNightMjs);
var _moonMjs = require("./moon.mjs");
var _moonMjsDefault = parcelHelpers.interopDefault(_moonMjs);
var _moreFilledMjs = require("./more-filled.mjs");
var _moreFilledMjsDefault = parcelHelpers.interopDefault(_moreFilledMjs);
var _moreMjs = require("./more.mjs");
var _moreMjsDefault = parcelHelpers.interopDefault(_moreMjs);
var _mostlyCloudyMjs = require("./mostly-cloudy.mjs");
var _mostlyCloudyMjsDefault = parcelHelpers.interopDefault(_mostlyCloudyMjs);
var _mouseMjs = require("./mouse.mjs");
var _mouseMjsDefault = parcelHelpers.interopDefault(_mouseMjs);
var _mugMjs = require("./mug.mjs");
var _mugMjsDefault = parcelHelpers.interopDefault(_mugMjs);
var _muteNotificationMjs = require("./mute-notification.mjs");
var _muteNotificationMjsDefault = parcelHelpers.interopDefault(_muteNotificationMjs);
var _muteMjs = require("./mute.mjs");
var _muteMjsDefault = parcelHelpers.interopDefault(_muteMjs);
var _noSmokingMjs = require("./no-smoking.mjs");
var _noSmokingMjsDefault = parcelHelpers.interopDefault(_noSmokingMjs);
var _notebookMjs = require("./notebook.mjs");
var _notebookMjsDefault = parcelHelpers.interopDefault(_notebookMjs);
var _notificationMjs = require("./notification.mjs");
var _notificationMjsDefault = parcelHelpers.interopDefault(_notificationMjs);
var _odometerMjs = require("./odometer.mjs");
var _odometerMjsDefault = parcelHelpers.interopDefault(_odometerMjs);
var _officeBuildingMjs = require("./office-building.mjs");
var _officeBuildingMjsDefault = parcelHelpers.interopDefault(_officeBuildingMjs);
var _openMjs = require("./open.mjs");
var _openMjsDefault = parcelHelpers.interopDefault(_openMjs);
var _operationMjs = require("./operation.mjs");
var _operationMjsDefault = parcelHelpers.interopDefault(_operationMjs);
var _opportunityMjs = require("./opportunity.mjs");
var _opportunityMjsDefault = parcelHelpers.interopDefault(_opportunityMjs);
var _orangeMjs = require("./orange.mjs");
var _orangeMjsDefault = parcelHelpers.interopDefault(_orangeMjs);
var _paperclipMjs = require("./paperclip.mjs");
var _paperclipMjsDefault = parcelHelpers.interopDefault(_paperclipMjs);
var _partlyCloudyMjs = require("./partly-cloudy.mjs");
var _partlyCloudyMjsDefault = parcelHelpers.interopDefault(_partlyCloudyMjs);
var _pearMjs = require("./pear.mjs");
var _pearMjsDefault = parcelHelpers.interopDefault(_pearMjs);
var _phoneFilledMjs = require("./phone-filled.mjs");
var _phoneFilledMjsDefault = parcelHelpers.interopDefault(_phoneFilledMjs);
var _phoneMjs = require("./phone.mjs");
var _phoneMjsDefault = parcelHelpers.interopDefault(_phoneMjs);
var _pictureFilledMjs = require("./picture-filled.mjs");
var _pictureFilledMjsDefault = parcelHelpers.interopDefault(_pictureFilledMjs);
var _pictureRoundedMjs = require("./picture-rounded.mjs");
var _pictureRoundedMjsDefault = parcelHelpers.interopDefault(_pictureRoundedMjs);
var _pictureMjs = require("./picture.mjs");
var _pictureMjsDefault = parcelHelpers.interopDefault(_pictureMjs);
var _pieChartMjs = require("./pie-chart.mjs");
var _pieChartMjsDefault = parcelHelpers.interopDefault(_pieChartMjs);
var _placeMjs = require("./place.mjs");
var _placeMjsDefault = parcelHelpers.interopDefault(_placeMjs);
var _platformMjs = require("./platform.mjs");
var _platformMjsDefault = parcelHelpers.interopDefault(_platformMjs);
var _plusMjs = require("./plus.mjs");
var _plusMjsDefault = parcelHelpers.interopDefault(_plusMjs);
var _pointerMjs = require("./pointer.mjs");
var _pointerMjsDefault = parcelHelpers.interopDefault(_pointerMjs);
var _positionMjs = require("./position.mjs");
var _positionMjsDefault = parcelHelpers.interopDefault(_positionMjs);
var _postcardMjs = require("./postcard.mjs");
var _postcardMjsDefault = parcelHelpers.interopDefault(_postcardMjs);
var _pouringMjs = require("./pouring.mjs");
var _pouringMjsDefault = parcelHelpers.interopDefault(_pouringMjs);
var _presentMjs = require("./present.mjs");
var _presentMjsDefault = parcelHelpers.interopDefault(_presentMjs);
var _priceTagMjs = require("./price-tag.mjs");
var _priceTagMjsDefault = parcelHelpers.interopDefault(_priceTagMjs);
var _printerMjs = require("./printer.mjs");
var _printerMjsDefault = parcelHelpers.interopDefault(_printerMjs);
var _promotionMjs = require("./promotion.mjs");
var _promotionMjsDefault = parcelHelpers.interopDefault(_promotionMjs);
var _questionFilledMjs = require("./question-filled.mjs");
var _questionFilledMjsDefault = parcelHelpers.interopDefault(_questionFilledMjs);
var _rankMjs = require("./rank.mjs");
var _rankMjsDefault = parcelHelpers.interopDefault(_rankMjs);
var _readingLampMjs = require("./reading-lamp.mjs");
var _readingLampMjsDefault = parcelHelpers.interopDefault(_readingLampMjs);
var _readingMjs = require("./reading.mjs");
var _readingMjsDefault = parcelHelpers.interopDefault(_readingMjs);
var _refreshLeftMjs = require("./refresh-left.mjs");
var _refreshLeftMjsDefault = parcelHelpers.interopDefault(_refreshLeftMjs);
var _refreshRightMjs = require("./refresh-right.mjs");
var _refreshRightMjsDefault = parcelHelpers.interopDefault(_refreshRightMjs);
var _refreshMjs = require("./refresh.mjs");
var _refreshMjsDefault = parcelHelpers.interopDefault(_refreshMjs);
var _refrigeratorMjs = require("./refrigerator.mjs");
var _refrigeratorMjsDefault = parcelHelpers.interopDefault(_refrigeratorMjs);
var _removeFilledMjs = require("./remove-filled.mjs");
var _removeFilledMjsDefault = parcelHelpers.interopDefault(_removeFilledMjs);
var _removeMjs = require("./remove.mjs");
var _removeMjsDefault = parcelHelpers.interopDefault(_removeMjs);
var _rightMjs = require("./right.mjs");
var _rightMjsDefault = parcelHelpers.interopDefault(_rightMjs);
var _scaleToOriginalMjs = require("./scale-to-original.mjs");
var _scaleToOriginalMjsDefault = parcelHelpers.interopDefault(_scaleToOriginalMjs);
var _schoolMjs = require("./school.mjs");
var _schoolMjsDefault = parcelHelpers.interopDefault(_schoolMjs);
var _scissorMjs = require("./scissor.mjs");
var _scissorMjsDefault = parcelHelpers.interopDefault(_scissorMjs);
var _searchMjs = require("./search.mjs");
var _searchMjsDefault = parcelHelpers.interopDefault(_searchMjs);
var _selectMjs = require("./select.mjs");
var _selectMjsDefault = parcelHelpers.interopDefault(_selectMjs);
var _sellMjs = require("./sell.mjs");
var _sellMjsDefault = parcelHelpers.interopDefault(_sellMjs);
var _semiSelectMjs = require("./semi-select.mjs");
var _semiSelectMjsDefault = parcelHelpers.interopDefault(_semiSelectMjs);
var _serviceMjs = require("./service.mjs");
var _serviceMjsDefault = parcelHelpers.interopDefault(_serviceMjs);
var _setUpMjs = require("./set-up.mjs");
var _setUpMjsDefault = parcelHelpers.interopDefault(_setUpMjs);
var _settingMjs = require("./setting.mjs");
var _settingMjsDefault = parcelHelpers.interopDefault(_settingMjs);
var _shareMjs = require("./share.mjs");
var _shareMjsDefault = parcelHelpers.interopDefault(_shareMjs);
var _shipMjs = require("./ship.mjs");
var _shipMjsDefault = parcelHelpers.interopDefault(_shipMjs);
var _shopMjs = require("./shop.mjs");
var _shopMjsDefault = parcelHelpers.interopDefault(_shopMjs);
var _shoppingBagMjs = require("./shopping-bag.mjs");
var _shoppingBagMjsDefault = parcelHelpers.interopDefault(_shoppingBagMjs);
var _shoppingCartFullMjs = require("./shopping-cart-full.mjs");
var _shoppingCartFullMjsDefault = parcelHelpers.interopDefault(_shoppingCartFullMjs);
var _shoppingCartMjs = require("./shopping-cart.mjs");
var _shoppingCartMjsDefault = parcelHelpers.interopDefault(_shoppingCartMjs);
var _smokingMjs = require("./smoking.mjs");
var _smokingMjsDefault = parcelHelpers.interopDefault(_smokingMjs);
var _soccerMjs = require("./soccer.mjs");
var _soccerMjsDefault = parcelHelpers.interopDefault(_soccerMjs);
var _soldOutMjs = require("./sold-out.mjs");
var _soldOutMjsDefault = parcelHelpers.interopDefault(_soldOutMjs);
var _sortDownMjs = require("./sort-down.mjs");
var _sortDownMjsDefault = parcelHelpers.interopDefault(_sortDownMjs);
var _sortUpMjs = require("./sort-up.mjs");
var _sortUpMjsDefault = parcelHelpers.interopDefault(_sortUpMjs);
var _sortMjs = require("./sort.mjs");
var _sortMjsDefault = parcelHelpers.interopDefault(_sortMjs);
var _stampMjs = require("./stamp.mjs");
var _stampMjsDefault = parcelHelpers.interopDefault(_stampMjs);
var _starFilledMjs = require("./star-filled.mjs");
var _starFilledMjsDefault = parcelHelpers.interopDefault(_starFilledMjs);
var _starMjs = require("./star.mjs");
var _starMjsDefault = parcelHelpers.interopDefault(_starMjs);
var _stopwatchMjs = require("./stopwatch.mjs");
var _stopwatchMjsDefault = parcelHelpers.interopDefault(_stopwatchMjs);
var _successFilledMjs = require("./success-filled.mjs");
var _successFilledMjsDefault = parcelHelpers.interopDefault(_successFilledMjs);
var _sugarMjs = require("./sugar.mjs");
var _sugarMjsDefault = parcelHelpers.interopDefault(_sugarMjs);
var _suitcaseMjs = require("./suitcase.mjs");
var _suitcaseMjsDefault = parcelHelpers.interopDefault(_suitcaseMjs);
var _sunnyMjs = require("./sunny.mjs");
var _sunnyMjsDefault = parcelHelpers.interopDefault(_sunnyMjs);
var _sunriseMjs = require("./sunrise.mjs");
var _sunriseMjsDefault = parcelHelpers.interopDefault(_sunriseMjs);
var _sunsetMjs = require("./sunset.mjs");
var _sunsetMjsDefault = parcelHelpers.interopDefault(_sunsetMjs);
var _switchButtonMjs = require("./switch-button.mjs");
var _switchButtonMjsDefault = parcelHelpers.interopDefault(_switchButtonMjs);
var _switchMjs = require("./switch.mjs");
var _switchMjsDefault = parcelHelpers.interopDefault(_switchMjs);
var _takeawayBoxMjs = require("./takeaway-box.mjs");
var _takeawayBoxMjsDefault = parcelHelpers.interopDefault(_takeawayBoxMjs);
var _ticketMjs = require("./ticket.mjs");
var _ticketMjsDefault = parcelHelpers.interopDefault(_ticketMjs);
var _ticketsMjs = require("./tickets.mjs");
var _ticketsMjsDefault = parcelHelpers.interopDefault(_ticketsMjs);
var _timerMjs = require("./timer.mjs");
var _timerMjsDefault = parcelHelpers.interopDefault(_timerMjs);
var _toiletPaperMjs = require("./toilet-paper.mjs");
var _toiletPaperMjsDefault = parcelHelpers.interopDefault(_toiletPaperMjs);
var _toolsMjs = require("./tools.mjs");
var _toolsMjsDefault = parcelHelpers.interopDefault(_toolsMjs);
var _topLeftMjs = require("./top-left.mjs");
var _topLeftMjsDefault = parcelHelpers.interopDefault(_topLeftMjs);
var _topRightMjs = require("./top-right.mjs");
var _topRightMjsDefault = parcelHelpers.interopDefault(_topRightMjs);
var _topMjs = require("./top.mjs");
var _topMjsDefault = parcelHelpers.interopDefault(_topMjs);
var _trendChartsMjs = require("./trend-charts.mjs");
var _trendChartsMjsDefault = parcelHelpers.interopDefault(_trendChartsMjs);
var _trophyMjs = require("./trophy.mjs");
var _trophyMjsDefault = parcelHelpers.interopDefault(_trophyMjs);
var _turnOffMjs = require("./turn-off.mjs");
var _turnOffMjsDefault = parcelHelpers.interopDefault(_turnOffMjs);
var _umbrellaMjs = require("./umbrella.mjs");
var _umbrellaMjsDefault = parcelHelpers.interopDefault(_umbrellaMjs);
var _unlockMjs = require("./unlock.mjs");
var _unlockMjsDefault = parcelHelpers.interopDefault(_unlockMjs);
var _uploadFilledMjs = require("./upload-filled.mjs");
var _uploadFilledMjsDefault = parcelHelpers.interopDefault(_uploadFilledMjs);
var _uploadMjs = require("./upload.mjs");
var _uploadMjsDefault = parcelHelpers.interopDefault(_uploadMjs);
var _userFilledMjs = require("./user-filled.mjs");
var _userFilledMjsDefault = parcelHelpers.interopDefault(_userFilledMjs);
var _userMjs = require("./user.mjs");
var _userMjsDefault = parcelHelpers.interopDefault(_userMjs);
var _vanMjs = require("./van.mjs");
var _vanMjsDefault = parcelHelpers.interopDefault(_vanMjs);
var _videoCameraFilledMjs = require("./video-camera-filled.mjs");
var _videoCameraFilledMjsDefault = parcelHelpers.interopDefault(_videoCameraFilledMjs);
var _videoCameraMjs = require("./video-camera.mjs");
var _videoCameraMjsDefault = parcelHelpers.interopDefault(_videoCameraMjs);
var _videoPauseMjs = require("./video-pause.mjs");
var _videoPauseMjsDefault = parcelHelpers.interopDefault(_videoPauseMjs);
var _videoPlayMjs = require("./video-play.mjs");
var _videoPlayMjsDefault = parcelHelpers.interopDefault(_videoPlayMjs);
var _viewMjs = require("./view.mjs");
var _viewMjsDefault = parcelHelpers.interopDefault(_viewMjs);
var _walletFilledMjs = require("./wallet-filled.mjs");
var _walletFilledMjsDefault = parcelHelpers.interopDefault(_walletFilledMjs);
var _walletMjs = require("./wallet.mjs");
var _walletMjsDefault = parcelHelpers.interopDefault(_walletMjs);
var _warningFilledMjs = require("./warning-filled.mjs");
var _warningFilledMjsDefault = parcelHelpers.interopDefault(_warningFilledMjs);
var _warningMjs = require("./warning.mjs");
var _warningMjsDefault = parcelHelpers.interopDefault(_warningMjs);
var _watchMjs = require("./watch.mjs");
var _watchMjsDefault = parcelHelpers.interopDefault(_watchMjs);
var _watermelonMjs = require("./watermelon.mjs");
var _watermelonMjsDefault = parcelHelpers.interopDefault(_watermelonMjs);
var _windPowerMjs = require("./wind-power.mjs");
var _windPowerMjsDefault = parcelHelpers.interopDefault(_windPowerMjs);
var _zoomInMjs = require("./zoom-in.mjs");
var _zoomInMjsDefault = parcelHelpers.interopDefault(_zoomInMjs);
var _zoomOutMjs = require("./zoom-out.mjs");
var _zoomOutMjsDefault = parcelHelpers.interopDefault(_zoomOutMjs);

},{"./add-location.mjs":false,"./aim.mjs":false,"./alarm-clock.mjs":false,"./apple.mjs":false,"./arrow-down-bold.mjs":false,"./arrow-down.mjs":"6n9Gq","./arrow-left-bold.mjs":false,"./arrow-left.mjs":"jMNry","./arrow-right-bold.mjs":false,"./arrow-right.mjs":"lvWBQ","./arrow-up-bold.mjs":false,"./arrow-up.mjs":"cH6IN","./avatar.mjs":false,"./back.mjs":"8pffc","./baseball.mjs":false,"./basketball.mjs":false,"./bell-filled.mjs":false,"./bell.mjs":false,"./bicycle.mjs":false,"./bottom-left.mjs":false,"./bottom-right.mjs":false,"./bottom.mjs":false,"./bowl.mjs":false,"./box.mjs":false,"./briefcase.mjs":false,"./brush-filled.mjs":false,"./brush.mjs":false,"./burger.mjs":false,"./calendar.mjs":"9fi03","./camera-filled.mjs":false,"./camera.mjs":false,"./caret-bottom.mjs":false,"./caret-left.mjs":false,"./caret-right.mjs":"aYBQC","./caret-top.mjs":"euGfp","./cellphone.mjs":false,"./chat-dot-round.mjs":false,"./chat-dot-square.mjs":false,"./chat-line-round.mjs":false,"./chat-line-square.mjs":false,"./chat-round.mjs":false,"./chat-square.mjs":false,"./check.mjs":"7MEag","./checked.mjs":false,"./cherry.mjs":false,"./chicken.mjs":false,"./circle-check-filled.mjs":"dVcSH","./circle-check.mjs":"huUvC","./circle-close-filled.mjs":"37R1w","./circle-close.mjs":"cMdv0","./circle-plus-filled.mjs":false,"./circle-plus.mjs":false,"./clock.mjs":"kDAhq","./close-bold.mjs":false,"./close.mjs":"93UkR","./cloudy.mjs":false,"./coffee-cup.mjs":false,"./coffee.mjs":false,"./coin.mjs":false,"./cold-drink.mjs":false,"./collection-tag.mjs":false,"./collection.mjs":false,"./comment.mjs":false,"./compass.mjs":false,"./connection.mjs":false,"./coordinate.mjs":false,"./copy-document.mjs":false,"./cpu.mjs":false,"./credit-card.mjs":false,"./crop.mjs":false,"./d-arrow-left.mjs":"1zD9D","./d-arrow-right.mjs":"5pVgC","./d-caret.mjs":false,"./data-analysis.mjs":false,"./data-board.mjs":false,"./data-line.mjs":false,"./delete-filled.mjs":false,"./delete-location.mjs":false,"./delete.mjs":"ecSdL","./dessert.mjs":false,"./discount.mjs":false,"./dish-dot.mjs":false,"./dish.mjs":false,"./document-add.mjs":false,"./document-checked.mjs":false,"./document-copy.mjs":false,"./document-delete.mjs":false,"./document-remove.mjs":false,"./document.mjs":"10dXm","./download.mjs":false,"./drizzling.mjs":false,"./edit-pen.mjs":false,"./edit.mjs":false,"./eleme-filled.mjs":false,"./eleme.mjs":false,"./expand.mjs":false,"./failed.mjs":false,"./female.mjs":false,"./files.mjs":false,"./film.mjs":false,"./filter.mjs":false,"./finished.mjs":false,"./first-aid-kit.mjs":false,"./flag.mjs":false,"./fold.mjs":false,"./folder-add.mjs":false,"./folder-checked.mjs":false,"./folder-delete.mjs":false,"./folder-opened.mjs":false,"./folder-remove.mjs":false,"./folder.mjs":false,"./food.mjs":false,"./football.mjs":false,"./fork-spoon.mjs":false,"./fries.mjs":false,"./full-screen.mjs":"bqqII","./goblet-full.mjs":false,"./goblet-square-full.mjs":false,"./goblet-square.mjs":false,"./goblet.mjs":false,"./goods-filled.mjs":false,"./goods.mjs":false,"./grape.mjs":false,"./grid.mjs":false,"./guide.mjs":false,"./headset.mjs":false,"./help-filled.mjs":false,"./help.mjs":false,"./histogram.mjs":false,"./home-filled.mjs":false,"./hot-water.mjs":false,"./house.mjs":false,"./ice-cream-round.mjs":false,"./ice-cream-square.mjs":false,"./ice-cream.mjs":false,"./ice-drink.mjs":false,"./ice-tea.mjs":false,"./info-filled.mjs":"8FOlq","./iphone.mjs":false,"./key.mjs":false,"./knife-fork.mjs":false,"./lightning.mjs":false,"./link.mjs":false,"./list.mjs":false,"./loading.mjs":"5HYNF","./location-filled.mjs":false,"./location-information.mjs":false,"./location.mjs":false,"./lock.mjs":false,"./lollipop.mjs":false,"./magic-stick.mjs":false,"./magnet.mjs":false,"./male.mjs":false,"./management.mjs":false,"./map-location.mjs":false,"./medal.mjs":false,"./menu.mjs":false,"./message-box.mjs":false,"./message.mjs":false,"./mic.mjs":false,"./microphone.mjs":false,"./milk-tea.mjs":false,"./minus.mjs":"cQ4Ms","./money.mjs":false,"./monitor.mjs":false,"./moon-night.mjs":false,"./moon.mjs":false,"./more-filled.mjs":"d3oEe","./more.mjs":"28uzQ","./mostly-cloudy.mjs":false,"./mouse.mjs":false,"./mug.mjs":false,"./mute-notification.mjs":false,"./mute.mjs":false,"./no-smoking.mjs":false,"./notebook.mjs":false,"./notification.mjs":false,"./odometer.mjs":false,"./office-building.mjs":false,"./open.mjs":false,"./operation.mjs":false,"./opportunity.mjs":false,"./orange.mjs":false,"./paperclip.mjs":false,"./partly-cloudy.mjs":false,"./pear.mjs":false,"./phone-filled.mjs":false,"./phone.mjs":false,"./picture-filled.mjs":false,"./picture-rounded.mjs":false,"./picture.mjs":false,"./pie-chart.mjs":false,"./place.mjs":false,"./platform.mjs":false,"./plus.mjs":"91S6i","./pointer.mjs":false,"./position.mjs":false,"./postcard.mjs":false,"./pouring.mjs":false,"./present.mjs":false,"./price-tag.mjs":false,"./printer.mjs":false,"./promotion.mjs":false,"./question-filled.mjs":"kMhFR","./rank.mjs":false,"./reading-lamp.mjs":false,"./reading.mjs":false,"./refresh-left.mjs":"dB8is","./refresh-right.mjs":"iSHvO","./refresh.mjs":false,"./refrigerator.mjs":false,"./remove-filled.mjs":false,"./remove.mjs":false,"./right.mjs":false,"./scale-to-original.mjs":"d38D7","./school.mjs":false,"./scissor.mjs":false,"./search.mjs":"fkL6Y","./select.mjs":false,"./sell.mjs":false,"./semi-select.mjs":false,"./service.mjs":false,"./set-up.mjs":false,"./setting.mjs":false,"./share.mjs":false,"./ship.mjs":false,"./shop.mjs":false,"./shopping-bag.mjs":false,"./shopping-cart-full.mjs":false,"./shopping-cart.mjs":false,"./smoking.mjs":false,"./soccer.mjs":false,"./sold-out.mjs":false,"./sort-down.mjs":false,"./sort-up.mjs":false,"./sort.mjs":false,"./stamp.mjs":false,"./star-filled.mjs":"9uRTI","./star.mjs":"aGrWt","./stopwatch.mjs":false,"./success-filled.mjs":"acZr3","./sugar.mjs":false,"./suitcase.mjs":false,"./sunny.mjs":false,"./sunrise.mjs":false,"./sunset.mjs":false,"./switch-button.mjs":false,"./switch.mjs":false,"./takeaway-box.mjs":false,"./ticket.mjs":false,"./tickets.mjs":false,"./timer.mjs":false,"./toilet-paper.mjs":false,"./tools.mjs":false,"./top-left.mjs":false,"./top-right.mjs":false,"./top.mjs":false,"./trend-charts.mjs":false,"./trophy.mjs":false,"./turn-off.mjs":false,"./umbrella.mjs":false,"./unlock.mjs":false,"./upload-filled.mjs":false,"./upload.mjs":false,"./user-filled.mjs":false,"./user.mjs":false,"./van.mjs":false,"./video-camera-filled.mjs":false,"./video-camera.mjs":false,"./video-pause.mjs":false,"./video-play.mjs":false,"./view.mjs":"jYJvf","./wallet-filled.mjs":false,"./wallet.mjs":false,"./warning-filled.mjs":"46HfV","./warning.mjs":false,"./watch.mjs":false,"./watermelon.mjs":false,"./wind-power.mjs":false,"./zoom-in.mjs":"9vFYG","./zoom-out.mjs":"ekp6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6n9Gq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>arrowDown
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ArrowDown"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M831.872 340.864L512 652.672 192.128 340.864a30.592 30.592 0 00-42.752 0 29.12 29.12 0 000 41.6L489.664 714.24a32 32 0 0044.672 0l340.288-331.712a29.12 29.12 0 000-41.728 30.592 30.592 0 00-42.752 0z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var arrowDown = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cpEwC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_export_sfc
);
var _export_sfc = (sfc, props)=>{
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props)target[key] = val;
    return target;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jMNry":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>arrowLeft
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ArrowLeft"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M609.408 149.376L277.76 489.6a32 32 0 000 44.672l331.648 340.352a29.12 29.12 0 0041.728 0 30.592 30.592 0 000-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 000-42.688 29.12 29.12 0 00-41.728 0z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var arrowLeft = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lvWBQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>arrowRight
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ArrowRight"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M340.864 149.312a30.592 30.592 0 000 42.752L652.736 512 340.864 831.872a30.592 30.592 0 000 42.752 29.12 29.12 0 0041.728 0L714.24 534.336a32 32 0 000-44.672L382.592 149.376a29.12 29.12 0 00-41.728 0z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var arrowRight = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cH6IN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>arrowUp
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ArrowUp"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M488.832 344.32l-339.84 356.672a32 32 0 000 44.16l.384.384a29.44 29.44 0 0042.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0042.688 0l.384-.384a32 32 0 000-44.16L535.168 344.32a32 32 0 00-46.336 0z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var arrowUp = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8pffc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>back
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "Back"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M224 480h640a32 32 0 110 64H224a32 32 0 010-64z"
}, null, -1);
const _hoisted_3 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M237.248 512l265.408 265.344a32 32 0 01-45.312 45.312l-288-288a32 32 0 010-45.312l288-288a32 32 0 1145.312 45.312L237.248 512z"
}, null, -1);
const _hoisted_4 = [
    _hoisted_2,
    _hoisted_3
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_4);
}
var back = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9fi03":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>calendar
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "Calendar"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M128 384v512h768V192H768v32a32 32 0 11-64 0v-32H320v32a32 32 0 01-64 0v-32H128v128h768v64H128zm192-256h384V96a32 32 0 1164 0v32h160a32 32 0 0132 32v768a32 32 0 01-32 32H96a32 32 0 01-32-32V160a32 32 0 0132-32h160V96a32 32 0 0164 0v32zm-32 384h64a32 32 0 010 64h-64a32 32 0 010-64zm0 192h64a32 32 0 110 64h-64a32 32 0 110-64zm192-192h64a32 32 0 010 64h-64a32 32 0 010-64zm0 192h64a32 32 0 110 64h-64a32 32 0 110-64zm192-192h64a32 32 0 110 64h-64a32 32 0 110-64zm0 192h64a32 32 0 110 64h-64a32 32 0 110-64z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var calendar = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aYBQC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>caretRight
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "CaretRight"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M384 192v640l384-320.064z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var caretRight = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"euGfp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>caretTop
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "CaretTop"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 320L192 704h639.936z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var caretTop = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7MEag":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>check
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "Check"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var check = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dVcSH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>circleCheckFilled
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "CircleCheckFilled"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 64a448 448 0 110 896 448 448 0 010-896zm-55.808 536.384l-99.52-99.584a38.4 38.4 0 10-54.336 54.336l126.72 126.72a38.272 38.272 0 0054.336 0l262.4-262.464a38.4 38.4 0 10-54.272-54.336L456.192 600.384z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var circleCheckFilled = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"huUvC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>circleCheck
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "CircleCheck"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_3 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M745.344 361.344a32 32 0 0145.312 45.312l-288 288a32 32 0 01-45.312 0l-160-160a32 32 0 1145.312-45.312L480 626.752l265.344-265.408z"
}, null, -1);
const _hoisted_4 = [
    _hoisted_2,
    _hoisted_3
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_4);
}
var circleCheck = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"37R1w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>circleCloseFilled
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "CircleCloseFilled"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 64a448 448 0 110 896 448 448 0 010-896zm0 393.664L407.936 353.6a38.4 38.4 0 10-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1054.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1054.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 10-54.336-54.336L512 457.664z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var circleCloseFilled = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cMdv0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>circleClose
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "CircleClose"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M466.752 512l-90.496-90.496a32 32 0 0145.248-45.248L512 466.752l90.496-90.496a32 32 0 1145.248 45.248L557.248 512l90.496 90.496a32 32 0 11-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 01-45.248-45.248L466.752 512z"
}, null, -1);
const _hoisted_3 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_4 = [
    _hoisted_2,
    _hoisted_3
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_4);
}
var circleClose = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kDAhq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>clock
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "Clock"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
const _hoisted_3 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M480 256a32 32 0 0132 32v256a32 32 0 01-64 0V288a32 32 0 0132-32z"
}, null, -1);
const _hoisted_4 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_5 = [
    _hoisted_2,
    _hoisted_3,
    _hoisted_4
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_5);
}
var clock = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"93UkR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>close
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "Close"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M764.288 214.592L512 466.88 259.712 214.592a31.936 31.936 0 00-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1045.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0045.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 10-45.12-45.184z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var close = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1zD9D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>dArrowLeft
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "DArrowLeft"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M529.408 149.376a29.12 29.12 0 0141.728 0 30.592 30.592 0 010 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 01-.512 43.264 29.12 29.12 0 01-41.216-.512L197.76 534.272a32 32 0 010-44.672l331.648-340.224zm256 0a29.12 29.12 0 0141.728 0 30.592 30.592 0 010 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 01-.512 43.264 29.12 29.12 0 01-41.216-.512L453.76 534.272a32 32 0 010-44.672l331.648-340.224z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var dArrowLeft = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5pVgC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>dArrowRight
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "DArrowRight"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M452.864 149.312a29.12 29.12 0 0141.728.064L826.24 489.664a32 32 0 010 44.672L494.592 874.624a29.12 29.12 0 01-41.728 0 30.592 30.592 0 010-42.752L764.736 512 452.864 192a30.592 30.592 0 010-42.688zm-256 0a29.12 29.12 0 0141.728.064L570.24 489.664a32 32 0 010 44.672L238.592 874.624a29.12 29.12 0 01-41.728 0 30.592 30.592 0 010-42.752L508.736 512 196.864 192a30.592 30.592 0 010-42.688z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var dArrowRight = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ecSdL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_delete
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "Delete"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M160 256H96a32 32 0 010-64h256V95.936a32 32 0 0132-32h256a32 32 0 0132 32V192h256a32 32 0 110 64h-64v672a32 32 0 01-32 32H192a32 32 0 01-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 01-32-32V416a32 32 0 0164 0v320a32 32 0 01-32 32zm192 0a32 32 0 01-32-32V416a32 32 0 0164 0v320a32 32 0 01-32 32z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var _delete = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"10dXm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>document
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "Document"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 01-32 32H160a32 32 0 01-32-32V96a32 32 0 0132-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var document = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bqqII":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>fullScreen
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "FullScreen"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M160 96.064l192 .192a32 32 0 010 64l-192-.192V352a32 32 0 01-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1164 0v191.936l192-.192a32 32 0 110 64l-192 .192zM864 96.064V96h64v256a32 32 0 11-64 0V160.064l-192 .192a32 32 0 110-64l192-.192zm0 831.872l-192-.192a32 32 0 010-64l192 .192V672a32 32 0 1164 0v256h-64v-.064z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var fullScreen = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8FOlq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>infoFilled
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "InfoFilled"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 64a448 448 0 110 896.064A448 448 0 01512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 01-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 017.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var infoFilled = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5HYNF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>loading
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "Loading"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 64a32 32 0 0132 32v192a32 32 0 01-64 0V96a32 32 0 0132-32zm0 640a32 32 0 0132 32v192a32 32 0 11-64 0V736a32 32 0 0132-32zm448-192a32 32 0 01-32 32H736a32 32 0 110-64h192a32 32 0 0132 32zm-640 0a32 32 0 01-32 32H96a32 32 0 010-64h192a32 32 0 0132 32zM195.2 195.2a32 32 0 0145.248 0L376.32 331.008a32 32 0 01-45.248 45.248L195.2 240.448a32 32 0 010-45.248zm452.544 452.544a32 32 0 0145.248 0L828.8 783.552a32 32 0 01-45.248 45.248L647.744 692.992a32 32 0 010-45.248zM828.8 195.264a32 32 0 010 45.184L692.992 376.32a32 32 0 01-45.248-45.248l135.808-135.808a32 32 0 0145.248 0zm-452.544 452.48a32 32 0 010 45.248L240.448 828.8a32 32 0 01-45.248-45.248l135.808-135.808a32 32 0 0145.248 0z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var loading = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cQ4Ms":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>minus
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "Minus"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M128 544h768a32 32 0 100-64H128a32 32 0 000 64z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var minus = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d3oEe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>moreFilled
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "MoreFilled"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M176 416a112 112 0 110 224 112 112 0 010-224zm336 0a112 112 0 110 224 112 112 0 010-224zm336 0a112 112 0 110 224 112 112 0 010-224z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var moreFilled = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"28uzQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>more
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "More"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M176 416a112 112 0 100 224 112 112 0 000-224m0 64a48 48 0 110 96 48 48 0 010-96zm336-64a112 112 0 110 224 112 112 0 010-224zm0 64a48 48 0 100 96 48 48 0 000-96zm336-64a112 112 0 110 224 112 112 0 010-224zm0 64a48 48 0 100 96 48 48 0 000-96z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var more = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"91S6i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>plus
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "Plus"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M480 480V128a32 32 0 0164 0v352h352a32 32 0 110 64H544v352a32 32 0 11-64 0V544H128a32 32 0 010-64h352z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var plus = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kMhFR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>questionFilled
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "QuestionFilled"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 64a448 448 0 110 896 448 448 0 010-896zm23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 00-38.72 14.784 49.408 49.408 0 00-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 00523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0016.192-38.72 51.968 51.968 0 00-15.488-38.016 55.936 55.936 0 00-39.424-14.784z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var questionFilled = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dB8is":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>refreshLeft
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "RefreshLeft"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M289.088 296.704h92.992a32 32 0 010 64H232.96a32 32 0 01-32-32V179.712a32 32 0 0164 0v50.56a384 384 0 01643.84 282.88 384 384 0 01-383.936 384 384 384 0 01-384-384h64a320 320 0 10640 0 320 320 0 00-555.712-216.448z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var refreshLeft = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iSHvO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>refreshRight
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "RefreshRight"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M784.512 230.272v-50.56a32 32 0 1164 0v149.056a32 32 0 01-32 32H667.52a32 32 0 110-64h92.992A320 320 0 10524.8 833.152a320 320 0 00320-320h64a384 384 0 01-384 384 384 384 0 01-384-384 384 384 0 01643.712-282.88z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var refreshRight = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d38D7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>scaleToOriginal
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ScaleToOriginal"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M813.176 180.706a60.235 60.235 0 0160.236 60.235v481.883a60.235 60.235 0 01-60.236 60.235H210.824a60.235 60.235 0 01-60.236-60.235V240.94a60.235 60.235 0 0160.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0090.353 240.94v481.883a120.47 120.47 0 00120.47 120.47h602.353a120.47 120.47 0 00120.471-120.47V240.94a120.47 120.47 0 00-120.47-120.47zm-120.47 180.705a30.118 30.118 0 00-30.118 30.118v301.177a30.118 30.118 0 0060.236 0V331.294a30.118 30.118 0 00-30.118-30.118zm-361.412 0a30.118 30.118 0 00-30.118 30.118v301.177a30.118 30.118 0 1060.236 0V331.294a30.118 30.118 0 00-30.118-30.118zM512 361.412a30.118 30.118 0 00-30.118 30.117v30.118a30.118 30.118 0 0060.236 0V391.53A30.118 30.118 0 00512 361.412zM512 512a30.118 30.118 0 00-30.118 30.118v30.117a30.118 30.118 0 0060.236 0v-30.117A30.118 30.118 0 00512 512z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var scaleToOriginal = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fkL6Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>search
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "Search"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M795.904 750.72l124.992 124.928a32 32 0 01-45.248 45.248L750.656 795.904a416 416 0 1145.248-45.248zM480 832a352 352 0 100-704 352 352 0 000 704z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var search = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9uRTI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>starFilled
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "StarFilled"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M283.84 867.84L512 747.776l228.16 119.936a6.4 6.4 0 009.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 00-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 00-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 00-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 009.28 6.72z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var starFilled = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aGrWt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>star
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "Star"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 747.84l228.16 119.936a6.4 6.4 0 009.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 00-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 00-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 00-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 009.28 6.72L512 747.84zM313.6 924.48a70.4 70.4 0 01-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 01128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 01126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0139.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 01-102.144 74.24L512 820.096l-198.4 104.32z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var star = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"acZr3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>successFilled
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "SuccessFilled"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 64a448 448 0 110 896 448 448 0 010-896zm-55.808 536.384l-99.52-99.584a38.4 38.4 0 10-54.336 54.336l126.72 126.72a38.272 38.272 0 0054.336 0l262.4-262.464a38.4 38.4 0 10-54.272-54.336L456.192 600.384z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var successFilled = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jYJvf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>view
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "View"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 110 448 224 224 0 010-448zm0 64a160.192 160.192 0 00-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var view = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"46HfV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>warningFilled
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "WarningFilled"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M512 64a448 448 0 110 896 448 448 0 010-896zm0 192a58.432 58.432 0 00-58.24 63.744l23.36 256.384a35.072 35.072 0 0069.76 0l23.296-256.384A58.432 58.432 0 00512 256zm0 512a51.2 51.2 0 100-102.4 51.2 51.2 0 000 102.4z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var warningFilled = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9vFYG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>zoomIn
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ZoomIn"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M795.904 750.72l124.992 124.928a32 32 0 01-45.248 45.248L750.656 795.904a416 416 0 1145.248-45.248zM480 832a352 352 0 100-704 352 352 0 000 704zm-32-384v-96a32 32 0 0164 0v96h96a32 32 0 010 64h-96v96a32 32 0 01-64 0v-96h-96a32 32 0 010-64h96z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var zoomIn = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ekp6M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>zoomOut
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("./_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ZoomOut"
});
const _hoisted_1 = {
    class: "icon",
    width: "200",
    height: "200",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M795.904 750.72l124.992 124.928a32 32 0 01-45.248 45.248L750.656 795.904a416 416 0 1145.248-45.248zM480 832a352 352 0 100-704 352 352 0 000 704zM352 448h256a32 32 0 010 64H352a32 32 0 010-64z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var zoomOut = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./_virtual/plugin-vue_export-helper.mjs":"cpEwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cpwWK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildProp", ()=>buildProp
);
parcelHelpers.export(exports, "buildProps", ()=>buildProps
);
parcelHelpers.export(exports, "definePropType", ()=>definePropType
);
parcelHelpers.export(exports, "propKey", ()=>propKey
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _typesMjs = require("../types.mjs");
var _objectsMjs = require("../objects.mjs");
var _shared = require("@vue/shared");
const wrapperKey = Symbol();
const propKey = "__elPropsReservedKey";
function buildProp(option, key) {
    if (!_shared.isObject(option) || !!option[propKey]) return option;
    const { values , required , default: defaultValue , type , validator  } = option;
    const _validator = values || validator ? (val)=>{
        let valid = false;
        let allowedValues = [];
        if (values) {
            allowedValues = Array.from(values);
            if (_shared.hasOwn(option, "default")) allowedValues.push(defaultValue);
            valid || (valid = allowedValues.includes(val));
        }
        if (validator) valid || (valid = validator(val));
        if (!valid && allowedValues.length > 0) {
            const allowValuesText = [
                ...new Set(allowedValues)
            ].map((value)=>JSON.stringify(value)
            ).join(", ");
            _vue.warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
        }
        return valid;
    } : void 0;
    const prop = {
        type: _shared.isObject(type) && Object.getOwnPropertySymbols(type).includes(wrapperKey) ? type[wrapperKey] : type,
        required: !!required,
        validator: _validator,
        [propKey]: true
    };
    if (_shared.hasOwn(option, "default")) prop.default = defaultValue;
    return prop;
}
const buildProps = (props)=>_lodashUnified.fromPairs(Object.entries(props).map(([key, option])=>[
            key,
            buildProp(option, key)
        ]
    ))
;
const definePropType = (val)=>({
        [wrapperKey]: val
    })
;

},{"vue":"gzxs9","lodash-unified":"4Oj4p","../types.mjs":"4VsDK","../objects.mjs":"1tXXV","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4TMmv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "withInstall", ()=>withInstall
);
parcelHelpers.export(exports, "withInstallFunction", ()=>withInstallFunction
);
parcelHelpers.export(exports, "withNoopInstall", ()=>withNoopInstall
);
var _shared = require("@vue/shared");
const withInstall = (main, extra)=>{
    main.install = (app)=>{
        for (const comp of [
            main,
            ...Object.values(extra != null ? extra : {
            })
        ])app.component(comp.name, comp);
    };
    if (extra) for (const [key, comp1] of Object.entries(extra))main[key] = comp1;
    return main;
};
const withInstallFunction = (fn, name)=>{
    fn.install = (app)=>{
        app.config.globalProperties[name] = fn;
    };
    return fn;
};
const withNoopInstall = (component)=>{
    component.install = _shared.NOOP;
    return component;
};

},{"@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iuyFi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "composeRefs", ()=>composeRefs
);
const composeRefs = (...refs)=>{
    return (el)=>{
        refs.forEach((ref)=>{
            ref.value = el;
        });
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"pODHb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addUnit", ()=>addUnit
);
var _typesMjs = require("../types.mjs");
var _errorMjs = require("../error.mjs");
var _shared = require("@vue/shared");
var _core = require("@vueuse/core");
const SCOPE = "utils/vue/style";
function addUnit(value, defaultUnit = "px") {
    if (!value) return "";
    if (_shared.isString(value)) return value;
    else if (_core.isNumber(value)) return `${value}${defaultUnit}`;
    _errorMjs.debugWarn(SCOPE, "binding value must be a string or number");
}

},{"../types.mjs":"4VsDK","../error.mjs":"2zPBN","@vue/shared":"3SM3y","@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4UnBa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isValidComponentSize", ()=>isValidComponentSize
);
parcelHelpers.export(exports, "isValidDatePickType", ()=>isValidDatePickType
);
var _indexMjs = require("../../constants/index.mjs");
var _sizeMjs = require("../../constants/size.mjs");
var _datePickMjs = require("../../constants/date-pick.mjs");
const isValidComponentSize = (val)=>[
        "",
        ..._sizeMjs.componentSizes
    ].includes(val)
;
const isValidDatePickType = (val)=>[
        ..._datePickMjs.datePickTypes
    ].includes(val)
;

},{"../../constants/index.mjs":"74Fbn","../../constants/size.mjs":"jelXi","../../constants/date-pick.mjs":"kBqQc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"74Fbn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EVENT_CODE", ()=>_ariaMjs.EVENT_CODE
);
parcelHelpers.export(exports, "datePickTypes", ()=>_datePickMjs.datePickTypes
);
parcelHelpers.export(exports, "CHANGE_EVENT", ()=>_eventMjs.CHANGE_EVENT
);
parcelHelpers.export(exports, "INPUT_EVENT", ()=>_eventMjs.INPUT_EVENT
);
parcelHelpers.export(exports, "UPDATE_MODEL_EVENT", ()=>_eventMjs.UPDATE_MODEL_EVENT
);
parcelHelpers.export(exports, "componentSizes", ()=>_sizeMjs.componentSizes
);
var _ariaMjs = require("./aria.mjs");
var _datePickMjs = require("./date-pick.mjs");
var _eventMjs = require("./event.mjs");
var _sizeMjs = require("./size.mjs");

},{"./aria.mjs":"jS6iK","./date-pick.mjs":"kBqQc","./event.mjs":"92xVn","./size.mjs":"jelXi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jS6iK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EVENT_CODE", ()=>EVENT_CODE
);
const EVENT_CODE = {
    tab: "Tab",
    enter: "Enter",
    space: "Space",
    left: "ArrowLeft",
    up: "ArrowUp",
    right: "ArrowRight",
    down: "ArrowDown",
    esc: "Escape",
    delete: "Delete",
    backspace: "Backspace",
    numpadEnter: "NumpadEnter",
    pageUp: "PageUp",
    pageDown: "PageDown",
    home: "Home",
    end: "End"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kBqQc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "datePickTypes", ()=>datePickTypes
);
const datePickTypes = [
    "year",
    "month",
    "date",
    "dates",
    "week",
    "datetime",
    "datetimerange",
    "daterange",
    "monthrange"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"92xVn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CHANGE_EVENT", ()=>CHANGE_EVENT
);
parcelHelpers.export(exports, "INPUT_EVENT", ()=>INPUT_EVENT
);
parcelHelpers.export(exports, "UPDATE_MODEL_EVENT", ()=>UPDATE_MODEL_EVENT
);
const UPDATE_MODEL_EVENT = "update:modelValue";
const CHANGE_EVENT = "change";
const INPUT_EVENT = "input";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jelXi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "componentSizes", ()=>componentSizes
);
const componentSizes = [
    "default",
    "small",
    "large"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ljPKw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PatchFlags", ()=>PatchFlags
);
parcelHelpers.export(exports, "getFirstValidNode", ()=>getFirstValidNode
);
parcelHelpers.export(exports, "getNormalizedProps", ()=>getNormalizedProps
);
parcelHelpers.export(exports, "isComment", ()=>isComment
);
parcelHelpers.export(exports, "isFragment", ()=>isFragment
);
parcelHelpers.export(exports, "isTemplate", ()=>isTemplate
);
parcelHelpers.export(exports, "isText", ()=>isText
);
parcelHelpers.export(exports, "isValidElementNode", ()=>isValidElementNode
);
parcelHelpers.export(exports, "renderBlock", ()=>renderBlock
);
parcelHelpers.export(exports, "renderIf", ()=>renderIf
);
var _vue = require("vue");
var _objectsMjs = require("../objects.mjs");
var _errorMjs = require("../error.mjs");
var _shared = require("@vue/shared");
const SCOPE = "utils/vue/vnode";
var PatchFlags = /* @__PURE__ */ ((PatchFlags2)=>{
    PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
    PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
    PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
    PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
    PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
    PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
    PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
    PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
    PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
    PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
    PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
    PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
    PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
    return PatchFlags2;
})(PatchFlags || {
});
function isFragment(node) {
    return _vue.isVNode(node) && node.type === _vue.Fragment;
}
function isText(node) {
    return _vue.isVNode(node) && node.type === _vue.Text;
}
function isComment(node) {
    return _vue.isVNode(node) && node.type === _vue.Comment;
}
const TEMPLATE = "template";
function isTemplate(node) {
    return _vue.isVNode(node) && node.type === TEMPLATE;
}
function isValidElementNode(node) {
    return _vue.isVNode(node) && !isFragment(node) && !isComment(node);
}
function getChildren(node, depth) {
    if (isComment(node)) return;
    if (isFragment(node) || isTemplate(node)) return depth > 0 ? getFirstValidNode(node.children, depth - 1) : void 0;
    return node;
}
const getFirstValidNode = (nodes, maxDepth = 3)=>{
    if (Array.isArray(nodes)) return getChildren(nodes[0], maxDepth);
    else return getChildren(nodes, maxDepth);
};
function renderIf(condition, ...args) {
    return condition ? renderBlock(...args) : _vue.createCommentVNode("v-if", true);
}
function renderBlock(...args) {
    return _vue.openBlock(), _vue.createBlock(...args);
}
const getNormalizedProps = (node)=>{
    if (!_vue.isVNode(node)) {
        _errorMjs.debugWarn(SCOPE, "[getNormalizedProps] must be a VNode");
        return {
        };
    }
    const raw = node.props || {
    };
    const type = (_vue.isVNode(node.type) ? node.type.props : void 0) || {
    };
    const props = {
    };
    Object.keys(type).forEach((key)=>{
        if (_shared.hasOwn(type[key], "default")) props[key] = type[key].default;
    });
    Object.keys(raw).forEach((key)=>{
        props[_vue.camelize(key)] = raw[key];
    });
    return props;
};

},{"vue":"gzxs9","../objects.mjs":"1tXXV","../error.mjs":"2zPBN","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kaKZY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cubic", ()=>cubic
);
parcelHelpers.export(exports, "easeInOutCubic", ()=>easeInOutCubic
);
const cubic = (value)=>Math.pow(value, 3)
;
const easeInOutCubic = (value)=>value < 0.5 ? cubic(value * 2) / 2 : 1 - cubic((1 - value) * 2) / 2
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e9h0v":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "castArray", ()=>castArray
);
parcelHelpers.export(exports, "unique", ()=>unique
);
const unique = (arr)=>[
        ...new Set(arr)
    ]
;
const castArray = (arr)=>{
    if (!arr && arr !== 0) return [];
    return Array.isArray(arr) ? arr : [
        arr
    ];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9TDf1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isFirefox", ()=>isFirefox
);
var _core = require("@vueuse/core");
const isFirefox = ()=>_core.isClient && /firefox/i.test(window.navigator.userAgent)
;

},{"@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5xQne":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isKorean", ()=>isKorean
);
const isKorean = (text)=>/([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi.test(text)
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"apnDl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cAF", ()=>cAF
);
parcelHelpers.export(exports, "rAF", ()=>rAF
);
var _core = require("@vueuse/core");
const rAF = (fn)=>_core.isClient ? window.requestAnimationFrame(fn) : setTimeout(fn, 16)
;
const cAF = (handle)=>_core.isClient ? window.cancelAnimationFrame(handle) : clearTimeout(handle)
;

},{"@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6d823":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "generateId", ()=>generateId
);
parcelHelpers.export(exports, "getRandomInt", ()=>getRandomInt
);
const generateId = ()=>Math.floor(Math.random() * 10000)
;
const getRandomInt = (max)=>Math.floor(Math.random() * Math.floor(max))
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bRl53":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mutable", ()=>mutable
);
const mutable = (val)=>val
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"05czU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useDisabled", ()=>useDisabled
);
parcelHelpers.export(exports, "useSize", ()=>useSize
);
parcelHelpers.export(exports, "useSizeProp", ()=>useSizeProp
);
var _vue = require("vue");
var _indexMjs = require("../../tokens/index.mjs");
var _indexMjs1 = require("../../utils/index.mjs");
var _indexMjs2 = require("../../constants/index.mjs");
var _indexMjs3 = require("../use-prop/index.mjs");
var _indexMjs4 = require("../use-global-config/index.mjs");
var _propsMjs = require("../../utils/vue/props.mjs");
var _sizeMjs = require("../../constants/size.mjs");
var _formMjs = require("../../tokens/form.mjs");
const useSizeProp = _propsMjs.buildProp({
    type: String,
    values: _sizeMjs.componentSizes,
    required: false
});
const useSize = (fallback, ignore = {
})=>{
    const emptyRef = _vue.ref(void 0);
    const size = ignore.prop ? emptyRef : _indexMjs3.useProp("size");
    const globalConfig = ignore.global ? emptyRef : _indexMjs4.useGlobalConfig("size");
    const form = ignore.form ? {
        size: void 0
    } : _vue.inject(_formMjs.elFormKey, void 0);
    const formItem = ignore.formItem ? {
        size: void 0
    } : _vue.inject(_formMjs.elFormItemKey, void 0);
    return _vue.computed(()=>size.value || _vue.unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig.value || "default"
    );
};
const useDisabled = (fallback)=>{
    const disabled = _indexMjs3.useProp("disabled");
    const form = _vue.inject(_formMjs.elFormKey, void 0);
    return _vue.computed(()=>disabled.value || _vue.unref(fallback) || (form == null ? void 0 : form.disabled) || false
    );
};

},{"vue":"gzxs9","../../tokens/index.mjs":"wVNQi","../../utils/index.mjs":"dsdeP","../../constants/index.mjs":"74Fbn","../use-prop/index.mjs":"2C7KS","../use-global-config/index.mjs":"jLlCF","../../utils/vue/props.mjs":"cpwWK","../../constants/size.mjs":"jelXi","../../tokens/form.mjs":"2r4O0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"wVNQi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "elFormItemKey", ()=>_formMjs.elFormItemKey
);
parcelHelpers.export(exports, "elFormKey", ()=>_formMjs.elFormKey
);
parcelHelpers.export(exports, "buttonGroupContextKey", ()=>_buttonMjs.buttonGroupContextKey
);
parcelHelpers.export(exports, "elBreadcrumbKey", ()=>_breadcrumbMjs.elBreadcrumbKey
);
parcelHelpers.export(exports, "elPaginationKey", ()=>_paginationMjs.elPaginationKey
);
parcelHelpers.export(exports, "configProviderContextKey", ()=>_configProviderMjs.configProviderContextKey
);
parcelHelpers.export(exports, "radioGroupKey", ()=>_radioMjs.radioGroupKey
);
parcelHelpers.export(exports, "tabsRootContextKey", ()=>_tabsMjs.tabsRootContextKey
);
parcelHelpers.export(exports, "scrollbarContextKey", ()=>_scrollbarMjs.scrollbarContextKey
);
var _formMjs = require("./form.mjs");
var _buttonMjs = require("./button.mjs");
var _breadcrumbMjs = require("./breadcrumb.mjs");
var _paginationMjs = require("./pagination.mjs");
var _configProviderMjs = require("./config-provider.mjs");
var _radioMjs = require("./radio.mjs");
var _tabsMjs = require("./tabs.mjs");
var _scrollbarMjs = require("./scrollbar.mjs");

},{"./form.mjs":"2r4O0","./button.mjs":"guqr8","./breadcrumb.mjs":"5AKMw","./pagination.mjs":"9NXrn","./config-provider.mjs":"ko1P7","./radio.mjs":"3tXVv","./tabs.mjs":"kNnQs","./scrollbar.mjs":"1zNPP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2r4O0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "elFormItemKey", ()=>elFormItemKey
);
parcelHelpers.export(exports, "elFormKey", ()=>elFormKey
);
const elFormKey = Symbol("elForm");
const elFormItemKey = Symbol("elFormItem");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"guqr8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buttonGroupContextKey", ()=>buttonGroupContextKey
);
const buttonGroupContextKey = Symbol("buttonGroupContextKey");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5AKMw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "elBreadcrumbKey", ()=>elBreadcrumbKey
);
const elBreadcrumbKey = Symbol("elBreadcrumbKey");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9NXrn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "elPaginationKey", ()=>elPaginationKey
);
const elPaginationKey = Symbol("elPaginationKey");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ko1P7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "configProviderContextKey", ()=>configProviderContextKey
);
const configProviderContextKey = Symbol();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3tXVv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "radioGroupKey", ()=>radioGroupKey
);
const radioGroupKey = Symbol("radioGroupKey");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kNnQs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tabsRootContextKey", ()=>tabsRootContextKey
);
const tabsRootContextKey = Symbol("tabsRootContextKey");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1zNPP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scrollbarContextKey", ()=>scrollbarContextKey
);
const scrollbarContextKey = Symbol("scrollbarContextKey");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2C7KS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useProp", ()=>useProp
);
var _vue = require("vue");
const useProp = (name)=>{
    const vm = _vue.getCurrentInstance();
    return _vue.computed(()=>{
        var _a, _b;
        return (_b = (_a = vm.proxy) == null ? void 0 : _a.$props[name]) != null ? _b : void 0;
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jLlCF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "provideGlobalConfig", ()=>provideGlobalConfig
);
parcelHelpers.export(exports, "useGlobalConfig", ()=>useGlobalConfig
);
var _vue = require("vue");
var _indexMjs = require("../../tokens/index.mjs");
var _indexMjs1 = require("../../utils/index.mjs");
var _configProviderMjs = require("../../tokens/config-provider.mjs");
var _errorMjs = require("../../utils/error.mjs");
var _objectsMjs = require("../../utils/objects.mjs");
const globalConfig = _vue.ref();
function useGlobalConfig(key, defaultValue) {
    const config = _vue.getCurrentInstance() ? _vue.inject(_configProviderMjs.configProviderContextKey, globalConfig) : globalConfig;
    if (key) return _vue.computed(()=>{
        var _a, _b;
        return (_b = (_a = config.value) == null ? void 0 : _a[key]) != null ? _b : defaultValue;
    });
    else return config;
}
const provideGlobalConfig = (config, app, global = false)=>{
    var _a;
    const inSetup = !!_vue.getCurrentInstance();
    const oldConfig = inSetup ? useGlobalConfig() : void 0;
    const provideFn = (_a = app == null ? void 0 : app.provide) != null ? _a : inSetup ? _vue.provide : void 0;
    if (!provideFn) {
        _errorMjs.debugWarn("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
        return;
    }
    const context = _vue.computed(()=>{
        const cfg = _vue.unref(config);
        if (!(oldConfig == null ? void 0 : oldConfig.value)) return cfg;
        return mergeConfig(oldConfig.value, cfg);
    });
    provideFn(_configProviderMjs.configProviderContextKey, context);
    if (global || !globalConfig.value) globalConfig.value = context.value;
    return context;
};
const mergeConfig = (a, b)=>{
    var _a;
    const keys = [
        .../* @__PURE__ */ new Set([
            ..._objectsMjs.keysOf(a),
            ..._objectsMjs.keysOf(b)
        ])
    ];
    const obj = {
    };
    for (const key of keys)obj[key] = (_a = b[key]) != null ? _a : a[key];
    return obj;
};

},{"vue":"gzxs9","../../tokens/index.mjs":"wVNQi","../../utils/index.mjs":"dsdeP","../../tokens/config-provider.mjs":"ko1P7","../../utils/error.mjs":"2zPBN","../../utils/objects.mjs":"1tXXV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4fitg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useDeprecated", ()=>useDeprecated
);
var _vue = require("vue");
var _indexMjs = require("../../utils/index.mjs");
var _errorMjs = require("../../utils/error.mjs");
const useDeprecated = ({ from , replacement , scope , version , ref  }, condition)=>{
    _vue.watch(()=>_vue.unref(condition)
    , (val)=>{
        if (val) _errorMjs.debugWarn(scope, `API ${from} is about to be deprecated in version ${version}, please use ${replacement} instead.
For more detail, please visit: ${ref}
`);
    }, {
        immediate: true
    });
};

},{"vue":"gzxs9","../../utils/index.mjs":"dsdeP","../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3SWUw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useDraggable", ()=>useDraggable
);
var _vue = require("vue");
var _indexMjs = require("../../utils/index.mjs");
var _styleMjs = require("../../utils/vue/style.mjs");
const useDraggable = (targetRef, dragRef, draggable)=>{
    let transform = {
        offsetX: 0,
        offsetY: 0
    };
    const onMousedown = (e)=>{
        const downX = e.clientX;
        const downY = e.clientY;
        const { offsetX , offsetY  } = transform;
        const targetRect = targetRef.value.getBoundingClientRect();
        const targetLeft = targetRect.left;
        const targetTop = targetRect.top;
        const targetWidth = targetRect.width;
        const targetHeight = targetRect.height;
        const clientWidth = document.documentElement.clientWidth;
        const clientHeight = document.documentElement.clientHeight;
        const minLeft = -targetLeft + offsetX;
        const minTop = -targetTop + offsetY;
        const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
        const maxTop = clientHeight - targetTop - targetHeight + offsetY;
        const onMousemove = (e2)=>{
            const moveX = Math.min(Math.max(offsetX + e2.clientX - downX, minLeft), maxLeft);
            const moveY = Math.min(Math.max(offsetY + e2.clientY - downY, minTop), maxTop);
            transform = {
                offsetX: moveX,
                offsetY: moveY
            };
            targetRef.value.style.transform = `translate(${_styleMjs.addUnit(moveX)}, ${_styleMjs.addUnit(moveY)})`;
        };
        const onMouseup = ()=>{
            document.removeEventListener("mousemove", onMousemove);
            document.removeEventListener("mouseup", onMouseup);
        };
        document.addEventListener("mousemove", onMousemove);
        document.addEventListener("mouseup", onMouseup);
    };
    const onDraggable = ()=>{
        if (dragRef.value && targetRef.value) dragRef.value.addEventListener("mousedown", onMousedown);
    };
    const offDraggable = ()=>{
        if (dragRef.value && targetRef.value) dragRef.value.removeEventListener("mousedown", onMousedown);
    };
    _vue.onMounted(()=>{
        _vue.watchEffect(()=>{
            if (draggable.value) onDraggable();
            else offDraggable();
        });
    });
    _vue.onBeforeUnmount(()=>{
        offDraggable();
    });
};

},{"vue":"gzxs9","../../utils/index.mjs":"dsdeP","../../utils/vue/style.mjs":"pODHb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8V0bg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useFocus", ()=>useFocus
);
const useFocus = (el)=>{
    return {
        focus: ()=>{
            var _a, _b;
            (_b = (_a = el.value) == null ? void 0 : _a.focus) == null || _b.call(_a);
        }
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jSs21":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useFormItem", ()=>useFormItem
);
var _vue = require("vue");
var _indexMjs = require("../../tokens/index.mjs");
var _formMjs = require("../../tokens/form.mjs");
const useFormItem = ()=>{
    const form = _vue.inject(_formMjs.elFormKey, void 0);
    const formItem = _vue.inject(_formMjs.elFormItemKey, void 0);
    return {
        form,
        formItem
    };
};

},{"vue":"gzxs9","../../tokens/index.mjs":"wVNQi","../../tokens/form.mjs":"2r4O0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c1HoA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildLocaleContext", ()=>buildLocaleContext
);
parcelHelpers.export(exports, "buildTranslator", ()=>buildTranslator
);
parcelHelpers.export(exports, "translate", ()=>translate
);
parcelHelpers.export(exports, "useLocale", ()=>useLocale
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _enMjs = require("../../locale/lang/en.mjs");
var _enMjsDefault = parcelHelpers.interopDefault(_enMjs);
var _indexMjs = require("../use-global-config/index.mjs");
const buildTranslator = (locale)=>(path, option)=>translate(path, option, _vue.unref(locale))
;
const translate = (path, option, locale)=>_lodashUnified.get(locale, path, path).replace(/\{(\w+)\}/g, (_, key)=>{
        var _a;
        return `${(_a = option == null ? void 0 : option[key]) != null ? _a : `{${key}}`}`;
    })
;
const buildLocaleContext = (locale)=>{
    const lang = _vue.computed(()=>_vue.unref(locale).name
    );
    const localeRef = _vue.isRef(locale) ? locale : _vue.ref(locale);
    return {
        lang,
        locale: localeRef,
        t: buildTranslator(locale)
    };
};
const useLocale = ()=>{
    const locale = _indexMjs.useGlobalConfig("locale");
    return buildLocaleContext(_vue.computed(()=>locale.value || _enMjsDefault.default
    ));
};

},{"vue":"gzxs9","lodash-unified":"4Oj4p","../../locale/lang/en.mjs":"6JiOn","../use-global-config/index.mjs":"jLlCF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6JiOn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>English
);
var English = {
    name: "en",
    el: {
        colorpicker: {
            confirm: "OK",
            clear: "Clear"
        },
        datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
                sun: "Sun",
                mon: "Mon",
                tue: "Tue",
                wed: "Wed",
                thu: "Thu",
                fri: "Fri",
                sat: "Sat"
            },
            months: {
                jan: "Jan",
                feb: "Feb",
                mar: "Mar",
                apr: "Apr",
                may: "May",
                jun: "Jun",
                jul: "Jul",
                aug: "Aug",
                sep: "Sep",
                oct: "Oct",
                nov: "Nov",
                dec: "Dec"
            }
        },
        select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
        },
        cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
        },
        pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
        },
        messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input"
        },
        upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
        },
        table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
        },
        tree: {
            emptyText: "No Data"
        },
        transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: [
                "List 1",
                "List 2"
            ],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
        },
        image: {
            error: "FAILED"
        },
        pageHeader: {
            title: "Back"
        },
        popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f9Ur8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useLockscreen", ()=>useLockscreen
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../utils/index.mjs");
var _errorMjs = require("../../utils/error.mjs");
var _styleMjs = require("../../utils/dom/style.mjs");
var _scrollMjs = require("../../utils/dom/scroll.mjs");
const useLockscreen = (trigger)=>{
    if (!_vue.isRef(trigger)) _errorMjs.throwError("[useLockscreen]", "You need to pass a ref param to this function");
    if (!_core.isClient || _styleMjs.hasClass(document.body, "el-popup-parent--hidden")) return;
    let scrollBarWidth = 0;
    let withoutHiddenClass = false;
    let bodyPaddingRight = "0";
    let computedBodyPaddingRight = 0;
    const cleanup = ()=>{
        _styleMjs.removeClass(document.body, "el-popup-parent--hidden");
        if (withoutHiddenClass) document.body.style.paddingRight = bodyPaddingRight;
    };
    _vue.watch(trigger, (val)=>{
        if (!val) {
            cleanup();
            return;
        }
        withoutHiddenClass = !_styleMjs.hasClass(document.body, "el-popup-parent--hidden");
        if (withoutHiddenClass) {
            bodyPaddingRight = document.body.style.paddingRight;
            computedBodyPaddingRight = parseInt(_styleMjs.getStyle(document.body, "paddingRight"), 10);
        }
        scrollBarWidth = _scrollMjs.getScrollBarWidth();
        const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
        const bodyOverflowY = _styleMjs.getStyle(document.body, "overflowY");
        if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarWidth}px`;
        _styleMjs.addClass(document.body, "el-popup-parent--hidden");
    });
    _vue.onScopeDispose(()=>cleanup()
    );
};

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../utils/index.mjs":"dsdeP","../../utils/error.mjs":"2zPBN","../../utils/dom/style.mjs":"cA8Mp","../../utils/dom/scroll.mjs":"hpitc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klFTZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useModal", ()=>useModal
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../constants/index.mjs");
var _ariaMjs = require("../../constants/aria.mjs");
const modalStack = [];
const closeModal = (e)=>{
    if (modalStack.length === 0) return;
    if (e.code === _ariaMjs.EVENT_CODE.esc) {
        e.stopPropagation();
        const topModal = modalStack[modalStack.length - 1];
        topModal.handleClose();
    }
};
const useModal = (instance, visibleRef)=>{
    _vue.watch(visibleRef, (val)=>{
        if (val) modalStack.push(instance);
        else modalStack.splice(modalStack.findIndex((modal)=>modal === instance
        ), 1);
    });
};
if (_core.isClient) _core.useEventListener(document, "keydown", closeModal);

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../constants/index.mjs":"74Fbn","../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"97z8S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createModelToggleComposable", ()=>createModelToggleComposable
);
parcelHelpers.export(exports, "useModelToggle", ()=>useModelToggle
);
parcelHelpers.export(exports, "useModelToggleEmits", ()=>useModelToggleEmits
);
parcelHelpers.export(exports, "useModelToggleProps", ()=>useModelToggleProps
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _core = require("@vueuse/core");
var _indexMjs = require("../../utils/index.mjs");
var _propsMjs = require("../../utils/vue/props.mjs");
const createModelToggleComposable = (name)=>{
    const useModelToggleProps2 = {
        [name]: _propsMjs.buildProp({
            type: _propsMjs.definePropType(Boolean),
            default: null
        }),
        [`onUpdate:${name}`]: _propsMjs.buildProp({
            type: _propsMjs.definePropType(Function)
        })
    };
    const useModelToggleEmits2 = [
        `update:${name}`
    ];
    const useModelToggle2 = ({ indicator , shouldHideWhenRouteChanges , shouldProceed , onShow , onHide  })=>{
        const instance = _vue.getCurrentInstance();
        const props = instance.props;
        const { emit  } = instance;
        const updateEventKey = `update:${name}`;
        const hasUpdateHandler = _vue.computed(()=>_shared.isFunction(props[`onUpdate:${name}`])
        );
        const isModelBindingAbsent = _vue.computed(()=>props[name] === null
        );
        const doShow = ()=>{
            if (indicator.value === true) return;
            indicator.value = true;
            if (_shared.isFunction(onShow)) onShow();
        };
        const doHide = ()=>{
            if (indicator.value === false) return;
            indicator.value = false;
            if (_shared.isFunction(onHide)) onHide();
        };
        const show = ()=>{
            if (props.disabled === true || _shared.isFunction(shouldProceed) && !shouldProceed()) return;
            const shouldEmit = hasUpdateHandler.value && _core.isClient;
            if (shouldEmit) emit(updateEventKey, true);
            if (isModelBindingAbsent.value || !shouldEmit) doShow();
        };
        const hide = ()=>{
            if (props.disabled === true || !_core.isClient) return;
            const shouldEmit = hasUpdateHandler.value && _core.isClient;
            if (shouldEmit) emit(updateEventKey, false);
            if (isModelBindingAbsent.value || !shouldEmit) doHide();
        };
        const onChange = (val)=>{
            if (!_core.isBoolean(val)) return;
            if (props.disabled && val) {
                if (hasUpdateHandler.value) emit(updateEventKey, false);
            } else if (indicator.value !== val) {
                if (val) doShow();
                else doHide();
            }
        };
        const toggle = ()=>{
            if (indicator.value) hide();
            else show();
        };
        _vue.watch(()=>props[name]
        , onChange);
        if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) _vue.watch(()=>({
                ...instance.proxy.$route
            })
        , ()=>{
            if (shouldHideWhenRouteChanges.value && indicator.value) hide();
        });
        _vue.onMounted(()=>{
            onChange(props[name]);
        });
        return {
            hide,
            show,
            toggle
        };
    };
    return {
        useModelToggle: useModelToggle2,
        useModelToggleProps: useModelToggleProps2,
        useModelToggleEmits: useModelToggleEmits2
    };
};
const { useModelToggle , useModelToggleProps , useModelToggleEmits  } = createModelToggleComposable("modelValue");

},{"vue":"gzxs9","@vue/shared":"3SM3y","@vueuse/core":"eEHP9","../../utils/index.mjs":"dsdeP","../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Sy0W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "usePreventGlobal", ()=>usePreventGlobal
);
var _vue = require("vue");
var _core = require("@vueuse/core");
const usePreventGlobal = (indicator, evt, cb)=>{
    const prevent = (e)=>{
        if (cb(e)) e.stopImmediatePropagation();
    };
    let stop = void 0;
    _vue.watch(()=>indicator.value
    , (val)=>{
        if (val) stop = _core.useEventListener(document, evt, prevent, true);
        else stop == null || stop();
    }, {
        immediate: true
    });
};

},{"vue":"gzxs9","@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9OlL1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useRestoreActive", ()=>useRestoreActive
);
var _vue = require("vue");
const useRestoreActive = (toggle, initialFocus)=>{
    let previousActive;
    _vue.watch(()=>toggle.value
    , (val)=>{
        var _a, _b;
        if (val) {
            previousActive = document.activeElement;
            if (_vue.isRef(initialFocus)) (_b = (_a = initialFocus.value).focus) == null || _b.call(_a);
        } else previousActive.focus();
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"duu8u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useSameTarget", ()=>useSameTarget
);
var _shared = require("@vue/shared");
const useSameTarget = (handleClick)=>{
    if (!handleClick) return {
        onClick: _shared.NOOP,
        onMousedown: _shared.NOOP,
        onMouseup: _shared.NOOP
    };
    let mousedownTarget = false;
    let mouseupTarget = false;
    const onClick = (e)=>{
        if (mousedownTarget && mouseupTarget) handleClick(e);
        mousedownTarget = mouseupTarget = false;
    };
    const onMousedown = (e)=>{
        mousedownTarget = e.target === e.currentTarget;
    };
    const onMouseup = (e)=>{
        mouseupTarget = e.target === e.currentTarget;
    };
    return {
        onClick,
        onMousedown,
        onMouseup
    };
};

},{"@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fVzv0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useTeleport", ()=>useTeleport
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _core = require("@vueuse/core");
var _indexMjs = require("../../utils/index.mjs");
var _globalNodeMjs = require("../../utils/vue/global-node.mjs");
const useTeleport = (contentRenderer, appendToBody)=>{
    const isTeleportVisible = _vue.ref(false);
    if (!_core.isClient) return {
        isTeleportVisible,
        showTeleport: _shared.NOOP,
        hideTeleport: _shared.NOOP,
        renderTeleport: _shared.NOOP
    };
    let $el = null;
    const showTeleport = ()=>{
        isTeleportVisible.value = true;
        if ($el !== null) return;
        $el = _globalNodeMjs.createGlobalNode();
    };
    const hideTeleport = ()=>{
        isTeleportVisible.value = false;
        if ($el !== null) {
            _globalNodeMjs.removeGlobalNode($el);
            $el = null;
        }
    };
    const renderTeleport = ()=>{
        return appendToBody.value !== true ? contentRenderer() : isTeleportVisible.value ? [
            _vue.h(_vue.Teleport, {
                to: $el
            }, contentRenderer())
        ] : void 0;
    };
    _vue.onUnmounted(hideTeleport);
    return {
        isTeleportVisible,
        showTeleport,
        hideTeleport,
        renderTeleport
    };
};

},{"vue":"gzxs9","@vue/shared":"3SM3y","@vueuse/core":"eEHP9","../../utils/index.mjs":"dsdeP","../../utils/vue/global-node.mjs":"f1gd1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"azm2F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useThrottleRender", ()=>useThrottleRender
);
var _vue = require("vue");
const useThrottleRender = (loading, throttle = 0)=>{
    if (throttle === 0) return loading;
    const throttled = _vue.ref(false);
    let timeoutHandle = 0;
    const dispatchThrottling = ()=>{
        if (timeoutHandle) clearTimeout(timeoutHandle);
        timeoutHandle = window.setTimeout(()=>{
            throttled.value = loading.value;
        }, throttle);
    };
    _vue.onMounted(dispatchThrottling);
    _vue.watch(()=>loading.value
    , (val)=>{
        if (val) dispatchThrottling();
        else throttled.value = val;
    });
    return throttled;
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"61vlm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useTimeout", ()=>useTimeout
);
var _core = require("@vueuse/core");
function useTimeout() {
    let timeoutHandle;
    const registerTimeout = (fn, delay)=>{
        cancelTimeout();
        timeoutHandle = window.setTimeout(fn, delay);
    };
    const cancelTimeout = ()=>window.clearTimeout(timeoutHandle)
    ;
    _core.tryOnScopeDispose(()=>cancelTimeout()
    );
    return {
        registerTimeout,
        cancelTimeout
    };
}

},{"@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fyWbH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useTransitionFallthrough", ()=>useTransitionFallthrough
);
parcelHelpers.export(exports, "useTransitionFallthroughEmits", ()=>useTransitionFallthroughEmits
);
var _vue = require("vue");
const AFTER_APPEAR = "after-appear";
const AFTER_ENTER = "after-enter";
const AFTER_LEAVE = "after-leave";
const APPEAR = "appear";
const APPEAR_CANCELLED = "appear-cancelled";
const BEFORE_ENTER = "before-enter";
const BEFORE_LEAVE = "before-leave";
const ENTER = "enter";
const ENTER_CANCELLED = "enter-cancelled";
const LEAVE = "leave";
const LEAVE_CANCELLED = "leave-cancelled";
const useTransitionFallthroughEmits = [
    AFTER_APPEAR,
    AFTER_ENTER,
    AFTER_LEAVE,
    APPEAR,
    APPEAR_CANCELLED,
    BEFORE_ENTER,
    BEFORE_LEAVE,
    ENTER,
    ENTER_CANCELLED,
    LEAVE,
    LEAVE_CANCELLED
];
const useTransitionFallthrough = ()=>{
    const { emit  } = _vue.getCurrentInstance();
    return {
        onAfterAppear: ()=>{
            emit(AFTER_APPEAR);
        },
        onAfterEnter: ()=>{
            emit(AFTER_ENTER);
        },
        onAfterLeave: ()=>{
            emit(AFTER_LEAVE);
        },
        onAppearCancelled: ()=>{
            emit(APPEAR_CANCELLED);
        },
        onBeforeEnter: ()=>{
            emit(BEFORE_ENTER);
        },
        onBeforeLeave: ()=>{
            emit(BEFORE_LEAVE);
        },
        onEnter: ()=>{
            emit(ENTER);
        },
        onEnterCancelled: ()=>{
            emit(ENTER_CANCELLED);
        },
        onLeave: ()=>{
            emit(LEAVE);
        },
        onLeaveCancelled: ()=>{
            emit(LEAVE_CANCELLED);
        }
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jWUTV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ID_INJECTION_KEY", ()=>ID_INJECTION_KEY
);
parcelHelpers.export(exports, "useId", ()=>useId
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../utils/index.mjs");
var _errorMjs = require("../../utils/error.mjs");
const defaultIdInjection = {
    prefix: Math.floor(Math.random() * 10000),
    current: 0
};
const ID_INJECTION_KEY = Symbol("elIdInjection");
const useId = (deterministicId)=>{
    const idInjection = _vue.inject(ID_INJECTION_KEY, defaultIdInjection);
    if (!_core.isClient && idInjection === defaultIdInjection) _errorMjs.debugWarn("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
    const idRef = _vue.computed(()=>_vue.unref(deterministicId) || `el-id-${idInjection.prefix}-${idInjection.current++}`
    );
    return idRef;
};

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../utils/index.mjs":"dsdeP","../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5NOQk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useEscapeKeydown", ()=>useEscapeKeydown
);
var _vue = require("vue");
var _indexMjs = require("../../utils/index.mjs");
var _indexMjs1 = require("../../constants/index.mjs");
var _ariaMjs = require("../../constants/aria.mjs");
var _eventMjs = require("../../utils/dom/event.mjs");
const useEscapeKeydown = (handler)=>{
    const cachedHandler = (e)=>{
        const event = e;
        if (event.key === _ariaMjs.EVENT_CODE.esc) handler == null || handler(event);
    };
    _vue.onMounted(()=>{
        _eventMjs.on(document, "keydown", cachedHandler);
    });
    _vue.onBeforeUnmount(()=>{
        _eventMjs.off(document, "keydown", cachedHandler);
    });
};

},{"vue":"gzxs9","../../utils/index.mjs":"dsdeP","../../constants/index.mjs":"74Fbn","../../constants/aria.mjs":"jS6iK","../../utils/dom/event.mjs":"fnXSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hz53M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "POPPER_CONTAINER_ID", ()=>POPPER_CONTAINER_ID
);
parcelHelpers.export(exports, "POPPER_CONTAINER_SELECTOR", ()=>POPPER_CONTAINER_SELECTOR
);
parcelHelpers.export(exports, "usePopperContainer", ()=>usePopperContainer
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../utils/index.mjs");
var _randMjs = require("../../utils/rand.mjs");
let cachedContainer;
const POPPER_CONTAINER_ID = `el-popper-container-${_randMjs.generateId()}`;
const POPPER_CONTAINER_SELECTOR = `#${POPPER_CONTAINER_ID}`;
const usePopperContainer = ()=>{
    _vue.onBeforeMount(()=>{
        if (!_core.isClient) return;
        if (!cachedContainer) {
            const container = document.createElement("div");
            container.id = POPPER_CONTAINER_ID;
            document.body.appendChild(container);
            cachedContainer = container;
        }
    });
};

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../utils/index.mjs":"dsdeP","../../utils/rand.mjs":"6d823","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lDx6c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useDelayedRender", ()=>useDelayedRender
);
var _vue = require("vue");
const useDelayedRender = ({ indicator , intermediateIndicator , shouldSetIntermediate =()=>true
 , beforeShow , afterShow , afterHide , beforeHide  })=>{
    _vue.watch(()=>_vue.unref(indicator)
    , (val)=>{
        if (val) {
            beforeShow == null || beforeShow();
            _vue.nextTick(()=>{
                if (!_vue.unref(indicator)) return;
                if (shouldSetIntermediate("show")) intermediateIndicator.value = true;
            });
        } else {
            beforeHide == null || beforeHide();
            _vue.nextTick(()=>{
                if (_vue.unref(indicator)) return;
                if (shouldSetIntermediate("hide")) intermediateIndicator.value = false;
            });
        }
    });
    _vue.watch(()=>intermediateIndicator.value
    , (val)=>{
        if (val) afterShow == null || afterShow();
        else afterHide == null || afterHide();
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jbu1G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useDelayedToggle", ()=>useDelayedToggle
);
parcelHelpers.export(exports, "useDelayedToggleProps", ()=>useDelayedToggleProps
);
var _vue = require("vue");
var _indexMjs = require("../../utils/index.mjs");
var _indexMjs1 = require("../use-timeout/index.mjs");
var _propsMjs = require("../../utils/vue/props.mjs");
const useDelayedToggleProps = _propsMjs.buildProps({
    showAfter: {
        type: Number,
        default: 0
    },
    hideAfter: {
        type: Number,
        default: 200
    }
});
const useDelayedToggle = ({ showAfter , hideAfter , open , close  })=>{
    const { registerTimeout  } = _indexMjs1.useTimeout();
    const onOpen = ()=>{
        registerTimeout(()=>{
            open();
        }, _vue.unref(showAfter));
    };
    const onClose = ()=>{
        registerTimeout(()=>{
            close();
        }, _vue.unref(hideAfter));
    };
    return {
        onOpen,
        onClose
    };
};

},{"vue":"gzxs9","../../utils/index.mjs":"dsdeP","../use-timeout/index.mjs":"61vlm","../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eMx3i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FORWARD_REF_INJECTION_KEY", ()=>FORWARD_REF_INJECTION_KEY
);
parcelHelpers.export(exports, "useForwardRef", ()=>useForwardRef
);
parcelHelpers.export(exports, "useForwardRefDirective", ()=>useForwardRefDirective
);
var _vue = require("vue");
const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
const useForwardRef = (forwardRef)=>{
    const setForwardRef = (el)=>{
        forwardRef.value = el;
    };
    _vue.provide(FORWARD_REF_INJECTION_KEY, {
        setForwardRef
    });
};
const useForwardRefDirective = (setForwardRef)=>{
    return {
        mounted (el) {
            setForwardRef(el);
        },
        updated (el) {
            setForwardRef(el);
        },
        unmounted () {
            setForwardRef(null);
        }
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a1pcf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useNamespace", ()=>useNamespace
);
var _vue = require("vue");
var _indexMjs = require("../use-global-config/index.mjs");
const defaultNamespace = "el";
const statePrefix = "is-";
const _bem = (namespace, block, blockSuffix, element, modifier)=>{
    let cls = `${namespace}-${block}`;
    if (blockSuffix) cls += `-${blockSuffix}`;
    if (element) cls += `__${element}`;
    if (modifier) cls += `--${modifier}`;
    return cls;
};
const useNamespace = (block)=>{
    const globalConfig = _indexMjs.useGlobalConfig("namespace");
    const namespace = _vue.computed(()=>globalConfig.value || defaultNamespace
    );
    const b = (blockSuffix = "")=>_bem(_vue.unref(namespace), block, blockSuffix, "", "")
    ;
    const e = (element)=>element ? _bem(_vue.unref(namespace), block, "", element, "") : ""
    ;
    const m = (modifier)=>modifier ? _bem(_vue.unref(namespace), block, "", "", modifier) : ""
    ;
    const be = (blockSuffix, element)=>blockSuffix && element ? _bem(_vue.unref(namespace), block, blockSuffix, element, "") : ""
    ;
    const em = (element, modifier)=>element && modifier ? _bem(_vue.unref(namespace), block, "", element, modifier) : ""
    ;
    const bm = (blockSuffix, modifier)=>blockSuffix && modifier ? _bem(_vue.unref(namespace), block, blockSuffix, "", modifier) : ""
    ;
    const bem = (blockSuffix, element, modifier)=>blockSuffix && element && modifier ? _bem(_vue.unref(namespace), block, blockSuffix, element, modifier) : ""
    ;
    const is = (name, ...args)=>{
        const state = args.length >= 1 ? args[0] : true;
        return name && state ? `${statePrefix}${name}` : "";
    };
    return {
        namespace,
        b,
        e,
        m,
        be,
        em,
        bm,
        bem,
        is
    };
};

},{"vue":"gzxs9","../use-global-config/index.mjs":"jLlCF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7aKZA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useZIndex", ()=>useZIndex
);
var _vue = require("vue");
var _indexMjs = require("../use-global-config/index.mjs");
const zIndex = _vue.ref(0);
const useZIndex = ()=>{
    const initialZIndex = _indexMjs.useGlobalConfig("zIndex", 2000);
    const currentZIndex = _vue.computed(()=>initialZIndex.value + zIndex.value
    );
    const nextZIndex = ()=>{
        zIndex.value++;
        return currentZIndex.value;
    };
    return {
        initialZIndex,
        currentZIndex,
        nextZIndex
    };
};

},{"vue":"gzxs9","../use-global-config/index.mjs":"jLlCF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3V5nN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version
);
const version = "2.0.2";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eTopt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Components
);
var _indexMjs = require("./components/affix/index.mjs");
var _indexMjs1 = require("./components/alert/index.mjs");
var _indexMjs2 = require("./components/autocomplete/index.mjs");
var _indexMjs3 = require("./components/avatar/index.mjs");
var _indexMjs4 = require("./components/backtop/index.mjs");
var _indexMjs5 = require("./components/badge/index.mjs");
var _indexMjs6 = require("./components/breadcrumb/index.mjs");
var _indexMjs7 = require("./components/button/index.mjs");
var _indexMjs8 = require("./components/calendar/index.mjs");
var _indexMjs9 = require("./components/card/index.mjs");
var _indexMjs10 = require("./components/carousel/index.mjs");
var _indexMjs11 = require("./components/cascader/index.mjs");
var _indexMjs12 = require("./components/cascader-panel/index.mjs");
var _indexMjs13 = require("./components/check-tag/index.mjs");
var _indexMjs14 = require("./components/checkbox/index.mjs");
var _indexMjs15 = require("./components/col/index.mjs");
var _indexMjs16 = require("./components/collapse/index.mjs");
var _indexMjs17 = require("./components/collapse-transition/index.mjs");
var _indexMjs18 = require("./components/color-picker/index.mjs");
var _indexMjs19 = require("./components/config-provider/index.mjs");
var _indexMjs20 = require("./components/container/index.mjs");
var _indexMjs21 = require("./components/date-picker/index.mjs");
var _indexMjs22 = require("./components/descriptions/index.mjs");
var _indexMjs23 = require("./components/dialog/index.mjs");
var _indexMjs24 = require("./components/divider/index.mjs");
var _indexMjs25 = require("./components/drawer/index.mjs");
var _indexMjs26 = require("./components/dropdown/index.mjs");
var _indexMjs27 = require("./components/empty/index.mjs");
var _indexMjs28 = require("./components/form/index.mjs");
var _indexMjs29 = require("./components/icon/index.mjs");
var _indexMjs30 = require("./components/image/index.mjs");
var _indexMjs31 = require("./components/image-viewer/index.mjs");
var _indexMjs32 = require("./components/input/index.mjs");
var _indexMjs33 = require("./components/input-number/index.mjs");
var _indexMjs34 = require("./components/link/index.mjs");
var _indexMjs35 = require("./components/menu/index.mjs");
var _indexMjs36 = require("./components/page-header/index.mjs");
var _indexMjs37 = require("./components/pagination/index.mjs");
var _indexMjs38 = require("./components/popconfirm/index.mjs");
var _indexMjs39 = require("./components/popover/index.mjs");
var _indexMjs40 = require("./components/popper/index.mjs");
var _indexMjs41 = require("./components/progress/index.mjs");
var _indexMjs42 = require("./components/radio/index.mjs");
var _indexMjs43 = require("./components/rate/index.mjs");
var _indexMjs44 = require("./components/result/index.mjs");
var _indexMjs45 = require("./components/row/index.mjs");
var _indexMjs46 = require("./components/scrollbar/index.mjs");
var _indexMjs47 = require("./components/select/index.mjs");
var _indexMjs48 = require("./components/select-v2/index.mjs");
var _indexMjs49 = require("./components/skeleton/index.mjs");
var _indexMjs50 = require("./components/slider/index.mjs");
var _indexMjs51 = require("./components/space/index.mjs");
var _indexMjs52 = require("./components/steps/index.mjs");
var _indexMjs53 = require("./components/switch/index.mjs");
var _indexMjs54 = require("./components/table/index.mjs");
var _indexMjs55 = require("./components/tabs/index.mjs");
var _indexMjs56 = require("./components/tag/index.mjs");
var _indexMjs57 = require("./components/time-picker/index.mjs");
var _indexMjs58 = require("./components/time-select/index.mjs");
var _indexMjs59 = require("./components/timeline/index.mjs");
var _indexMjs60 = require("./components/tooltip/index.mjs");
var _indexMjs61 = require("./components/transfer/index.mjs");
var _indexMjs62 = require("./components/tree/index.mjs");
var _indexMjs63 = require("./components/tree-v2/index.mjs");
var _indexMjs64 = require("./components/upload/index.mjs");
var Components = [
    _indexMjs.ElAffix,
    _indexMjs1.ElAlert,
    _indexMjs2.ElAutocomplete,
    _indexMjs3.ElAvatar,
    _indexMjs4.ElBacktop,
    _indexMjs5.ElBadge,
    _indexMjs6.ElBreadcrumb,
    _indexMjs6.ElBreadcrumbItem,
    _indexMjs7.ElButton,
    _indexMjs7.ElButtonGroup,
    _indexMjs8.ElCalendar,
    _indexMjs9.ElCard,
    _indexMjs10.ElCarousel,
    _indexMjs10.ElCarouselItem,
    _indexMjs11.ElCascader,
    _indexMjs12.ElCascaderPanel,
    _indexMjs13.ElCheckTag,
    _indexMjs14.ElCheckbox,
    _indexMjs14.ElCheckboxButton,
    _indexMjs14.ElCheckboxGroup,
    _indexMjs15.ElCol,
    _indexMjs16.ElCollapse,
    _indexMjs16.ElCollapseItem,
    _indexMjs17.ElCollapseTransition,
    _indexMjs18.ElColorPicker,
    _indexMjs19.ElConfigProvider,
    _indexMjs20.ElContainer,
    _indexMjs20.ElAside,
    _indexMjs20.ElFooter,
    _indexMjs20.ElHeader,
    _indexMjs20.ElMain,
    _indexMjs21.ElDatePicker,
    _indexMjs22.ElDescriptions,
    _indexMjs22.ElDescriptionsItem,
    _indexMjs23.ElDialog,
    _indexMjs24.ElDivider,
    _indexMjs25.ElDrawer,
    _indexMjs26.ElDropdown,
    _indexMjs26.ElDropdownItem,
    _indexMjs26.ElDropdownMenu,
    _indexMjs27.ElEmpty,
    _indexMjs28.ElForm,
    _indexMjs28.ElFormItem,
    _indexMjs29.ElIcon,
    _indexMjs30.ElImage,
    _indexMjs31.ElImageViewer,
    _indexMjs32.ElInput,
    _indexMjs33.ElInputNumber,
    _indexMjs34.ElLink,
    _indexMjs35.ElMenu,
    _indexMjs35.ElMenuItem,
    _indexMjs35.ElMenuItemGroup,
    _indexMjs36.ElPageHeader,
    _indexMjs37.ElPagination,
    _indexMjs38.ElPopconfirm,
    _indexMjs39.ElPopover,
    _indexMjs40.ElPopper,
    _indexMjs41.ElProgress,
    _indexMjs42.ElRadio,
    _indexMjs42.ElRadioButton,
    _indexMjs42.ElRadioGroup,
    _indexMjs43.ElRate,
    _indexMjs44.ElResult,
    _indexMjs45.ElRow,
    _indexMjs46.ElScrollbar,
    _indexMjs47.ElSelect,
    _indexMjs47.ElOption,
    _indexMjs47.ElOptionGroup,
    _indexMjs48.ElSelectV2,
    _indexMjs49.ElSkeleton,
    _indexMjs49.ElSkeletonItem,
    _indexMjs50.ElSlider,
    _indexMjs51.ElSpace,
    _indexMjs52.ElSteps,
    _indexMjs52.ElStep,
    _indexMjs53.ElSwitch,
    _indexMjs54.ElTable,
    _indexMjs54.ElTableColumn,
    _indexMjs55.ElTabs,
    _indexMjs55.ElTabPane,
    _indexMjs56.ElTag,
    _indexMjs57.ElTimePicker,
    _indexMjs58.ElTimeSelect,
    _indexMjs59.ElTimeline,
    _indexMjs59.ElTimelineItem,
    _indexMjs60.ElTooltip,
    _indexMjs61.ElTransfer,
    _indexMjs62.ElTree,
    _indexMjs63.ElTreeV2,
    _indexMjs64.ElUpload
];

},{"./components/affix/index.mjs":"fMcKf","./components/alert/index.mjs":"jX4vK","./components/autocomplete/index.mjs":"lnNbL","./components/avatar/index.mjs":"edhpQ","./components/backtop/index.mjs":"iA9M1","./components/badge/index.mjs":"gvyeW","./components/breadcrumb/index.mjs":"6p9GR","./components/button/index.mjs":"64Ym1","./components/calendar/index.mjs":"iyUgV","./components/card/index.mjs":"ftRFC","./components/carousel/index.mjs":"DjiER","./components/cascader/index.mjs":"hgxNT","./components/cascader-panel/index.mjs":"cvCE6","./components/check-tag/index.mjs":"2yvIi","./components/checkbox/index.mjs":"jMNjD","./components/col/index.mjs":"iutZ4","./components/collapse/index.mjs":"2aUAi","./components/collapse-transition/index.mjs":"kOsra","./components/color-picker/index.mjs":"kWiGH","./components/config-provider/index.mjs":"5LcSW","./components/container/index.mjs":"7nKg2","./components/date-picker/index.mjs":"fdWz7","./components/descriptions/index.mjs":"aXmMH","./components/dialog/index.mjs":"iXu3z","./components/divider/index.mjs":"8bcJq","./components/drawer/index.mjs":"DJoCd","./components/dropdown/index.mjs":"dk8yW","./components/empty/index.mjs":"5bPkj","./components/form/index.mjs":"hQT2m","./components/icon/index.mjs":"hnNTG","./components/image/index.mjs":"hFVHx","./components/image-viewer/index.mjs":"39t5l","./components/input/index.mjs":"18eQI","./components/input-number/index.mjs":"1U2Gu","./components/link/index.mjs":"18DrN","./components/menu/index.mjs":"5wfdz","./components/page-header/index.mjs":"cmyvF","./components/pagination/index.mjs":"ep8iT","./components/popconfirm/index.mjs":"ds8jY","./components/popover/index.mjs":"cnet0","./components/popper/index.mjs":"kIV7g","./components/progress/index.mjs":"9ijV7","./components/radio/index.mjs":"fekfn","./components/rate/index.mjs":"8o4Y1","./components/result/index.mjs":"lHyTs","./components/row/index.mjs":"7Vl2s","./components/scrollbar/index.mjs":"kXLHt","./components/select/index.mjs":"llDRW","./components/select-v2/index.mjs":"lUvDZ","./components/skeleton/index.mjs":"2N5x8","./components/slider/index.mjs":"6YyBo","./components/space/index.mjs":"fdm11","./components/steps/index.mjs":"9fit0","./components/switch/index.mjs":"aErYv","./components/table/index.mjs":"imp1h","./components/tabs/index.mjs":"3MxUG","./components/tag/index.mjs":"96fQG","./components/time-picker/index.mjs":"4TaeO","./components/time-select/index.mjs":"k6X13","./components/timeline/index.mjs":"2CPF0","./components/tooltip/index.mjs":"kiwBC","./components/transfer/index.mjs":"baYrE","./components/tree/index.mjs":"bpXS0","./components/tree-v2/index.mjs":"eqslC","./components/upload/index.mjs":"fvmYn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fMcKf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "affixEmits", ()=>_affixMjs.affixEmits
);
parcelHelpers.export(exports, "affixProps", ()=>_affixMjs.affixProps
);
parcelHelpers.export(exports, "ElAffix", ()=>ElAffix
);
parcelHelpers.export(exports, "default", ()=>ElAffix
);
var _indexMjs = require("../../utils/index.mjs");
var _affix2Mjs = require("./src/affix2.mjs");
var _affix2MjsDefault = parcelHelpers.interopDefault(_affix2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _affixMjs = require("./src/affix.mjs");
const ElAffix = _installMjs.withInstall(_affix2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/affix2.mjs":"bHBrt","../../utils/vue/install.mjs":"4TMmv","./src/affix.mjs":"31RpQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bHBrt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Affix
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _affixMjs = require("./affix.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
var _scrollMjs = require("../../../utils/dom/scroll.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElAffix",
    props: _affixMjs.affixProps,
    emits: _affixMjs.affixEmits,
    setup (props, { emit  }) {
        const ns = _indexMjs2.useNamespace("affix");
        const target = _vue.shallowRef();
        const root = _vue.shallowRef();
        const scrollContainer = _vue.shallowRef();
        const state = _vue.reactive({
            fixed: false,
            height: 0,
            width: 0,
            scrollTop: 0,
            clientHeight: 0,
            transform: 0
        });
        const rootStyle = _vue.computed(()=>{
            return {
                height: state.fixed ? `${state.height}px` : "",
                width: state.fixed ? `${state.width}px` : ""
            };
        });
        const affixStyle = _vue.computed(()=>{
            if (!state.fixed) return;
            const offset = props.offset ? `${props.offset}px` : 0;
            const transform = state.transform ? `translateY(${state.transform}px)` : "";
            return {
                height: `${state.height}px`,
                width: `${state.width}px`,
                top: props.position === "top" ? offset : "",
                bottom: props.position === "bottom" ? offset : "",
                transform,
                zIndex: props.zIndex
            };
        });
        const update = ()=>{
            if (!root.value || !target.value || !scrollContainer.value) return;
            const rootRect = root.value.getBoundingClientRect();
            const targetRect = target.value.getBoundingClientRect();
            state.height = rootRect.height;
            state.width = rootRect.width;
            state.scrollTop = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop || 0;
            state.clientHeight = document.documentElement.clientHeight;
            if (props.position === "top") {
                if (props.target) {
                    const difference = targetRect.bottom - props.offset - state.height;
                    state.fixed = props.offset > rootRect.top && targetRect.bottom > 0;
                    state.transform = difference < 0 ? difference : 0;
                } else state.fixed = props.offset > rootRect.top;
            } else if (props.target) {
                const difference = state.clientHeight - targetRect.top - props.offset - state.height;
                state.fixed = state.clientHeight - props.offset < rootRect.bottom && state.clientHeight > targetRect.top;
                state.transform = difference < 0 ? -difference : 0;
            } else state.fixed = state.clientHeight - props.offset < rootRect.bottom;
        };
        const onScroll = ()=>{
            update();
            emit("scroll", {
                scrollTop: state.scrollTop,
                fixed: state.fixed
            });
        };
        _vue.watch(()=>state.fixed
        , ()=>{
            emit("change", state.fixed);
        });
        _vue.onMounted(()=>{
            var _a;
            if (props.target) {
                target.value = (_a = document.querySelector(props.target)) != null ? _a : void 0;
                if (!target.value) throw new Error(`Target is not existed: ${props.target}`);
            } else target.value = document.documentElement;
            scrollContainer.value = _scrollMjs.getScrollContainer(root.value, true);
        });
        _core.useEventListener(scrollContainer, "scroll", onScroll);
        _core.useResizeObserver(root, ()=>update()
        );
        _core.useResizeObserver(target, ()=>update()
        );
        return {
            ns,
            root,
            state,
            rootStyle,
            affixStyle,
            update
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "root",
        class: _vue.normalizeClass(_ctx.ns.b()),
        style: _vue.normalizeStyle(_ctx.rootStyle)
    }, [
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass({
                [_ctx.ns.m("fixed")]: _ctx.state.fixed
            }),
            style: _vue.normalizeStyle(_ctx.affixStyle)
        }, [
            _vue.renderSlot(_ctx.$slots, "default")
        ], 6)
    ], 6);
}
var Affix = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./affix.mjs":"31RpQ","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/dom/scroll.mjs":"hpitc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"31RpQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "affixEmits", ()=>affixEmits
);
parcelHelpers.export(exports, "affixProps", ()=>affixProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const affixProps = _propsMjs.buildProps({
    zIndex: {
        type: _propsMjs.definePropType([
            Number,
            String
        ]),
        default: 100
    },
    target: {
        type: String,
        default: ""
    },
    offset: {
        type: Number,
        default: 0
    },
    position: {
        type: String,
        values: [
            "top",
            "bottom"
        ],
        default: "top"
    }
});
const affixEmits = {
    scroll: ({ scrollTop , fixed  })=>typeof scrollTop === "number" && typeof fixed === "boolean"
    ,
    change: (fixed)=>typeof fixed === "boolean"
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"acxEY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_export_sfc
);
var _export_sfc = (sfc, props)=>{
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props)target[key] = val;
    return target;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jX4vK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "alertEffects", ()=>_alertMjs.alertEffects
);
parcelHelpers.export(exports, "alertEmits", ()=>_alertMjs.alertEmits
);
parcelHelpers.export(exports, "alertProps", ()=>_alertMjs.alertProps
);
parcelHelpers.export(exports, "ElAlert", ()=>ElAlert
);
parcelHelpers.export(exports, "default", ()=>ElAlert
);
var _indexMjs = require("../../utils/index.mjs");
var _alert2Mjs = require("./src/alert2.mjs");
var _alert2MjsDefault = parcelHelpers.interopDefault(_alert2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _alertMjs = require("./src/alert.mjs");
const ElAlert = _installMjs.withInstall(_alert2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/alert2.mjs":"gm4qs","../../utils/vue/install.mjs":"4TMmv","./src/alert.mjs":"bmmdq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gm4qs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Alert
);
var _vue = require("vue");
var _indexMjs = require("../../icon/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _alertMjs = require("./alert.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElAlert",
    components: {
        ElIcon: _indexMjs.ElIcon,
        ..._iconMjs.TypeComponents
    },
    props: _alertMjs.alertProps,
    emits: _alertMjs.alertEmits,
    setup (props, { emit , slots  }) {
        const ns = _indexMjs3.useNamespace("alert");
        const visible = _vue.ref(true);
        const iconComponent = _vue.computed(()=>_iconMjs.TypeComponentsMap[props.type] || _iconMjs.TypeComponentsMap["info"]
        );
        const isBigIcon = _vue.computed(()=>props.description || slots.default ? ns.is("big") : ""
        );
        const isBoldTitle = _vue.computed(()=>props.description || slots.default ? ns.is("bold") : ""
        );
        const close = (evt)=>{
            visible.value = false;
            emit("close", evt);
        };
        return {
            ns,
            visible,
            iconComponent,
            isBigIcon,
            isBoldTitle,
            close
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_close = _vue.resolveComponent("close");
    return _vue.openBlock(), _vue.createBlock(_vue.Transition, {
        name: _ctx.ns.b("fade")
    }, {
        default: _vue.withCtx(()=>[
                _vue.withDirectives(_vue.createElementVNode("div", {
                    class: _vue.normalizeClass([
                        _ctx.ns.b(),
                        _ctx.ns.m(_ctx.type),
                        _ctx.ns.is("center", _ctx.center),
                        _ctx.ns.is(_ctx.effect)
                    ]),
                    role: "alert"
                }, [
                    _ctx.showIcon && _ctx.iconComponent ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 0,
                        class: _vue.normalizeClass([
                            _ctx.ns.e("icon"),
                            _ctx.isBigIcon
                        ])
                    }, {
                        default: _vue.withCtx(()=>[
                                (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.iconComponent)))
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "class"
                    ])) : _vue.createCommentVNode("v-if", true),
                    _vue.createElementVNode("div", {
                        class: _vue.normalizeClass(_ctx.ns.e("content"))
                    }, [
                        _ctx.title || _ctx.$slots.title ? (_vue.openBlock(), _vue.createElementBlock("span", {
                            key: 0,
                            class: _vue.normalizeClass([
                                _ctx.ns.e("title"),
                                _ctx.isBoldTitle
                            ])
                        }, [
                            _vue.renderSlot(_ctx.$slots, "title", {
                            }, ()=>[
                                    _vue.createTextVNode(_vue.toDisplayString(_ctx.title), 1)
                                ]
                            )
                        ], 2)) : _vue.createCommentVNode("v-if", true),
                        _ctx.$slots.default || _ctx.description ? (_vue.openBlock(), _vue.createElementBlock("p", {
                            key: 1,
                            class: _vue.normalizeClass(_ctx.ns.e("description"))
                        }, [
                            _vue.renderSlot(_ctx.$slots, "default", {
                            }, ()=>[
                                    _vue.createTextVNode(_vue.toDisplayString(_ctx.description), 1)
                                ]
                            )
                        ], 2)) : _vue.createCommentVNode("v-if", true),
                        _ctx.closable ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                            key: 2
                        }, [
                            _ctx.closeText ? (_vue.openBlock(), _vue.createElementBlock("div", {
                                key: 0,
                                class: _vue.normalizeClass([
                                    _ctx.ns.e("close-btn"),
                                    _ctx.ns.is("customed")
                                ]),
                                onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.close && _ctx.close(...args)
                                )
                            }, _vue.toDisplayString(_ctx.closeText), 3)) : (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                key: 1,
                                class: _vue.normalizeClass(_ctx.ns.e("close-btn")),
                                onClick: _ctx.close
                            }, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_close)
                                    ]
                                ),
                                _: 1
                            }, 8, [
                                "class",
                                "onClick"
                            ]))
                        ], 2112)) : _vue.createCommentVNode("v-if", true)
                    ], 2)
                ], 2), [
                    [
                        _vue.vShow,
                        _ctx.visible
                    ]
                ])
            ]
        ),
        _: 3
    }, 8, [
        "name"
    ]);
}
var Alert = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../icon/index.mjs":"hnNTG","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./alert.mjs":"bmmdq","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/vue/icon.mjs":"3YbE5","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hnNTG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "iconProps", ()=>_iconMjs.iconProps
);
parcelHelpers.export(exports, "ElIcon", ()=>ElIcon
);
parcelHelpers.export(exports, "default", ()=>ElIcon
);
var _indexMjs = require("../../utils/index.mjs");
var _icon2Mjs = require("./src/icon2.mjs");
var _icon2MjsDefault = parcelHelpers.interopDefault(_icon2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _iconMjs = require("./src/icon.mjs");
const ElIcon = _installMjs.withInstall(_icon2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/icon2.mjs":"lMCeJ","../../utils/vue/install.mjs":"4TMmv","./src/icon.mjs":"buNkD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lMCeJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_sfc_main
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _iconMjs = require("./icon.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
var _typesMjs = require("../../../utils/types.mjs");
var _styleMjs = require("../../../utils/vue/style.mjs");
const __default__ = {
    name: "ElIcon",
    inheritAttrs: false
};
const _sfc_main = /* @__PURE__ */ _vue.defineComponent({
    ...__default__,
    props: _iconMjs.iconProps,
    setup (__props) {
        const props = __props;
        const ns = _indexMjs2.useNamespace("icon");
        const style = _vue.computed(()=>{
            if (!props.size && !props.color) return {
            };
            return {
                fontSize: _typesMjs.isUndefined(props.size) ? void 0 : _styleMjs.addUnit(props.size),
                "--color": props.color
            };
        });
        return (_ctx, _cache)=>{
            return _vue.openBlock(), _vue.createElementBlock("i", _vue.mergeProps({
                class: _vue.unref(ns).b(),
                style: _vue.unref(style)
            }, _ctx.$attrs), [
                _vue.renderSlot(_ctx.$slots, "default")
            ], 16);
        };
    }
});

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./icon.mjs":"buNkD","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/types.mjs":"4VsDK","../../../utils/vue/style.mjs":"pODHb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"buNkD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "iconProps", ()=>iconProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const iconProps = _propsMjs.buildProps({
    size: {
        type: _propsMjs.definePropType([
            Number,
            String
        ])
    },
    color: {
        type: String
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bmmdq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "alertEffects", ()=>alertEffects
);
parcelHelpers.export(exports, "alertEmits", ()=>alertEmits
);
parcelHelpers.export(exports, "alertProps", ()=>alertProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _objectsMjs = require("../../../utils/objects.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
const alertEffects = [
    "light",
    "dark"
];
const alertProps = _propsMjs.buildProps({
    title: {
        type: String,
        default: ""
    },
    description: {
        type: String,
        default: ""
    },
    type: {
        type: String,
        values: _objectsMjs.keysOf(_iconMjs.TypeComponentsMap),
        default: "info"
    },
    closable: {
        type: Boolean,
        default: true
    },
    closeText: {
        type: String,
        default: ""
    },
    showIcon: Boolean,
    center: Boolean,
    effect: {
        type: String,
        values: alertEffects,
        default: "light"
    }
});
const alertEmits = {
    close: (evt)=>evt instanceof MouseEvent
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","../../../utils/objects.mjs":"1tXXV","../../../utils/vue/icon.mjs":"3YbE5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lnNbL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElAutocomplete", ()=>ElAutocomplete
);
parcelHelpers.export(exports, "default", ()=>_Autocomplete
);
var _indexMjs = require("./src/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
_indexMjsDefault.default.install = (app)=>{
    app.component(_indexMjsDefault.default.name, _indexMjsDefault.default);
};
const _Autocomplete = _indexMjsDefault.default;
const ElAutocomplete = _Autocomplete;

},{"./src/index.mjs":"dJHED","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dJHED":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Autocomplete
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../../directives/index.mjs");
var _indexMjs2 = require("../../../utils/index.mjs");
var _indexMjs3 = require("../../../constants/index.mjs");
var _indexMjs4 = require("../../input/index.mjs");
var _indexMjs5 = require("../../scrollbar/index.mjs");
var _indexMjs6 = require("../../tooltip/index.mjs");
var _indexMjs7 = require("../../popper/index.mjs");
var _indexMjs8 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs9 = require("../../../directives/click-outside/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs9);
var _tooltipMjs = require("../../tooltip/src/tooltip.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs10 = require("../../../hooks/use-namespace/index.mjs");
var _deprecationMjs = require("../../popper/src/deprecation.mjs");
var _indexMjs11 = require("../../../hooks/use-attrs/index.mjs");
var _randMjs = require("../../../utils/rand.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const COMPONENT_NAME = "ElAutocomplete";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    components: {
        ElTooltip: _indexMjs6.ElTooltip,
        ElInput: _indexMjs4.ElInput,
        ElScrollbar: _indexMjs5.ElScrollbar,
        ElIcon: _indexMjs8.ElIcon,
        Loading: _iconsVue.Loading
    },
    directives: {
        clickoutside: _indexMjsDefault.default
    },
    inheritAttrs: false,
    props: {
        valueKey: {
            type: String,
            default: "value"
        },
        modelValue: {
            type: [
                String,
                Number
            ],
            default: ""
        },
        debounce: {
            type: Number,
            default: 300
        },
        placement: {
            type: String,
            validator: (val)=>{
                return [
                    "top",
                    "top-start",
                    "top-end",
                    "bottom",
                    "bottom-start",
                    "bottom-end"
                ].includes(val);
            },
            default: "bottom-start"
        },
        fetchSuggestions: {
            type: Function,
            default: _shared.NOOP
        },
        popperClass: {
            type: String,
            default: ""
        },
        triggerOnFocus: {
            type: Boolean,
            default: true
        },
        selectWhenUnmatched: {
            type: Boolean,
            default: false
        },
        hideLoading: {
            type: Boolean,
            default: false
        },
        popperAppendToBody: {
            type: Boolean,
            default: void 0
        },
        teleported: _tooltipMjs.useTooltipContentProps.teleported,
        highlightFirstItem: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        _eventMjs.UPDATE_MODEL_EVENT,
        "input",
        "change",
        "focus",
        "blur",
        "clear",
        "select"
    ],
    setup (props, ctx) {
        const ns = _indexMjs10.useNamespace("autocomplete");
        const { compatTeleported  } = _deprecationMjs.useDeprecateAppendToBody(COMPONENT_NAME, "popperAppendToBody");
        const attrs = _indexMjs11.useAttrs();
        const suggestions = _vue.ref([]);
        const highlightedIndex = _vue.ref(-1);
        const dropdownWidth = _vue.ref("");
        const activated = _vue.ref(false);
        const suggestionDisabled = _vue.ref(false);
        const loading = _vue.ref(false);
        const inputRef = _vue.ref(null);
        const regionRef = _vue.ref(null);
        const popper = _vue.ref(null);
        const id = _vue.computed(()=>{
            return ns.b(String(_randMjs.generateId()));
        });
        const suggestionVisible = _vue.computed(()=>{
            const isValidData = _shared.isArray(suggestions.value) && suggestions.value.length > 0;
            return (isValidData || loading.value) && activated.value;
        });
        const suggestionLoading = _vue.computed(()=>{
            return !props.hideLoading && loading.value;
        });
        const onSuggestionShow = ()=>{
            _vue.nextTick(()=>{
                if (suggestionVisible.value) dropdownWidth.value = `${inputRef.value.$el.offsetWidth}px`;
            });
        };
        _vue.onMounted(()=>{
            inputRef.value.inputOrTextarea.setAttribute("role", "textbox");
            inputRef.value.inputOrTextarea.setAttribute("aria-autocomplete", "list");
            inputRef.value.inputOrTextarea.setAttribute("aria-controls", "id");
            inputRef.value.inputOrTextarea.setAttribute("aria-activedescendant", `${id.value}-item-${highlightedIndex.value}`);
        });
        const getData = (queryString)=>{
            if (suggestionDisabled.value) return;
            loading.value = true;
            props.fetchSuggestions(queryString, (suggestionsArg)=>{
                loading.value = false;
                if (suggestionDisabled.value) return;
                if (_shared.isArray(suggestionsArg)) {
                    suggestions.value = suggestionsArg;
                    highlightedIndex.value = props.highlightFirstItem ? 0 : -1;
                } else _errorMjs.throwError("ElAutocomplete", "autocomplete suggestions must be an array");
            });
        };
        const debouncedGetData = _lodashUnified.debounce(getData, props.debounce);
        const handleInput = (value)=>{
            ctx.emit("input", value);
            ctx.emit(_eventMjs.UPDATE_MODEL_EVENT, value);
            suggestionDisabled.value = false;
            if (!props.triggerOnFocus && !value) {
                suggestionDisabled.value = true;
                suggestions.value = [];
                return;
            }
            debouncedGetData(value);
        };
        const handleChange = (value)=>{
            ctx.emit("change", value);
        };
        const handleFocus = (e)=>{
            activated.value = true;
            ctx.emit("focus", e);
            if (props.triggerOnFocus) debouncedGetData(String(props.modelValue));
        };
        const handleBlur = (e)=>{
            ctx.emit("blur", e);
        };
        const handleClear = ()=>{
            activated.value = false;
            ctx.emit(_eventMjs.UPDATE_MODEL_EVENT, "");
            ctx.emit("clear");
        };
        const handleKeyEnter = ()=>{
            if (suggestionVisible.value && highlightedIndex.value >= 0 && highlightedIndex.value < suggestions.value.length) select(suggestions.value[highlightedIndex.value]);
            else if (props.selectWhenUnmatched) {
                ctx.emit("select", {
                    value: props.modelValue
                });
                _vue.nextTick(()=>{
                    suggestions.value = [];
                    highlightedIndex.value = -1;
                });
            }
        };
        const close = ()=>{
            activated.value = false;
        };
        const focus = ()=>{
            var _a;
            (_a = inputRef.value) == null || _a.focus();
        };
        const select = (item)=>{
            ctx.emit("input", item[props.valueKey]);
            ctx.emit(_eventMjs.UPDATE_MODEL_EVENT, item[props.valueKey]);
            ctx.emit("select", item);
            _vue.nextTick(()=>{
                suggestions.value = [];
                highlightedIndex.value = -1;
            });
        };
        const highlight = (index)=>{
            if (!suggestionVisible.value || loading.value) return;
            if (index < 0) {
                highlightedIndex.value = -1;
                return;
            }
            if (index >= suggestions.value.length) index = suggestions.value.length - 1;
            const suggestion = regionRef.value.querySelector(`.${ns.be("suggestion", "wrap")}`);
            const suggestionList = suggestion.querySelectorAll(`.${ns.be("suggestion", "list")} li`);
            const highlightItem = suggestionList[index];
            const scrollTop = suggestion.scrollTop;
            const { offsetTop , scrollHeight  } = highlightItem;
            if (offsetTop + scrollHeight > scrollTop + suggestion.clientHeight) suggestion.scrollTop += scrollHeight;
            if (offsetTop < scrollTop) suggestion.scrollTop -= scrollHeight;
            highlightedIndex.value = index;
            inputRef.value.inputOrTextarea.setAttribute("aria-activedescendant", `${id.value}-item-${highlightedIndex.value}`);
        };
        return {
            attrs,
            suggestions,
            highlightedIndex,
            dropdownWidth,
            activated,
            suggestionDisabled,
            loading,
            inputRef,
            regionRef,
            popper,
            id,
            suggestionVisible,
            suggestionLoading,
            compatTeleported,
            getData,
            handleInput,
            handleChange,
            handleFocus,
            handleBlur,
            handleClear,
            handleKeyEnter,
            close,
            focus,
            select,
            highlight,
            onSuggestionShow,
            ns
        };
    }
});
const _hoisted_1 = [
    "aria-expanded",
    "aria-owns"
];
const _hoisted_2 = {
    key: 0
};
const _hoisted_3 = [
    "id",
    "aria-selected",
    "onClick"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_input = _vue.resolveComponent("el-input");
    const _component_loading = _vue.resolveComponent("loading");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_scrollbar = _vue.resolveComponent("el-scrollbar");
    const _component_el_tooltip = _vue.resolveComponent("el-tooltip");
    const _directive_clickoutside = _vue.resolveDirective("clickoutside");
    return _vue.openBlock(), _vue.createBlock(_component_el_tooltip, {
        ref: "popper",
        visible: _ctx.suggestionVisible,
        "onUpdate:visible": _cache[2] || (_cache[2] = ($event)=>_ctx.suggestionVisible = $event
        ),
        placement: _ctx.placement,
        "fallback-placements": [
            "bottom-start",
            "top-start"
        ],
        "popper-class": `${_ctx.ns.e("popper")} ${_ctx.popperClass}`,
        teleported: _ctx.compatTeleported,
        "gpu-acceleration": false,
        pure: "",
        "manual-mode": "",
        effect: "light",
        trigger: "click",
        transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
        persistent: "",
        onShow: _ctx.onSuggestionShow
    }, {
        content: _vue.withCtx(()=>[
                _vue.createElementVNode("div", {
                    ref: "regionRef",
                    class: _vue.normalizeClass([
                        _ctx.ns.b("suggestion"),
                        _ctx.ns.is("loading", _ctx.suggestionLoading)
                    ]),
                    style: _vue.normalizeStyle({
                        minWidth: _ctx.dropdownWidth,
                        outline: "none"
                    }),
                    role: "region"
                }, [
                    _vue.createVNode(_component_el_scrollbar, {
                        id: _ctx.id,
                        tag: "ul",
                        "wrap-class": _ctx.ns.be("suggestion", "wrap"),
                        "view-class": _ctx.ns.be("suggestion", "list"),
                        role: "listbox"
                    }, {
                        default: _vue.withCtx(()=>[
                                _ctx.suggestionLoading ? (_vue.openBlock(), _vue.createElementBlock("li", _hoisted_2, [
                                    _vue.createVNode(_component_el_icon, {
                                        class: "is-loading"
                                    }, {
                                        default: _vue.withCtx(()=>[
                                                _vue.createVNode(_component_loading)
                                            ]
                                        ),
                                        _: 1
                                    })
                                ])) : (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, {
                                    key: 1
                                }, _vue.renderList(_ctx.suggestions, (item, index)=>{
                                    return _vue.openBlock(), _vue.createElementBlock("li", {
                                        id: `${_ctx.id}-item-${index}`,
                                        key: index,
                                        class: _vue.normalizeClass({
                                            highlighted: _ctx.highlightedIndex === index
                                        }),
                                        role: "option",
                                        "aria-selected": _ctx.highlightedIndex === index,
                                        onClick: ($event)=>_ctx.select(item)
                                    }, [
                                        _vue.renderSlot(_ctx.$slots, "default", {
                                            item
                                        }, ()=>[
                                                _vue.createTextVNode(_vue.toDisplayString(item[_ctx.valueKey]), 1)
                                            ]
                                        )
                                    ], 10, _hoisted_3);
                                }), 128))
                            ]
                        ),
                        _: 3
                    }, 8, [
                        "id",
                        "wrap-class",
                        "view-class"
                    ])
                ], 6)
            ]
        ),
        default: _vue.withCtx(()=>[
                _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
                    class: _vue.normalizeClass([
                        _ctx.ns.b(),
                        _ctx.$attrs.class
                    ]),
                    style: _vue.normalizeStyle(_ctx.$attrs.style),
                    role: "combobox",
                    "aria-haspopup": "listbox",
                    "aria-expanded": _ctx.suggestionVisible,
                    "aria-owns": _ctx.id
                }, [
                    _vue.createVNode(_component_el_input, _vue.mergeProps({
                        ref: "inputRef"
                    }, _ctx.attrs, {
                        "model-value": _ctx.modelValue,
                        onInput: _ctx.handleInput,
                        onChange: _ctx.handleChange,
                        onFocus: _ctx.handleFocus,
                        onBlur: _ctx.handleBlur,
                        onClear: _ctx.handleClear,
                        onKeydown: [
                            _cache[0] || (_cache[0] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.highlight(_ctx.highlightedIndex - 1)
                            , [
                                "prevent"
                            ]), [
                                "up"
                            ])),
                            _cache[1] || (_cache[1] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.highlight(_ctx.highlightedIndex + 1)
                            , [
                                "prevent"
                            ]), [
                                "down"
                            ])),
                            _vue.withKeys(_ctx.handleKeyEnter, [
                                "enter"
                            ]),
                            _vue.withKeys(_ctx.close, [
                                "tab"
                            ])
                        ]
                    }), _vue.createSlots({
                        _: 2
                    }, [
                        _ctx.$slots.prepend ? {
                            name: "prepend",
                            fn: _vue.withCtx(()=>[
                                    _vue.renderSlot(_ctx.$slots, "prepend")
                                ]
                            )
                        } : void 0,
                        _ctx.$slots.append ? {
                            name: "append",
                            fn: _vue.withCtx(()=>[
                                    _vue.renderSlot(_ctx.$slots, "append")
                                ]
                            )
                        } : void 0,
                        _ctx.$slots.prefix ? {
                            name: "prefix",
                            fn: _vue.withCtx(()=>[
                                    _vue.renderSlot(_ctx.$slots, "prefix")
                                ]
                            )
                        } : void 0,
                        _ctx.$slots.suffix ? {
                            name: "suffix",
                            fn: _vue.withCtx(()=>[
                                    _vue.renderSlot(_ctx.$slots, "suffix")
                                ]
                            )
                        } : void 0
                    ]), 1040, [
                        "model-value",
                        "onInput",
                        "onChange",
                        "onFocus",
                        "onBlur",
                        "onClear",
                        "onKeydown"
                    ])
                ], 14, _hoisted_1)), [
                    [
                        _directive_clickoutside,
                        _ctx.close
                    ]
                ])
            ]
        ),
        _: 3
    }, 8, [
        "visible",
        "placement",
        "popper-class",
        "teleported",
        "transition",
        "onShow"
    ]);
}
var Autocomplete = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vue/shared":"3SM3y","lodash-unified":"4Oj4p","../../../hooks/index.mjs":"1Ansp","../../../directives/index.mjs":"aRbJ2","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../input/index.mjs":"18eQI","../../scrollbar/index.mjs":"kXLHt","../../tooltip/index.mjs":"kiwBC","../../popper/index.mjs":"kIV7g","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../directives/click-outside/index.mjs":"cdlLW","../../tooltip/src/tooltip.mjs":"7LVFi","../../../constants/event.mjs":"92xVn","../../../hooks/use-namespace/index.mjs":"a1pcf","../../popper/src/deprecation.mjs":"jm0Kb","../../../hooks/use-attrs/index.mjs":"3W2Zt","../../../utils/rand.mjs":"6d823","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aRbJ2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ClickOutside", ()=>_indexMjsDefault.default
);
parcelHelpers.export(exports, "RepeatClick", ()=>_indexMjsDefault1.default
);
parcelHelpers.export(exports, "TrapFocus", ()=>_indexMjsDefault2.default
);
parcelHelpers.export(exports, "Mousewheel", ()=>_indexMjsDefault3.default
);
parcelHelpers.export(exports, "Resize", ()=>_indexMjsDefault4.default
);
var _indexMjs = require("./click-outside/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _indexMjs1 = require("./repeat-click/index.mjs");
var _indexMjsDefault1 = parcelHelpers.interopDefault(_indexMjs1);
var _indexMjs2 = require("./trap-focus/index.mjs");
var _indexMjsDefault2 = parcelHelpers.interopDefault(_indexMjs2);
var _indexMjs3 = require("./mousewheel/index.mjs");
var _indexMjsDefault3 = parcelHelpers.interopDefault(_indexMjs3);
var _indexMjs4 = require("./resize/index.mjs");
var _indexMjsDefault4 = parcelHelpers.interopDefault(_indexMjs4);

},{"./click-outside/index.mjs":"cdlLW","./repeat-click/index.mjs":"3krgJ","./trap-focus/index.mjs":"lw3sX","./mousewheel/index.mjs":"5NhJf","./resize/index.mjs":"dLlY9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cdlLW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ClickOutside
);
var _core = require("@vueuse/core");
var _indexMjs = require("../../utils/index.mjs");
var _eventMjs = require("../../utils/dom/event.mjs");
const nodeList = /* @__PURE__ */ new Map();
let startClick;
if (_core.isClient) {
    _eventMjs.on(document, "mousedown", (e)=>startClick = e
    );
    _eventMjs.on(document, "mouseup", (e)=>{
        for (const handlers of nodeList.values())for (const { documentHandler  } of handlers)documentHandler(e, startClick);
    });
}
function createDocumentHandler(el, binding) {
    let excludes = [];
    if (Array.isArray(binding.arg)) excludes = binding.arg;
    else if (binding.arg instanceof HTMLElement) excludes.push(binding.arg);
    return function(mouseup, mousedown) {
        const popperRef = binding.instance.popperRef;
        const mouseUpTarget = mouseup.target;
        const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
        const isBound = !binding || !binding.instance;
        const isTargetExists = !mouseUpTarget || !mouseDownTarget;
        const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
        const isSelf = el === mouseUpTarget;
        const isTargetExcluded = excludes.length && excludes.some((item)=>item == null ? void 0 : item.contains(mouseUpTarget)
        ) || excludes.length && excludes.includes(mouseDownTarget);
        const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
        if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) return;
        binding.value(mouseup, mousedown);
    };
}
const ClickOutside = {
    beforeMount (el, binding) {
        if (!nodeList.has(el)) nodeList.set(el, []);
        nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
        });
    },
    updated (el, binding) {
        if (!nodeList.has(el)) nodeList.set(el, []);
        const handlers = nodeList.get(el);
        const oldHandlerIndex = handlers.findIndex((item)=>item.bindingFn === binding.oldValue
        );
        const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
        };
        if (oldHandlerIndex >= 0) handlers.splice(oldHandlerIndex, 1, newHandler);
        else handlers.push(newHandler);
    },
    unmounted (el) {
        nodeList.delete(el);
    }
};

},{"@vueuse/core":"eEHP9","../../utils/index.mjs":"dsdeP","../../utils/dom/event.mjs":"fnXSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3krgJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>RepeatClick
);
var _indexMjs = require("../../utils/index.mjs");
var _eventMjs = require("../../utils/dom/event.mjs");
var RepeatClick = {
    beforeMount (el, binding) {
        let interval = null;
        let startTime;
        const handler = ()=>binding.value && binding.value()
        ;
        const clear = ()=>{
            if (Date.now() - startTime < 100) handler();
            clearInterval(interval);
            interval = null;
        };
        _eventMjs.on(el, "mousedown", (e)=>{
            if (e.button !== 0) return;
            startTime = Date.now();
            _eventMjs.once(document, "mouseup", clear);
            clearInterval(interval);
            interval = setInterval(handler, 100);
        });
    }
};

},{"../../utils/index.mjs":"dsdeP","../../utils/dom/event.mjs":"fnXSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lw3sX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FOCUSABLE_CHILDREN", ()=>FOCUSABLE_CHILDREN
);
parcelHelpers.export(exports, "TRAP_FOCUS_HANDLER", ()=>TRAP_FOCUS_HANDLER
);
parcelHelpers.export(exports, "default", ()=>TrapFocus
);
var _vue = require("vue");
var _indexMjs = require("../../utils/index.mjs");
var _indexMjs1 = require("../../constants/index.mjs");
var _ariaMjs = require("../../constants/aria.mjs");
var _ariaMjs1 = require("../../utils/dom/aria.mjs");
var _eventMjs = require("../../utils/dom/event.mjs");
const FOCUSABLE_CHILDREN = "_trap-focus-children";
const TRAP_FOCUS_HANDLER = "_trap-focus-handler";
const FOCUS_STACK = [];
const FOCUS_HANDLER = (e)=>{
    var _a;
    if (FOCUS_STACK.length === 0) return;
    const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
    if (focusableElement.length > 0 && e.code === _ariaMjs.EVENT_CODE.tab) {
        if (focusableElement.length === 1) {
            e.preventDefault();
            if (document.activeElement !== focusableElement[0]) focusableElement[0].focus();
            return;
        }
        const goingBackward = e.shiftKey;
        const isFirst = e.target === focusableElement[0];
        const isLast = e.target === focusableElement[focusableElement.length - 1];
        if (isFirst && goingBackward) {
            e.preventDefault();
            focusableElement[focusableElement.length - 1].focus();
        }
        if (isLast && !goingBackward) {
            e.preventDefault();
            focusableElement[0].focus();
        }
    }
};
const TrapFocus = {
    beforeMount (el) {
        el[FOCUSABLE_CHILDREN] = _ariaMjs1.obtainAllFocusableElements(el);
        FOCUS_STACK.push(el);
        if (FOCUS_STACK.length <= 1) _eventMjs.on(document, "keydown", FOCUS_HANDLER);
    },
    updated (el) {
        _vue.nextTick(()=>{
            el[FOCUSABLE_CHILDREN] = _ariaMjs1.obtainAllFocusableElements(el);
        });
    },
    unmounted () {
        FOCUS_STACK.shift();
        if (FOCUS_STACK.length === 0) _eventMjs.off(document, "keydown", FOCUS_HANDLER);
    }
};

},{"vue":"gzxs9","../../utils/index.mjs":"dsdeP","../../constants/index.mjs":"74Fbn","../../constants/aria.mjs":"jS6iK","../../utils/dom/aria.mjs":"6roYP","../../utils/dom/event.mjs":"fnXSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5NhJf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Mousewheel
);
var _normalizeWheelEs = require("normalize-wheel-es");
var _normalizeWheelEsDefault = parcelHelpers.interopDefault(_normalizeWheelEs);
var _indexMjs = require("../../utils/index.mjs");
var _browserMjs = require("../../utils/browser.mjs");
const mousewheel = function(element, callback) {
    if (element && element.addEventListener) {
        const fn = function(event) {
            const normalized = _normalizeWheelEsDefault.default(event);
            callback && callback.apply(this, [
                event,
                normalized
            ]);
        };
        if (_browserMjs.isFirefox()) element.addEventListener("DOMMouseScroll", fn);
        else element.onmousewheel = fn;
    }
};
const Mousewheel = {
    beforeMount (el, binding) {
        mousewheel(el, binding.value);
    }
};

},{"normalize-wheel-es":"11nKW","../../utils/index.mjs":"dsdeP","../../utils/browser.mjs":"9TDf1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"11nKW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>W
) /**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */ ;
var h = !1, o, s, f, u, d, D, l, p, m, w, N, E, x, A, M;
function a() {
    if (!h) {
        h = !0;
        var e = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
        if (E = /\b(iPhone|iP[ao]d)/.exec(e), x = /\b(iP[ao]d)/.exec(e), w = /Android/i.exec(e), A = /FBAN\/\w+;/i.exec(e), M = /Mobile/i.exec(e), N = !!/Win64/.exec(e), n) {
            o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
            var r = /(?:Trident\/(\d+.\d+))/.exec(e);
            D = r ? parseFloat(r[1]) + 4 : o, s = n[2] ? parseFloat(n[2]) : NaN, f = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
        } else o = s = f = d = u = NaN;
        if (i) {
            if (i[1]) {
                var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
                l = t ? parseFloat(t[1].replace("_", ".")) : !0;
            } else l = !1;
            p = !!i[2], m = !!i[3];
        } else l = p = m = !1;
    }
}
var _ = {
    ie: function() {
        return a() || o;
    },
    ieCompatibilityMode: function() {
        return a() || D > o;
    },
    ie64: function() {
        return _.ie() && N;
    },
    firefox: function() {
        return a() || s;
    },
    opera: function() {
        return a() || f;
    },
    webkit: function() {
        return a() || u;
    },
    safari: function() {
        return _.webkit();
    },
    chrome: function() {
        return a() || d;
    },
    windows: function() {
        return a() || p;
    },
    osx: function() {
        return a() || l;
    },
    linux: function() {
        return a() || m;
    },
    iphone: function() {
        return a() || E;
    },
    mobile: function() {
        return a() || E || x || w || M;
    },
    nativeApp: function() {
        return a() || A;
    },
    android: function() {
        return a() || w;
    },
    ipad: function() {
        return a() || x;
    }
}, F = _;
var c = !!(typeof window != "undefined" && window.document && window.document.createElement), I = {
    canUseDOM: c,
    canUseWorkers: typeof Worker != "undefined",
    canUseEventListeners: c && !!(window.addEventListener || window.attachEvent),
    canUseViewport: c && !!window.screen,
    isInWorker: !c
}, v = I;
var X;
v.canUseDOM && (X = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
function S(e, n) {
    if (!v.canUseDOM || n && !("addEventListener" in document)) return !1;
    var i = "on" + e, r = i in document;
    if (!r) {
        var t = document.createElement("div");
        t.setAttribute(i, "return;"), r = typeof t[i] == "function";
    }
    return !r && X && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
}
var b = S;
var O = 10, P = 40, T = 800;
function U(e) {
    var n = 0, i = 0, r = 0, t = 0;
    return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t = i * O, "deltaY" in e && (t = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t) && e.deltaMode && (e.deltaMode == 1 ? (r *= P, t *= P) : (r *= T, t *= T)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), {
        spinX: n,
        spinY: i,
        pixelX: r,
        pixelY: t
    };
}
U.getEventType = function() {
    return F.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
};
var W = U;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dLlY9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Resize
);
var _indexMjs = require("../../utils/index.mjs");
var _resizeEventMjs = require("../../utils/dom/resize-event.mjs");
const Resize = {
    beforeMount (el, binding) {
        el._handleResize = ()=>{
            var _a;
            el && ((_a = binding.value) == null || _a.call(binding, el));
        };
        _resizeEventMjs.addResizeListener(el, el._handleResize);
    },
    beforeUnmount (el) {
        _resizeEventMjs.removeResizeListener(el, el._handleResize);
    }
};

},{"../../utils/index.mjs":"dsdeP","../../utils/dom/resize-event.mjs":"TzEEU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"18eQI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "inputEmits", ()=>_inputMjs.inputEmits
);
parcelHelpers.export(exports, "inputProps", ()=>_inputMjs.inputProps
);
parcelHelpers.export(exports, "ElInput", ()=>ElInput
);
parcelHelpers.export(exports, "default", ()=>ElInput
);
var _indexMjs = require("../../utils/index.mjs");
var _input2Mjs = require("./src/input2.mjs");
var _input2MjsDefault = parcelHelpers.interopDefault(_input2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _inputMjs = require("./src/input.mjs");
const ElInput = _installMjs.withInstall(_input2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/input2.mjs":"8oJiS","../../utils/vue/install.mjs":"4TMmv","./src/input.mjs":"8Zju5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8oJiS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Input
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _indexMjs3 = require("../../../constants/index.mjs");
var _calcTextareaHeightMjs = require("./calc-textarea-height.mjs");
var _inputMjs = require("./input.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs4 = require("../../../hooks/use-attrs/index.mjs");
var _indexMjs5 = require("../../../hooks/use-form-item/index.mjs");
var _indexMjs6 = require("../../../hooks/use-common-props/index.mjs");
var _indexMjs7 = require("../../../hooks/use-namespace/index.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _shared = require("@vue/shared");
var _eventMjs = require("../../../constants/event.mjs");
var _i18NMjs = require("../../../utils/i18n.mjs");
const PENDANT_MAP = {
    suffix: "append",
    prefix: "prepend"
};
const _sfc_main = _vue.defineComponent({
    name: "ElInput",
    components: {
        ElIcon: _indexMjs.ElIcon,
        CircleClose: _iconsVue.CircleClose,
        IconView: _iconsVue.View
    },
    inheritAttrs: false,
    props: _inputMjs.inputProps,
    emits: _inputMjs.inputEmits,
    setup (props, { slots , emit , attrs: rawAttrs  }) {
        const instance = _vue.getCurrentInstance();
        const attrs = _indexMjs4.useAttrs();
        const { form , formItem  } = _indexMjs5.useFormItem();
        const inputSize = _indexMjs6.useSize();
        const inputDisabled = _indexMjs6.useDisabled();
        const nsInput = _indexMjs7.useNamespace("input");
        const nsTextarea = _indexMjs7.useNamespace("textarea");
        const input = _vue.ref();
        const textarea = _vue.ref();
        const focused = _vue.ref(false);
        const hovering = _vue.ref(false);
        const isComposing = _vue.ref(false);
        const passwordVisible = _vue.ref(false);
        const _textareaCalcStyle = _vue.shallowRef(props.inputStyle);
        const inputOrTextarea = _vue.computed(()=>input.value || textarea.value
        );
        const needStatusIcon = _vue.computed(()=>{
            var _a;
            return (_a = form == null ? void 0 : form.statusIcon) != null ? _a : false;
        });
        const validateState = _vue.computed(()=>(formItem == null ? void 0 : formItem.validateState) || ""
        );
        const validateIcon = _vue.computed(()=>_iconMjs.ValidateComponentsMap[validateState.value]
        );
        const containerStyle = _vue.computed(()=>rawAttrs.style
        );
        const computedTextareaStyle = _vue.computed(()=>[
                props.inputStyle,
                _textareaCalcStyle.value,
                {
                    resize: props.resize
                }
            ]
        );
        const nativeInputValue = _vue.computed(()=>props.modelValue === null || props.modelValue === void 0 ? "" : String(props.modelValue)
        );
        const showClear = _vue.computed(()=>props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (focused.value || hovering.value)
        );
        const showPwdVisible = _vue.computed(()=>props.showPassword && !inputDisabled.value && !props.readonly && (!!nativeInputValue.value || focused.value)
        );
        const isWordLimitVisible = _vue.computed(()=>props.showWordLimit && !!attrs.value.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword
        );
        const textLength = _vue.computed(()=>Array.from(nativeInputValue.value).length
        );
        const inputExceed = _vue.computed(()=>!!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength)
        );
        const resizeTextarea = ()=>{
            const { type , autosize  } = props;
            if (!_core.isClient || type !== "textarea") return;
            if (autosize) {
                const minRows = _shared.isObject(autosize) ? autosize.minRows : void 0;
                const maxRows = _shared.isObject(autosize) ? autosize.maxRows : void 0;
                _textareaCalcStyle.value = {
                    ..._calcTextareaHeightMjs.calcTextareaHeight(textarea.value, minRows, maxRows)
                };
            } else _textareaCalcStyle.value = {
                minHeight: _calcTextareaHeightMjs.calcTextareaHeight(textarea.value).minHeight
            };
        };
        const setNativeInputValue = ()=>{
            const input2 = inputOrTextarea.value;
            if (!input2 || input2.value === nativeInputValue.value) return;
            input2.value = nativeInputValue.value;
        };
        const calcIconOffset = (place)=>{
            const { el  } = instance.vnode;
            if (!el) return;
            const elList = Array.from(el.querySelectorAll(`.${nsInput.e(place)}`));
            const target = elList.find((item)=>item.parentNode === el
            );
            if (!target) return;
            const pendant = PENDANT_MAP[place];
            if (slots[pendant]) target.style.transform = `translateX(${place === "suffix" ? "-" : ""}${el.querySelector(`.${nsInput.be("group", pendant)}`).offsetWidth}px)`;
            else target.removeAttribute("style");
        };
        const updateIconOffset = ()=>{
            calcIconOffset("prefix");
            calcIconOffset("suffix");
        };
        const handleInput = (event)=>{
            const { value  } = event.target;
            if (isComposing.value) return;
            if (value === nativeInputValue.value) return;
            emit(_eventMjs.UPDATE_MODEL_EVENT, value);
            emit("input", value);
            _vue.nextTick(setNativeInputValue);
        };
        const handleChange = (event)=>{
            emit("change", event.target.value);
        };
        const focus = ()=>{
            _vue.nextTick(()=>{
                var _a;
                (_a = inputOrTextarea.value) == null || _a.focus();
            });
        };
        const blur = ()=>{
            var _a;
            (_a = inputOrTextarea.value) == null || _a.blur();
        };
        const handleFocus = (event)=>{
            focused.value = true;
            emit("focus", event);
        };
        const handleBlur = (event)=>{
            var _a;
            focused.value = false;
            emit("blur", event);
            if (props.validateEvent) (_a = formItem == null ? void 0 : formItem.validate) == null || _a.call(formItem, "blur");
        };
        const select = ()=>{
            var _a;
            (_a = inputOrTextarea.value) == null || _a.select();
        };
        const handleCompositionStart = (event)=>{
            emit("compositionstart", event);
            isComposing.value = true;
        };
        const handleCompositionUpdate = (event)=>{
            var _a;
            emit("compositionupdate", event);
            const text = (_a = event.target) == null ? void 0 : _a.value;
            const lastCharacter = text[text.length - 1] || "";
            isComposing.value = !_i18NMjs.isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event)=>{
            emit("compositionend", event);
            if (isComposing.value) {
                isComposing.value = false;
                handleInput(event);
            }
        };
        const clear = ()=>{
            emit(_eventMjs.UPDATE_MODEL_EVENT, "");
            emit("change", "");
            emit("clear");
            emit("input", "");
        };
        const handlePasswordVisible = ()=>{
            passwordVisible.value = !passwordVisible.value;
            focus();
        };
        const suffixVisible = _vue.computed(()=>!!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value
        );
        _vue.watch(()=>props.modelValue
        , ()=>{
            var _a;
            _vue.nextTick(resizeTextarea);
            if (props.validateEvent) (_a = formItem == null ? void 0 : formItem.validate) == null || _a.call(formItem, "change");
        });
        _vue.watch(nativeInputValue, ()=>setNativeInputValue()
        );
        _vue.watch(()=>props.type
        , ()=>{
            _vue.nextTick(()=>{
                setNativeInputValue();
                resizeTextarea();
                updateIconOffset();
            });
        });
        _vue.onMounted(()=>{
            setNativeInputValue();
            updateIconOffset();
            _vue.nextTick(resizeTextarea);
        });
        _vue.onUpdated(()=>{
            _vue.nextTick(updateIconOffset);
        });
        const onMouseLeave = (evt)=>{
            hovering.value = false;
            emit("mouseleave", evt);
        };
        const onMouseEnter = (evt)=>{
            hovering.value = true;
            emit("mouseenter", evt);
        };
        const handleKeydown = (evt)=>{
            emit("keydown", evt);
        };
        return {
            input,
            textarea,
            attrs,
            inputSize,
            validateState,
            validateIcon,
            containerStyle,
            computedTextareaStyle,
            inputDisabled,
            showClear,
            showPwdVisible,
            isWordLimitVisible,
            textLength,
            hovering,
            inputExceed,
            passwordVisible,
            inputOrTextarea,
            suffixVisible,
            needStatusIcon,
            resizeTextarea,
            handleInput,
            handleChange,
            handleFocus,
            handleBlur,
            handleCompositionStart,
            handleCompositionUpdate,
            handleCompositionEnd,
            handlePasswordVisible,
            clear,
            select,
            focus,
            blur,
            onMouseLeave,
            onMouseEnter,
            handleKeydown,
            nsInput,
            nsTextarea
        };
    }
});
const _hoisted_1 = [
    "type",
    "disabled",
    "readonly",
    "autocomplete",
    "tabindex",
    "aria-label",
    "placeholder"
];
const _hoisted_2 = [
    "tabindex",
    "disabled",
    "readonly",
    "autocomplete",
    "aria-label",
    "placeholder"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_circle_close = _vue.resolveComponent("circle-close");
    const _component_icon_view = _vue.resolveComponent("icon-view");
    return _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.type === "textarea" ? _ctx.nsTextarea.b() : _ctx.nsInput.b(),
            _ctx.nsInput.m(_ctx.inputSize),
            _ctx.nsInput.is("disabled", _ctx.inputDisabled),
            _ctx.nsInput.is("exceed", _ctx.inputExceed),
            {
                [_ctx.nsInput.b("group")]: _ctx.$slots.prepend || _ctx.$slots.append,
                [_ctx.nsInput.bm("group", "append")]: _ctx.$slots.append,
                [_ctx.nsInput.bm("group", "prepend")]: _ctx.$slots.prepend,
                [_ctx.nsInput.m("prefix")]: _ctx.$slots.prefix || _ctx.prefixIcon,
                [_ctx.nsInput.m("suffix")]: _ctx.$slots.suffix || _ctx.suffixIcon || _ctx.clearable || _ctx.showPassword,
                [_ctx.nsInput.m("suffix--password-clear")]: _ctx.clearable && _ctx.showPassword
            },
            _ctx.$attrs.class
        ]),
        style: _vue.normalizeStyle(_ctx.containerStyle),
        onMouseenter: _cache[17] || (_cache[17] = (...args)=>_ctx.onMouseEnter && _ctx.onMouseEnter(...args)
        ),
        onMouseleave: _cache[18] || (_cache[18] = (...args)=>_ctx.onMouseLeave && _ctx.onMouseLeave(...args)
        )
    }, [
        _vue.createCommentVNode(" input "),
        _ctx.type !== "textarea" ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
            key: 0
        }, [
            _vue.createCommentVNode(" prepend slot "),
            _ctx.$slots.prepend ? (_vue.openBlock(), _vue.createElementBlock("div", {
                key: 0,
                class: _vue.normalizeClass(_ctx.nsInput.be("group", "prepend"))
            }, [
                _vue.renderSlot(_ctx.$slots, "prepend")
            ], 2)) : _vue.createCommentVNode("v-if", true),
            _vue.createElementVNode("input", _vue.mergeProps({
                ref: "input",
                class: _ctx.nsInput.e("inner")
            }, _ctx.attrs, {
                type: _ctx.showPassword ? _ctx.passwordVisible ? "text" : "password" : _ctx.type,
                disabled: _ctx.inputDisabled,
                readonly: _ctx.readonly,
                autocomplete: _ctx.autocomplete,
                tabindex: _ctx.tabindex,
                "aria-label": _ctx.label,
                placeholder: _ctx.placeholder,
                style: _ctx.inputStyle,
                onCompositionstart: _cache[0] || (_cache[0] = (...args)=>_ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)
                ),
                onCompositionupdate: _cache[1] || (_cache[1] = (...args)=>_ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)
                ),
                onCompositionend: _cache[2] || (_cache[2] = (...args)=>_ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)
                ),
                onInput: _cache[3] || (_cache[3] = (...args)=>_ctx.handleInput && _ctx.handleInput(...args)
                ),
                onFocus: _cache[4] || (_cache[4] = (...args)=>_ctx.handleFocus && _ctx.handleFocus(...args)
                ),
                onBlur: _cache[5] || (_cache[5] = (...args)=>_ctx.handleBlur && _ctx.handleBlur(...args)
                ),
                onChange: _cache[6] || (_cache[6] = (...args)=>_ctx.handleChange && _ctx.handleChange(...args)
                ),
                onKeydown: _cache[7] || (_cache[7] = (...args)=>_ctx.handleKeydown && _ctx.handleKeydown(...args)
                )
            }), null, 16, _hoisted_1),
            _vue.createCommentVNode(" prefix slot "),
            _ctx.$slots.prefix || _ctx.prefixIcon ? (_vue.openBlock(), _vue.createElementBlock("span", {
                key: 1,
                class: _vue.normalizeClass(_ctx.nsInput.e("prefix"))
            }, [
                _vue.createElementVNode("span", {
                    class: _vue.normalizeClass(_ctx.nsInput.e("prefix-inner"))
                }, [
                    _vue.renderSlot(_ctx.$slots, "prefix"),
                    _ctx.prefixIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 0,
                        class: _vue.normalizeClass(_ctx.nsInput.e("icon"))
                    }, {
                        default: _vue.withCtx(()=>[
                                (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.prefixIcon)))
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "class"
                    ])) : _vue.createCommentVNode("v-if", true)
                ], 2)
            ], 2)) : _vue.createCommentVNode("v-if", true),
            _vue.createCommentVNode(" suffix slot "),
            _ctx.suffixVisible ? (_vue.openBlock(), _vue.createElementBlock("span", {
                key: 2,
                class: _vue.normalizeClass(_ctx.nsInput.e("suffix"))
            }, [
                _vue.createElementVNode("span", {
                    class: _vue.normalizeClass(_ctx.nsInput.e("suffix-inner"))
                }, [
                    !_ctx.showClear || !_ctx.showPwdVisible || !_ctx.isWordLimitVisible ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                        key: 0
                    }, [
                        _vue.renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                            key: 0,
                            class: _vue.normalizeClass(_ctx.nsInput.e("icon"))
                        }, {
                            default: _vue.withCtx(()=>[
                                    (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.suffixIcon)))
                                ]
                            ),
                            _: 1
                        }, 8, [
                            "class"
                        ])) : _vue.createCommentVNode("v-if", true)
                    ], 64)) : _vue.createCommentVNode("v-if", true),
                    _ctx.showClear ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 1,
                        class: _vue.normalizeClass([
                            _ctx.nsInput.e("icon"),
                            _ctx.nsInput.e("clear")
                        ]),
                        onMousedown: _cache[8] || (_cache[8] = _vue.withModifiers(()=>{
                        }, [
                            "prevent"
                        ])),
                        onClick: _ctx.clear
                    }, {
                        default: _vue.withCtx(()=>[
                                _vue.createVNode(_component_circle_close)
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "class",
                        "onClick"
                    ])) : _vue.createCommentVNode("v-if", true),
                    _ctx.showPwdVisible ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 2,
                        class: _vue.normalizeClass([
                            _ctx.nsInput.e("icon"),
                            _ctx.nsInput.e("clear")
                        ]),
                        onClick: _ctx.handlePasswordVisible
                    }, {
                        default: _vue.withCtx(()=>[
                                _vue.createVNode(_component_icon_view)
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "class",
                        "onClick"
                    ])) : _vue.createCommentVNode("v-if", true),
                    _ctx.isWordLimitVisible ? (_vue.openBlock(), _vue.createElementBlock("span", {
                        key: 3,
                        class: _vue.normalizeClass(_ctx.nsInput.e("count"))
                    }, [
                        _vue.createElementVNode("span", {
                            class: _vue.normalizeClass(_ctx.nsInput.e("count-inner"))
                        }, _vue.toDisplayString(_ctx.textLength) + " / " + _vue.toDisplayString(_ctx.attrs.maxlength), 3)
                    ], 2)) : _vue.createCommentVNode("v-if", true)
                ], 2),
                _ctx.validateState && _ctx.validateIcon && _ctx.needStatusIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                    key: 0,
                    class: _vue.normalizeClass([
                        _ctx.nsInput.e("icon"),
                        _ctx.nsInput.e("validateIcon")
                    ])
                }, {
                    default: _vue.withCtx(()=>[
                            (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.validateIcon)))
                        ]
                    ),
                    _: 1
                }, 8, [
                    "class"
                ])) : _vue.createCommentVNode("v-if", true)
            ], 2)) : _vue.createCommentVNode("v-if", true),
            _vue.createCommentVNode(" append slot "),
            _ctx.$slots.append ? (_vue.openBlock(), _vue.createElementBlock("div", {
                key: 3,
                class: _vue.normalizeClass(_ctx.nsInput.be("group", "append"))
            }, [
                _vue.renderSlot(_ctx.$slots, "append")
            ], 2)) : _vue.createCommentVNode("v-if", true)
        ], 64)) : (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
            key: 1
        }, [
            _vue.createCommentVNode(" textarea "),
            _vue.createElementVNode("textarea", _vue.mergeProps({
                ref: "textarea",
                class: _ctx.nsTextarea.e("inner")
            }, _ctx.attrs, {
                tabindex: _ctx.tabindex,
                disabled: _ctx.inputDisabled,
                readonly: _ctx.readonly,
                autocomplete: _ctx.autocomplete,
                style: _ctx.computedTextareaStyle,
                "aria-label": _ctx.label,
                placeholder: _ctx.placeholder,
                onCompositionstart: _cache[9] || (_cache[9] = (...args)=>_ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)
                ),
                onCompositionupdate: _cache[10] || (_cache[10] = (...args)=>_ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)
                ),
                onCompositionend: _cache[11] || (_cache[11] = (...args)=>_ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)
                ),
                onInput: _cache[12] || (_cache[12] = (...args)=>_ctx.handleInput && _ctx.handleInput(...args)
                ),
                onFocus: _cache[13] || (_cache[13] = (...args)=>_ctx.handleFocus && _ctx.handleFocus(...args)
                ),
                onBlur: _cache[14] || (_cache[14] = (...args)=>_ctx.handleBlur && _ctx.handleBlur(...args)
                ),
                onChange: _cache[15] || (_cache[15] = (...args)=>_ctx.handleChange && _ctx.handleChange(...args)
                ),
                onKeydown: _cache[16] || (_cache[16] = (...args)=>_ctx.handleKeydown && _ctx.handleKeydown(...args)
                )
            }), null, 16, _hoisted_2),
            _ctx.isWordLimitVisible ? (_vue.openBlock(), _vue.createElementBlock("span", {
                key: 0,
                class: _vue.normalizeClass(_ctx.nsInput.e("count"))
            }, _vue.toDisplayString(_ctx.textLength) + " / " + _vue.toDisplayString(_ctx.attrs.maxlength), 3)) : _vue.createCommentVNode("v-if", true)
        ], 64))
    ], 38)), [
        [
            _vue.vShow,
            _ctx.type !== "hidden"
        ]
    ]);
}
var Input = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","../../../constants/index.mjs":"74Fbn","./calc-textarea-height.mjs":"3SNtH","./input.mjs":"8Zju5","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-attrs/index.mjs":"3W2Zt","../../../hooks/use-form-item/index.mjs":"jSs21","../../../hooks/use-common-props/index.mjs":"05czU","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/vue/icon.mjs":"3YbE5","@vue/shared":"3SM3y","../../../constants/event.mjs":"92xVn","../../../utils/i18n.mjs":"5xQne","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3SNtH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "calcTextareaHeight", ()=>calcTextareaHeight
);
var _indexMjs = require("../../../utils/index.mjs");
var _core = require("@vueuse/core");
let hiddenTextarea = void 0;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
const CONTEXT_STYLE = [
    "letter-spacing",
    "line-height",
    "padding-top",
    "padding-bottom",
    "font-family",
    "font-weight",
    "font-size",
    "text-rendering",
    "text-transform",
    "width",
    "text-indent",
    "padding-left",
    "padding-right",
    "border-width",
    "box-sizing"
];
function calculateNodeStyling(targetElement) {
    const style = window.getComputedStyle(targetElement);
    const boxSizing = style.getPropertyValue("box-sizing");
    const paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
    const borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
    const contextStyle = CONTEXT_STYLE.map((name)=>`${name}:${style.getPropertyValue(name)}`
    ).join(";");
    return {
        contextStyle,
        paddingSize,
        borderSize,
        boxSizing
    };
}
function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
    var _a;
    if (!hiddenTextarea) {
        hiddenTextarea = document.createElement("textarea");
        document.body.appendChild(hiddenTextarea);
    }
    const { paddingSize , borderSize , boxSizing , contextStyle  } = calculateNodeStyling(targetElement);
    hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
    hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
    let height = hiddenTextarea.scrollHeight;
    const result = {
    };
    if (boxSizing === "border-box") height = height + borderSize;
    else if (boxSizing === "content-box") height = height - paddingSize;
    hiddenTextarea.value = "";
    const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (_core.isNumber(minRows)) {
        let minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") minHeight = minHeight + paddingSize + borderSize;
        height = Math.max(minHeight, height);
        result.minHeight = `${minHeight}px`;
    }
    if (_core.isNumber(maxRows)) {
        let maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") maxHeight = maxHeight + paddingSize + borderSize;
        height = Math.min(maxHeight, height);
    }
    result.height = `${height}px`;
    (_a = hiddenTextarea.parentNode) == null || _a.removeChild(hiddenTextarea);
    hiddenTextarea = void 0;
    return result;
}

},{"../../../utils/index.mjs":"dsdeP","@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Zju5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "inputEmits", ()=>inputEmits
);
parcelHelpers.export(exports, "inputProps", ()=>inputProps
);
var _shared = require("@vue/shared");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _indexMjs3 = require("../../../hooks/use-common-props/index.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _typescriptMjs = require("../../../utils/typescript.mjs");
var _eventMjs = require("../../../constants/event.mjs");
const inputProps = _propsMjs.buildProps({
    size: _indexMjs3.useSizeProp,
    disabled: Boolean,
    modelValue: {
        type: _propsMjs.definePropType(void 0),
        default: ""
    },
    type: {
        type: String,
        default: "text"
    },
    resize: {
        type: String,
        values: [
            "none",
            "both",
            "horizontal",
            "vertical"
        ]
    },
    autosize: {
        type: _propsMjs.definePropType([
            Boolean,
            Object
        ]),
        default: false
    },
    autocomplete: {
        type: String,
        default: "off"
    },
    placeholder: {
        type: String
    },
    form: {
        type: String,
        default: ""
    },
    readonly: {
        type: Boolean,
        default: false
    },
    clearable: {
        type: Boolean,
        default: false
    },
    showPassword: {
        type: Boolean,
        default: false
    },
    showWordLimit: {
        type: Boolean,
        default: false
    },
    suffixIcon: {
        type: _iconMjs.iconPropType,
        default: ""
    },
    prefixIcon: {
        type: _iconMjs.iconPropType,
        default: ""
    },
    label: {
        type: String
    },
    tabindex: {
        type: [
            Number,
            String
        ]
    },
    validateEvent: {
        type: Boolean,
        default: true
    },
    inputStyle: {
        type: _propsMjs.definePropType([
            Object,
            Array,
            String
        ]),
        default: ()=>_typescriptMjs.mutable({
            })
    }
});
const inputEmits = {
    [_eventMjs.UPDATE_MODEL_EVENT]: (value)=>_shared.isString(value)
    ,
    input: (value)=>_shared.isString(value)
    ,
    change: (value)=>_shared.isString(value)
    ,
    focus: (evt)=>evt instanceof FocusEvent
    ,
    blur: (evt)=>evt instanceof FocusEvent
    ,
    clear: ()=>true
    ,
    mouseleave: (evt)=>evt instanceof MouseEvent
    ,
    mouseenter: (evt)=>evt instanceof MouseEvent
    ,
    keydown: (evt)=>evt instanceof KeyboardEvent
    ,
    compositionstart: (evt)=>evt instanceof CompositionEvent
    ,
    compositionupdate: (evt)=>evt instanceof CompositionEvent
    ,
    compositionend: (evt)=>evt instanceof CompositionEvent
};

},{"@vue/shared":"3SM3y","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../../hooks/index.mjs":"1Ansp","../../../utils/vue/props.mjs":"cpwWK","../../../hooks/use-common-props/index.mjs":"05czU","../../../utils/vue/icon.mjs":"3YbE5","../../../utils/typescript.mjs":"bRl53","../../../constants/event.mjs":"92xVn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kXLHt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BAR_MAP", ()=>_utilMjs.BAR_MAP
);
parcelHelpers.export(exports, "renderThumbStyle", ()=>_utilMjs.renderThumbStyle
);
parcelHelpers.export(exports, "scrollbarEmits", ()=>_scrollbarMjs.scrollbarEmits
);
parcelHelpers.export(exports, "scrollbarProps", ()=>_scrollbarMjs.scrollbarProps
);
parcelHelpers.export(exports, "thumbProps", ()=>_thumbMjs.thumbProps
);
parcelHelpers.export(exports, "ElScrollbar", ()=>ElScrollbar
);
parcelHelpers.export(exports, "default", ()=>ElScrollbar
);
var _indexMjs = require("../../utils/index.mjs");
var _scrollbar2Mjs = require("./src/scrollbar2.mjs");
var _scrollbar2MjsDefault = parcelHelpers.interopDefault(_scrollbar2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _utilMjs = require("./src/util.mjs");
var _scrollbarMjs = require("./src/scrollbar.mjs");
var _thumbMjs = require("./src/thumb.mjs");
const ElScrollbar = _installMjs.withInstall(_scrollbar2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/scrollbar2.mjs":"9hHWf","../../utils/vue/install.mjs":"4TMmv","./src/util.mjs":"eBQCF","./src/scrollbar.mjs":"123QS","./src/thumb.mjs":"gZPgI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9hHWf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Scrollbar
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../tokens/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _bar2Mjs = require("./bar2.mjs");
var _bar2MjsDefault = parcelHelpers.interopDefault(_bar2Mjs);
var _scrollbarMjs = require("./scrollbar.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
var _styleMjs = require("../../../utils/vue/style.mjs");
var _errorMjs = require("../../../utils/error.mjs");
var _scrollbarMjs1 = require("../../../tokens/scrollbar.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElScrollbar",
    components: {
        Bar: _bar2MjsDefault.default
    },
    props: _scrollbarMjs.scrollbarProps,
    emits: _scrollbarMjs.scrollbarEmits,
    setup (props, { emit  }) {
        const ns = _indexMjs3.useNamespace("scrollbar");
        let stopResizeObserver = void 0;
        let stopResizeListener = void 0;
        const scrollbar$ = _vue.ref();
        const wrap$ = _vue.ref();
        const resize$ = _vue.ref();
        const sizeWidth = _vue.ref("0");
        const sizeHeight = _vue.ref("0");
        const barRef = _vue.ref();
        const moveX = _vue.ref(0);
        const moveY = _vue.ref(0);
        const ratioY = _vue.ref(1);
        const ratioX = _vue.ref(1);
        const SCOPE = "ElScrollbar";
        const GAP = 4;
        const style = _vue.computed(()=>{
            const style2 = {
            };
            if (props.height) style2.height = _styleMjs.addUnit(props.height);
            if (props.maxHeight) style2.maxHeight = _styleMjs.addUnit(props.maxHeight);
            return [
                props.wrapStyle,
                style2
            ];
        });
        const handleScroll = ()=>{
            var _a;
            if (wrap$.value) {
                (_a = barRef.value) == null || _a.handleScroll(wrap$.value);
                emit("scroll", {
                    scrollTop: wrap$.value.scrollTop,
                    scrollLeft: wrap$.value.scrollLeft
                });
            }
        };
        const setScrollTop = (value)=>{
            if (!_core.isNumber(value)) {
                _errorMjs.debugWarn(SCOPE, "value must be a number");
                return;
            }
            wrap$.value.scrollTop = value;
        };
        const setScrollLeft = (value)=>{
            if (!_core.isNumber(value)) {
                _errorMjs.debugWarn(SCOPE, "value must be a number");
                return;
            }
            wrap$.value.scrollLeft = value;
        };
        const update = ()=>{
            if (!wrap$.value) return;
            const offsetHeight = wrap$.value.offsetHeight - GAP;
            const offsetWidth = wrap$.value.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrap$.value.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrap$.value.scrollWidth;
            const height = Math.max(originalHeight, props.minSize);
            const width = Math.max(originalWidth, props.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
        };
        _vue.watch(()=>props.noresize
        , (noresize)=>{
            if (noresize) {
                stopResizeObserver == null || stopResizeObserver();
                stopResizeListener == null || stopResizeListener();
            } else {
                ({ stop: stopResizeObserver  } = _core.useResizeObserver(resize$, update));
                stopResizeListener = _core.useEventListener("resize", update);
            }
        }, {
            immediate: true
        });
        _vue.watch(()=>[
                props.maxHeight,
                props.height
            ]
        , ()=>{
            if (!props.native) _vue.nextTick(()=>{
                var _a;
                update();
                if (wrap$.value) (_a = barRef.value) == null || _a.handleScroll(wrap$.value);
            });
        });
        _vue.provide(_scrollbarMjs1.scrollbarContextKey, _vue.reactive({
            scrollbarElement: scrollbar$,
            wrapElement: wrap$
        }));
        _vue.onMounted(()=>{
            if (!props.native) _vue.nextTick(()=>update()
            );
        });
        return {
            ns,
            scrollbar$,
            wrap$,
            resize$,
            barRef,
            moveX,
            moveY,
            ratioX,
            ratioY,
            sizeWidth,
            sizeHeight,
            style,
            update,
            handleScroll,
            setScrollTop,
            setScrollLeft
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_bar = _vue.resolveComponent("bar");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "scrollbar$",
        class: _vue.normalizeClass(_ctx.ns.b())
    }, [
        _vue.createElementVNode("div", {
            ref: "wrap$",
            class: _vue.normalizeClass([
                _ctx.wrapClass,
                _ctx.ns.e("wrap"),
                {
                    [_ctx.ns.em("wrap", "hidden-default")]: !_ctx.native
                }
            ]),
            style: _vue.normalizeStyle(_ctx.style),
            onScroll: _cache[0] || (_cache[0] = (...args)=>_ctx.handleScroll && _ctx.handleScroll(...args)
            )
        }, [
            (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.tag), {
                ref: "resize$",
                class: _vue.normalizeClass([
                    _ctx.ns.e("view"),
                    _ctx.viewClass
                ]),
                style: _vue.normalizeStyle(_ctx.viewStyle)
            }, {
                default: _vue.withCtx(()=>[
                        _vue.renderSlot(_ctx.$slots, "default")
                    ]
                ),
                _: 3
            }, 8, [
                "class",
                "style"
            ]))
        ], 38),
        !_ctx.native ? (_vue.openBlock(), _vue.createBlock(_component_bar, {
            key: 0,
            ref: "barRef",
            height: _ctx.sizeHeight,
            width: _ctx.sizeWidth,
            always: _ctx.always,
            "ratio-x": _ctx.ratioX,
            "ratio-y": _ctx.ratioY
        }, null, 8, [
            "height",
            "width",
            "always",
            "ratio-x",
            "ratio-y"
        ])) : _vue.createCommentVNode("v-if", true)
    ], 2);
}
var Scrollbar = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../utils/index.mjs":"dsdeP","../../../tokens/index.mjs":"wVNQi","../../../hooks/index.mjs":"1Ansp","./bar2.mjs":"7KGya","./scrollbar.mjs":"123QS","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/vue/style.mjs":"pODHb","../../../utils/error.mjs":"2zPBN","../../../tokens/scrollbar.mjs":"1zNPP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7KGya":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Bar
);
var _vue = require("vue");
var _thumb2Mjs = require("./thumb2.mjs");
var _thumb2MjsDefault = parcelHelpers.interopDefault(_thumb2Mjs);
var _barMjs = require("./bar.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    components: {
        Thumb: _thumb2MjsDefault.default
    },
    props: _barMjs.barProps,
    setup (props) {
        const moveX = _vue.ref(0);
        const moveY = _vue.ref(0);
        const GAP = 4;
        const handleScroll = (wrap)=>{
            if (wrap) {
                const offsetHeight = wrap.offsetHeight - GAP;
                const offsetWidth = wrap.offsetWidth - GAP;
                moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
                moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
            }
        };
        return {
            handleScroll,
            moveX,
            moveY
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_thumb = _vue.resolveComponent("thumb");
    return _vue.openBlock(), _vue.createElementBlock(_vue.Fragment, null, [
        _vue.createVNode(_component_thumb, {
            move: _ctx.moveX,
            ratio: _ctx.ratioX,
            size: _ctx.width,
            always: _ctx.always
        }, null, 8, [
            "move",
            "ratio",
            "size",
            "always"
        ]),
        _vue.createVNode(_component_thumb, {
            move: _ctx.moveY,
            ratio: _ctx.ratioY,
            size: _ctx.height,
            vertical: "",
            always: _ctx.always
        }, null, 8, [
            "move",
            "ratio",
            "size",
            "always"
        ])
    ], 64);
}
var Bar = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./thumb2.mjs":"iK8km","./bar.mjs":"jbTGu","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iK8km":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Thumb
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../tokens/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _utilMjs = require("./util.mjs");
var _thumbMjs = require("./thumb.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _scrollbarMjs = require("../../../tokens/scrollbar.mjs");
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const COMPONENT_NAME = "Thumb";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    props: _thumbMjs.thumbProps,
    setup (props) {
        const scrollbar = _vue.inject(_scrollbarMjs.scrollbarContextKey);
        const ns = _indexMjs3.useNamespace("scrollbar");
        if (!scrollbar) _errorMjs.throwError(COMPONENT_NAME, "can not inject scrollbar context");
        const instance = _vue.ref();
        const thumb = _vue.ref();
        const thumbState = _vue.ref({
        });
        const visible = _vue.ref(false);
        let cursorDown = false;
        let cursorLeave = false;
        let originalOnSelectStart = _core.isClient ? document.onselectstart : null;
        const bar = _vue.computed(()=>_utilMjs.BAR_MAP[props.vertical ? "vertical" : "horizontal"]
        );
        const thumbStyle = _vue.computed(()=>_utilMjs.renderThumbStyle({
                size: props.size,
                move: props.move,
                bar: bar.value
            })
        );
        const offsetRatio = _vue.computed(()=>instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]
        );
        const clickThumbHandler = (e)=>{
            var _a;
            e.stopPropagation();
            if (e.ctrlKey || [
                1,
                2
            ].includes(e.button)) return;
            (_a = window.getSelection()) == null || _a.removeAllRanges();
            startDrag(e);
            const el = e.currentTarget;
            if (!el) return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
        };
        const clickTrackHandler = (e)=>{
            if (!thumb.value || !instance.value || !scrollbar.wrapElement) return;
            const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        };
        const startDrag = (e)=>{
            e.stopImmediatePropagation();
            cursorDown = true;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = ()=>false
            ;
        };
        const mouseMoveDocumentHandler = (e)=>{
            if (!instance.value || !thumb.value) return;
            if (cursorDown === false) return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage) return;
            const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        };
        const mouseUpDocumentHandler = ()=>{
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave) visible.value = false;
        };
        const mouseMoveScrollbarHandler = ()=>{
            cursorLeave = false;
            visible.value = !!props.size;
        };
        const mouseLeaveScrollbarHandler = ()=>{
            cursorLeave = true;
            visible.value = cursorDown;
        };
        _vue.onBeforeUnmount(()=>{
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
        });
        const restoreOnselectstart = ()=>{
            if (document.onselectstart !== originalOnSelectStart) document.onselectstart = originalOnSelectStart;
        };
        _core.useEventListener(_vue.toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
        _core.useEventListener(_vue.toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
        return {
            ns,
            instance,
            thumb,
            bar,
            thumbStyle,
            visible,
            clickTrackHandler,
            clickThumbHandler
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createBlock(_vue.Transition, {
        name: _ctx.ns.b("fade")
    }, {
        default: _vue.withCtx(()=>[
                _vue.withDirectives(_vue.createElementVNode("div", {
                    ref: "instance",
                    class: _vue.normalizeClass([
                        _ctx.ns.e("bar"),
                        _ctx.ns.is(_ctx.bar.key)
                    ]),
                    onMousedown: _cache[1] || (_cache[1] = (...args)=>_ctx.clickTrackHandler && _ctx.clickTrackHandler(...args)
                    )
                }, [
                    _vue.createElementVNode("div", {
                        ref: "thumb",
                        class: _vue.normalizeClass(_ctx.ns.e("thumb")),
                        style: _vue.normalizeStyle(_ctx.thumbStyle),
                        onMousedown: _cache[0] || (_cache[0] = (...args)=>_ctx.clickThumbHandler && _ctx.clickThumbHandler(...args)
                        )
                    }, null, 38)
                ], 34), [
                    [
                        _vue.vShow,
                        _ctx.always || _ctx.visible
                    ]
                ])
            ]
        ),
        _: 1
    }, 8, [
        "name"
    ]);
}
var Thumb = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../tokens/index.mjs":"wVNQi","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./util.mjs":"eBQCF","./thumb.mjs":"gZPgI","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../tokens/scrollbar.mjs":"1zNPP","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eBQCF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BAR_MAP", ()=>BAR_MAP
);
parcelHelpers.export(exports, "renderThumbStyle", ()=>renderThumbStyle
);
const BAR_MAP = {
    vertical: {
        offset: "offsetHeight",
        scroll: "scrollTop",
        scrollSize: "scrollHeight",
        size: "height",
        key: "vertical",
        axis: "Y",
        client: "clientY",
        direction: "top"
    },
    horizontal: {
        offset: "offsetWidth",
        scroll: "scrollLeft",
        scrollSize: "scrollWidth",
        size: "width",
        key: "horizontal",
        axis: "X",
        client: "clientX",
        direction: "left"
    }
};
const renderThumbStyle = ({ move , size , bar  })=>({
        [bar.size]: size,
        transform: `translate${bar.axis}(${move}%)`
    })
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gZPgI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "thumbProps", ()=>thumbProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const thumbProps = _propsMjs.buildProps({
    vertical: Boolean,
    size: String,
    move: Number,
    ratio: {
        type: Number,
        required: true
    },
    always: Boolean
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jbTGu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "barProps", ()=>barProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const barProps = _propsMjs.buildProps({
    always: {
        type: Boolean,
        default: true
    },
    width: {
        type: String,
        default: ""
    },
    height: {
        type: String,
        default: ""
    },
    ratioX: {
        type: Number,
        default: 1
    },
    ratioY: {
        type: Number,
        default: 1
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"123QS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scrollbarEmits", ()=>scrollbarEmits
);
parcelHelpers.export(exports, "scrollbarProps", ()=>scrollbarProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _core = require("@vueuse/core");
const scrollbarProps = _propsMjs.buildProps({
    height: {
        type: [
            String,
            Number
        ],
        default: ""
    },
    maxHeight: {
        type: [
            String,
            Number
        ],
        default: ""
    },
    native: {
        type: Boolean,
        default: false
    },
    wrapStyle: {
        type: _propsMjs.definePropType([
            String,
            Object,
            Array
        ]),
        default: ""
    },
    wrapClass: {
        type: [
            String,
            Array
        ],
        default: ""
    },
    viewClass: {
        type: [
            String,
            Array
        ],
        default: ""
    },
    viewStyle: {
        type: [
            String,
            Array
        ],
        default: ""
    },
    noresize: Boolean,
    tag: {
        type: String,
        default: "div"
    },
    always: {
        type: Boolean,
        default: false
    },
    minSize: {
        type: Number,
        default: 20
    }
});
const scrollbarEmits = {
    scroll: ({ scrollTop , scrollLeft  })=>_core.isNumber(scrollTop) && _core.isNumber(scrollLeft)
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kiwBC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useTooltipContentProps", ()=>_tooltipMjs.useTooltipContentProps
);
parcelHelpers.export(exports, "useTooltipProps", ()=>_tooltipMjs.useTooltipProps
);
parcelHelpers.export(exports, "useTooltipTriggerProps", ()=>_tooltipMjs.useTooltipTriggerProps
);
parcelHelpers.export(exports, "TOOLTIP_INJECTION_KEY", ()=>_tokensMjs.TOOLTIP_INJECTION_KEY
);
parcelHelpers.export(exports, "ElTooltip", ()=>ElTooltip
);
parcelHelpers.export(exports, "default", ()=>ElTooltip
);
var _indexMjs = require("../../utils/index.mjs");
var _tooltip2Mjs = require("./src/tooltip2.mjs");
var _tooltip2MjsDefault = parcelHelpers.interopDefault(_tooltip2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _tooltipMjs = require("./src/tooltip.mjs");
var _tokensMjs = require("./src/tokens.mjs");
const ElTooltip = _installMjs.withInstall(_tooltip2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/tooltip2.mjs":"klf8K","../../utils/vue/install.mjs":"4TMmv","./src/tooltip.mjs":"7LVFi","./src/tokens.mjs":"a6G79","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klf8K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Tooltip
);
var _vue = require("vue");
var _indexMjs = require("../../popper/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _contentMjs = require("./content.mjs");
var _contentMjsDefault = parcelHelpers.interopDefault(_contentMjs);
var _triggerMjs = require("./trigger.mjs");
var _triggerMjsDefault = parcelHelpers.interopDefault(_triggerMjs);
var _tooltipMjs = require("./tooltip.mjs");
var _tokensMjs = require("./tokens.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../hooks/use-model-toggle/index.mjs");
var _arrowMjs = require("../../popper/src/arrow.mjs");
var _arrowMjsDefault = parcelHelpers.interopDefault(_arrowMjs);
var _popperMjs = require("../../popper/src/popper.mjs");
var _indexMjs4 = require("../../../hooks/use-popper-container/index.mjs");
var _typesMjs = require("../../../utils/types.mjs");
var _errorMjs = require("../../../utils/error.mjs");
var _core = require("@vueuse/core");
var _indexMjs5 = require("../../../hooks/use-id/index.mjs");
var _indexMjs6 = require("../../../hooks/use-delayed-toggle/index.mjs");
const { useModelToggleProps , useModelToggle , useModelToggleEmits  } = _indexMjs3.createModelToggleComposable("visible");
const _sfc_main = _vue.defineComponent({
    name: "ElTooltip",
    components: {
        ElPopper: _indexMjs.ElPopper,
        ElPopperArrow: _arrowMjsDefault.default,
        ElTooltipContent: _contentMjsDefault.default,
        ElTooltipTrigger: _triggerMjsDefault.default
    },
    props: {
        ...useModelToggleProps,
        ..._tooltipMjs.useTooltipContentProps,
        ..._tooltipMjs.useTooltipTriggerProps,
        ..._popperMjs.usePopperArrowProps,
        ..._tooltipMjs.useTooltipProps
    },
    emits: [
        ...useModelToggleEmits,
        "show",
        "hide"
    ],
    setup (props, { emit  }) {
        _indexMjs4.usePopperContainer();
        const compatShowAfter = _vue.computed(()=>{
            if (!_typesMjs.isUndefined(props.openDelay)) _errorMjs.debugWarn("ElTooltip", "open-delay is about to be deprecated in the next major version, please use `show-after` instead");
            return props.openDelay || props.showAfter;
        });
        const compatShowArrow = _vue.computed(()=>{
            if (!_typesMjs.isUndefined(props.visibleArrow)) _errorMjs.debugWarn("ElTooltip", "`visible-arrow` is about to be deprecated in the next major version, please use `show-arrow` instead");
            return _core.isBoolean(props.visibleArrow) ? props.visibleArrow : props.showArrow;
        });
        const id = _indexMjs5.useId();
        const popperRef = _vue.ref(null);
        const updatePopper = ()=>{
            var _a;
            const popperComponent = _vue.unref(popperRef);
            if (popperComponent) (_a = popperComponent.popperInstanceRef) == null || _a.update();
        };
        const open = _vue.ref(false);
        const { show , hide  } = useModelToggle({
            indicator: open
        });
        const { onOpen , onClose  } = _indexMjs6.useDelayedToggle({
            showAfter: compatShowAfter,
            hideAfter: _vue.toRef(props, "hideAfter"),
            open: show,
            close: hide
        });
        const controlled = _vue.computed(()=>_core.isBoolean(props.visible)
        );
        _vue.provide(_tokensMjs.TOOLTIP_INJECTION_KEY, {
            controlled,
            id,
            open: _vue.readonly(open),
            trigger: _vue.toRef(props, "trigger"),
            onOpen,
            onClose,
            onToggle: ()=>{
                if (_vue.unref(open)) onClose();
                else onOpen();
            },
            onShow: ()=>{
                emit("show");
            },
            onHide: ()=>{
                emit("hide");
            },
            updatePopper
        });
        return {
            compatShowAfter,
            compatShowArrow,
            popperRef,
            open,
            hide,
            updatePopper,
            onOpen,
            onClose
        };
    }
});
const _hoisted_1 = [
    "innerHTML"
];
const _hoisted_2 = {
    key: 1
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_tooltip_trigger = _vue.resolveComponent("el-tooltip-trigger");
    const _component_el_popper_arrow = _vue.resolveComponent("el-popper-arrow");
    const _component_el_tooltip_content = _vue.resolveComponent("el-tooltip-content");
    const _component_el_popper = _vue.resolveComponent("el-popper");
    return _vue.openBlock(), _vue.createBlock(_component_el_popper, {
        ref: "popperRef"
    }, {
        default: _vue.withCtx(()=>[
                _vue.createVNode(_component_el_tooltip_trigger, {
                    disabled: _ctx.disabled,
                    trigger: _ctx.trigger,
                    "virtual-ref": _ctx.virtualRef,
                    "virtual-triggering": _ctx.virtualTriggering
                }, {
                    default: _vue.withCtx(()=>[
                            _ctx.$slots.default ? _vue.renderSlot(_ctx.$slots, "default", {
                                key: 0
                            }) : _vue.createCommentVNode("v-if", true)
                        ]
                    ),
                    _: 3
                }, 8, [
                    "disabled",
                    "trigger",
                    "virtual-ref",
                    "virtual-triggering"
                ]),
                _vue.createVNode(_component_el_tooltip_content, {
                    "aria-label": _ctx.ariaLabel,
                    "boundaries-padding": _ctx.boundariesPadding,
                    content: _ctx.content,
                    disabled: _ctx.disabled,
                    effect: _ctx.effect,
                    enterable: _ctx.enterable,
                    "fallback-placements": _ctx.fallbackPlacements,
                    "hide-after": _ctx.hideAfter,
                    "gpu-acceleration": _ctx.gpuAcceleration,
                    offset: _ctx.offset,
                    persistent: _ctx.persistent,
                    "popper-class": _ctx.popperClass,
                    "popper-style": _ctx.popperStyle,
                    placement: _ctx.placement,
                    "popper-options": _ctx.popperOptions,
                    pure: _ctx.pure,
                    "raw-content": _ctx.rawContent,
                    "reference-el": _ctx.referenceEl,
                    "show-after": _ctx.compatShowAfter,
                    strategy: _ctx.strategy,
                    teleported: _ctx.teleported,
                    transition: _ctx.transition,
                    "z-index": _ctx.zIndex
                }, {
                    default: _vue.withCtx(()=>[
                            _vue.renderSlot(_ctx.$slots, "content", {
                            }, ()=>[
                                    _ctx.rawContent ? (_vue.openBlock(), _vue.createElementBlock("span", {
                                        key: 0,
                                        innerHTML: _ctx.content
                                    }, null, 8, _hoisted_1)) : (_vue.openBlock(), _vue.createElementBlock("span", _hoisted_2, _vue.toDisplayString(_ctx.content), 1))
                                ]
                            ),
                            _ctx.compatShowArrow ? (_vue.openBlock(), _vue.createBlock(_component_el_popper_arrow, {
                                key: 0,
                                "arrow-offset": _ctx.arrowOffset
                            }, null, 8, [
                                "arrow-offset"
                            ])) : _vue.createCommentVNode("v-if", true)
                        ]
                    ),
                    _: 3
                }, 8, [
                    "aria-label",
                    "boundaries-padding",
                    "content",
                    "disabled",
                    "effect",
                    "enterable",
                    "fallback-placements",
                    "hide-after",
                    "gpu-acceleration",
                    "offset",
                    "persistent",
                    "popper-class",
                    "popper-style",
                    "placement",
                    "popper-options",
                    "pure",
                    "raw-content",
                    "reference-el",
                    "show-after",
                    "strategy",
                    "teleported",
                    "transition",
                    "z-index"
                ])
            ]
        ),
        _: 3
    }, 512);
}
var Tooltip = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../popper/index.mjs":"kIV7g","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./content.mjs":"5JkjD","./trigger.mjs":"eOwiG","./tooltip.mjs":"7LVFi","./tokens.mjs":"a6G79","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-model-toggle/index.mjs":"97z8S","../../popper/src/arrow.mjs":"fjUPr","../../popper/src/popper.mjs":"lCFux","../../../hooks/use-popper-container/index.mjs":"hz53M","../../../utils/types.mjs":"4VsDK","../../../utils/error.mjs":"2zPBN","@vueuse/core":"eEHP9","../../../hooks/use-id/index.mjs":"jWUTV","../../../hooks/use-delayed-toggle/index.mjs":"jbu1G","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kIV7g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElPopperArrow", ()=>_arrowMjsDefault.default
);
parcelHelpers.export(exports, "ElPopperTrigger", ()=>_triggerMjsDefault.default
);
parcelHelpers.export(exports, "ElPopperContent", ()=>_contentMjsDefault.default
);
parcelHelpers.export(exports, "Effect", ()=>_popperMjs.Effect
);
parcelHelpers.export(exports, "usePopperArrowProps", ()=>_popperMjs.usePopperArrowProps
);
parcelHelpers.export(exports, "usePopperContentProps", ()=>_popperMjs.usePopperContentProps
);
parcelHelpers.export(exports, "usePopperCoreConfigProps", ()=>_popperMjs.usePopperCoreConfigProps
);
parcelHelpers.export(exports, "usePopperProps", ()=>_popperMjs.usePopperProps
);
parcelHelpers.export(exports, "usePopperTriggerProps", ()=>_popperMjs.usePopperTriggerProps
);
parcelHelpers.export(exports, "POPPER_CONTENT_INJECTION_KEY", ()=>_tokensMjs.POPPER_CONTENT_INJECTION_KEY
);
parcelHelpers.export(exports, "POPPER_INJECTION_KEY", ()=>_tokensMjs.POPPER_INJECTION_KEY
);
parcelHelpers.export(exports, "useDeprecateAppendToBody", ()=>_deprecationMjs.useDeprecateAppendToBody
);
parcelHelpers.export(exports, "ElPopper", ()=>ElPopper
);
parcelHelpers.export(exports, "default", ()=>ElPopper
);
var _indexMjs = require("../../utils/index.mjs");
var _popper2Mjs = require("./src/popper2.mjs");
var _popper2MjsDefault = parcelHelpers.interopDefault(_popper2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _arrowMjs = require("./src/arrow.mjs");
var _arrowMjsDefault = parcelHelpers.interopDefault(_arrowMjs);
var _triggerMjs = require("./src/trigger.mjs");
var _triggerMjsDefault = parcelHelpers.interopDefault(_triggerMjs);
var _contentMjs = require("./src/content.mjs");
var _contentMjsDefault = parcelHelpers.interopDefault(_contentMjs);
var _popperMjs = require("./src/popper.mjs");
var _tokensMjs = require("./src/tokens.mjs");
var _deprecationMjs = require("./src/deprecation.mjs");
const ElPopper = _installMjs.withInstall(_popper2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/popper2.mjs":"bPMBo","../../utils/vue/install.mjs":"4TMmv","./src/arrow.mjs":"fjUPr","./src/trigger.mjs":"3POmC","./src/content.mjs":"lN2o5","./src/popper.mjs":"lCFux","./src/tokens.mjs":"cbHZm","./src/deprecation.mjs":"jm0Kb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bPMBo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Popper
);
var _vue = require("vue");
var _tokensMjs = require("./tokens.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ElPopperProvider",
    inheritAttrs: false,
    setup () {
        const popperProvides = {
            triggerRef: _vue.ref(null),
            popperInstanceRef: _vue.ref(null),
            contentRef: _vue.ref(null)
        };
        _vue.provide(_tokensMjs.POPPER_INJECTION_KEY, popperProvides);
        return popperProvides;
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.renderSlot(_ctx.$slots, "default");
}
var Popper = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./tokens.mjs":"cbHZm","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cbHZm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "POPPER_CONTENT_INJECTION_KEY", ()=>POPPER_CONTENT_INJECTION_KEY
);
parcelHelpers.export(exports, "POPPER_INJECTION_KEY", ()=>POPPER_INJECTION_KEY
);
const POPPER_INJECTION_KEY = Symbol("elPopper");
const POPPER_CONTENT_INJECTION_KEY = Symbol("elPopperContent");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fjUPr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElPopperArrow
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _popperMjs = require("./popper.mjs");
var _tokensMjs = require("./tokens.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElPopperArrow",
    props: _popperMjs.usePopperArrowProps,
    setup (props) {
        const ns = _indexMjs1.useNamespace("popper");
        const arrowRef = _vue.ref(null);
        const popperContentInjection = _vue.inject(_tokensMjs.POPPER_CONTENT_INJECTION_KEY, void 0);
        _vue.watch(()=>props.arrowOffset
        , (val)=>{
            popperContentInjection.arrowOffset.value = val;
        });
        _vue.onMounted(()=>{
            popperContentInjection.arrowRef.value = _vue.unref(arrowRef);
        });
        _vue.onBeforeUnmount(()=>{
            popperContentInjection.arrowRef.value = null;
        });
        return {
            ns,
            arrowRef
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("span", {
        ref: "arrowRef",
        class: _vue.normalizeClass(_ctx.ns.e("arrow")),
        "data-popper-arrow": ""
    }, null, 2);
}
var ElPopperArrow = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./popper.mjs":"lCFux","./tokens.mjs":"cbHZm","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lCFux":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Effect", ()=>Effect
);
parcelHelpers.export(exports, "usePopperArrowProps", ()=>usePopperArrowProps
);
parcelHelpers.export(exports, "usePopperContentProps", ()=>usePopperContentProps
);
parcelHelpers.export(exports, "usePopperCoreConfigProps", ()=>usePopperCoreConfigProps
);
parcelHelpers.export(exports, "usePopperProps", ()=>usePopperProps
);
parcelHelpers.export(exports, "usePopperTriggerProps", ()=>usePopperTriggerProps
);
var _core = require("@popperjs/core");
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const effects = [
    "light",
    "dark"
];
const triggers = [
    "click",
    "contextmenu",
    "hover",
    "focus"
];
const Effect = {
    LIGHT: "light",
    DARK: "dark"
};
const usePopperArrowProps = _propsMjs.buildProps({
    arrowOffset: {
        type: Number,
        default: 5
    }
});
const usePopperCoreConfigProps = _propsMjs.buildProps({
    boundariesPadding: {
        type: Number,
        default: 0
    },
    fallbackPlacements: {
        type: _propsMjs.definePropType(Array),
        default: ()=>[]
    },
    gpuAcceleration: {
        type: Boolean,
        default: true
    },
    offset: {
        type: Number,
        default: 12
    },
    placement: {
        type: String,
        values: _core.placements,
        default: "bottom"
    },
    popperOptions: {
        type: _propsMjs.definePropType(Object),
        default: ()=>({
            })
    },
    strategy: {
        type: String,
        values: [
            "fixed",
            "absolute"
        ],
        default: "absolute"
    }
});
const usePopperProps = _propsMjs.buildProps({
    autoClose: {
        type: Number,
        default: 0
    },
    cutoff: {
        type: Boolean,
        default: false
    },
    disabled: {
        type: Boolean,
        default: false
    }
});
const usePopperContentProps = _propsMjs.buildProps({
    ...usePopperCoreConfigProps,
    style: {
        type: _propsMjs.definePropType([
            String,
            Array,
            Object
        ])
    },
    className: {
        type: _propsMjs.definePropType([
            String,
            Array,
            Object
        ])
    },
    effect: {
        type: String,
        default: "dark"
    },
    enterable: {
        type: Boolean,
        default: true
    },
    pure: {
        type: Boolean
    },
    popperClass: {
        type: _propsMjs.definePropType([
            String,
            Array,
            Object
        ])
    },
    popperStyle: {
        type: _propsMjs.definePropType([
            String,
            Array,
            Object
        ])
    },
    referenceEl: {
        type: _propsMjs.definePropType(Object)
    },
    stopPopperMouseEvent: {
        type: Boolean,
        default: true
    },
    zIndex: Number
});
const usePopperTriggerProps = _propsMjs.buildProps({
    virtualRef: {
        type: _propsMjs.definePropType(Object)
    },
    virtualTriggering: {
        type: Boolean
    }
});

},{"@popperjs/core":"7unqC","../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7unqC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popperGenerator", ()=>_createPopperJs.popperGenerator
) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "detectOverflow", ()=>_createPopperJs.detectOverflow
);
parcelHelpers.export(exports, "createPopperBase", ()=>_createPopperJs.createPopper
);
parcelHelpers.export(exports, "createPopper", ()=>_popperJs.createPopper
) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "createPopperLite", ()=>_popperLiteJs.createPopper
);
var _enumsJs = require("./enums.js");
parcelHelpers.exportAll(_enumsJs, exports);
var _indexJs = require("./modifiers/index.js"); // eslint-disable-next-line import/no-unused-modules
parcelHelpers.exportAll(_indexJs, exports);
var _createPopperJs = require("./createPopper.js");
var _popperJs = require("./popper.js");
var _popperLiteJs = require("./popper-lite.js");

},{"./enums.js":"lCAq5","./modifiers/index.js":"cap3W","./createPopper.js":"cHuNp","./popper.js":"1PuRF","./popper-lite.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lCAq5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "top", ()=>top
);
parcelHelpers.export(exports, "bottom", ()=>bottom
);
parcelHelpers.export(exports, "right", ()=>right
);
parcelHelpers.export(exports, "left", ()=>left
);
parcelHelpers.export(exports, "auto", ()=>auto
);
parcelHelpers.export(exports, "basePlacements", ()=>basePlacements
);
parcelHelpers.export(exports, "start", ()=>start
);
parcelHelpers.export(exports, "end", ()=>end
);
parcelHelpers.export(exports, "clippingParents", ()=>clippingParents
);
parcelHelpers.export(exports, "viewport", ()=>viewport
);
parcelHelpers.export(exports, "popper", ()=>popper
);
parcelHelpers.export(exports, "reference", ()=>reference
);
parcelHelpers.export(exports, "variationPlacements", ()=>variationPlacements
);
parcelHelpers.export(exports, "placements", ()=>placements
);
parcelHelpers.export(exports, "beforeRead", ()=>beforeRead
);
parcelHelpers.export(exports, "read", ()=>read
);
parcelHelpers.export(exports, "afterRead", ()=>afterRead
);
parcelHelpers.export(exports, "beforeMain", ()=>beforeMain
);
parcelHelpers.export(exports, "main", ()=>main
);
parcelHelpers.export(exports, "afterMain", ()=>afterMain
);
parcelHelpers.export(exports, "beforeWrite", ()=>beforeWrite
);
parcelHelpers.export(exports, "write", ()=>write
);
parcelHelpers.export(exports, "afterWrite", ()=>afterWrite
);
parcelHelpers.export(exports, "modifierPhases", ()=>modifierPhases
);
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [
    top,
    bottom,
    right,
    left
];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/ basePlacements.reduce(function(acc, placement) {
    return acc.concat([
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []);
var placements = /*#__PURE__*/ [].concat(basePlacements, [
    auto
]).reduce(function(acc, placement) {
    return acc.concat([
        placement,
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []); // modifiers that need to read the DOM
var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers
var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)
var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [
    beforeRead,
    read,
    afterRead,
    beforeMain,
    main,
    afterMain,
    beforeWrite,
    write,
    afterWrite
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cap3W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "applyStyles", ()=>_applyStylesJsDefault.default
);
parcelHelpers.export(exports, "arrow", ()=>_arrowJsDefault.default
);
parcelHelpers.export(exports, "computeStyles", ()=>_computeStylesJsDefault.default
);
parcelHelpers.export(exports, "eventListeners", ()=>_eventListenersJsDefault.default
);
parcelHelpers.export(exports, "flip", ()=>_flipJsDefault.default
);
parcelHelpers.export(exports, "hide", ()=>_hideJsDefault.default
);
parcelHelpers.export(exports, "offset", ()=>_offsetJsDefault.default
);
parcelHelpers.export(exports, "popperOffsets", ()=>_popperOffsetsJsDefault.default
);
parcelHelpers.export(exports, "preventOverflow", ()=>_preventOverflowJsDefault.default
);
var _applyStylesJs = require("./applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var _arrowJs = require("./arrow.js");
var _arrowJsDefault = parcelHelpers.interopDefault(_arrowJs);
var _computeStylesJs = require("./computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _eventListenersJs = require("./eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _flipJs = require("./flip.js");
var _flipJsDefault = parcelHelpers.interopDefault(_flipJs);
var _hideJs = require("./hide.js");
var _hideJsDefault = parcelHelpers.interopDefault(_hideJs);
var _offsetJs = require("./offset.js");
var _offsetJsDefault = parcelHelpers.interopDefault(_offsetJs);
var _popperOffsetsJs = require("./popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _preventOverflowJs = require("./preventOverflow.js");
var _preventOverflowJsDefault = parcelHelpers.interopDefault(_preventOverflowJs);

},{"./applyStyles.js":"4iMn4","./arrow.js":"31HFW","./computeStyles.js":"gDlm2","./eventListeners.js":"hBKsL","./flip.js":"fv5wq","./hide.js":"2g4OF","./offset.js":"3GKVY","./popperOffsets.js":"6I679","./preventOverflow.js":"1AMhb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4iMn4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNodeNameJs = require("../dom-utils/getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("../dom-utils/instanceOf.js"); // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow
function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name1) {
        var style = state.styles[name1] || {
        };
        var attributes = state.attributes[name1] || {
        };
        var element = state.elements[name1]; // arrow is optional + virtual elements
        if (!_instanceOfJs.isHTMLElement(element) || !_getNodeNameJsDefault.default(element)) return;
         // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name) {
            var value = attributes[name];
            if (value === false) element.removeAttribute(name);
            else element.setAttribute(name, value === true ? '' : value);
        });
    });
}
function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
        popper: {
            position: state.options.strategy,
            left: '0',
            top: '0',
            margin: '0'
        },
        arrow: {
            position: 'absolute'
        },
        reference: {
        }
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
    return function() {
        Object.keys(state.elements).forEach(function(name) {
            var element = state.elements[name];
            var attributes = state.attributes[name] || {
            };
            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them
            var style1 = styleProperties.reduce(function(style, property) {
                style[property] = '';
                return style;
            }, {
            }); // arrow is optional + virtual elements
            if (!_instanceOfJs.isHTMLElement(element) || !_getNodeNameJsDefault.default(element)) return;
            Object.assign(element.style, style1);
            Object.keys(attributes).forEach(function(attribute) {
                element.removeAttribute(attribute);
            });
        });
    };
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    effect: effect,
    requires: [
        'computeStyles'
    ]
};

},{"../dom-utils/getNodeName.js":"a2Qom","../dom-utils/instanceOf.js":"gYFUC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a2Qom":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getNodeName(element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
}
exports.default = getNodeName;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gYFUC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isElement", ()=>isElement
);
parcelHelpers.export(exports, "isHTMLElement", ()=>isHTMLElement
);
parcelHelpers.export(exports, "isShadowRoot", ()=>isShadowRoot
);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function isElement(node) {
    var OwnElement = _getWindowJsDefault.default(node).Element;
    return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
    var OwnElement = _getWindowJsDefault.default(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === 'undefined') return false;
    var OwnElement = _getWindowJsDefault.default(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
}

},{"./getWindow.js":"2SkOo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2SkOo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getWindow(node) {
    if (node == null) return window;
    if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
}
exports.default = getWindow;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"31HFW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getLayoutRectJs = require("../dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _containsJs = require("../dom-utils/contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getMainAxisFromPlacementJs = require("../utils/getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _withinJs = require("../utils/within.js");
var _mergePaddingObjectJs = require("../utils/mergePaddingObject.js");
var _mergePaddingObjectJsDefault = parcelHelpers.interopDefault(_mergePaddingObjectJs);
var _expandToHashMapJs = require("../utils/expandToHashMap.js");
var _expandToHashMapJsDefault = parcelHelpers.interopDefault(_expandToHashMapJs);
var _enumsJs = require("../enums.js");
var _instanceOfJs = require("../dom-utils/instanceOf.js"); // eslint-disable-next-line import/no-unused-modules
var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === 'function' ? padding(Object.assign({
    }, state.rects, {
        placement: state.placement
    })) : padding;
    return _mergePaddingObjectJsDefault.default(typeof padding !== 'number' ? padding : _expandToHashMapJsDefault.default(padding, _enumsJs.basePlacements));
};
function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = _getBasePlacementJsDefault.default(state.placement);
    var axis = _getMainAxisFromPlacementJsDefault.default(basePlacement);
    var isVertical = [
        _enumsJs.left,
        _enumsJs.right
    ].indexOf(basePlacement) >= 0;
    var len = isVertical ? 'height' : 'width';
    if (!arrowElement || !popperOffsets) return;
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = _getLayoutRectJsDefault.default(arrowElement);
    var minProp = axis === 'y' ? _enumsJs.top : _enumsJs.left;
    var maxProp = axis === 'y' ? _enumsJs.bottom : _enumsJs.right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = _getOffsetParentJsDefault.default(arrowElement);
    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds
    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = _withinJs.within(min, center, max); // Prevents breaking syntax highlighting...
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {
    }, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
    if (arrowElement == null) return;
     // CSS selector
    if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) return;
    }
    if (!_instanceOfJs.isHTMLElement(arrowElement)) console.error([
        'Popper: "arrow" element must be an HTMLElement (not an SVGElement).',
        'To use an SVG arrow, wrap it in an HTMLElement that will be used as',
        'the arrow.'
    ].join(' '));
    if (!_containsJsDefault.default(state.elements.popper, arrowElement)) {
        console.error([
            'Popper: "arrow" modifier\'s `element` must be a child of the popper',
            'element.'
        ].join(' '));
        return;
    }
    state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    effect: effect,
    requires: [
        'popperOffsets'
    ],
    requiresIfExists: [
        'preventOverflow'
    ]
};

},{"../utils/getBasePlacement.js":"59Wp3","../dom-utils/getLayoutRect.js":"jvjuf","../dom-utils/contains.js":"4QxRR","../dom-utils/getOffsetParent.js":"laoYw","../utils/getMainAxisFromPlacement.js":"1Xlom","../utils/within.js":"3glSz","../utils/mergePaddingObject.js":"lEIf9","../utils/expandToHashMap.js":"iQlH5","../enums.js":"lCAq5","../dom-utils/instanceOf.js":"gYFUC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"59Wp3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
function getBasePlacement(placement) {
    return placement.split('-')[0];
}
exports.default = getBasePlacement;

},{"../enums.js":"lCAq5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jvjuf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js"); // Returns the layout rect of an element relative to its offsetParent. Layout
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
function getLayoutRect(element) {
    var clientRect = _getBoundingClientRectJsDefault.default(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) width = clientRect.width;
    if (Math.abs(clientRect.height - height) <= 1) height = clientRect.height;
    return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
    };
}
exports.default = getLayoutRect;

},{"./getBoundingClientRect.js":"9CFSQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9CFSQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instanceOfJs = require("./instanceOf.js");
var _mathJs = require("../utils/math.js");
function getBoundingClientRect(element, includeScale) {
    if (includeScale === void 0) includeScale = false;
    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (_instanceOfJs.isHTMLElement(element) && includeScale) {
        var offsetHeight = element.offsetHeight;
        var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
        // Fallback to 1 in case both values are `0`
        if (offsetWidth > 0) scaleX = _mathJs.round(rect.width) / offsetWidth || 1;
        if (offsetHeight > 0) scaleY = _mathJs.round(rect.height) / offsetHeight || 1;
    }
    return {
        width: rect.width / scaleX,
        height: rect.height / scaleY,
        top: rect.top / scaleY,
        right: rect.right / scaleX,
        bottom: rect.bottom / scaleY,
        left: rect.left / scaleX,
        x: rect.left / scaleX,
        y: rect.top / scaleY
    };
}
exports.default = getBoundingClientRect;

},{"./instanceOf.js":"gYFUC","../utils/math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gQqVe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "max", ()=>max
);
parcelHelpers.export(exports, "min", ()=>min
);
parcelHelpers.export(exports, "round", ()=>round
);
var max = Math.max;
var min = Math.min;
var round = Math.round;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4QxRR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instanceOfJs = require("./instanceOf.js");
function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method
    if (parent.contains(child)) return true;
    else if (rootNode && _instanceOfJs.isShadowRoot(rootNode)) {
        var next = child;
        do {
            if (next && parent.isSameNode(next)) return true;
             // $FlowFixMe[prop-missing]: need a better way to handle this...
            next = next.parentNode || next.host;
        }while (next)
    } // Give up, the result is false
    return false;
}
exports.default = contains;

},{"./instanceOf.js":"gYFUC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"laoYw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _instanceOfJs = require("./instanceOf.js");
var _isTableElementJs = require("./isTableElement.js");
var _isTableElementJsDefault = parcelHelpers.interopDefault(_isTableElementJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
function getTrueOffsetParent(element) {
    if (!_instanceOfJs.isHTMLElement(element) || _getComputedStyleJsDefault.default(element).position === 'fixed') return null;
    return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block
function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
    var isIE = navigator.userAgent.indexOf('Trident') !== -1;
    if (isIE && _instanceOfJs.isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = _getComputedStyleJsDefault.default(element);
        if (elementCss.position === 'fixed') return null;
    }
    var currentNode = _getParentNodeJsDefault.default(element);
    while(_instanceOfJs.isHTMLElement(currentNode) && [
        'html',
        'body'
    ].indexOf(_getNodeNameJsDefault.default(currentNode)) < 0){
        var css = _getComputedStyleJsDefault.default(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || [
            'transform',
            'perspective'
        ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') return currentNode;
        else currentNode = currentNode.parentNode;
    }
    return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
function getOffsetParent(element) {
    var window = _getWindowJsDefault.default(element);
    var offsetParent = getTrueOffsetParent(element);
    while(offsetParent && _isTableElementJsDefault.default(offsetParent) && _getComputedStyleJsDefault.default(offsetParent).position === 'static')offsetParent = getTrueOffsetParent(offsetParent);
    if (offsetParent && (_getNodeNameJsDefault.default(offsetParent) === 'html' || _getNodeNameJsDefault.default(offsetParent) === 'body' && _getComputedStyleJsDefault.default(offsetParent).position === 'static')) return window;
    return offsetParent || getContainingBlock(element) || window;
}
exports.default = getOffsetParent;

},{"./getWindow.js":"2SkOo","./getNodeName.js":"a2Qom","./getComputedStyle.js":"3mZjB","./instanceOf.js":"gYFUC","./isTableElement.js":"2qBb7","./getParentNode.js":"bIHpd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3mZjB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function getComputedStyle(element) {
    return _getWindowJsDefault.default(element).getComputedStyle(element);
}
exports.default = getComputedStyle;

},{"./getWindow.js":"2SkOo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2qBb7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
function isTableElement(element) {
    return [
        'table',
        'td',
        'th'
    ].indexOf(_getNodeNameJsDefault.default(element)) >= 0;
}
exports.default = isTableElement;

},{"./getNodeName.js":"a2Qom","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bIHpd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _instanceOfJs = require("./instanceOf.js");
function getParentNode(element) {
    if (_getNodeNameJsDefault.default(element) === 'html') return element;
    return(// $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || element.parentNode || (_instanceOfJs.isShadowRoot(element) ? element.host : null) || // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    _getDocumentElementJsDefault.default(element) // fallback
    );
}
exports.default = getParentNode;

},{"./getNodeName.js":"a2Qom","./getDocumentElement.js":"eJ9Y1","./instanceOf.js":"gYFUC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eJ9Y1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instanceOfJs = require("./instanceOf.js");
function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return ((_instanceOfJs.isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
exports.default = getDocumentElement;

},{"./instanceOf.js":"gYFUC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Xlom":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getMainAxisFromPlacement(placement) {
    return [
        'top',
        'bottom'
    ].indexOf(placement) >= 0 ? 'x' : 'y';
}
exports.default = getMainAxisFromPlacement;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3glSz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "within", ()=>within
);
parcelHelpers.export(exports, "withinMaxClamp", ()=>withinMaxClamp
);
var _mathJs = require("./math.js");
function within(min, value, max) {
    return _mathJs.max(min, _mathJs.min(value, max));
}
function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
}

},{"./math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lEIf9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getFreshSideObjectJs = require("./getFreshSideObject.js");
var _getFreshSideObjectJsDefault = parcelHelpers.interopDefault(_getFreshSideObjectJs);
function mergePaddingObject(paddingObject) {
    return Object.assign({
    }, _getFreshSideObjectJsDefault.default(), paddingObject);
}
exports.default = mergePaddingObject;

},{"./getFreshSideObject.js":"g4xOt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g4xOt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getFreshSideObject() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    };
}
exports.default = getFreshSideObject;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iQlH5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
    }, {
    });
}
exports.default = expandToHashMap;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gDlm2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapToStyles", ()=>mapToStyles
);
var _enumsJs = require("../enums.js");
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getWindowJs = require("../dom-utils/getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getDocumentElementJs = require("../dom-utils/getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("../dom-utils/getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getVariationJs = require("../utils/getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _mathJs = require("../utils/math.js"); // eslint-disable-next-line import/no-unused-modules
var unsetSides = {
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.
function roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
        x: _mathJs.round(x * dpr) / dpr || 0,
        y: _mathJs.round(y * dpr) / dpr || 0
    };
}
function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
        x: x,
        y: y
    }) : {
        x: x,
        y: y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y');
    var sideX = _enumsJs.left;
    var sideY = _enumsJs.top;
    var win = window;
    if (adaptive) {
        var offsetParent = _getOffsetParentJsDefault.default(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';
        if (offsetParent === _getWindowJsDefault.default(popper)) {
            offsetParent = _getDocumentElementJsDefault.default(popper);
            if (_getComputedStyleJsDefault.default(offsetParent).position !== 'static' && position === 'absolute') {
                heightProp = 'scrollHeight';
                widthProp = 'scrollWidth';
            }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it
        if (placement === _enumsJs.top || (placement === _enumsJs.left || placement === _enumsJs.right) && variation === _enumsJs.end) {
            sideY = _enumsJs.bottom;
            var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
            y -= offsetY - popperRect.height;
            y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === _enumsJs.left || (placement === _enumsJs.top || placement === _enumsJs.bottom) && variation === _enumsJs.end) {
            sideX = _enumsJs.right;
            var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
            x -= offsetX - popperRect.width;
            x *= gpuAcceleration ? 1 : -1;
        }
    }
    var commonStyles = Object.assign({
        position: position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
    }) : {
        x: x,
        y: y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({
        }, commonStyles, (_Object$assign = {
        }, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({
    }, commonStyles, (_Object$assign2 = {
    }, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}
function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var transitionProperty = _getComputedStyleJsDefault.default(state.elements.popper).transitionProperty || '';
    if (adaptive && [
        'transform',
        'top',
        'right',
        'bottom',
        'left'
    ].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
    })) console.warn([
        'Popper: Detected CSS transitions on at least one of the following',
        'CSS properties: "transform", "top", "right", "bottom", "left".',
        '\n\n',
        'Disable the "computeStyles" modifier\'s `adaptive` option to allow',
        'for smooth transitions, or remove these properties from the CSS',
        'transition declaration on the popper element if only transitioning',
        'opacity or background-color for example.',
        '\n\n',
        'We recommend using the popper element as a wrapper around an inner',
        'element that can have any CSS property transitioned for animations.'
    ].join(' '));
    var commonStyles = {
        placement: _getBasePlacementJsDefault.default(state.placement),
        variation: _getVariationJsDefault.default(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === 'fixed'
    };
    if (state.modifiersData.popperOffsets != null) state.styles.popper = Object.assign({
    }, state.styles.popper, mapToStyles(Object.assign({
    }, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
    })));
    if (state.modifiersData.arrow != null) state.styles.arrow = Object.assign({
    }, state.styles.arrow, mapToStyles(Object.assign({
    }, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets: roundOffsets
    })));
    state.attributes.popper = Object.assign({
    }, state.attributes.popper, {
        'data-popper-placement': state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'computeStyles',
    enabled: true,
    phase: 'beforeWrite',
    fn: computeStyles,
    data: {
    }
};

},{"../enums.js":"lCAq5","../dom-utils/getOffsetParent.js":"laoYw","../dom-utils/getWindow.js":"2SkOo","../dom-utils/getDocumentElement.js":"eJ9Y1","../dom-utils/getComputedStyle.js":"3mZjB","../utils/getBasePlacement.js":"59Wp3","../utils/getVariation.js":"hIo7Y","../utils/math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hIo7Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getVariation(placement) {
    return placement.split('-')[1];
}
exports.default = getVariation;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hBKsL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("../dom-utils/getWindow.js"); // eslint-disable-next-line import/no-unused-modules
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var passive = {
    passive: true
};
function effect(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window = _getWindowJsDefault.default(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener('scroll', instance.update, passive);
    });
    if (resize) window.addEventListener('resize', instance.update, passive);
    return function() {
        if (scroll) scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
        });
        if (resize) window.removeEventListener('resize', instance.update, passive);
    };
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: function fn() {
    },
    effect: effect,
    data: {
    }
};

},{"../dom-utils/getWindow.js":"2SkOo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fv5wq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getOppositePlacementJs = require("../utils/getOppositePlacement.js");
var _getOppositePlacementJsDefault = parcelHelpers.interopDefault(_getOppositePlacementJs);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getOppositeVariationPlacementJs = require("../utils/getOppositeVariationPlacement.js");
var _getOppositeVariationPlacementJsDefault = parcelHelpers.interopDefault(_getOppositeVariationPlacementJs);
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _computeAutoPlacementJs = require("../utils/computeAutoPlacement.js");
var _computeAutoPlacementJsDefault = parcelHelpers.interopDefault(_computeAutoPlacementJs);
var _enumsJs = require("../enums.js");
var _getVariationJs = require("../utils/getVariation.js"); // eslint-disable-next-line import/no-unused-modules
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
function getExpandedFallbackPlacements(placement) {
    if (_getBasePlacementJsDefault.default(placement) === _enumsJs.auto) return [];
    var oppositePlacement = _getOppositePlacementJsDefault.default(placement);
    return [
        _getOppositeVariationPlacementJsDefault.default(placement),
        oppositePlacement,
        _getOppositeVariationPlacementJsDefault.default(oppositePlacement)
    ];
}
function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) return;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = _getBasePlacementJsDefault.default(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [
        _getOppositePlacementJsDefault.default(preferredPlacement)
    ] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [
        preferredPlacement
    ].concat(fallbackPlacements).reduce(function(acc, placement) {
        return acc.concat(_getBasePlacementJsDefault.default(placement) === _enumsJs.auto ? _computeAutoPlacementJsDefault.default(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding,
            flipVariations: flipVariations,
            allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];
    for(var i = 0; i < placements.length; i++){
        var placement1 = placements[i];
        var _basePlacement = _getBasePlacementJsDefault.default(placement1);
        var isStartVariation = _getVariationJsDefault.default(placement1) === _enumsJs.start;
        var isVertical = [
            _enumsJs.top,
            _enumsJs.bottom
        ].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = _detectOverflowJsDefault.default(state, {
            placement: placement1,
            boundary: boundary,
            rootBoundary: rootBoundary,
            altBoundary: altBoundary,
            padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? _enumsJs.right : _enumsJs.left : isStartVariation ? _enumsJs.bottom : _enumsJs.top;
        if (referenceRect[len] > popperRect[len]) mainVariationSide = _getOppositePlacementJsDefault.default(mainVariationSide);
        var altVariationSide = _getOppositePlacementJsDefault.default(mainVariationSide);
        var checks = [];
        if (checkMainAxis) checks.push(overflow[_basePlacement] <= 0);
        if (checkAltAxis) checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        if (checks.every(function(check) {
            return check;
        })) {
            firstFittingPlacement = placement1;
            makeFallbackChecks = false;
            break;
        }
        checksMap.set(placement1, checks);
    }
    if (makeFallbackChecks) {
        // `2` may be desired in some cases â€“ research later
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop(_i) {
            var fittingPlacement = placements.find(function(placement) {
                var checks = checksMap.get(placement);
                if (checks) return checks.slice(0, _i).every(function(check) {
                    return check;
                });
            });
            if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                return "break";
            }
        };
        for(var _i1 = numberOfChecks; _i1 > 0; _i1--){
            var _ret = _loop(_i1);
            if (_ret === "break") break;
        }
    }
    if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
    }
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requiresIfExists: [
        'offset'
    ],
    data: {
        _skip: false
    }
};

},{"../utils/getOppositePlacement.js":"a8CY0","../utils/getBasePlacement.js":"59Wp3","../utils/getOppositeVariationPlacement.js":"bKTLC","../utils/detectOverflow.js":"ltCuw","../utils/computeAutoPlacement.js":"gytMj","../enums.js":"lCAq5","../utils/getVariation.js":"hIo7Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a8CY0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
};
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash[matched];
    });
}
exports.default = getOppositePlacement;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bKTLC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var hash = {
    start: 'end',
    end: 'start'
};
function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
    });
}
exports.default = getOppositeVariationPlacement;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ltCuw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getClippingRectJs = require("../dom-utils/getClippingRect.js");
var _getClippingRectJsDefault = parcelHelpers.interopDefault(_getClippingRectJs);
var _getDocumentElementJs = require("../dom-utils/getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getBoundingClientRectJs = require("../dom-utils/getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _computeOffsetsJs = require("./computeOffsets.js");
var _computeOffsetsJsDefault = parcelHelpers.interopDefault(_computeOffsetsJs);
var _rectToClientRectJs = require("./rectToClientRect.js");
var _rectToClientRectJsDefault = parcelHelpers.interopDefault(_rectToClientRectJs);
var _enumsJs = require("../enums.js");
var _instanceOfJs = require("../dom-utils/instanceOf.js");
var _mergePaddingObjectJs = require("./mergePaddingObject.js");
var _mergePaddingObjectJsDefault = parcelHelpers.interopDefault(_mergePaddingObjectJs);
var _expandToHashMapJs = require("./expandToHashMap.js"); // eslint-disable-next-line import/no-unused-modules
var _expandToHashMapJsDefault = parcelHelpers.interopDefault(_expandToHashMapJs);
function detectOverflow(state, options) {
    if (options === void 0) options = {
    };
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? _enumsJs.clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? _enumsJs.viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? _enumsJs.popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = _mergePaddingObjectJsDefault.default(typeof padding !== 'number' ? padding : _expandToHashMapJsDefault.default(padding, _enumsJs.basePlacements));
    var altContext = elementContext === _enumsJs.popper ? _enumsJs.reference : _enumsJs.popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = _getClippingRectJsDefault.default(_instanceOfJs.isElement(element) ? element : element.contextElement || _getDocumentElementJsDefault.default(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = _getBoundingClientRectJsDefault.default(state.elements.reference);
    var popperOffsets = _computeOffsetsJsDefault.default({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
    });
    var popperClientRect = _rectToClientRectJsDefault.default(Object.assign({
    }, popperRect, popperOffsets));
    var elementClientRect = elementContext === _enumsJs.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect
    var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element
    if (elementContext === _enumsJs.popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
            var multiply = [
                _enumsJs.right,
                _enumsJs.bottom
            ].indexOf(key) >= 0 ? 1 : -1;
            var axis = [
                _enumsJs.top,
                _enumsJs.bottom
            ].indexOf(key) >= 0 ? 'y' : 'x';
            overflowOffsets[key] += offset[axis] * multiply;
        });
    }
    return overflowOffsets;
}
exports.default = detectOverflow;

},{"../dom-utils/getClippingRect.js":"eeg2s","../dom-utils/getDocumentElement.js":"eJ9Y1","../dom-utils/getBoundingClientRect.js":"9CFSQ","./computeOffsets.js":"7jtXk","./rectToClientRect.js":"cQ3tg","../enums.js":"lCAq5","../dom-utils/instanceOf.js":"gYFUC","./mergePaddingObject.js":"lEIf9","./expandToHashMap.js":"iQlH5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eeg2s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _getViewportRectJs = require("./getViewportRect.js");
var _getViewportRectJsDefault = parcelHelpers.interopDefault(_getViewportRectJs);
var _getDocumentRectJs = require("./getDocumentRect.js");
var _getDocumentRectJsDefault = parcelHelpers.interopDefault(_getDocumentRectJs);
var _listScrollParentsJs = require("./listScrollParents.js");
var _listScrollParentsJsDefault = parcelHelpers.interopDefault(_listScrollParentsJs);
var _getOffsetParentJs = require("./getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _instanceOfJs = require("./instanceOf.js");
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _rectToClientRectJs = require("../utils/rectToClientRect.js");
var _rectToClientRectJsDefault = parcelHelpers.interopDefault(_rectToClientRectJs);
var _mathJs = require("../utils/math.js");
function getInnerBoundingClientRect(element) {
    var rect = _getBoundingClientRectJsDefault.default(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === _enumsJs.viewport ? _rectToClientRectJsDefault.default(_getViewportRectJsDefault.default(element)) : _instanceOfJs.isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : _rectToClientRectJsDefault.default(_getDocumentRectJsDefault.default(_getDocumentElementJsDefault.default(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`
function getClippingParents(element) {
    var clippingParents = _listScrollParentsJsDefault.default(_getParentNodeJsDefault.default(element));
    var canEscapeClipping = [
        'absolute',
        'fixed'
    ].indexOf(_getComputedStyleJsDefault.default(element).position) >= 0;
    var clipperElement = canEscapeClipping && _instanceOfJs.isHTMLElement(element) ? _getOffsetParentJsDefault.default(element) : element;
    if (!_instanceOfJs.isElement(clipperElement)) return [];
     // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414
    return clippingParents.filter(function(clippingParent) {
        return _instanceOfJs.isElement(clippingParent) && _containsJsDefault.default(clippingParent, clipperElement) && _getNodeNameJsDefault.default(clippingParent) !== 'body';
    });
} // Gets the maximum area that the element is visible in due to any number of
function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [
        rootBoundary
    ]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = _mathJs.max(rect.top, accRect.top);
        accRect.right = _mathJs.min(rect.right, accRect.right);
        accRect.bottom = _mathJs.min(rect.bottom, accRect.bottom);
        accRect.left = _mathJs.max(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
}
exports.default = getClippingRect;

},{"../enums.js":"lCAq5","./getViewportRect.js":"cnH2G","./getDocumentRect.js":"d94SC","./listScrollParents.js":"2di3T","./getOffsetParent.js":"laoYw","./getDocumentElement.js":"eJ9Y1","./getComputedStyle.js":"3mZjB","./instanceOf.js":"gYFUC","./getBoundingClientRect.js":"9CFSQ","./getParentNode.js":"bIHpd","./contains.js":"4QxRR","./getNodeName.js":"a2Qom","../utils/rectToClientRect.js":"cQ3tg","../utils/math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cnH2G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
function getViewportRect(element) {
    var win = _getWindowJsDefault.default(element);
    var html = _getDocumentElementJsDefault.default(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
    // can be obscured underneath it.
    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
    // if it isn't open, so if this isn't available, the popper will be detected
    // to overflow the bottom of the screen too early.
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent
        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width: width,
        height: height,
        x: x + _getWindowScrollBarXJsDefault.default(element),
        y: y
    };
}
exports.default = getViewportRect;

},{"./getWindow.js":"2SkOo","./getDocumentElement.js":"eJ9Y1","./getWindowScrollBarX.js":"sz4Ld","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"sz4Ld":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return _getBoundingClientRectJsDefault.default(_getDocumentElementJsDefault.default(element)).left + _getWindowScrollJsDefault.default(element).scrollLeft;
}
exports.default = getWindowScrollBarX;

},{"./getBoundingClientRect.js":"9CFSQ","./getDocumentElement.js":"eJ9Y1","./getWindowScroll.js":"1XUtN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1XUtN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function getWindowScroll(node) {
    var win = _getWindowJsDefault.default(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
    };
}
exports.default = getWindowScroll;

},{"./getWindow.js":"2SkOo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d94SC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
var _mathJs = require("../utils/math.js"); // Gets the entire size of the scrollable document area, even extending outside
function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = _getDocumentElementJsDefault.default(element);
    var winScroll = _getWindowScrollJsDefault.default(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = _mathJs.max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = _mathJs.max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + _getWindowScrollBarXJsDefault.default(element);
    var y = -winScroll.scrollTop;
    if (_getComputedStyleJsDefault.default(body || html).direction === 'rtl') x += _mathJs.max(html.clientWidth, body ? body.clientWidth : 0) - width;
    return {
        width: width,
        height: height,
        x: x,
        y: y
    };
}
exports.default = getDocumentRect;

},{"./getDocumentElement.js":"eJ9Y1","./getComputedStyle.js":"3mZjB","./getWindowScrollBarX.js":"sz4Ld","./getWindowScroll.js":"1XUtN","../utils/math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2di3T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getScrollParentJs = require("./getScrollParent.js");
var _getScrollParentJsDefault = parcelHelpers.interopDefault(_getScrollParentJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) list = [];
    var scrollParent = _getScrollParentJsDefault.default(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = _getWindowJsDefault.default(scrollParent);
    var target = isBody ? [
        win
    ].concat(win.visualViewport || [], _isScrollParentJsDefault.default(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(_getParentNodeJsDefault.default(target)));
}
exports.default = listScrollParents;

},{"./getScrollParent.js":"jy4ZS","./getParentNode.js":"bIHpd","./getWindow.js":"2SkOo","./isScrollParent.js":"9rLGO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jy4ZS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("./instanceOf.js");
function getScrollParent(node) {
    if ([
        'html',
        'body',
        '#document'
    ].indexOf(_getNodeNameJsDefault.default(node)) >= 0) // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
    if (_instanceOfJs.isHTMLElement(node) && _isScrollParentJsDefault.default(node)) return node;
    return getScrollParent(_getParentNodeJsDefault.default(node));
}
exports.default = getScrollParent;

},{"./getParentNode.js":"bIHpd","./isScrollParent.js":"9rLGO","./getNodeName.js":"a2Qom","./instanceOf.js":"gYFUC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9rLGO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = _getComputedStyleJsDefault.default(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
exports.default = isScrollParent;

},{"./getComputedStyle.js":"3mZjB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cQ3tg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function rectToClientRect(rect) {
    return Object.assign({
    }, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
    });
}
exports.default = rectToClientRect;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7jtXk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBasePlacementJs = require("./getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getVariationJs = require("./getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _getMainAxisFromPlacementJs = require("./getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _enumsJs = require("../enums.js");
function computeOffsets(_ref) {
    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? _getBasePlacementJsDefault.default(placement) : null;
    var variation = placement ? _getVariationJsDefault.default(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;
    switch(basePlacement){
        case _enumsJs.top:
            offsets = {
                x: commonX,
                y: reference.y - element.height
            };
            break;
        case _enumsJs.bottom:
            offsets = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;
        case _enumsJs.right:
            offsets = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;
        case _enumsJs.left:
            offsets = {
                x: reference.x - element.width,
                y: commonY
            };
            break;
        default:
            offsets = {
                x: reference.x,
                y: reference.y
            };
    }
    var mainAxis = basePlacement ? _getMainAxisFromPlacementJsDefault.default(basePlacement) : null;
    if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';
        switch(variation){
            case _enumsJs.start:
                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                break;
            case _enumsJs.end:
                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                break;
            default:
        }
    }
    return offsets;
}
exports.default = computeOffsets;

},{"./getBasePlacement.js":"59Wp3","./getVariation.js":"hIo7Y","./getMainAxisFromPlacement.js":"1Xlom","../enums.js":"lCAq5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gytMj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getVariationJs = require("./getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _enumsJs = require("../enums.js");
var _detectOverflowJs = require("./detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _getBasePlacementJs = require("./getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
function computeAutoPlacement(state, options) {
    if (options === void 0) options = {
    };
    var _options = options, placement1 = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enumsJs.placements : _options$allowedAutoP;
    var variation = _getVariationJsDefault.default(placement1);
    var placements = variation ? flipVariations ? _enumsJs.variationPlacements : _enumsJs.variationPlacements.filter(function(placement) {
        return _getVariationJsDefault.default(placement) === variation;
    }) : _enumsJs.basePlacements;
    var allowedPlacements = placements.filter(function(placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
    });
    if (allowedPlacements.length === 0) {
        allowedPlacements = placements;
        console.error([
            'Popper: The `allowedAutoPlacements` option did not allow any',
            'placements. Ensure the `placement` option matches the variation',
            'of the allowed placements.',
            'For example, "auto" cannot be used to allow "bottom-start".',
            'Use "auto-start" instead.'
        ].join(' '));
    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...
    var overflows = allowedPlacements.reduce(function(acc, placement) {
        acc[placement] = _detectOverflowJsDefault.default(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding
        })[_getBasePlacementJsDefault.default(placement)];
        return acc;
    }, {
    });
    return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
    });
}
exports.default = computeAutoPlacement;

},{"./getVariation.js":"hIo7Y","../enums.js":"lCAq5","./detectOverflow.js":"ltCuw","./getBasePlacement.js":"59Wp3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2g4OF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) preventedOffsets = {
        x: 0,
        y: 0
    };
    return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
    };
}
function isAnySideFullyClipped(overflow) {
    return [
        _enumsJs.top,
        _enumsJs.right,
        _enumsJs.bottom,
        _enumsJs.left
    ].some(function(side) {
        return overflow[side] >= 0;
    });
}
function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = _detectOverflowJsDefault.default(state, {
        elementContext: 'reference'
    });
    var popperAltOverflow = _detectOverflowJsDefault.default(state, {
        altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({
    }, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'hide',
    enabled: true,
    phase: 'main',
    requiresIfExists: [
        'preventOverflow'
    ],
    fn: hide
};

},{"../enums.js":"lCAq5","../utils/detectOverflow.js":"ltCuw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3GKVY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distanceAndSkiddingToXY", ()=>distanceAndSkiddingToXY
);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _enumsJs = require("../enums.js"); // eslint-disable-next-line import/no-unused-modules
function distanceAndSkiddingToXY(placement, rects, offset1) {
    var basePlacement = _getBasePlacementJsDefault.default(placement);
    var invertDistance = [
        _enumsJs.left,
        _enumsJs.top
    ].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset1 === 'function' ? offset1(Object.assign({
    }, rects, {
        placement: placement
    })) : offset1, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [
        _enumsJs.left,
        _enumsJs.right
    ].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
    } : {
        x: skidding,
        y: distance
    };
}
function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [
        0,
        0
    ] : _options$offset;
    var data = _enumsJs.placements.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
        return acc;
    }, {
    });
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'offset',
    enabled: true,
    phase: 'main',
    requires: [
        'popperOffsets'
    ],
    fn: offset
};

},{"../utils/getBasePlacement.js":"59Wp3","../enums.js":"lCAq5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6I679":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _computeOffsetsJs = require("../utils/computeOffsets.js");
var _computeOffsetsJsDefault = parcelHelpers.interopDefault(_computeOffsetsJs);
function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = _computeOffsetsJsDefault.default({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {
    }
};

},{"../utils/computeOffsets.js":"7jtXk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1AMhb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getMainAxisFromPlacementJs = require("../utils/getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _getAltAxisJs = require("../utils/getAltAxis.js");
var _getAltAxisJsDefault = parcelHelpers.interopDefault(_getAltAxisJs);
var _withinJs = require("../utils/within.js");
var _getLayoutRectJs = require("../dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _getVariationJs = require("../utils/getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _getFreshSideObjectJs = require("../utils/getFreshSideObject.js");
var _getFreshSideObjectJsDefault = parcelHelpers.interopDefault(_getFreshSideObjectJs);
var _mathJs = require("../utils/math.js");
function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = _detectOverflowJsDefault.default(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
    });
    var basePlacement = _getBasePlacementJsDefault.default(state.placement);
    var variation = _getVariationJsDefault.default(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = _getMainAxisFromPlacementJsDefault.default(basePlacement);
    var altAxis = _getAltAxisJsDefault.default(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({
    }, state.rects, {
        placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
    } : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
        x: 0,
        y: 0
    };
    if (!popperOffsets) return;
    if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === 'y' ? _enumsJs.top : _enumsJs.left;
        var altSide = mainAxis === 'y' ? _enumsJs.bottom : _enumsJs.right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min = offset + overflow[mainSide];
        var max = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === _enumsJs.start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === _enumsJs.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? _getLayoutRectJsDefault.default(arrowElement) : {
            width: 0,
            height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : _getFreshSideObjectJsDefault.default();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)
        var arrowLen = _withinJs.within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && _getOffsetParentJsDefault.default(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = _withinJs.within(tether ? _mathJs.min(min, tetherMin) : min, offset, tether ? _mathJs.max(max, tetherMax) : max);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
    }
    if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === 'x' ? _enumsJs.top : _enumsJs.left;
        var _altSide = mainAxis === 'x' ? _enumsJs.bottom : _enumsJs.right;
        var _offset = popperOffsets[altAxis];
        var _len = altAxis === 'y' ? 'height' : 'width';
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [
            _enumsJs.top,
            _enumsJs.left
        ].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? _withinJs.withinMaxClamp(_tetherMin, _offset, _tetherMax) : _withinJs.within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requiresIfExists: [
        'offset'
    ]
};

},{"../enums.js":"lCAq5","../utils/getBasePlacement.js":"59Wp3","../utils/getMainAxisFromPlacement.js":"1Xlom","../utils/getAltAxis.js":"59FWE","../utils/within.js":"3glSz","../dom-utils/getLayoutRect.js":"jvjuf","../dom-utils/getOffsetParent.js":"laoYw","../utils/detectOverflow.js":"ltCuw","../utils/getVariation.js":"hIo7Y","../utils/getFreshSideObject.js":"g4xOt","../utils/math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"59FWE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getAltAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
}
exports.default = getAltAxis;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cHuNp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popperGenerator", ()=>popperGenerator
);
parcelHelpers.export(exports, "createPopper", ()=>createPopper
);
parcelHelpers.export(exports, "detectOverflow", ()=>_detectOverflowJsDefault.default
);
var _getCompositeRectJs = require("./dom-utils/getCompositeRect.js");
var _getCompositeRectJsDefault = parcelHelpers.interopDefault(_getCompositeRectJs);
var _getLayoutRectJs = require("./dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _listScrollParentsJs = require("./dom-utils/listScrollParents.js");
var _listScrollParentsJsDefault = parcelHelpers.interopDefault(_listScrollParentsJs);
var _getOffsetParentJs = require("./dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getComputedStyleJs = require("./dom-utils/getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _orderModifiersJs = require("./utils/orderModifiers.js");
var _orderModifiersJsDefault = parcelHelpers.interopDefault(_orderModifiersJs);
var _debounceJs = require("./utils/debounce.js");
var _debounceJsDefault = parcelHelpers.interopDefault(_debounceJs);
var _validateModifiersJs = require("./utils/validateModifiers.js");
var _validateModifiersJsDefault = parcelHelpers.interopDefault(_validateModifiersJs);
var _uniqueByJs = require("./utils/uniqueBy.js");
var _uniqueByJsDefault = parcelHelpers.interopDefault(_uniqueByJs);
var _getBasePlacementJs = require("./utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _mergeByNameJs = require("./utils/mergeByName.js");
var _mergeByNameJsDefault = parcelHelpers.interopDefault(_mergeByNameJs);
var _detectOverflowJs = require("./utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _instanceOfJs = require("./dom-utils/instanceOf.js");
var _enumsJs = require("./enums.js");
var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
};
function areValidElements() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
    });
}
function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) generatorOptions = {
    };
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference1, popper1, options1) {
        if (options1 === void 0) options1 = defaultOptions;
        var state1 = {
            placement: 'bottom',
            orderedModifiers: [],
            options: Object.assign({
            }, DEFAULT_OPTIONS, defaultOptions),
            modifiersData: {
            },
            elements: {
                reference: reference1,
                popper: popper1
            },
            attributes: {
            },
            styles: {
            }
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
            state: state1,
            setOptions: function setOptions(setOptionsAction) {
                var options = typeof setOptionsAction === 'function' ? setOptionsAction(state1.options) : setOptionsAction;
                cleanupModifierEffects();
                state1.options = Object.assign({
                }, defaultOptions, state1.options, options);
                state1.scrollParents = {
                    reference: _instanceOfJs.isElement(reference1) ? _listScrollParentsJsDefault.default(reference1) : reference1.contextElement ? _listScrollParentsJsDefault.default(reference1.contextElement) : [],
                    popper: _listScrollParentsJsDefault.default(popper1)
                }; // Orders the modifiers based on their dependencies and `phase`
                // properties
                var orderedModifiers = _orderModifiersJsDefault.default(_mergeByNameJsDefault.default([].concat(defaultModifiers, state1.options.modifiers))); // Strip out disabled modifiers
                state1.orderedModifiers = orderedModifiers.filter(function(m) {
                    return m.enabled;
                }); // Validate the provided modifiers so that the consumer will get warned
                var modifiers = _uniqueByJsDefault.default([].concat(orderedModifiers, state1.options.modifiers), function(_ref) {
                    var name = _ref.name;
                    return name;
                });
                _validateModifiersJsDefault.default(modifiers);
                if (_getBasePlacementJsDefault.default(state1.options.placement) === _enumsJs.auto) {
                    var flipModifier = state1.orderedModifiers.find(function(_ref2) {
                        var name = _ref2.name;
                        return name === 'flip';
                    });
                    if (!flipModifier) console.error([
                        'Popper: "auto" placements require the "flip" modifier be',
                        'present and enabled to work.'
                    ].join(' '));
                }
                var _getComputedStyle = _getComputedStyleJsDefault.default(popper1), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
                // cause bugs with positioning, so we'll warn the consumer
                if ([
                    marginTop,
                    marginRight,
                    marginBottom,
                    marginLeft
                ].some(function(margin) {
                    return parseFloat(margin);
                })) console.warn([
                    'Popper: CSS "margin" styles cannot be used to apply padding',
                    'between the popper and its reference element or boundary.',
                    'To replicate margin, use the `offset` modifier, as well as',
                    'the `padding` option in the `preventOverflow` and `flip`',
                    'modifiers.'
                ].join(' '));
                runModifierEffects();
                return instance.update();
            },
            // Sync update â€“ it will always be executed, even if not necessary. This
            // is useful for low frequency updates where sync behavior simplifies the
            // logic.
            // For high frequency updates (e.g. `resize` and `scroll` events), always
            // prefer the async Popper#update method
            forceUpdate: function forceUpdate() {
                if (isDestroyed) return;
                var _state$elements = state1.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
                // anymore
                if (!areValidElements(reference, popper)) {
                    console.error(INVALID_ELEMENT_ERROR);
                    return;
                } // Store the reference and popper rects to be read by modifiers
                state1.rects = {
                    reference: _getCompositeRectJsDefault.default(reference, _getOffsetParentJsDefault.default(popper), state1.options.strategy === 'fixed'),
                    popper: _getLayoutRectJsDefault.default(popper)
                }; // Modifiers have the ability to reset the current update cycle. The
                // most common use case for this is the `flip` modifier changing the
                // placement, which then needs to re-run all the modifiers, because the
                // logic was previously ran for the previous placement and is therefore
                // stale/incorrect
                state1.reset = false;
                state1.placement = state1.options.placement; // On each update cycle, the `modifiersData` property for each modifier
                // is filled with the initial data specified by the modifier. This means
                // it doesn't persist and is fresh on each update.
                // To ensure persistent data, use `${name}#persistent`
                state1.orderedModifiers.forEach(function(modifier) {
                    return state1.modifiersData[modifier.name] = Object.assign({
                    }, modifier.data);
                });
                var __debug_loops__ = 0;
                for(var index = 0; index < state1.orderedModifiers.length; index++){
                    __debug_loops__ += 1;
                    if (__debug_loops__ > 100) {
                        console.error(INFINITE_LOOP_ERROR);
                        break;
                    }
                    if (state1.reset === true) {
                        state1.reset = false;
                        index = -1;
                        continue;
                    }
                    var _state$orderedModifie = state1.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {
                    } : _state$orderedModifie2, name = _state$orderedModifie.name;
                    if (typeof fn === 'function') state1 = fn({
                        state: state1,
                        options: _options,
                        name: name,
                        instance: instance
                    }) || state1;
                }
            },
            // Async and optimistically optimized update â€“ it will not be executed if
            // not necessary (debounced to run at most once-per-tick)
            update: _debounceJsDefault.default(function() {
                return new Promise(function(resolve) {
                    instance.forceUpdate();
                    resolve(state1);
                });
            }),
            destroy: function destroy() {
                cleanupModifierEffects();
                isDestroyed = true;
            }
        };
        if (!areValidElements(reference1, popper1)) {
            console.error(INVALID_ELEMENT_ERROR);
            return instance;
        }
        instance.setOptions(options1).then(function(state) {
            if (!isDestroyed && options1.onFirstUpdate) options1.onFirstUpdate(state);
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.
        function runModifierEffects() {
            state1.orderedModifiers.forEach(function(_ref3) {
                var name = _ref3.name, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {
                } : _ref3$options, effect = _ref3.effect;
                if (typeof effect === 'function') {
                    var cleanupFn = effect({
                        state: state1,
                        name: name,
                        instance: instance,
                        options: options
                    });
                    var noopFn = function noopFn() {
                    };
                    effectCleanupFns.push(cleanupFn || noopFn);
                }
            });
        }
        function cleanupModifierEffects() {
            effectCleanupFns.forEach(function(fn) {
                return fn();
            });
            effectCleanupFns = [];
        }
        return instance;
    };
}
var createPopper = /*#__PURE__*/ popperGenerator(); // eslint-disable-next-line import/no-unused-modules

},{"./dom-utils/getCompositeRect.js":"ijPls","./dom-utils/getLayoutRect.js":"jvjuf","./dom-utils/listScrollParents.js":"2di3T","./dom-utils/getOffsetParent.js":"laoYw","./dom-utils/getComputedStyle.js":"3mZjB","./utils/orderModifiers.js":"N0VO0","./utils/debounce.js":"g6Chr","./utils/validateModifiers.js":"1S5dQ","./utils/uniqueBy.js":"hhl2M","./utils/getBasePlacement.js":"59Wp3","./utils/mergeByName.js":"2zTVN","./utils/detectOverflow.js":"ltCuw","./dom-utils/instanceOf.js":"gYFUC","./enums.js":"lCAq5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ijPls":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getNodeScrollJs = require("./getNodeScroll.js");
var _getNodeScrollJsDefault = parcelHelpers.interopDefault(_getNodeScrollJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("./instanceOf.js");
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
var _mathJs = require("../utils/math.js");
function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = _mathJs.round(rect.width) / element.offsetWidth || 1;
    var scaleY = _mathJs.round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) isFixed = false;
    var isOffsetParentAnElement = _instanceOfJs.isHTMLElement(offsetParent);
    var offsetParentIsScaled = _instanceOfJs.isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = _getDocumentElementJsDefault.default(offsetParent);
    var rect = _getBoundingClientRectJsDefault.default(elementOrVirtualElement, offsetParentIsScaled);
    var scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    var offsets = {
        x: 0,
        y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (_getNodeNameJsDefault.default(offsetParent) !== 'body' || _isScrollParentJsDefault.default(documentElement)) scroll = _getNodeScrollJsDefault.default(offsetParent);
        if (_instanceOfJs.isHTMLElement(offsetParent)) {
            offsets = _getBoundingClientRectJsDefault.default(offsetParent, true);
            offsets.x += offsetParent.clientLeft;
            offsets.y += offsetParent.clientTop;
        } else if (documentElement) offsets.x = _getWindowScrollBarXJsDefault.default(documentElement);
    }
    return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
    };
}
exports.default = getCompositeRect;

},{"./getBoundingClientRect.js":"9CFSQ","./getNodeScroll.js":"bBjCr","./getNodeName.js":"a2Qom","./instanceOf.js":"gYFUC","./getWindowScrollBarX.js":"sz4Ld","./getDocumentElement.js":"eJ9Y1","./isScrollParent.js":"9rLGO","../utils/math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bBjCr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _instanceOfJs = require("./instanceOf.js");
var _getHTMLElementScrollJs = require("./getHTMLElementScroll.js");
var _getHTMLElementScrollJsDefault = parcelHelpers.interopDefault(_getHTMLElementScrollJs);
function getNodeScroll(node) {
    if (node === _getWindowJsDefault.default(node) || !_instanceOfJs.isHTMLElement(node)) return _getWindowScrollJsDefault.default(node);
    else return _getHTMLElementScrollJsDefault.default(node);
}
exports.default = getNodeScroll;

},{"./getWindowScroll.js":"1XUtN","./getWindow.js":"2SkOo","./instanceOf.js":"gYFUC","./getHTMLElementScroll.js":"6pwY2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6pwY2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getHTMLElementScroll(element) {
    return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
    };
}
exports.default = getHTMLElementScroll;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"N0VO0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js"); // source: https://stackoverflow.com/questions/49875255
function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
        map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively
    function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
            if (!visited.has(dep)) {
                var depModifier = map.get(dep);
                if (depModifier) sort(depModifier);
            }
        });
        result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) // check for visited object
        sort(modifier);
    });
    return result;
}
function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase
    return _enumsJs.modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
            return modifier.phase === phase;
        }));
    }, []);
}
exports.default = orderModifiers;

},{"../enums.js":"lCAq5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g6Chr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function debounce(fn) {
    var pending;
    return function() {
        if (!pending) pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
                pending = undefined;
                resolve(fn());
            });
        });
        return pending;
    };
}
exports.default = debounce;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1S5dQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _formatJs = require("./format.js");
var _formatJsDefault = parcelHelpers.interopDefault(_formatJs);
var _enumsJs = require("../enums.js");
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = [
    'name',
    'enabled',
    'phase',
    'fn',
    'effect',
    'requires',
    'options'
];
function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
        .filter(function(value, index, self) {
            return self.indexOf(value) === index;
        }).forEach(function(key) {
            switch(key){
                case 'name':
                    if (typeof modifier.name !== 'string') console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
                    break;
                case 'enabled':
                    if (typeof modifier.enabled !== 'boolean') console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
                    break;
                case 'phase':
                    if (_enumsJs.modifierPhases.indexOf(modifier.phase) < 0) console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + _enumsJs.modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
                    break;
                case 'fn':
                    if (typeof modifier.fn !== 'function') console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
                    break;
                case 'effect':
                    if (modifier.effect != null && typeof modifier.effect !== 'function') console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
                    break;
                case 'requires':
                    if (modifier.requires != null && !Array.isArray(modifier.requires)) console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
                    break;
                case 'requiresIfExists':
                    if (!Array.isArray(modifier.requiresIfExists)) console.error(_formatJsDefault.default(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
                    break;
                case 'options':
                case 'data':
                    break;
                default:
                    console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function(s) {
                        return "\"" + s + "\"";
                    }).join(', ') + "; but \"" + key + "\" was provided.");
            }
            modifier.requires && modifier.requires.forEach(function(requirement) {
                if (modifiers.find(function(mod) {
                    return mod.name === requirement;
                }) == null) console.error(_formatJsDefault.default(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
            });
        });
    });
}
exports.default = validateModifiers;

},{"./format.js":"baNIW","../enums.js":"lCAq5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"baNIW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function format(str) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
    return [].concat(args).reduce(function(p, c) {
        return p.replace(/%s/, c);
    }, str);
}
exports.default = format;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hhl2M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function uniqueBy(arr, fn) {
    var identifiers = new Set();
    return arr.filter(function(item) {
        var identifier = fn(item);
        if (!identifiers.has(identifier)) {
            identifiers.add(identifier);
            return true;
        }
    });
}
exports.default = uniqueBy;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2zTVN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function mergeByName(modifiers) {
    var merged1 = modifiers.reduce(function(merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({
        }, existing, current, {
            options: Object.assign({
            }, existing.options, current.options),
            data: Object.assign({
            }, existing.data, current.data)
        }) : current;
        return merged;
    }, {
    }); // IE11 does not support Object.values
    return Object.keys(merged1).map(function(key) {
        return merged1[key];
    });
}
exports.default = mergeByName;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1PuRF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPopper", ()=>createPopper
) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "popperGenerator", ()=>_createPopperJs.popperGenerator
);
parcelHelpers.export(exports, "defaultModifiers", ()=>defaultModifiers
);
parcelHelpers.export(exports, "detectOverflow", ()=>_createPopperJs.detectOverflow
);
parcelHelpers.export(exports, "createPopperLite", ()=>_popperLiteJs.createPopper
) // eslint-disable-next-line import/no-unused-modules
;
var _createPopperJs = require("./createPopper.js");
var _eventListenersJs = require("./modifiers/eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _popperOffsetsJs = require("./modifiers/popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _computeStylesJs = require("./modifiers/computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _applyStylesJs = require("./modifiers/applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var _offsetJs = require("./modifiers/offset.js");
var _offsetJsDefault = parcelHelpers.interopDefault(_offsetJs);
var _flipJs = require("./modifiers/flip.js");
var _flipJsDefault = parcelHelpers.interopDefault(_flipJs);
var _preventOverflowJs = require("./modifiers/preventOverflow.js");
var _preventOverflowJsDefault = parcelHelpers.interopDefault(_preventOverflowJs);
var _arrowJs = require("./modifiers/arrow.js");
var _arrowJsDefault = parcelHelpers.interopDefault(_arrowJs);
var _hideJs = require("./modifiers/hide.js");
var _hideJsDefault = parcelHelpers.interopDefault(_hideJs);
var _popperLiteJs = require("./popper-lite.js");
var _indexJs = require("./modifiers/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var defaultModifiers = [
    _eventListenersJsDefault.default,
    _popperOffsetsJsDefault.default,
    _computeStylesJsDefault.default,
    _applyStylesJsDefault.default,
    _offsetJsDefault.default,
    _flipJsDefault.default,
    _preventOverflowJsDefault.default,
    _arrowJsDefault.default,
    _hideJsDefault.default
];
var createPopper = /*#__PURE__*/ _createPopperJs.popperGenerator({
    defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":"cHuNp","./modifiers/eventListeners.js":"hBKsL","./modifiers/popperOffsets.js":"6I679","./modifiers/computeStyles.js":"gDlm2","./modifiers/applyStyles.js":"4iMn4","./modifiers/offset.js":"3GKVY","./modifiers/flip.js":"fv5wq","./modifiers/preventOverflow.js":"1AMhb","./modifiers/arrow.js":"31HFW","./modifiers/hide.js":"2g4OF","./popper-lite.js":false,"./modifiers/index.js":"cap3W","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3POmC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElPopperTrigger
);
var _vue = require("vue");
var _indexMjs = require("../../slot/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _popperMjs = require("./popper.mjs");
var _tokensMjs = require("./tokens.mjs");
var _utilsMjs = require("./utils.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _onlyChildMjs = require("../../slot/src/only-child.mjs");
var _onlyChildMjsDefault = parcelHelpers.interopDefault(_onlyChildMjs);
var _indexMjs2 = require("../../../hooks/use-forward-ref/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElPopperTrigger",
    components: {
        ElOnlyChild: _onlyChildMjsDefault.default
    },
    inheritAttrs: false,
    props: {
        ..._popperMjs.usePopperTriggerProps,
        onMouseenter: Function,
        onMouseleave: Function,
        onClick: Function,
        onKeydown: Function,
        onFocus: Function,
        onBlur: Function,
        onContextmenu: Function,
        id: String,
        open: Boolean
    },
    setup (props) {
        const { triggerRef  } = _vue.inject(_tokensMjs.POPPER_INJECTION_KEY, void 0);
        _indexMjs2.useForwardRef(triggerRef);
        _vue.watch(()=>props.virtualRef
        , (val)=>{
            if (val) triggerRef.value = _utilsMjs.unwrapMeasurableEl(val);
        }, {
            immediate: true
        });
        _vue.watch(()=>triggerRef.value
        , (el, prevEl)=>{
            if (el && el instanceof HTMLElement) [
                "onMouseenter",
                "onMouseleave",
                "onClick",
                "onKeydown",
                "onFocus",
                "onBlur",
                "onContextmenu"
            ].forEach((eventName)=>{
                const handler = props[eventName];
                if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    prevEl == null || prevEl.removeEventListener(eventName.slice(2).toLowerCase(), handler);
                }
            });
        }, {
            immediate: true
        });
        return {
            triggerRef
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_only_child = _vue.resolveComponent("el-only-child");
    return !_ctx.virtualTriggering ? (_vue.openBlock(), _vue.createBlock(_component_el_only_child, _vue.mergeProps({
        key: 0
    }, _ctx.$attrs, {
        "aria-describedby": _ctx.open ? _ctx.id : void 0
    }), {
        default: _vue.withCtx(()=>[
                _vue.renderSlot(_ctx.$slots, "default")
            ]
        ),
        _: 3
    }, 16, [
        "aria-describedby"
    ])) : _vue.createCommentVNode("v-if", true);
}
var ElPopperTrigger = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../slot/index.mjs":"95VyJ","../../../hooks/index.mjs":"1Ansp","./popper.mjs":"lCFux","./tokens.mjs":"cbHZm","./utils.mjs":"8wJef","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../slot/src/only-child.mjs":"4HiAq","../../../hooks/use-forward-ref/index.mjs":"eMx3i","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"95VyJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElOnlyChild", ()=>_onlyChildMjsDefault.default
);
var _onlyChildMjs = require("./src/only-child.mjs");
var _onlyChildMjsDefault = parcelHelpers.interopDefault(_onlyChildMjs);

},{"./src/only-child.mjs":"4HiAq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4HiAq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>OnlyChild
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../../hooks/use-forward-ref/index.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const NAME = "ElOnlyChild";
const OnlyChild = _vue.defineComponent({
    name: NAME,
    setup (_, { slots , attrs  }) {
        var _a;
        const forwardRefInjection = _vue.inject(_indexMjs2.FORWARD_REF_INJECTION_KEY, void 0);
        const forwardRefDirective = _indexMjs2.useForwardRefDirective((_a = forwardRefInjection.setForwardRef) != null ? _a : _shared.NOOP);
        return ()=>{
            var _a2;
            const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots, attrs);
            if (!defaultSlot) return null;
            if (defaultSlot.length > 1) {
                _errorMjs.debugWarn(NAME, "ElOnlyChild requires exact only one valid child.");
                return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
                _errorMjs.debugWarn(NAME, "no valid child node found");
                return null;
            }
            return _vue.withDirectives(_vue.cloneVNode(firstLegitNode, attrs), [
                [
                    forwardRefDirective
                ]
            ]);
        };
    }
});
function findFirstLegitChild(node) {
    if (!node) return null;
    const children = node;
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        if (_shared.isObject(child)) switch(child.type){
            case _vue.Comment:
                continue;
            case _vue.Text:
                return wrapTextContent(child);
            case _vue.Fragment:
                return findFirstLegitChild(child.children);
            default:
                return child;
        }
        return wrapTextContent(child);
    }
    return null;
}
function wrapTextContent(s) {
    return _vue.h("span", {
        class: "el-only-child__content"
    }, [
        s
    ]);
}

},{"vue":"gzxs9","@vue/shared":"3SM3y","../../../hooks/index.mjs":"1Ansp","../../../utils/index.mjs":"dsdeP","../../../hooks/use-forward-ref/index.mjs":"eMx3i","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8wJef":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildPopperOptions", ()=>buildPopperOptions
);
parcelHelpers.export(exports, "unwrapMeasurableEl", ()=>unwrapMeasurableEl
);
const buildPopperOptions = (props, arrowProps)=>{
    const { placement , strategy , popperOptions  } = props;
    const options = {
        placement,
        strategy,
        ...popperOptions,
        modifiers: genModifiers(props)
    };
    attachArrow(options, arrowProps);
    deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
    return options;
};
const unwrapMeasurableEl = ($el)=>{
    let el = null;
    if (!$el) return null;
    if ("getBoundingClientRect" in $el || $el instanceof HTMLElement) el = $el;
    else el = $el.$el;
    return el;
};
function genModifiers(options) {
    const { offset , gpuAcceleration , fallbackPlacements  } = options;
    return [
        {
            name: "offset",
            options: {
                offset: [
                    0,
                    offset != null ? offset : 12
                ]
            }
        },
        {
            name: "preventOverflow",
            options: {
                padding: {
                    top: 2,
                    bottom: 2,
                    left: 5,
                    right: 5
                }
            }
        },
        {
            name: "flip",
            options: {
                padding: 5,
                fallbackPlacements: fallbackPlacements != null ? fallbackPlacements : []
            }
        },
        {
            name: "computeStyles",
            options: {
                gpuAcceleration,
                adaptive: gpuAcceleration
            }
        }
    ];
}
function attachArrow(options, { arrowEl , arrowOffset  }) {
    options.modifiers.push({
        name: "arrow",
        options: {
            element: arrowEl,
            padding: arrowOffset != null ? arrowOffset : 5
        }
    });
}
function deriveExtraModifiers(options, modifiers) {
    if (modifiers) options.modifiers = [
        ...options.modifiers,
        ...modifiers != null ? modifiers : []
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lN2o5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElPopperContent
);
var _vue = require("vue");
var _core = require("@popperjs/core");
var _indexMjs = require("../../../hooks/index.mjs");
var _tokensMjs = require("./tokens.mjs");
var _popperMjs = require("./popper.mjs");
var _utilsMjs = require("./utils.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-z-index/index.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElPopperContent",
    props: _popperMjs.usePopperContentProps,
    emits: [
        "mouseenter",
        "mouseleave"
    ],
    setup (props) {
        const { triggerRef , popperInstanceRef , contentRef  } = _vue.inject(_tokensMjs.POPPER_INJECTION_KEY, void 0);
        const { nextZIndex  } = _indexMjs1.useZIndex();
        const ns = _indexMjs2.useNamespace("popper");
        const popperContentRef = _vue.ref(null);
        const arrowRef = _vue.ref(null);
        const arrowOffset = _vue.ref();
        _vue.provide(_tokensMjs.POPPER_CONTENT_INJECTION_KEY, {
            arrowRef,
            arrowOffset
        });
        const contentZIndex = _vue.ref(props.zIndex || nextZIndex());
        const contentStyle = _vue.computed(()=>[
                {
                    zIndex: _vue.unref(contentZIndex)
                },
                props.popperStyle
            ]
        );
        const contentClass = _vue.computed(()=>[
                ns.b(),
                ns.is("pure", props.pure),
                ns.is(props.effect),
                props.popperClass
            ]
        );
        const createPopperInstance = ({ referenceEl , popperContentEl , arrowEl  })=>{
            const options = _utilsMjs.buildPopperOptions(props, {
                arrowEl,
                arrowOffset: _vue.unref(arrowOffset)
            });
            return _core.createPopper(referenceEl, popperContentEl, options);
        };
        const updatePopper = ()=>{
            var _a;
            (_a = _vue.unref(popperInstanceRef)) == null || _a.update();
            contentZIndex.value = props.zIndex || nextZIndex();
        };
        _vue.onMounted(()=>{
            let updateHandle;
            _vue.watch(()=>_utilsMjs.unwrapMeasurableEl(props.referenceEl) || _vue.unref(triggerRef)
            , (val)=>{
                var _a;
                updateHandle == null || updateHandle();
                if (val) {
                    (_a = popperInstanceRef.value) == null || _a.destroy();
                    const popperContentEl = _vue.unref(popperContentRef);
                    contentRef.value = popperContentEl;
                    const arrowEl = _vue.unref(arrowRef);
                    const newInstance = createPopperInstance({
                        referenceEl: val,
                        popperContentEl: _vue.unref(popperContentRef),
                        arrowEl
                    });
                    popperInstanceRef.value = newInstance;
                    updateHandle = _vue.watch(()=>val.getBoundingClientRect()
                    , ()=>{
                        updatePopper();
                    }, {
                        immediate: true
                    });
                } else popperInstanceRef.value = null;
            }, {
                immediate: true
            });
            _vue.watch(()=>_utilsMjs.buildPopperOptions(props, {
                    arrowEl: _vue.unref(arrowRef),
                    arrowOffset: _vue.unref(arrowOffset)
                })
            , (option)=>{
                var _a;
                return (_a = popperInstanceRef.value) == null ? void 0 : _a.setOptions(option);
            });
        });
        return {
            ns,
            popperContentRef,
            popperInstanceRef,
            contentStyle,
            contentClass,
            updatePopper
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "popperContentRef",
        style: _vue.normalizeStyle(_ctx.contentStyle),
        class: _vue.normalizeClass(_ctx.contentClass),
        role: "tooltip",
        onMouseenter: _cache[0] || (_cache[0] = (e)=>_ctx.$emit("mouseenter", e)
        ),
        onMouseleave: _cache[1] || (_cache[1] = (e)=>_ctx.$emit("mouseleave", e)
        )
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 38);
}
var ElPopperContent = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@popperjs/core":"7unqC","../../../hooks/index.mjs":"1Ansp","./tokens.mjs":"cbHZm","./popper.mjs":"lCFux","./utils.mjs":"8wJef","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-z-index/index.mjs":"7aKZA","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jm0Kb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useDeprecateAppendToBody", ()=>useDeprecateAppendToBody
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _core = require("@vueuse/core");
var _indexMjs2 = require("../../../hooks/use-deprecated/index.mjs");
function useDeprecateAppendToBody(scope, from) {
    const vm = _vue.getCurrentInstance();
    const compatTeleported = _vue.computed(()=>{
        return _core.isBoolean(vm.props[from]) ? vm.props[from] : vm.props.teleported;
    });
    _indexMjs2.useDeprecated({
        scope,
        from,
        replacement: "teleported",
        version: "2.1.0",
        ref: "https://element-plus.org/en-US/component/tooltip.html#attributes"
    }, _vue.computed(()=>_core.isBoolean(vm.props[from])
    ));
    return {
        compatTeleported
    };
}

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../utils/index.mjs":"dsdeP","@vueuse/core":"eEHP9","../../../hooks/use-deprecated/index.mjs":"4fitg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5JkjD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElTooltipContent
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../popper/index.mjs");
var _indexMjs1 = require("../../visual-hidden/index.mjs");
var _indexMjs2 = require("../../../utils/index.mjs");
var _indexMjs3 = require("../../../hooks/index.mjs");
var _tooltipMjs = require("./tooltip.mjs");
var _tokensMjs = require("./tokens.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _contentMjs = require("../../popper/src/content.mjs");
var _contentMjsDefault = parcelHelpers.interopDefault(_contentMjs);
var _visualHiddenMjs = require("../../visual-hidden/src/visual-hidden.mjs");
var _visualHiddenMjsDefault = parcelHelpers.interopDefault(_visualHiddenMjs);
var _indexMjs4 = require("../../../hooks/use-escape-keydown/index.mjs");
var _eventMjs = require("../../../utils/dom/event.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElTooltipContent",
    components: {
        ElPopperContent: _contentMjsDefault.default,
        ElVisuallyHidden: _visualHiddenMjsDefault.default
    },
    inheritAttrs: false,
    props: _tooltipMjs.useTooltipContentProps,
    setup (props) {
        const contentRef = _vue.ref(null);
        const intermediateOpen = _vue.ref(false);
        const entering = _vue.ref(false);
        const leaving = _vue.ref(false);
        const { controlled , id , open , trigger , onClose , onOpen , onShow , onHide  } = _vue.inject(_tokensMjs.TOOLTIP_INJECTION_KEY, void 0);
        const persistentRef = _vue.computed(()=>{
            return props.persistent;
        });
        const shouldRender = _vue.computed(()=>{
            return _vue.unref(persistentRef) ? true : _vue.unref(open);
        });
        const shouldShow = _vue.computed(()=>{
            return props.disabled ? false : _vue.unref(open);
        });
        const contentStyle = _vue.computed(()=>{
            var _a;
            return (_a = props.style) != null ? _a : {
            };
        });
        const ariaHidden = _vue.computed(()=>!_vue.unref(open)
        );
        _indexMjs4.useEscapeKeydown(onClose);
        const onTransitionLeave = ()=>{
            onHide();
        };
        const stopWhenControlled = ()=>{
            if (_vue.unref(controlled)) return true;
        };
        const onContentEnter = _eventMjs.composeEventHandlers(stopWhenControlled, ()=>{
            if (props.enterable && _vue.unref(trigger) === "hover") onOpen();
        });
        const onContentLeave = _eventMjs.composeEventHandlers(stopWhenControlled, ()=>{
            if (_vue.unref(trigger) === "hover") onClose();
        });
        const onBeforeEnter = ()=>{
            var _a, _b;
            (_b = (_a = contentRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
        };
        const onAfterShow = ()=>{
            onShow();
        };
        let stopHandle;
        _vue.watch(()=>_vue.unref(open)
        , (val)=>{
            if (val) stopHandle = _core.onClickOutside(_vue.computed(()=>{
                var _a;
                return (_a = contentRef.value) == null ? void 0 : _a.popperContentRef;
            }), ()=>{
                if (_vue.unref(controlled)) return;
                const $trigger = _vue.unref(trigger);
                if ($trigger !== "hover") onClose();
            });
            else stopHandle == null || stopHandle();
        }, {
            flush: "post"
        });
        return {
            ariaHidden,
            entering,
            leaving,
            id,
            intermediateOpen,
            contentStyle,
            contentRef,
            shouldRender,
            shouldShow,
            open,
            onAfterShow,
            onBeforeEnter,
            onContentEnter,
            onContentLeave,
            onTransitionLeave
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_visually_hidden = _vue.resolveComponent("el-visually-hidden");
    const _component_el_popper_content = _vue.resolveComponent("el-popper-content");
    return _vue.openBlock(), _vue.createBlock(_vue.Teleport, {
        disabled: !_ctx.teleported,
        to: _ctx.appendTo
    }, [
        _vue.createVNode(_vue.Transition, {
            name: _ctx.transition,
            onAfterLeave: _ctx.onTransitionLeave,
            onBeforeEnter: _ctx.onBeforeEnter,
            onAfterEnter: _ctx.onAfterShow
        }, {
            default: _vue.withCtx(()=>[
                    _ctx.shouldRender ? _vue.withDirectives((_vue.openBlock(), _vue.createBlock(_component_el_popper_content, _vue.mergeProps({
                        key: 0,
                        ref: "contentRef"
                    }, _ctx.$attrs, {
                        "aria-hidden": _ctx.ariaHidden,
                        "boundaries-padding": _ctx.boundariesPadding,
                        "fallback-placements": _ctx.fallbackPlacements,
                        "gpu-acceleration": _ctx.gpuAcceleration,
                        offset: _ctx.offset,
                        placement: _ctx.placement,
                        "popper-options": _ctx.popperOptions,
                        strategy: _ctx.strategy,
                        effect: _ctx.effect,
                        enterable: _ctx.enterable,
                        pure: _ctx.pure,
                        "popper-class": _ctx.popperClass,
                        "popper-style": [
                            _ctx.popperStyle,
                            _ctx.contentStyle
                        ],
                        "reference-el": _ctx.referenceEl,
                        "z-index": _ctx.zIndex,
                        onMouseenter: _ctx.onContentEnter,
                        onMouseleave: _ctx.onContentLeave
                    }), {
                        default: _vue.withCtx(()=>[
                                _vue.renderSlot(_ctx.$slots, "default"),
                                _vue.createVNode(_component_el_visually_hidden, {
                                    id: _ctx.id,
                                    role: "tooltip"
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createTextVNode(_vue.toDisplayString(_ctx.ariaLabel), 1)
                                        ]
                                    ),
                                    _: 1
                                }, 8, [
                                    "id"
                                ])
                            ]
                        ),
                        _: 3
                    }, 16, [
                        "aria-hidden",
                        "boundaries-padding",
                        "fallback-placements",
                        "gpu-acceleration",
                        "offset",
                        "placement",
                        "popper-options",
                        "strategy",
                        "effect",
                        "enterable",
                        "pure",
                        "popper-class",
                        "popper-style",
                        "reference-el",
                        "z-index",
                        "onMouseenter",
                        "onMouseleave"
                    ])), [
                        [
                            _vue.vShow,
                            _ctx.shouldShow
                        ]
                    ]) : _vue.createCommentVNode("v-if", true)
                ]
            ),
            _: 3
        }, 8, [
            "name",
            "onAfterLeave",
            "onBeforeEnter",
            "onAfterEnter"
        ])
    ], 8, [
        "disabled",
        "to"
    ]);
}
var ElTooltipContent = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../popper/index.mjs":"kIV7g","../../visual-hidden/index.mjs":"e7ZSX","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./tooltip.mjs":"7LVFi","./tokens.mjs":"a6G79","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../popper/src/content.mjs":"lN2o5","../../visual-hidden/src/visual-hidden.mjs":"eQMhl","../../../hooks/use-escape-keydown/index.mjs":"5NOQk","../../../utils/dom/event.mjs":"fnXSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e7ZSX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElVisuallyHidden", ()=>_visualHiddenMjsDefault.default
);
parcelHelpers.export(exports, "default", ()=>_visualHiddenMjsDefault.default
);
var _visualHiddenMjs = require("./src/visual-hidden.mjs");
var _visualHiddenMjsDefault = parcelHelpers.interopDefault(_visualHiddenMjs);

},{"./src/visual-hidden.mjs":"eQMhl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eQMhl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElVisuallyHidden
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ElVisuallyHidden",
    props: {
        style: {
            type: [
                String,
                Object,
                Array
            ]
        }
    },
    setup (props) {
        return {
            computedStyle: _vue.computed(()=>{
                return [
                    props.style,
                    {
                        position: "absolute",
                        border: 0,
                        width: 1,
                        height: 1,
                        padding: 0,
                        margin: -1,
                        overflow: "hidden",
                        clip: "rect(0, 0, 0, 0)",
                        whiteSpace: "nowrap",
                        wordWrap: "normal"
                    }
                ];
            })
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("span", _vue.mergeProps(_ctx.$attrs, {
        style: _ctx.computedStyle
    }), null, 16);
}
var ElVisuallyHidden = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7LVFi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useTooltipContentProps", ()=>useTooltipContentProps
);
parcelHelpers.export(exports, "useTooltipProps", ()=>useTooltipProps
);
parcelHelpers.export(exports, "useTooltipTriggerProps", ()=>useTooltipTriggerProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../popper/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _indexMjs3 = require("../../../hooks/use-delayed-toggle/index.mjs");
var _popperMjs = require("../../popper/src/popper.mjs");
var _indexMjs4 = require("../../../hooks/use-popper-container/index.mjs");
const triggers = [
    "hover",
    "focus",
    "click",
    "contextmenu"
];
const useTooltipContentProps = _propsMjs.buildProps({
    ..._indexMjs3.useDelayedToggleProps,
    ..._popperMjs.usePopperContentProps,
    appendTo: {
        type: _propsMjs.definePropType([
            String,
            Object
        ]),
        default: _indexMjs4.POPPER_CONTAINER_SELECTOR
    },
    content: {
        type: String,
        default: ""
    },
    rawContent: {
        type: Boolean,
        default: false
    },
    persistent: Boolean,
    ariaLabel: String,
    visible: {
        type: _propsMjs.definePropType(Boolean),
        default: null
    },
    transition: {
        type: String,
        default: "el-fade-in-linear"
    },
    teleported: {
        type: Boolean,
        default: true
    },
    disabled: {
        type: Boolean
    }
});
const useTooltipTriggerProps = _propsMjs.buildProps({
    ..._popperMjs.usePopperTriggerProps,
    disabled: Boolean,
    trigger: {
        type: _propsMjs.definePropType([
            String,
            Array
        ]),
        default: "hover"
    }
});
const useTooltipProps = _propsMjs.buildProps({
    openDelay: {
        type: Number
    },
    visibleArrow: {
        type: Boolean,
        default: void 0
    },
    hideAfter: {
        type: Number,
        default: 200
    },
    showArrow: {
        type: Boolean,
        default: true
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../popper/index.mjs":"kIV7g","../../../hooks/index.mjs":"1Ansp","../../../utils/vue/props.mjs":"cpwWK","../../../hooks/use-delayed-toggle/index.mjs":"jbu1G","../../popper/src/popper.mjs":"lCFux","../../../hooks/use-popper-container/index.mjs":"hz53M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a6G79":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TOOLTIP_INJECTION_KEY", ()=>TOOLTIP_INJECTION_KEY
);
const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eOwiG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElTooltipTrigger
);
var _vue = require("vue");
var _indexMjs = require("../../popper/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../../constants/index.mjs");
var _indexMjs3 = require("../../../hooks/index.mjs");
var _tokensMjs = require("./tokens.mjs");
var _tooltipMjs = require("./tooltip.mjs");
var _utilsMjs = require("./utils.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _triggerMjs = require("../../popper/src/trigger.mjs");
var _triggerMjsDefault = parcelHelpers.interopDefault(_triggerMjs);
var _indexMjs4 = require("../../../hooks/use-namespace/index.mjs");
var _eventMjs = require("../../../utils/dom/event.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElTooltipTrigger",
    components: {
        ElPopperTrigger: _triggerMjsDefault.default
    },
    props: _tooltipMjs.useTooltipTriggerProps,
    setup (props) {
        const ns = _indexMjs4.useNamespace("tooltip");
        const { controlled , id , open , onOpen , onClose , onToggle  } = _vue.inject(_tokensMjs.TOOLTIP_INJECTION_KEY, void 0);
        const triggerRef = _vue.ref(null);
        const stopWhenControlledOrDisabled = ()=>{
            if (_vue.unref(controlled) || props.disabled) return true;
        };
        const trigger = _vue.toRef(props, "trigger");
        const onMouseenter = _eventMjs.composeEventHandlers(stopWhenControlledOrDisabled, _utilsMjs.whenTrigger(trigger, "hover", onOpen));
        const onMouseleave = _eventMjs.composeEventHandlers(stopWhenControlledOrDisabled, _utilsMjs.whenTrigger(trigger, "hover", onClose));
        const onClick = _eventMjs.composeEventHandlers(stopWhenControlledOrDisabled, _utilsMjs.whenTrigger(trigger, "click", (e)=>{
            if (e.button === 0) onToggle(e);
        }));
        const onFocus = _eventMjs.composeEventHandlers(stopWhenControlledOrDisabled, _utilsMjs.whenTrigger(trigger, "focus", onOpen));
        const onBlur = _eventMjs.composeEventHandlers(stopWhenControlledOrDisabled, _utilsMjs.whenTrigger(trigger, "focus", onClose));
        const onContextMenu = _eventMjs.composeEventHandlers(stopWhenControlledOrDisabled, _utilsMjs.whenTrigger(trigger, "contextmenu", (e)=>{
            e.preventDefault();
            onToggle(e);
        }));
        const onKeydown = _eventMjs.composeEventHandlers(stopWhenControlledOrDisabled, (e)=>{
            const { code  } = e;
            if (code === _ariaMjs.EVENT_CODE.enter || code === _ariaMjs.EVENT_CODE.space) onToggle(e);
        });
        return {
            onBlur,
            onContextMenu,
            onFocus,
            onMouseenter,
            onMouseleave,
            onClick,
            onKeydown,
            open,
            id,
            triggerRef,
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_popper_trigger = _vue.resolveComponent("el-popper-trigger");
    return _vue.openBlock(), _vue.createBlock(_component_el_popper_trigger, {
        id: _ctx.id,
        "virtual-ref": _ctx.virtualRef,
        open: _ctx.open,
        "virtual-triggering": _ctx.virtualTriggering,
        class: _vue.normalizeClass(_ctx.ns.e("trigger")),
        onBlur: _ctx.onBlur,
        onClick: _ctx.onClick,
        onContextmenu: _ctx.onContextMenu,
        onFocus: _ctx.onFocus,
        onMouseenter: _ctx.onMouseenter,
        onMouseleave: _ctx.onMouseleave,
        onKeydown: _ctx.onKeydown
    }, {
        default: _vue.withCtx(()=>[
                _vue.renderSlot(_ctx.$slots, "default")
            ]
        ),
        _: 3
    }, 8, [
        "id",
        "virtual-ref",
        "open",
        "virtual-triggering",
        "class",
        "onBlur",
        "onClick",
        "onContextmenu",
        "onFocus",
        "onMouseenter",
        "onMouseleave",
        "onKeydown"
    ]);
}
var ElTooltipTrigger = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../popper/index.mjs":"kIV7g","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../../hooks/index.mjs":"1Ansp","./tokens.mjs":"a6G79","./tooltip.mjs":"7LVFi","./utils.mjs":"b2HHe","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../popper/src/trigger.mjs":"3POmC","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/dom/event.mjs":"fnXSh","../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b2HHe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isTriggerType", ()=>isTriggerType
);
parcelHelpers.export(exports, "whenTrigger", ()=>whenTrigger
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _shared = require("@vue/shared");
const isTriggerType = (trigger, type)=>{
    if (_shared.isArray(trigger)) return trigger.includes(type);
    return trigger === type;
};
const whenTrigger = (trigger, type, handler)=>{
    return (e)=>{
        isTriggerType(_vue.unref(trigger), type) && handler(e);
    };
};

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"edhpQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "avatarEmits", ()=>_avatarMjs.avatarEmits
);
parcelHelpers.export(exports, "avatarProps", ()=>_avatarMjs.avatarProps
);
parcelHelpers.export(exports, "ElAvatar", ()=>ElAvatar
);
parcelHelpers.export(exports, "default", ()=>ElAvatar
);
var _indexMjs = require("../../utils/index.mjs");
var _avatar2Mjs = require("./src/avatar2.mjs");
var _avatar2MjsDefault = parcelHelpers.interopDefault(_avatar2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _avatarMjs = require("./src/avatar.mjs");
const ElAvatar = _installMjs.withInstall(_avatar2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/avatar2.mjs":"4ZeV7","../../utils/vue/install.mjs":"4TMmv","./src/avatar.mjs":"aSZOT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ZeV7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Avatar
);
var _vue = require("vue");
var _indexMjs = require("../../icon/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _indexMjs2 = require("../../../utils/index.mjs");
var _avatarMjs = require("./avatar.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
var _shared = require("@vue/shared");
var _core = require("@vueuse/core");
var _styleMjs = require("../../../utils/vue/style.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElAvatar",
    components: {
        ElIcon: _indexMjs.ElIcon
    },
    props: _avatarMjs.avatarProps,
    emits: _avatarMjs.avatarEmits,
    setup (props, { emit  }) {
        const ns = _indexMjs3.useNamespace("avatar");
        const hasLoadError = _vue.ref(false);
        const avatarClass = _vue.computed(()=>{
            const { size , icon , shape  } = props;
            const classList = [
                ns.b()
            ];
            if (_shared.isString(size)) classList.push(ns.m(size));
            if (icon) classList.push(ns.m("icon"));
            if (shape) classList.push(ns.m(shape));
            return classList;
        });
        const sizeStyle = _vue.computed(()=>{
            const { size  } = props;
            return _core.isNumber(size) ? {
                "--el-avatar-size": _styleMjs.addUnit(size)
            } : void 0;
        });
        const fitStyle = _vue.computed(()=>({
                objectFit: props.fit
            })
        );
        _vue.watch(()=>props.src
        , ()=>hasLoadError.value = false
        );
        function handleError(e) {
            hasLoadError.value = true;
            emit("error", e);
        }
        return {
            hasLoadError,
            avatarClass,
            sizeStyle,
            fitStyle,
            handleError
        };
    }
});
const _hoisted_1 = [
    "src",
    "alt",
    "srcset"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    return _vue.openBlock(), _vue.createElementBlock("span", {
        class: _vue.normalizeClass(_ctx.avatarClass),
        style: _vue.normalizeStyle(_ctx.sizeStyle)
    }, [
        (_ctx.src || _ctx.srcSet) && !_ctx.hasLoadError ? (_vue.openBlock(), _vue.createElementBlock("img", {
            key: 0,
            src: _ctx.src,
            alt: _ctx.alt,
            srcset: _ctx.srcSet,
            style: _vue.normalizeStyle(_ctx.fitStyle),
            onError: _cache[0] || (_cache[0] = (...args)=>_ctx.handleError && _ctx.handleError(...args)
            )
        }, null, 44, _hoisted_1)) : _ctx.icon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
            key: 1
        }, {
            default: _vue.withCtx(()=>[
                    (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.icon)))
                ]
            ),
            _: 1
        })) : _vue.renderSlot(_ctx.$slots, "default", {
            key: 2
        })
    ], 6);
}
var Avatar = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../icon/index.mjs":"hnNTG","../../../hooks/index.mjs":"1Ansp","../../../utils/index.mjs":"dsdeP","./avatar.mjs":"aSZOT","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@vue/shared":"3SM3y","@vueuse/core":"eEHP9","../../../utils/vue/style.mjs":"pODHb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aSZOT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "avatarEmits", ()=>avatarEmits
);
parcelHelpers.export(exports, "avatarProps", ()=>avatarProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
const avatarProps = _propsMjs.buildProps({
    size: {
        type: [
            Number,
            String
        ],
        values: [
            "large",
            "default",
            "small"
        ],
        default: "default",
        validator: (val)=>typeof val === "number"
    },
    shape: {
        type: String,
        values: [
            "circle",
            "square"
        ],
        default: "circle"
    },
    icon: {
        type: _iconMjs.iconPropType
    },
    src: {
        type: String,
        default: ""
    },
    alt: String,
    srcSet: String,
    fit: {
        type: _propsMjs.definePropType(String),
        default: "cover"
    }
});
const avatarEmits = {
    error: (evt)=>evt instanceof Event
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","../../../utils/vue/icon.mjs":"3YbE5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iA9M1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "backtopEmits", ()=>_backtopMjs.backtopEmits
);
parcelHelpers.export(exports, "backtopProps", ()=>_backtopMjs.backtopProps
);
parcelHelpers.export(exports, "ElBacktop", ()=>ElBacktop
);
parcelHelpers.export(exports, "default", ()=>ElBacktop
);
var _indexMjs = require("../../utils/index.mjs");
var _backtop2Mjs = require("./src/backtop2.mjs");
var _backtop2MjsDefault = parcelHelpers.interopDefault(_backtop2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _backtopMjs = require("./src/backtop.mjs");
const ElBacktop = _installMjs.withInstall(_backtop2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/backtop2.mjs":"dsm4W","../../utils/vue/install.mjs":"4TMmv","./src/backtop.mjs":"9ygQ4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dsm4W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Backtop
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../icon/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _backtopMjs = require("./backtop.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
var _animationMjs = require("../../../utils/animation.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const COMPONENT_NAME = "ElBacktop";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    components: {
        ElIcon: _indexMjs.ElIcon,
        CaretTop: _iconsVue.CaretTop
    },
    props: _backtopMjs.backtopProps,
    emits: _backtopMjs.backtopEmits,
    setup (props, { emit  }) {
        const ns = _indexMjs3.useNamespace("backtop");
        const el = _vue.shallowRef(document.documentElement);
        const container = _vue.shallowRef(document);
        const visible = _vue.ref(false);
        const styleBottom = _vue.computed(()=>`${props.bottom}px`
        );
        const styleRight = _vue.computed(()=>`${props.right}px`
        );
        const scrollToTop = ()=>{
            if (!el.value) return;
            const beginTime = Date.now();
            const beginValue = el.value.scrollTop;
            const frameFunc = ()=>{
                if (!el.value) return;
                const progress = (Date.now() - beginTime) / 500;
                if (progress < 1) {
                    el.value.scrollTop = beginValue * (1 - _animationMjs.easeInOutCubic(progress));
                    requestAnimationFrame(frameFunc);
                } else el.value.scrollTop = 0;
            };
            requestAnimationFrame(frameFunc);
        };
        const handleScroll = ()=>{
            if (el.value) visible.value = el.value.scrollTop >= props.visibilityHeight;
        };
        const handleClick = (event)=>{
            scrollToTop();
            emit("click", event);
        };
        const handleScrollThrottled = _core.useThrottleFn(handleScroll, 300);
        _vue.onMounted(()=>{
            var _a;
            if (props.target) {
                el.value = (_a = document.querySelector(props.target)) != null ? _a : void 0;
                if (!el.value) _errorMjs.throwError(COMPONENT_NAME, `target is not existed: ${props.target}`);
                container.value = el.value;
            }
            _core.useEventListener(container, "scroll", handleScrollThrottled);
        });
        return {
            visible,
            styleBottom,
            styleRight,
            handleClick,
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_caret_top = _vue.resolveComponent("caret-top");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    return _vue.openBlock(), _vue.createBlock(_vue.Transition, {
        name: `${_ctx.ns.namespace.value}-fade-in`
    }, {
        default: _vue.withCtx(()=>[
                _ctx.visible ? (_vue.openBlock(), _vue.createElementBlock("div", {
                    key: 0,
                    style: _vue.normalizeStyle({
                        right: _ctx.styleRight,
                        bottom: _ctx.styleBottom
                    }),
                    class: _vue.normalizeClass(_ctx.ns.b()),
                    onClick: _cache[0] || (_cache[0] = _vue.withModifiers((...args)=>_ctx.handleClick && _ctx.handleClick(...args)
                    , [
                        "stop"
                    ]))
                }, [
                    _vue.renderSlot(_ctx.$slots, "default", {
                    }, ()=>[
                            _vue.createVNode(_component_el_icon, {
                                class: _vue.normalizeClass(_ctx.ns.e("icon"))
                            }, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_caret_top)
                                    ]
                                ),
                                _: 1
                            }, 8, [
                                "class"
                            ])
                        ]
                    )
                ], 6)) : _vue.createCommentVNode("v-if", true)
            ]
        ),
        _: 3
    }, 8, [
        "name"
    ]);
}
var Backtop = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../icon/index.mjs":"hnNTG","../../../utils/index.mjs":"dsdeP","@element-plus/icons-vue":"b18uu","../../../hooks/index.mjs":"1Ansp","./backtop.mjs":"9ygQ4","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/animation.mjs":"kaKZY","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9ygQ4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "backtopEmits", ()=>backtopEmits
);
parcelHelpers.export(exports, "backtopProps", ()=>backtopProps
);
const backtopProps = {
    visibilityHeight: {
        type: Number,
        default: 200
    },
    target: {
        type: String,
        default: ""
    },
    right: {
        type: Number,
        default: 40
    },
    bottom: {
        type: Number,
        default: 40
    }
};
const backtopEmits = {
    click: (evt)=>evt instanceof MouseEvent
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gvyeW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "badgeProps", ()=>_badgeMjs.badgeProps
);
parcelHelpers.export(exports, "ElBadge", ()=>ElBadge
);
parcelHelpers.export(exports, "default", ()=>ElBadge
);
var _indexMjs = require("../../utils/index.mjs");
var _badge2Mjs = require("./src/badge2.mjs");
var _badge2MjsDefault = parcelHelpers.interopDefault(_badge2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _badgeMjs = require("./src/badge.mjs");
const ElBadge = _installMjs.withInstall(_badge2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/badge2.mjs":"j8MBj","../../utils/vue/install.mjs":"4TMmv","./src/badge.mjs":"4pSua","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j8MBj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Badge
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _badgeMjs = require("./badge.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElBadge",
    props: _badgeMjs.badgeProps,
    setup (props) {
        const ns = _indexMjs1.useNamespace("badge");
        const content = _vue.computed(()=>{
            if (props.isDot) return "";
            if (typeof props.value === "number" && typeof props.max === "number") return props.max < props.value ? `${props.max}+` : `${props.value}`;
            return `${props.value}`;
        });
        return {
            ns,
            content
        };
    }
});
const _hoisted_1 = [
    "textContent"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.ns.b())
    }, [
        _vue.renderSlot(_ctx.$slots, "default"),
        _vue.createVNode(_vue.Transition, {
            name: `${_ctx.ns.namespace.value}-zoom-in-center`
        }, {
            default: _vue.withCtx(()=>[
                    _vue.withDirectives(_vue.createElementVNode("sup", {
                        class: _vue.normalizeClass([
                            _ctx.ns.e("content"),
                            _ctx.ns.em("content", _ctx.type),
                            _ctx.ns.is("fixed", !!_ctx.$slots.default),
                            _ctx.ns.is("dot", _ctx.isDot)
                        ]),
                        textContent: _vue.toDisplayString(_ctx.content)
                    }, null, 10, _hoisted_1), [
                        [
                            _vue.vShow,
                            !_ctx.hidden && (_ctx.content || _ctx.content === "0" || _ctx.isDot)
                        ]
                    ])
                ]
            ),
            _: 1
        }, 8, [
            "name"
        ])
    ], 2);
}
var Badge = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./badge.mjs":"4pSua","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4pSua":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "badgeProps", ()=>badgeProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const badgeProps = _propsMjs.buildProps({
    value: {
        type: [
            String,
            Number
        ],
        default: ""
    },
    max: {
        type: Number,
        default: 99
    },
    isDot: Boolean,
    hidden: Boolean,
    type: {
        type: String,
        values: [
            "primary",
            "success",
            "warning",
            "info",
            "danger"
        ],
        default: "danger"
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6p9GR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "breadcrumbProps", ()=>_breadcrumbMjs.breadcrumbProps
);
parcelHelpers.export(exports, "breadcrumbItemProps", ()=>_breadcrumbItemMjs.breadcrumbItemProps
);
parcelHelpers.export(exports, "ElBreadcrumb", ()=>ElBreadcrumb
);
parcelHelpers.export(exports, "ElBreadcrumbItem", ()=>ElBreadcrumbItem
);
parcelHelpers.export(exports, "default", ()=>ElBreadcrumb
);
var _indexMjs = require("../../utils/index.mjs");
var _breadcrumb2Mjs = require("./src/breadcrumb2.mjs");
var _breadcrumb2MjsDefault = parcelHelpers.interopDefault(_breadcrumb2Mjs);
var _breadcrumbItem2Mjs = require("./src/breadcrumb-item2.mjs");
var _breadcrumbItem2MjsDefault = parcelHelpers.interopDefault(_breadcrumbItem2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _breadcrumbMjs = require("./src/breadcrumb.mjs");
var _breadcrumbItemMjs = require("./src/breadcrumb-item.mjs");
const ElBreadcrumb = _installMjs.withInstall(_breadcrumb2MjsDefault.default, {
    BreadcrumbItem: _breadcrumbItem2MjsDefault.default
});
const ElBreadcrumbItem = _installMjs.withNoopInstall(_breadcrumbItem2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/breadcrumb2.mjs":"94V5f","./src/breadcrumb-item2.mjs":"3edxq","../../utils/vue/install.mjs":"4TMmv","./src/breadcrumb.mjs":"iV9UH","./src/breadcrumb-item.mjs":"5U0qo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"94V5f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Breadcrumb
);
var _vue = require("vue");
var _indexMjs = require("../../../tokens/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _breadcrumbMjs = require("./breadcrumb.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
var _breadcrumbMjs1 = require("../../../tokens/breadcrumb.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElBreadcrumb",
    props: _breadcrumbMjs.breadcrumbProps,
    setup (props) {
        const ns = _indexMjs2.useNamespace("breadcrumb");
        const breadcrumb = _vue.ref();
        _vue.provide(_breadcrumbMjs1.elBreadcrumbKey, props);
        _vue.onMounted(()=>{
            const items = breadcrumb.value.querySelectorAll(`.${ns.e("item")}`);
            if (items.length) items[items.length - 1].setAttribute("aria-current", "page");
        });
        return {
            ns,
            breadcrumb
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "breadcrumb",
        class: _vue.normalizeClass(_ctx.ns.b()),
        "aria-label": "Breadcrumb",
        role: "navigation"
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 2);
}
var Breadcrumb = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../tokens/index.mjs":"wVNQi","../../../hooks/index.mjs":"1Ansp","./breadcrumb.mjs":"iV9UH","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../tokens/breadcrumb.mjs":"5AKMw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iV9UH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "breadcrumbProps", ()=>breadcrumbProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
const breadcrumbProps = _propsMjs.buildProps({
    separator: {
        type: String,
        default: "/"
    },
    separatorIcon: {
        type: _iconMjs.iconPropType,
        default: ""
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","../../../utils/vue/icon.mjs":"3YbE5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3edxq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>BreadcrumbItem
);
var _vue = require("vue");
var _indexMjs = require("../../icon/index.mjs");
var _indexMjs1 = require("../../../tokens/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _breadcrumbItemMjs = require("./breadcrumb-item.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _breadcrumbMjs = require("../../../tokens/breadcrumb.mjs");
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
const COMPONENT_NAME = "ElBreadcrumbItem";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    components: {
        ElIcon: _indexMjs.ElIcon
    },
    props: _breadcrumbItemMjs.breadcrumbItemProps,
    setup (props) {
        const instance = _vue.getCurrentInstance();
        const router = instance.appContext.config.globalProperties.$router;
        const parent = _vue.inject(_breadcrumbMjs.elBreadcrumbKey, void 0);
        const ns = _indexMjs3.useNamespace("breadcrumb");
        const link = _vue.ref();
        _vue.onMounted(()=>{
            link.value.setAttribute("role", "link");
            link.value.addEventListener("click", ()=>{
                if (!props.to || !router) return;
                props.replace ? router.replace(props.to) : router.push(props.to);
            });
        });
        return {
            ns,
            link,
            separator: parent == null ? void 0 : parent.separator,
            separatorIcon: parent == null ? void 0 : parent.separatorIcon
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    return _vue.openBlock(), _vue.createElementBlock("span", {
        class: _vue.normalizeClass(_ctx.ns.e("item"))
    }, [
        _vue.createElementVNode("span", {
            ref: "link",
            class: _vue.normalizeClass([
                _ctx.ns.e("inner"),
                _ctx.ns.is("link", !!_ctx.to)
            ]),
            role: "link"
        }, [
            _vue.renderSlot(_ctx.$slots, "default")
        ], 2),
        _ctx.separatorIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.e("separator"))
        }, {
            default: _vue.withCtx(()=>[
                    (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.separatorIcon)))
                ]
            ),
            _: 1
        }, 8, [
            "class"
        ])) : (_vue.openBlock(), _vue.createElementBlock("span", {
            key: 1,
            class: _vue.normalizeClass(_ctx.ns.e("separator")),
            role: "presentation"
        }, _vue.toDisplayString(_ctx.separator), 3))
    ], 2);
}
var BreadcrumbItem = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../icon/index.mjs":"hnNTG","../../../tokens/index.mjs":"wVNQi","../../../hooks/index.mjs":"1Ansp","./breadcrumb-item.mjs":"5U0qo","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../tokens/breadcrumb.mjs":"5AKMw","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5U0qo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "breadcrumbItemProps", ()=>breadcrumbItemProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const breadcrumbItemProps = _propsMjs.buildProps({
    to: {
        type: _propsMjs.definePropType([
            String,
            Object
        ]),
        default: ""
    },
    replace: {
        type: Boolean,
        default: false
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"64Ym1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buttonEmits", ()=>_buttonMjs.buttonEmits
);
parcelHelpers.export(exports, "buttonNativeTypes", ()=>_buttonMjs.buttonNativeTypes
);
parcelHelpers.export(exports, "buttonProps", ()=>_buttonMjs.buttonProps
);
parcelHelpers.export(exports, "buttonTypes", ()=>_buttonMjs.buttonTypes
);
parcelHelpers.export(exports, "ElButton", ()=>ElButton
);
parcelHelpers.export(exports, "ElButtonGroup", ()=>ElButtonGroup
);
parcelHelpers.export(exports, "default", ()=>ElButton
);
var _indexMjs = require("../../utils/index.mjs");
var _button2Mjs = require("./src/button2.mjs");
var _button2MjsDefault = parcelHelpers.interopDefault(_button2Mjs);
var _buttonGroup2Mjs = require("./src/button-group2.mjs");
var _buttonGroup2MjsDefault = parcelHelpers.interopDefault(_buttonGroup2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _buttonMjs = require("./src/button.mjs");
const ElButton = _installMjs.withInstall(_button2MjsDefault.default, {
    ButtonGroup: _buttonGroup2MjsDefault.default
});
const ElButtonGroup = _installMjs.withNoopInstall(_buttonGroup2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/button2.mjs":"k4R97","./src/button-group2.mjs":"5qNJN","../../utils/vue/install.mjs":"4TMmv","./src/button.mjs":"8GILO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k4R97":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_sfc_main
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _tinycolor = require("@ctrl/tinycolor");
var _indexMjs = require("../../icon/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _indexMjs2 = require("../../../tokens/index.mjs");
var _buttonMjs = require("./button.mjs");
var _buttonMjs1 = require("../../../tokens/button.mjs");
var _indexMjs3 = require("../../../hooks/use-global-config/index.mjs");
var _indexMjs4 = require("../../../hooks/use-namespace/index.mjs");
var _indexMjs5 = require("../../../hooks/use-form-item/index.mjs");
var _indexMjs6 = require("../../../hooks/use-common-props/index.mjs");
const _hoisted_1 = [
    "disabled",
    "autofocus",
    "type"
];
const __default__ = {
    name: "ElButton"
};
const _sfc_main = /* @__PURE__ */ _vue.defineComponent({
    ...__default__,
    props: _buttonMjs.buttonProps,
    emits: _buttonMjs.buttonEmits,
    setup (__props, { expose , emit  }) {
        const props = __props;
        const slots = _vue.useSlots();
        const buttonGroupContext = _vue.inject(_buttonMjs1.buttonGroupContextKey, void 0);
        const globalConfig = _indexMjs3.useGlobalConfig("button");
        const ns = _indexMjs4.useNamespace("button");
        const { form  } = _indexMjs5.useFormItem();
        const _size = _indexMjs6.useSize(_vue.computed(()=>buttonGroupContext == null ? void 0 : buttonGroupContext.size
        ));
        const _disabled = _indexMjs6.useDisabled();
        const _ref = _vue.ref();
        const _type = _vue.computed(()=>props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || ""
        );
        const autoInsertSpace = _vue.computed(()=>{
            var _a, _b, _c;
            return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a = globalConfig.value) == null ? void 0 : _a.autoInsertSpace) != null ? _c : false;
        });
        const shouldAddSpace = _vue.computed(()=>{
            var _a;
            const defaultSlot = (_a = slots.default) == null ? void 0 : _a.call(slots);
            if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
                const slot = defaultSlot[0];
                if ((slot == null ? void 0 : slot.type) === _vue.Text) {
                    const text = slot.children;
                    return /^\p{Unified_Ideograph}{2}$/u.test(text);
                }
            }
            return false;
        });
        const typeColor = _vue.computed(()=>_core.useCssVar(`--el-color-${props.type}`).value
        );
        const buttonStyle = _vue.computed(()=>{
            let styles = {
            };
            const buttonColor = props.color || typeColor.value;
            if (buttonColor) {
                const color = new _tinycolor.TinyColor(buttonColor);
                const shadeBgColor = color.shade(10).toString();
                if (props.plain) styles = {
                    "--el-button-bg-color": color.tint(90).toString(),
                    "--el-button-text-color": buttonColor,
                    "--el-button-hover-text-color": "var(--el-color-white)",
                    "--el-button-hover-bg-color": buttonColor,
                    "--el-button-hover-border-color": buttonColor,
                    "--el-button-active-bg-color": shadeBgColor,
                    "--el-button-active-text-color": "var(--el-color-white)",
                    "--el-button-active-border-color": shadeBgColor
                };
                else {
                    const tintBgColor = color.tint(20).toString();
                    styles = {
                        "--el-button-bg-color": buttonColor,
                        "--el-button-border-color": buttonColor,
                        "--el-button-hover-bg-color": tintBgColor,
                        "--el-button-hover-border-color": tintBgColor,
                        "--el-button-active-bg-color": shadeBgColor,
                        "--el-button-active-border-color": shadeBgColor
                    };
                }
                if (_disabled.value) {
                    const disabledButtonColor = color.tint(50).toString();
                    styles["--el-button-disabled-bg-color"] = disabledButtonColor;
                    styles["--el-button-disabled-border-color"] = disabledButtonColor;
                }
            }
            return styles;
        });
        const handleClick = (evt)=>{
            if (props.nativeType === "reset") form == null || form.resetFields();
            emit("click", evt);
        };
        expose({
            ref: _ref,
            size: _size,
            type: _type,
            disabled: _disabled,
            shouldAddSpace
        });
        return (_ctx, _cache)=>{
            return _vue.openBlock(), _vue.createElementBlock("button", {
                ref_key: "_ref",
                ref: _ref,
                class: _vue.normalizeClass([
                    _vue.unref(ns).b(),
                    _vue.unref(ns).m(_vue.unref(_type)),
                    _vue.unref(ns).m(_vue.unref(_size)),
                    _vue.unref(ns).is("disabled", _vue.unref(_disabled)),
                    _vue.unref(ns).is("loading", _ctx.loading),
                    _vue.unref(ns).is("plain", _ctx.plain),
                    _vue.unref(ns).is("round", _ctx.round),
                    _vue.unref(ns).is("circle", _ctx.circle)
                ]),
                disabled: _vue.unref(_disabled) || _ctx.loading,
                autofocus: _ctx.autofocus,
                type: _ctx.nativeType,
                style: _vue.normalizeStyle(_vue.unref(buttonStyle)),
                onClick: handleClick
            }, [
                _ctx.loading ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                    key: 0
                }, [
                    _ctx.$slots.loading ? _vue.renderSlot(_ctx.$slots, "loading", {
                        key: 0
                    }) : (_vue.openBlock(), _vue.createBlock(_vue.unref(_indexMjs.ElIcon), {
                        key: 1,
                        class: _vue.normalizeClass(_vue.unref(ns).is("loading"))
                    }, {
                        default: _vue.withCtx(()=>[
                                (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.loadingIcon)))
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "class"
                    ]))
                ], 2112)) : _ctx.icon ? (_vue.openBlock(), _vue.createBlock(_vue.unref(_indexMjs.ElIcon), {
                    key: 1
                }, {
                    default: _vue.withCtx(()=>[
                            (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.icon)))
                        ]
                    ),
                    _: 1
                })) : _vue.createCommentVNode("v-if", true),
                _ctx.$slots.default ? (_vue.openBlock(), _vue.createElementBlock("span", {
                    key: 2,
                    class: _vue.normalizeClass({
                        [_vue.unref(ns).em("text", "expand")]: _vue.unref(shouldAddSpace)
                    })
                }, [
                    _vue.renderSlot(_ctx.$slots, "default")
                ], 2)) : _vue.createCommentVNode("v-if", true)
            ], 14, _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","@vueuse/core":"eEHP9","@ctrl/tinycolor":"e1DHG","../../icon/index.mjs":"hnNTG","../../../hooks/index.mjs":"1Ansp","../../../tokens/index.mjs":"wVNQi","./button.mjs":"8GILO","../../../tokens/button.mjs":"guqr8","../../../hooks/use-global-config/index.mjs":"jLlCF","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../hooks/use-form-item/index.mjs":"jSs21","../../../hooks/use-common-props/index.mjs":"05czU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e1DHG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _index = require("./index");
parcelHelpers.exportAll(_index, exports);
var _cssColorNames = require("./css-color-names");
parcelHelpers.exportAll(_cssColorNames, exports);
var _readability = require("./readability");
parcelHelpers.exportAll(_readability, exports);
var _toMsFilter = require("./to-ms-filter");
parcelHelpers.exportAll(_toMsFilter, exports);
var _fromRatio = require("./from-ratio");
parcelHelpers.exportAll(_fromRatio, exports);
var _formatInput = require("./format-input");
parcelHelpers.exportAll(_formatInput, exports);
var _random = require("./random");
parcelHelpers.exportAll(_random, exports);
var _interfaces = require("./interfaces");
parcelHelpers.exportAll(_interfaces, exports);
var _conversion = require("./conversion");
parcelHelpers.exportAll(_conversion, exports);
exports.default = _index.tinycolor;

},{"./index":"lKbZq","./css-color-names":"b5HZM","./readability":"5IRQX","./to-ms-filter":"lh9Zs","./from-ratio":"aOZls","./format-input":"2EZlz","./random":"9EmXI","./interfaces":"5dzYk","./conversion":"lEGR9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lKbZq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TinyColor", ()=>TinyColor
);
// kept for backwards compatability with v1
parcelHelpers.export(exports, "tinycolor", ()=>tinycolor
);
var _conversion = require("./conversion");
var _cssColorNames = require("./css-color-names");
var _formatInput = require("./format-input");
var _util = require("./util");
var TinyColor = function() {
    function TinyColor1(color, opts) {
        if (color === void 0) color = '';
        if (opts === void 0) opts = {
        };
        var _a;
        // If input is already a tinycolor, return itself
        if (color instanceof TinyColor1) // eslint-disable-next-line no-constructor-return
        return color;
        if (typeof color === 'number') color = _conversion.numberInputToObject(color);
        this.originalInput = color;
        var rgb = _formatInput.inputToRGB(color);
        this.originalInput = color;
        this.r = rgb.r;
        this.g = rgb.g;
        this.b = rgb.b;
        this.a = rgb.a;
        this.roundA = Math.round(100 * this.a) / 100;
        this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
        this.gradientType = opts.gradientType;
        // Don't let the range of [0,255] come back in [0,1].
        // Potentially lose a little bit of precision here, but will fix issues where
        // .5 gets interpreted as half of the total, instead of half of 1
        // If it was supposed to be 128, this was already taken care of by `inputToRgb`
        if (this.r < 1) this.r = Math.round(this.r);
        if (this.g < 1) this.g = Math.round(this.g);
        if (this.b < 1) this.b = Math.round(this.b);
        this.isValid = rgb.ok;
    }
    TinyColor1.prototype.isDark = function() {
        return this.getBrightness() < 128;
    };
    TinyColor1.prototype.isLight = function() {
        return !this.isDark();
    };
    /**
     * Returns the perceived brightness of the color, from 0-255.
     */ TinyColor1.prototype.getBrightness = function() {
        // http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    };
    /**
     * Returns the perceived luminance of a color, from 0-1.
     */ TinyColor1.prototype.getLuminance = function() {
        // http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var R;
        var G;
        var B;
        var RsRGB = rgb.r / 255;
        var GsRGB = rgb.g / 255;
        var BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) R = RsRGB / 12.92;
        else // eslint-disable-next-line prefer-exponentiation-operator
        R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
        if (GsRGB <= 0.03928) G = GsRGB / 12.92;
        else // eslint-disable-next-line prefer-exponentiation-operator
        G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
        if (BsRGB <= 0.03928) B = BsRGB / 12.92;
        else // eslint-disable-next-line prefer-exponentiation-operator
        B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    };
    /**
     * Returns the alpha value of a color, from 0-1.
     */ TinyColor1.prototype.getAlpha = function() {
        return this.a;
    };
    /**
     * Sets the alpha value on the current color.
     *
     * @param alpha - The new alpha value. The accepted range is 0-1.
     */ TinyColor1.prototype.setAlpha = function(alpha) {
        this.a = _util.boundAlpha(alpha);
        this.roundA = Math.round(100 * this.a) / 100;
        return this;
    };
    /**
     * Returns the object as a HSVA object.
     */ TinyColor1.prototype.toHsv = function() {
        var hsv = _conversion.rgbToHsv(this.r, this.g, this.b);
        return {
            h: hsv.h * 360,
            s: hsv.s,
            v: hsv.v,
            a: this.a
        };
    };
    /**
     * Returns the hsva values interpolated into a string with the following format:
     * "hsva(xxx, xxx, xxx, xx)".
     */ TinyColor1.prototype.toHsvString = function() {
        var hsv = _conversion.rgbToHsv(this.r, this.g, this.b);
        var h = Math.round(hsv.h * 360);
        var s = Math.round(hsv.s * 100);
        var v = Math.round(hsv.v * 100);
        return this.a === 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this.roundA + ")";
    };
    /**
     * Returns the object as a HSLA object.
     */ TinyColor1.prototype.toHsl = function() {
        var hsl = _conversion.rgbToHsl(this.r, this.g, this.b);
        return {
            h: hsl.h * 360,
            s: hsl.s,
            l: hsl.l,
            a: this.a
        };
    };
    /**
     * Returns the hsla values interpolated into a string with the following format:
     * "hsla(xxx, xxx, xxx, xx)".
     */ TinyColor1.prototype.toHslString = function() {
        var hsl = _conversion.rgbToHsl(this.r, this.g, this.b);
        var h = Math.round(hsl.h * 360);
        var s = Math.round(hsl.s * 100);
        var l = Math.round(hsl.l * 100);
        return this.a === 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this.roundA + ")";
    };
    /**
     * Returns the hex value of the color.
     * @param allow3Char will shorten hex value to 3 char if possible
     */ TinyColor1.prototype.toHex = function(allow3Char) {
        if (allow3Char === void 0) allow3Char = false;
        return _conversion.rgbToHex(this.r, this.g, this.b, allow3Char);
    };
    /**
     * Returns the hex value of the color -with a # appened.
     * @param allow3Char will shorten hex value to 3 char if possible
     */ TinyColor1.prototype.toHexString = function(allow3Char) {
        if (allow3Char === void 0) allow3Char = false;
        return '#' + this.toHex(allow3Char);
    };
    /**
     * Returns the hex 8 value of the color.
     * @param allow4Char will shorten hex value to 4 char if possible
     */ TinyColor1.prototype.toHex8 = function(allow4Char) {
        if (allow4Char === void 0) allow4Char = false;
        return _conversion.rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
    };
    /**
     * Returns the hex 8 value of the color -with a # appened.
     * @param allow4Char will shorten hex value to 4 char if possible
     */ TinyColor1.prototype.toHex8String = function(allow4Char) {
        if (allow4Char === void 0) allow4Char = false;
        return '#' + this.toHex8(allow4Char);
    };
    /**
     * Returns the object as a RGBA object.
     */ TinyColor1.prototype.toRgb = function() {
        return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
        };
    };
    /**
     * Returns the RGBA values interpolated into a string with the following format:
     * "RGBA(xxx, xxx, xxx, xx)".
     */ TinyColor1.prototype.toRgbString = function() {
        var r = Math.round(this.r);
        var g = Math.round(this.g);
        var b = Math.round(this.b);
        return this.a === 1 ? "rgb(" + r + ", " + g + ", " + b + ")" : "rgba(" + r + ", " + g + ", " + b + ", " + this.roundA + ")";
    };
    /**
     * Returns the object as a RGBA object.
     */ TinyColor1.prototype.toPercentageRgb = function() {
        var fmt = function(x) {
            return Math.round(_util.bound01(x, 255) * 100) + "%";
        };
        return {
            r: fmt(this.r),
            g: fmt(this.g),
            b: fmt(this.b),
            a: this.a
        };
    };
    /**
     * Returns the RGBA relative values interpolated into a string
     */ TinyColor1.prototype.toPercentageRgbString = function() {
        var rnd = function(x) {
            return Math.round(_util.bound01(x, 255) * 100);
        };
        return this.a === 1 ? "rgb(" + rnd(this.r) + "%, " + rnd(this.g) + "%, " + rnd(this.b) + "%)" : "rgba(" + rnd(this.r) + "%, " + rnd(this.g) + "%, " + rnd(this.b) + "%, " + this.roundA + ")";
    };
    /**
     * The 'real' name of the color -if there is one.
     */ TinyColor1.prototype.toName = function() {
        if (this.a === 0) return 'transparent';
        if (this.a < 1) return false;
        var hex = '#' + _conversion.rgbToHex(this.r, this.g, this.b, false);
        for(var _i = 0, _a = Object.entries(_cssColorNames.names); _i < _a.length; _i++){
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (hex === value) return key;
        }
        return false;
    };
    TinyColor1.prototype.toString = function(format) {
        var formatSet = Boolean(format);
        format = format !== null && format !== void 0 ? format : this.format;
        var formattedString = false;
        var hasAlpha = this.a < 1 && this.a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith('hex') || format === 'name');
        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === 'name' && this.a === 0) return this.toName();
            return this.toRgbString();
        }
        if (format === 'rgb') formattedString = this.toRgbString();
        if (format === 'prgb') formattedString = this.toPercentageRgbString();
        if (format === 'hex' || format === 'hex6') formattedString = this.toHexString();
        if (format === 'hex3') formattedString = this.toHexString(true);
        if (format === 'hex4') formattedString = this.toHex8String(true);
        if (format === 'hex8') formattedString = this.toHex8String();
        if (format === 'name') formattedString = this.toName();
        if (format === 'hsl') formattedString = this.toHslString();
        if (format === 'hsv') formattedString = this.toHsvString();
        return formattedString || this.toHexString();
    };
    TinyColor1.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    };
    TinyColor1.prototype.clone = function() {
        return new TinyColor1(this.toString());
    };
    /**
     * Lighten the color a given amount. Providing 100 will always return white.
     * @param amount - valid between 1-100
     */ TinyColor1.prototype.lighten = function(amount) {
        if (amount === void 0) amount = 10;
        var hsl = this.toHsl();
        hsl.l += amount / 100;
        hsl.l = _util.clamp01(hsl.l);
        return new TinyColor1(hsl);
    };
    /**
     * Brighten the color a given amount, from 0 to 100.
     * @param amount - valid between 1-100
     */ TinyColor1.prototype.brighten = function(amount) {
        if (amount === void 0) amount = 10;
        var rgb = this.toRgb();
        rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
        rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
        rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
        return new TinyColor1(rgb);
    };
    /**
     * Darken the color a given amount, from 0 to 100.
     * Providing 100 will always return black.
     * @param amount - valid between 1-100
     */ TinyColor1.prototype.darken = function(amount) {
        if (amount === void 0) amount = 10;
        var hsl = this.toHsl();
        hsl.l -= amount / 100;
        hsl.l = _util.clamp01(hsl.l);
        return new TinyColor1(hsl);
    };
    /**
     * Mix the color with pure white, from 0 to 100.
     * Providing 0 will do nothing, providing 100 will always return white.
     * @param amount - valid between 1-100
     */ TinyColor1.prototype.tint = function(amount) {
        if (amount === void 0) amount = 10;
        return this.mix('white', amount);
    };
    /**
     * Mix the color with pure black, from 0 to 100.
     * Providing 0 will do nothing, providing 100 will always return black.
     * @param amount - valid between 1-100
     */ TinyColor1.prototype.shade = function(amount) {
        if (amount === void 0) amount = 10;
        return this.mix('black', amount);
    };
    /**
     * Desaturate the color a given amount, from 0 to 100.
     * Providing 100 will is the same as calling greyscale
     * @param amount - valid between 1-100
     */ TinyColor1.prototype.desaturate = function(amount) {
        if (amount === void 0) amount = 10;
        var hsl = this.toHsl();
        hsl.s -= amount / 100;
        hsl.s = _util.clamp01(hsl.s);
        return new TinyColor1(hsl);
    };
    /**
     * Saturate the color a given amount, from 0 to 100.
     * @param amount - valid between 1-100
     */ TinyColor1.prototype.saturate = function(amount) {
        if (amount === void 0) amount = 10;
        var hsl = this.toHsl();
        hsl.s += amount / 100;
        hsl.s = _util.clamp01(hsl.s);
        return new TinyColor1(hsl);
    };
    /**
     * Completely desaturates a color into greyscale.
     * Same as calling `desaturate(100)`
     */ TinyColor1.prototype.greyscale = function() {
        return this.desaturate(100);
    };
    /**
     * Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
     * Values outside of this range will be wrapped into this range.
     */ TinyColor1.prototype.spin = function(amount) {
        var hsl = this.toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return new TinyColor1(hsl);
    };
    /**
     * Mix the current color a given amount with another color, from 0 to 100.
     * 0 means no mixing (return current color).
     */ TinyColor1.prototype.mix = function(color, amount) {
        if (amount === void 0) amount = 50;
        var rgb1 = this.toRgb();
        var rgb2 = new TinyColor1(color).toRgb();
        var p = amount / 100;
        var rgba = {
            r: (rgb2.r - rgb1.r) * p + rgb1.r,
            g: (rgb2.g - rgb1.g) * p + rgb1.g,
            b: (rgb2.b - rgb1.b) * p + rgb1.b,
            a: (rgb2.a - rgb1.a) * p + rgb1.a
        };
        return new TinyColor1(rgba);
    };
    TinyColor1.prototype.analogous = function(results, slices) {
        if (results === void 0) results = 6;
        if (slices === void 0) slices = 30;
        var hsl = this.toHsl();
        var part = 360 / slices;
        var ret = [
            this
        ];
        for(hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;){
            hsl.h = (hsl.h + part) % 360;
            ret.push(new TinyColor1(hsl));
        }
        return ret;
    };
    /**
     * taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js
     */ TinyColor1.prototype.complement = function() {
        var hsl = this.toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return new TinyColor1(hsl);
    };
    TinyColor1.prototype.monochromatic = function(results) {
        if (results === void 0) results = 6;
        var hsv = this.toHsv();
        var h = hsv.h;
        var s = hsv.s;
        var v = hsv.v;
        var res = [];
        var modification = 1 / results;
        while(results--){
            res.push(new TinyColor1({
                h: h,
                s: s,
                v: v
            }));
            v = (v + modification) % 1;
        }
        return res;
    };
    TinyColor1.prototype.splitcomplement = function() {
        var hsl = this.toHsl();
        var h = hsl.h;
        return [
            this,
            new TinyColor1({
                h: (h + 72) % 360,
                s: hsl.s,
                l: hsl.l
            }),
            new TinyColor1({
                h: (h + 216) % 360,
                s: hsl.s,
                l: hsl.l
            }), 
        ];
    };
    /**
     * Compute how the color would appear on a background
     */ TinyColor1.prototype.onBackground = function(background) {
        var fg = this.toRgb();
        var bg = new TinyColor1(background).toRgb();
        return new TinyColor1({
            r: bg.r + (fg.r - bg.r) * fg.a,
            g: bg.g + (fg.g - bg.g) * fg.a,
            b: bg.b + (fg.b - bg.b) * fg.a
        });
    };
    /**
     * Alias for `polyad(3)`
     */ TinyColor1.prototype.triad = function() {
        return this.polyad(3);
    };
    /**
     * Alias for `polyad(4)`
     */ TinyColor1.prototype.tetrad = function() {
        return this.polyad(4);
    };
    /**
     * Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)
     * monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...
     */ TinyColor1.prototype.polyad = function(n) {
        var hsl = this.toHsl();
        var h = hsl.h;
        var result = [
            this
        ];
        var increment = 360 / n;
        for(var i = 1; i < n; i++)result.push(new TinyColor1({
            h: (h + i * increment) % 360,
            s: hsl.s,
            l: hsl.l
        }));
        return result;
    };
    /**
     * compare color vs current color
     */ TinyColor1.prototype.equals = function(color) {
        return this.toRgbString() === new TinyColor1(color).toRgbString();
    };
    return TinyColor1;
}();
function tinycolor(color, opts) {
    if (color === void 0) color = '';
    if (opts === void 0) opts = {
    };
    return new TinyColor(color, opts);
}

},{"./conversion":"lEGR9","./css-color-names":"b5HZM","./format-input":"2EZlz","./util":"83iaU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lEGR9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>
/**
 * Handle bounds / percentage checking to conform to CSS color spec
 * <http://www.w3.org/TR/css3-color/>
 * *Assumes:* r, g, b in [0, 255] or [0, 1]
 * *Returns:* { r, g, b } in [0, 255]
 */ parcelHelpers.export(exports, "rgbToRgb", ()=>rgbToRgb
);
/**
 * Converts an RGB color value to HSL.
 * *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
 * *Returns:* { h, s, l } in [0,1]
 */ parcelHelpers.export(exports, "rgbToHsl", ()=>rgbToHsl
);
/**
 * Converts an HSL color value to RGB.
 *
 * *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
 * *Returns:* { r, g, b } in the set [0, 255]
 */ parcelHelpers.export(exports, "hslToRgb", ()=>hslToRgb
);
/**
 * Converts an RGB color value to HSV
 *
 * *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
 * *Returns:* { h, s, v } in [0,1]
 */ parcelHelpers.export(exports, "rgbToHsv", ()=>rgbToHsv
);
/**
 * Converts an HSV color value to RGB.
 *
 * *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
 * *Returns:* { r, g, b } in the set [0, 255]
 */ parcelHelpers.export(exports, "hsvToRgb", ()=>hsvToRgb
);
/**
 * Converts an RGB color to hex
 *
 * Assumes r, g, and b are contained in the set [0, 255]
 * Returns a 3 or 6 character hex
 */ parcelHelpers.export(exports, "rgbToHex", ()=>rgbToHex
);
/**
 * Converts an RGBA color plus alpha transparency to hex
 *
 * Assumes r, g, b are contained in the set [0, 255] and
 * a in [0, 1]. Returns a 4 or 8 character rgba hex
 */ // eslint-disable-next-line max-params
parcelHelpers.export(exports, "rgbaToHex", ()=>rgbaToHex
);
/**
 * Converts an RGBA color to an ARGB Hex8 string
 * Rarely used, but required for "toFilter()"
 */ parcelHelpers.export(exports, "rgbaToArgbHex", ()=>rgbaToArgbHex
);
/** Converts a decimal to a hex value */ parcelHelpers.export(exports, "convertDecimalToHex", ()=>convertDecimalToHex
);
/** Converts a hex value to a decimal */ parcelHelpers.export(exports, "convertHexToDecimal", ()=>convertHexToDecimal
);
/** Parse a base-16 hex value into a base-10 integer */ parcelHelpers.export(exports, "parseIntFromHex", ()=>parseIntFromHex
);
parcelHelpers.export(exports, "numberInputToObject", ()=>numberInputToObject
);
var _util = require("./util");
function rgbToRgb(r, g, b) {
    return {
        r: _util.bound01(r, 255) * 255,
        g: _util.bound01(g, 255) * 255,
        b: _util.bound01(b, 255) * 255
    };
}
function rgbToHsl(r, g, b) {
    r = _util.bound01(r, 255);
    g = _util.bound01(g, 255);
    b = _util.bound01(b, 255);
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h = 0;
    var s = 0;
    var l = (max + min) / 2;
    if (max === min) {
        s = 0;
        h = 0; // achromatic
    } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
            default:
                break;
        }
        h /= 6;
    }
    return {
        h: h,
        s: s,
        l: l
    };
}
function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * (6 * t);
    if (t < 0.5) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
}
function hslToRgb(h, s, l) {
    var r;
    var g;
    var b;
    h = _util.bound01(h, 360);
    s = _util.bound01(s, 100);
    l = _util.bound01(l, 100);
    if (s === 0) {
        // achromatic
        g = l;
        b = l;
        r = l;
    } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return {
        r: r * 255,
        g: g * 255,
        b: b * 255
    };
}
function rgbToHsv(r, g, b) {
    r = _util.bound01(r, 255);
    g = _util.bound01(g, 255);
    b = _util.bound01(b, 255);
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h = 0;
    var v = max;
    var d = max - min;
    var s = max === 0 ? 0 : d / max;
    if (max === min) h = 0; // achromatic
    else {
        switch(max){
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
            default:
                break;
        }
        h /= 6;
    }
    return {
        h: h,
        s: s,
        v: v
    };
}
function hsvToRgb(h, s, v) {
    h = _util.bound01(h, 360) * 6;
    s = _util.bound01(s, 100);
    v = _util.bound01(v, 100);
    var i = Math.floor(h);
    var f = h - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    var mod = i % 6;
    var r = [
        v,
        q,
        p,
        p,
        t,
        v
    ][mod];
    var g = [
        t,
        v,
        v,
        q,
        p,
        p
    ][mod];
    var b = [
        p,
        p,
        t,
        v,
        v,
        q
    ][mod];
    return {
        r: r * 255,
        g: g * 255,
        b: b * 255
    };
}
function rgbToHex(r, g, b, allow3Char) {
    var hex = [
        _util.pad2(Math.round(r).toString(16)),
        _util.pad2(Math.round(g).toString(16)),
        _util.pad2(Math.round(b).toString(16)), 
    ];
    // Return a 3 character hex if possible
    if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    return hex.join('');
}
function rgbaToHex(r, g, b, a, allow4Char) {
    var hex = [
        _util.pad2(Math.round(r).toString(16)),
        _util.pad2(Math.round(g).toString(16)),
        _util.pad2(Math.round(b).toString(16)),
        _util.pad2(convertDecimalToHex(a)), 
    ];
    // Return a 4 character hex if possible
    if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    return hex.join('');
}
function rgbaToArgbHex(r, g, b, a) {
    var hex = [
        _util.pad2(convertDecimalToHex(a)),
        _util.pad2(Math.round(r).toString(16)),
        _util.pad2(Math.round(g).toString(16)),
        _util.pad2(Math.round(b).toString(16)), 
    ];
    return hex.join('');
}
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h) {
    return parseIntFromHex(h) / 255;
}
function parseIntFromHex(val) {
    return parseInt(val, 16);
}
function numberInputToObject(color) {
    return {
        r: color >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
    };
}

},{"./util":"83iaU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"83iaU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Take input from [0, n] and return it as [0, 1]
 * @hidden
 */ parcelHelpers.export(exports, "bound01", ()=>bound01
);
/**
 * Force a number between 0 and 1
 * @hidden
 */ parcelHelpers.export(exports, "clamp01", ()=>clamp01
);
/**
 * Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
 * <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
 * @hidden
 */ parcelHelpers.export(exports, "isOnePointZero", ()=>isOnePointZero
);
/**
 * Check to see if string passed in is a percentage
 * @hidden
 */ parcelHelpers.export(exports, "isPercentage", ()=>isPercentage
);
/**
 * Return a valid alpha value [0,1] with all invalid values being set to 1
 * @hidden
 */ parcelHelpers.export(exports, "boundAlpha", ()=>boundAlpha
);
/**
 * Replace a decimal with it's percentage value
 * @hidden
 */ parcelHelpers.export(exports, "convertToPercentage", ()=>convertToPercentage
);
/**
 * Force a hex value to have 2 characters
 * @hidden
 */ parcelHelpers.export(exports, "pad2", ()=>pad2
);
function bound01(n, max) {
    if (isOnePointZero(n)) n = '100%';
    var isPercent = isPercentage(n);
    n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
    // Automatically convert percentage into number
    if (isPercent) n = parseInt(String(n * max), 10) / 100;
    // Handle floating point rounding errors
    if (Math.abs(n - max) < 0.000001) return 1;
    // Convert into [0, 1] range if it isn't already
    if (max === 360) // If n is a hue given in degrees,
    // wrap around out-of-range values into [0, 360] range
    // then convert into [0, 1].
    n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
    else // If n not a hue given in degrees
    // Convert into [0, 1] range if it isn't already.
    n = n % max / parseFloat(String(max));
    return n;
}
function clamp01(val) {
    return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n) {
    return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
    return typeof n === 'string' && n.indexOf('%') !== -1;
}
function boundAlpha(a) {
    a = parseFloat(a);
    if (isNaN(a) || a < 0 || a > 1) a = 1;
    return a;
}
function convertToPercentage(n) {
    if (n <= 1) return Number(n) * 100 + "%";
    return n;
}
function pad2(c) {
    return c.length === 1 ? '0' + c : String(c);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b5HZM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "names", ()=>names
);
var names = {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgreen: '#006400',
    darkgrey: '#a9a9a9',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkslategrey: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dimgrey: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    goldenrod: '#daa520',
    gold: '#ffd700',
    gray: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    grey: '#808080',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavenderblush: '#fff0f5',
    lavender: '#e6e6fa',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgreen: '#90ee90',
    lightgrey: '#d3d3d3',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightslategrey: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    rebeccapurple: '#663399',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    slategrey: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2EZlz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Given a string or object, convert that input to RGB
 *
 * Possible string inputs:
 * ```
 * "red"
 * "#f00" or "f00"
 * "#ff0000" or "ff0000"
 * "#ff000000" or "ff000000"
 * "rgb 255 0 0" or "rgb (255, 0, 0)"
 * "rgb 1.0 0 0" or "rgb (1, 0, 0)"
 * "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
 * "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
 * "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
 * "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
 * "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
 * ```
 */ parcelHelpers.export(exports, "inputToRGB", ()=>inputToRGB
);
/**
 * Permissive string parsing.  Take in a number of formats, and output an object
 * based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
 */ parcelHelpers.export(exports, "stringInputToObject", ()=>stringInputToObject
);
/**
 * Check to see if it looks like a CSS unit
 * (see `matchers` above for definition).
 */ parcelHelpers.export(exports, "isValidCSSUnit", ()=>isValidCSSUnit
);
var _conversion = require("./conversion");
var _cssColorNames = require("./css-color-names");
var _util = require("./util");
function inputToRGB(color) {
    var rgb = {
        r: 0,
        g: 0,
        b: 0
    };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;
    if (typeof color === 'string') color = stringInputToObject(color);
    if (typeof color === 'object') {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = _conversion.rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === '%' ? 'prgb' : 'rgb';
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = _util.convertToPercentage(color.s);
            v = _util.convertToPercentage(color.v);
            rgb = _conversion.hsvToRgb(color.h, s, v);
            ok = true;
            format = 'hsv';
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = _util.convertToPercentage(color.s);
            l = _util.convertToPercentage(color.l);
            rgb = _conversion.hslToRgb(color.h, s, l);
            ok = true;
            format = 'hsl';
        }
        if (Object.prototype.hasOwnProperty.call(color, 'a')) a = color.a;
    }
    a = _util.boundAlpha(a);
    return {
        ok: ok,
        format: color.format || format,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a: a
    };
}
// <http://www.w3.org/TR/css3-values/#integers>
var CSS_INTEGER = '[-\\+]?\\d+%?';
// <http://www.w3.org/TR/css3-values/#number-value>
var CSS_NUMBER = '[-\\+]?\\d*\\.\\d+%?';
// Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
// Actual matching.
// Parentheses and commas are optional, but not required.
// Whitespace can take the place of commas or opening paren
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
var matchers = {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp('rgb' + PERMISSIVE_MATCH3),
    rgba: new RegExp('rgba' + PERMISSIVE_MATCH4),
    hsl: new RegExp('hsl' + PERMISSIVE_MATCH3),
    hsla: new RegExp('hsla' + PERMISSIVE_MATCH4),
    hsv: new RegExp('hsv' + PERMISSIVE_MATCH3),
    hsva: new RegExp('hsva' + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
    color = color.trim().toLowerCase();
    if (color.length === 0) return false;
    var named = false;
    if (_cssColorNames.names[color]) {
        color = _cssColorNames.names[color];
        named = true;
    } else if (color === 'transparent') return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        format: 'name'
    };
    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match = matchers.rgb.exec(color);
    if (match) return {
        r: match[1],
        g: match[2],
        b: match[3]
    };
    match = matchers.rgba.exec(color);
    if (match) return {
        r: match[1],
        g: match[2],
        b: match[3],
        a: match[4]
    };
    match = matchers.hsl.exec(color);
    if (match) return {
        h: match[1],
        s: match[2],
        l: match[3]
    };
    match = matchers.hsla.exec(color);
    if (match) return {
        h: match[1],
        s: match[2],
        l: match[3],
        a: match[4]
    };
    match = matchers.hsv.exec(color);
    if (match) return {
        h: match[1],
        s: match[2],
        v: match[3]
    };
    match = matchers.hsva.exec(color);
    if (match) return {
        h: match[1],
        s: match[2],
        v: match[3],
        a: match[4]
    };
    match = matchers.hex8.exec(color);
    if (match) return {
        r: _conversion.parseIntFromHex(match[1]),
        g: _conversion.parseIntFromHex(match[2]),
        b: _conversion.parseIntFromHex(match[3]),
        a: _conversion.convertHexToDecimal(match[4]),
        format: named ? 'name' : 'hex8'
    };
    match = matchers.hex6.exec(color);
    if (match) return {
        r: _conversion.parseIntFromHex(match[1]),
        g: _conversion.parseIntFromHex(match[2]),
        b: _conversion.parseIntFromHex(match[3]),
        format: named ? 'name' : 'hex'
    };
    match = matchers.hex4.exec(color);
    if (match) return {
        r: _conversion.parseIntFromHex(match[1] + match[1]),
        g: _conversion.parseIntFromHex(match[2] + match[2]),
        b: _conversion.parseIntFromHex(match[3] + match[3]),
        a: _conversion.convertHexToDecimal(match[4] + match[4]),
        format: named ? 'name' : 'hex8'
    };
    match = matchers.hex3.exec(color);
    if (match) return {
        r: _conversion.parseIntFromHex(match[1] + match[1]),
        g: _conversion.parseIntFromHex(match[2] + match[2]),
        b: _conversion.parseIntFromHex(match[3] + match[3]),
        format: named ? 'name' : 'hex'
    };
    return false;
}
function isValidCSSUnit(color) {
    return Boolean(matchers.CSS_UNIT.exec(String(color)));
}

},{"./conversion":"lEGR9","./css-color-names":"b5HZM","./util":"83iaU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5IRQX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)
/**
 * AKA `contrast`
 *
 * Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
 */ parcelHelpers.export(exports, "readability", ()=>readability
);
/**
 * Ensure that foreground and background color combinations meet WCAG2 guidelines.
 * The third argument is an object.
 *      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
 *      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
 * If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.
 *
 * Example
 * ```ts
 * new TinyColor().isReadable('#000', '#111') => false
 * new TinyColor().isReadable('#000', '#111', { level: 'AA', size: 'large' }) => false
 * ```
 */ parcelHelpers.export(exports, "isReadable", ()=>isReadable
);
/**
 * Given a base color and a list of possible foreground or background
 * colors for that base, returns the most readable color.
 * Optionally returns Black or White if the most readable color is unreadable.
 *
 * @param baseColor - the base color.
 * @param colorList - array of colors to pick the most readable one from.
 * @param args - and object with extra arguments
 *
 * Example
 * ```ts
 * new TinyColor().mostReadable('#123', ['#124", "#125'], { includeFallbackColors: false }).toHexString(); // "#112255"
 * new TinyColor().mostReadable('#123', ['#124", "#125'],{ includeFallbackColors: true }).toHexString();  // "#ffffff"
 * new TinyColor().mostReadable('#a8015a', ["#faf3f3"], { includeFallbackColors:true, level: 'AAA', size: 'large' }).toHexString(); // "#faf3f3"
 * new TinyColor().mostReadable('#a8015a', ["#faf3f3"], { includeFallbackColors:true, level: 'AAA', size: 'small' }).toHexString(); // "#ffffff"
 * ```
 */ parcelHelpers.export(exports, "mostReadable", ()=>mostReadable
);
var _index = require("./index");
function readability(color1, color2) {
    var c1 = new _index.TinyColor(color1);
    var c2 = new _index.TinyColor(color2);
    return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
}
function isReadable(color1, color2, wcag2) {
    var _a, _b;
    if (wcag2 === void 0) wcag2 = {
        level: 'AA',
        size: 'small'
    };
    var readabilityLevel = readability(color1, color2);
    switch(((_a = wcag2.level) !== null && _a !== void 0 ? _a : 'AA') + ((_b = wcag2.size) !== null && _b !== void 0 ? _b : 'small')){
        case 'AAsmall':
        case 'AAAlarge':
            return readabilityLevel >= 4.5;
        case 'AAlarge':
            return readabilityLevel >= 3;
        case 'AAAsmall':
            return readabilityLevel >= 7;
        default:
            return false;
    }
}
function mostReadable(baseColor, colorList, args) {
    if (args === void 0) args = {
        includeFallbackColors: false,
        level: 'AA',
        size: 'small'
    };
    var bestColor = null;
    var bestScore = 0;
    var includeFallbackColors = args.includeFallbackColors, level = args.level, size = args.size;
    for(var _i = 0, colorList_1 = colorList; _i < colorList_1.length; _i++){
        var color = colorList_1[_i];
        var score = readability(baseColor, color);
        if (score > bestScore) {
            bestScore = score;
            bestColor = new _index.TinyColor(color);
        }
    }
    if (isReadable(baseColor, bestColor, {
        level: level,
        size: size
    }) || !includeFallbackColors) return bestColor;
    args.includeFallbackColors = false;
    return mostReadable(baseColor, [
        '#fff',
        '#000'
    ], args);
}

},{"./index":"lKbZq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lh9Zs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the color represented as a Microsoft filter for use in old versions of IE.
 */ parcelHelpers.export(exports, "toMsFilter", ()=>toMsFilter
);
var _conversion = require("./conversion");
var _index = require("./index");
function toMsFilter(firstColor, secondColor) {
    var color = new _index.TinyColor(firstColor);
    var hex8String = '#' + _conversion.rgbaToArgbHex(color.r, color.g, color.b, color.a);
    var secondHex8String = hex8String;
    var gradientType = color.gradientType ? 'GradientType = 1, ' : '';
    if (secondColor) {
        var s = new _index.TinyColor(secondColor);
        secondHex8String = '#' + _conversion.rgbaToArgbHex(s.r, s.g, s.b, s.a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
}

},{"./conversion":"lEGR9","./index":"lKbZq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aOZls":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * If input is an object, force 1 into "1.0" to handle ratios properly
 * String input requires "1.0" as input, so 1 will be treated as 1
 */ parcelHelpers.export(exports, "fromRatio", ()=>fromRatio
);
/** old random function */ parcelHelpers.export(exports, "legacyRandom", ()=>legacyRandom
);
var _index = require("./index");
var _util = require("./util");
function fromRatio(ratio, opts) {
    var newColor = {
        r: _util.convertToPercentage(ratio.r),
        g: _util.convertToPercentage(ratio.g),
        b: _util.convertToPercentage(ratio.b)
    };
    if (ratio.a !== undefined) newColor.a = Number(ratio.a);
    return new _index.TinyColor(newColor, opts);
}
function legacyRandom() {
    return new _index.TinyColor({
        r: Math.random(),
        g: Math.random(),
        b: Math.random()
    });
}

},{"./index":"lKbZq","./util":"83iaU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9EmXI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "random", ()=>random
);
parcelHelpers.export(exports, "bounds", ()=>bounds
);
// randomColor by David Merfield under the CC0 license
// https://github.com/davidmerfield/randomColor/
var _index = require("./index");
function random(options) {
    if (options === void 0) options = {
    };
    // Check if we need to generate multiple colors
    if (options.count !== undefined && options.count !== null) {
        var totalColors = options.count;
        var colors = [];
        options.count = undefined;
        while(totalColors > colors.length){
            // Since we're generating multiple colors,
            // incremement the seed. Otherwise we'd just
            // generate the same color each time...
            options.count = null;
            if (options.seed) options.seed += 1;
            colors.push(random(options));
        }
        options.count = totalColors;
        return colors;
    }
    // First we pick a hue (H)
    var h = pickHue(options.hue, options.seed);
    // Then use H to determine saturation (S)
    var s = pickSaturation(h, options);
    // Then use S and H to determine brightness (B).
    var v = pickBrightness(h, s, options);
    var res = {
        h: h,
        s: s,
        v: v
    };
    if (options.alpha !== undefined) res.a = options.alpha;
    // Then we return the HSB color in the desired format
    return new _index.TinyColor(res);
}
function pickHue(hue, seed) {
    var hueRange = getHueRange(hue);
    var res = randomWithin(hueRange, seed);
    // Instead of storing red as two seperate ranges,
    // we group them, using negative numbers
    if (res < 0) res = 360 + res;
    return res;
}
function pickSaturation(hue, options) {
    if (options.hue === 'monochrome') return 0;
    if (options.luminosity === 'random') return randomWithin([
        0,
        100
    ], options.seed);
    var saturationRange = getColorInfo(hue).saturationRange;
    var sMin = saturationRange[0];
    var sMax = saturationRange[1];
    switch(options.luminosity){
        case 'bright':
            sMin = 55;
            break;
        case 'dark':
            sMin = sMax - 10;
            break;
        case 'light':
            sMax = 55;
            break;
        default:
            break;
    }
    return randomWithin([
        sMin,
        sMax
    ], options.seed);
}
function pickBrightness(H, S, options) {
    var bMin = getMinimumBrightness(H, S);
    var bMax = 100;
    switch(options.luminosity){
        case 'dark':
            bMax = bMin + 20;
            break;
        case 'light':
            bMin = (bMax + bMin) / 2;
            break;
        case 'random':
            bMin = 0;
            bMax = 100;
            break;
        default:
            break;
    }
    return randomWithin([
        bMin,
        bMax
    ], options.seed);
}
function getMinimumBrightness(H, S) {
    var lowerBounds = getColorInfo(H).lowerBounds;
    for(var i = 0; i < lowerBounds.length - 1; i++){
        var s1 = lowerBounds[i][0];
        var v1 = lowerBounds[i][1];
        var s2 = lowerBounds[i + 1][0];
        var v2 = lowerBounds[i + 1][1];
        if (S >= s1 && S <= s2) {
            var m = (v2 - v1) / (s2 - s1);
            var b = v1 - m * s1;
            return m * S + b;
        }
    }
    return 0;
}
function getHueRange(colorInput) {
    var num = parseInt(colorInput, 10);
    if (!Number.isNaN(num) && num < 360 && num > 0) return [
        num,
        num
    ];
    if (typeof colorInput === 'string') {
        var namedColor = bounds.find(function(n) {
            return n.name === colorInput;
        });
        if (namedColor) {
            var color = defineColor(namedColor);
            if (color.hueRange) return color.hueRange;
        }
        var parsed = new _index.TinyColor(colorInput);
        if (parsed.isValid) {
            var hue = parsed.toHsv().h;
            return [
                hue,
                hue
            ];
        }
    }
    return [
        0,
        360
    ];
}
function getColorInfo(hue) {
    // Maps red colors to make picking hue easier
    if (hue >= 334 && hue <= 360) hue -= 360;
    for(var _i = 0, bounds_1 = bounds; _i < bounds_1.length; _i++){
        var bound = bounds_1[_i];
        var color = defineColor(bound);
        if (color.hueRange && hue >= color.hueRange[0] && hue <= color.hueRange[1]) return color;
    }
    throw Error('Color not found');
}
function randomWithin(range, seed) {
    if (seed === undefined) return Math.floor(range[0] + Math.random() * (range[1] + 1 - range[0]));
    // Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/
    var max = range[1] || 1;
    var min = range[0] || 0;
    seed = (seed * 9301 + 49297) % 233280;
    var rnd = seed / 233280;
    return Math.floor(min + rnd * (max - min));
}
function defineColor(bound) {
    var sMin = bound.lowerBounds[0][0];
    var sMax = bound.lowerBounds[bound.lowerBounds.length - 1][0];
    var bMin = bound.lowerBounds[bound.lowerBounds.length - 1][1];
    var bMax = bound.lowerBounds[0][1];
    return {
        name: bound.name,
        hueRange: bound.hueRange,
        lowerBounds: bound.lowerBounds,
        saturationRange: [
            sMin,
            sMax
        ],
        brightnessRange: [
            bMin,
            bMax
        ]
    };
}
var bounds = [
    {
        name: 'monochrome',
        hueRange: null,
        lowerBounds: [
            [
                0,
                0
            ],
            [
                100,
                0
            ], 
        ]
    },
    {
        name: 'red',
        hueRange: [
            -26,
            18
        ],
        lowerBounds: [
            [
                20,
                100
            ],
            [
                30,
                92
            ],
            [
                40,
                89
            ],
            [
                50,
                85
            ],
            [
                60,
                78
            ],
            [
                70,
                70
            ],
            [
                80,
                60
            ],
            [
                90,
                55
            ],
            [
                100,
                50
            ], 
        ]
    },
    {
        name: 'orange',
        hueRange: [
            19,
            46
        ],
        lowerBounds: [
            [
                20,
                100
            ],
            [
                30,
                93
            ],
            [
                40,
                88
            ],
            [
                50,
                86
            ],
            [
                60,
                85
            ],
            [
                70,
                70
            ],
            [
                100,
                70
            ], 
        ]
    },
    {
        name: 'yellow',
        hueRange: [
            47,
            62
        ],
        lowerBounds: [
            [
                25,
                100
            ],
            [
                40,
                94
            ],
            [
                50,
                89
            ],
            [
                60,
                86
            ],
            [
                70,
                84
            ],
            [
                80,
                82
            ],
            [
                90,
                80
            ],
            [
                100,
                75
            ], 
        ]
    },
    {
        name: 'green',
        hueRange: [
            63,
            178
        ],
        lowerBounds: [
            [
                30,
                100
            ],
            [
                40,
                90
            ],
            [
                50,
                85
            ],
            [
                60,
                81
            ],
            [
                70,
                74
            ],
            [
                80,
                64
            ],
            [
                90,
                50
            ],
            [
                100,
                40
            ], 
        ]
    },
    {
        name: 'blue',
        hueRange: [
            179,
            257
        ],
        lowerBounds: [
            [
                20,
                100
            ],
            [
                30,
                86
            ],
            [
                40,
                80
            ],
            [
                50,
                74
            ],
            [
                60,
                60
            ],
            [
                70,
                52
            ],
            [
                80,
                44
            ],
            [
                90,
                39
            ],
            [
                100,
                35
            ], 
        ]
    },
    {
        name: 'purple',
        hueRange: [
            258,
            282
        ],
        lowerBounds: [
            [
                20,
                100
            ],
            [
                30,
                87
            ],
            [
                40,
                79
            ],
            [
                50,
                70
            ],
            [
                60,
                65
            ],
            [
                70,
                59
            ],
            [
                80,
                52
            ],
            [
                90,
                45
            ],
            [
                100,
                42
            ], 
        ]
    },
    {
        name: 'pink',
        hueRange: [
            283,
            334
        ],
        lowerBounds: [
            [
                20,
                100
            ],
            [
                30,
                90
            ],
            [
                40,
                86
            ],
            [
                60,
                84
            ],
            [
                80,
                80
            ],
            [
                90,
                75
            ],
            [
                100,
                73
            ], 
        ]
    }, 
];

},{"./index":"lKbZq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5dzYk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8GILO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buttonEmits", ()=>buttonEmits
);
parcelHelpers.export(exports, "buttonNativeTypes", ()=>buttonNativeTypes
);
parcelHelpers.export(exports, "buttonProps", ()=>buttonProps
);
parcelHelpers.export(exports, "buttonTypes", ()=>buttonTypes
);
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _indexMjs2 = require("../../../hooks/use-common-props/index.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
const buttonTypes = [
    "default",
    "primary",
    "success",
    "warning",
    "info",
    "danger",
    "text",
    ""
];
const buttonNativeTypes = [
    "button",
    "submit",
    "reset"
];
const buttonProps = _propsMjs.buildProps({
    size: _indexMjs2.useSizeProp,
    disabled: Boolean,
    type: {
        type: String,
        values: buttonTypes,
        default: ""
    },
    icon: {
        type: _iconMjs.iconPropType,
        default: ""
    },
    nativeType: {
        type: String,
        values: buttonNativeTypes,
        default: "button"
    },
    loading: Boolean,
    loadingIcon: {
        type: _iconMjs.iconPropType,
        default: ()=>_iconsVue.Loading
    },
    plain: Boolean,
    autofocus: Boolean,
    round: Boolean,
    circle: Boolean,
    color: String,
    autoInsertSpace: {
        type: Boolean,
        default: void 0
    }
});
const buttonEmits = {
    click: (evt)=>evt instanceof MouseEvent
};

},{"../../../hooks/index.mjs":"1Ansp","../../../utils/index.mjs":"dsdeP","@element-plus/icons-vue":"b18uu","../../../utils/vue/props.mjs":"cpwWK","../../../hooks/use-common-props/index.mjs":"05czU","../../../utils/vue/icon.mjs":"3YbE5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5qNJN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ButtonGroup
);
var _vue = require("vue");
var _indexMjs = require("../../../tokens/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _buttonGroupMjs = require("./button-group.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _buttonMjs = require("../../../tokens/button.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElButtonGroup",
    props: _buttonGroupMjs.buttonGroupProps,
    setup (props) {
        _vue.provide(_buttonMjs.buttonGroupContextKey, _vue.reactive({
            size: _vue.toRef(props, "size"),
            type: _vue.toRef(props, "type")
        }));
        const ns = _indexMjs2.useNamespace("button");
        return {
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(`${_ctx.ns.b("group")}`)
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 2);
}
var ButtonGroup = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../tokens/index.mjs":"wVNQi","../../../hooks/index.mjs":"1Ansp","./button-group.mjs":"dSt6Z","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../tokens/button.mjs":"guqr8","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dSt6Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buttonGroupProps", ()=>buttonGroupProps
);
var _buttonMjs = require("./button.mjs");
const buttonGroupProps = {
    size: _buttonMjs.buttonProps.size,
    type: _buttonMjs.buttonProps.type
};

},{"./button.mjs":"8GILO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iyUgV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "calendarEmits", ()=>_calendarMjs.calendarEmits
);
parcelHelpers.export(exports, "calendarProps", ()=>_calendarMjs.calendarProps
);
parcelHelpers.export(exports, "ElCalendar", ()=>ElCalendar
);
parcelHelpers.export(exports, "default", ()=>ElCalendar
);
var _indexMjs = require("../../utils/index.mjs");
var _calendar2Mjs = require("./src/calendar2.mjs");
var _calendar2MjsDefault = parcelHelpers.interopDefault(_calendar2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _calendarMjs = require("./src/calendar.mjs");
const ElCalendar = _installMjs.withInstall(_calendar2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/calendar2.mjs":"cgO5j","../../utils/vue/install.mjs":"4TMmv","./src/calendar.mjs":"4X2do","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cgO5j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Calendar
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _indexMjs = require("../../button/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _indexMjs2 = require("../../../utils/index.mjs");
var _dateTable2Mjs = require("./date-table2.mjs");
var _dateTable2MjsDefault = parcelHelpers.interopDefault(_dateTable2Mjs);
var _calendarMjs = require("./calendar.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
var _indexMjs4 = require("../../../hooks/use-locale/index.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElCalendar",
    components: {
        DateTable: _dateTable2MjsDefault.default,
        ElButton: _indexMjs.ElButton,
        ElButtonGroup: _indexMjs.ElButtonGroup
    },
    props: _calendarMjs.calendarProps,
    emits: _calendarMjs.calendarEmits,
    setup (props, { emit  }) {
        const ns = _indexMjs3.useNamespace("calendar");
        const { t , lang  } = _indexMjs4.useLocale();
        const selectedDay = _vue.ref();
        const now = _dayjsDefault.default().locale(lang.value);
        const prevMonthDayjs = _vue.computed(()=>{
            return date.value.subtract(1, "month").date(1);
        });
        const curMonthDatePrefix = _vue.computed(()=>{
            return _dayjsDefault.default(date.value).locale(lang.value).format("YYYY-MM");
        });
        const nextMonthDayjs = _vue.computed(()=>{
            return date.value.add(1, "month").date(1);
        });
        const prevYearDayjs = _vue.computed(()=>{
            return date.value.subtract(1, "year").date(1);
        });
        const nextYearDayjs = _vue.computed(()=>{
            return date.value.add(1, "year").date(1);
        });
        const i18nDate = _vue.computed(()=>{
            const pickedMonth = `el.datepicker.month${date.value.format("M")}`;
            return `${date.value.year()} ${t("el.datepicker.year")} ${t(pickedMonth)}`;
        });
        const realSelectedDay = _vue.computed({
            get () {
                if (!props.modelValue) return selectedDay.value;
                return date.value;
            },
            set (val) {
                if (!val) return;
                selectedDay.value = val;
                const result = val.toDate();
                emit("input", result);
                emit("update:modelValue", result);
            }
        });
        const date = _vue.computed(()=>{
            if (!props.modelValue) {
                if (realSelectedDay.value) return realSelectedDay.value;
                else if (validatedRange.value.length) return validatedRange.value[0][0];
                return now;
            } else return _dayjsDefault.default(props.modelValue).locale(lang.value);
        });
        const calculateValidatedDateRange = (startDayjs, endDayjs)=>{
            const firstDay = startDayjs.startOf("week");
            const lastDay = endDayjs.endOf("week");
            const firstMonth = firstDay.get("month");
            const lastMonth = lastDay.get("month");
            if (firstMonth === lastMonth) return [
                [
                    firstDay,
                    lastDay
                ]
            ];
            else if (firstMonth + 1 === lastMonth) {
                const firstMonthLastDay = firstDay.endOf("month");
                const lastMonthFirstDay = lastDay.startOf("month");
                const isSameWeek = firstMonthLastDay.isSame(lastMonthFirstDay, "week");
                const lastMonthStartDay = isSameWeek ? lastMonthFirstDay.add(1, "week") : lastMonthFirstDay;
                return [
                    [
                        firstDay,
                        firstMonthLastDay
                    ],
                    [
                        lastMonthStartDay.startOf("week"),
                        lastDay
                    ]
                ];
            } else if (firstMonth + 2 === lastMonth) {
                const firstMonthLastDay = firstDay.endOf("month");
                const secondMonthFirstDay = firstDay.add(1, "month").startOf("month");
                const secondMonthStartDay = firstMonthLastDay.isSame(secondMonthFirstDay, "week") ? secondMonthFirstDay.add(1, "week") : secondMonthFirstDay;
                const secondMonthLastDay = secondMonthStartDay.endOf("month");
                const lastMonthFirstDay = lastDay.startOf("month");
                const lastMonthStartDay = secondMonthLastDay.isSame(lastMonthFirstDay, "week") ? lastMonthFirstDay.add(1, "week") : lastMonthFirstDay;
                return [
                    [
                        firstDay,
                        firstMonthLastDay
                    ],
                    [
                        secondMonthStartDay.startOf("week"),
                        secondMonthLastDay
                    ],
                    [
                        lastMonthStartDay.startOf("week"),
                        lastDay
                    ]
                ];
            } else {
                _errorMjs.debugWarn("ElCalendar", "start time and end time interval must not exceed two months");
                return [];
            }
        };
        const validatedRange = _vue.computed(()=>{
            if (!props.range) return [];
            const rangeArrDayjs = props.range.map((_)=>_dayjsDefault.default(_).locale(lang.value)
            );
            const [startDayjs, endDayjs] = rangeArrDayjs;
            if (startDayjs.isAfter(endDayjs)) {
                _errorMjs.debugWarn("ElCalendar", "end time should be greater than start time");
                return [];
            }
            if (startDayjs.isSame(endDayjs, "month")) return calculateValidatedDateRange(startDayjs, endDayjs);
            else {
                if (startDayjs.add(1, "month").month() !== endDayjs.month()) {
                    _errorMjs.debugWarn("ElCalendar", "start time and end time interval must not exceed two months");
                    return [];
                }
                return calculateValidatedDateRange(startDayjs, endDayjs);
            }
        });
        const pickDay = (day)=>{
            realSelectedDay.value = day;
        };
        const selectDate = (type)=>{
            let day;
            if (type === "prev-month") day = prevMonthDayjs.value;
            else if (type === "next-month") day = nextMonthDayjs.value;
            else if (type === "prev-year") day = prevYearDayjs.value;
            else if (type === "next-year") day = nextYearDayjs.value;
            else day = now;
            if (day.isSame(date.value, "day")) return;
            pickDay(day);
        };
        return {
            selectedDay,
            curMonthDatePrefix,
            i18nDate,
            realSelectedDay,
            date,
            validatedRange,
            pickDay,
            selectDate,
            t,
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_button = _vue.resolveComponent("el-button");
    const _component_el_button_group = _vue.resolveComponent("el-button-group");
    const _component_date_table = _vue.resolveComponent("date-table");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.ns.b())
    }, [
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("header"))
        }, [
            _vue.renderSlot(_ctx.$slots, "header", {
                date: _ctx.i18nDate
            }, ()=>[
                    _vue.createElementVNode("div", {
                        class: _vue.normalizeClass(_ctx.ns.e("title"))
                    }, _vue.toDisplayString(_ctx.i18nDate), 3),
                    _ctx.validatedRange.length === 0 ? (_vue.openBlock(), _vue.createElementBlock("div", {
                        key: 0,
                        class: _vue.normalizeClass(_ctx.ns.e("button-group"))
                    }, [
                        _vue.createVNode(_component_el_button_group, null, {
                            default: _vue.withCtx(()=>[
                                    _vue.createVNode(_component_el_button, {
                                        size: "small",
                                        onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.selectDate("prev-month")
                                        )
                                    }, {
                                        default: _vue.withCtx(()=>[
                                                _vue.createTextVNode(_vue.toDisplayString(_ctx.t("el.datepicker.prevMonth")), 1)
                                            ]
                                        ),
                                        _: 1
                                    }),
                                    _vue.createVNode(_component_el_button, {
                                        size: "small",
                                        onClick: _cache[1] || (_cache[1] = ($event)=>_ctx.selectDate("today")
                                        )
                                    }, {
                                        default: _vue.withCtx(()=>[
                                                _vue.createTextVNode(_vue.toDisplayString(_ctx.t("el.datepicker.today")), 1)
                                            ]
                                        ),
                                        _: 1
                                    }),
                                    _vue.createVNode(_component_el_button, {
                                        size: "small",
                                        onClick: _cache[2] || (_cache[2] = ($event)=>_ctx.selectDate("next-month")
                                        )
                                    }, {
                                        default: _vue.withCtx(()=>[
                                                _vue.createTextVNode(_vue.toDisplayString(_ctx.t("el.datepicker.nextMonth")), 1)
                                            ]
                                        ),
                                        _: 1
                                    })
                                ]
                            ),
                            _: 1
                        })
                    ], 2)) : _vue.createCommentVNode("v-if", true)
                ]
            )
        ], 2),
        _ctx.validatedRange.length === 0 ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.e("body"))
        }, [
            _vue.createVNode(_component_date_table, {
                date: _ctx.date,
                "selected-day": _ctx.realSelectedDay,
                onPick: _ctx.pickDay
            }, _vue.createSlots({
                _: 2
            }, [
                _ctx.$slots.dateCell ? {
                    name: "dateCell",
                    fn: _vue.withCtx((data)=>[
                            _vue.renderSlot(_ctx.$slots, "dateCell", _vue.normalizeProps(_vue.guardReactiveProps(data)))
                        ]
                    )
                } : void 0
            ]), 1032, [
                "date",
                "selected-day",
                "onPick"
            ])
        ], 2)) : (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 1,
            class: _vue.normalizeClass(_ctx.ns.e("body"))
        }, [
            (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.validatedRange, (range_, index)=>{
                return _vue.openBlock(), _vue.createBlock(_component_date_table, {
                    key: index,
                    date: range_[0],
                    "selected-day": _ctx.realSelectedDay,
                    range: range_,
                    "hide-header": index !== 0,
                    onPick: _ctx.pickDay
                }, _vue.createSlots({
                    _: 2
                }, [
                    _ctx.$slots.dateCell ? {
                        name: "dateCell",
                        fn: _vue.withCtx((data)=>[
                                _vue.renderSlot(_ctx.$slots, "dateCell", _vue.normalizeProps(_vue.guardReactiveProps(data)))
                            ]
                        )
                    } : void 0
                ]), 1032, [
                    "date",
                    "selected-day",
                    "range",
                    "hide-header",
                    "onPick"
                ]);
            }), 128))
        ], 2))
    ], 2);
}
var Calendar = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","dayjs":"NJZFB","../../button/index.mjs":"64Ym1","../../../hooks/index.mjs":"1Ansp","../../../utils/index.mjs":"dsdeP","./date-table2.mjs":"9GISS","./calendar.mjs":"4X2do","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../hooks/use-locale/index.mjs":"c1HoA","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"NJZFB":[function(require,module,exports) {
!function(t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
}(this, function() {
    "use strict";
    var t1 = 1000, e1 = 60000, n1 = 3600000, r1 = "millisecond", i1 = "second", s1 = "minute", u1 = "hour", a1 = "day", o1 = "week", f1 = "month", h1 = "quarter", c1 = "year", d1 = "date", $1 = "Invalid Date", l1 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y1 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M1 = {
        name: "en",
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
    }, m1 = function(t, e, n) {
        var r = String(t);
        return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
    }, g1 = {
        s: m1,
        z: function(t) {
            var e = -t.utcOffset(), n = Math.abs(e), r = Math.floor(n / 60), i = n % 60;
            return (e <= 0 ? "+" : "-") + m1(r, 2, "0") + ":" + m1(i, 2, "0");
        },
        m: function t(e, n) {
            if (e.date() < n.date()) return -t(n, e);
            var r = 12 * (n.year() - e.year()) + (n.month() - e.month()), i = e.clone().add(r, f1), s = n - i < 0, u = e.clone().add(r + (s ? -1 : 1), f1);
            return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
        },
        a: function(t) {
            return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
        },
        p: function(t) {
            return ({
                M: f1,
                y: c1,
                w: o1,
                d: a1,
                D: d1,
                h: u1,
                m: s1,
                s: i1,
                ms: r1,
                Q: h1
            })[t] || String(t || "").toLowerCase().replace(/s$/, "");
        },
        u: function(t) {
            return void 0 === t;
        }
    }, D1 = "en", v1 = {
    };
    v1[D1] = M1;
    var p = function(t) {
        return t instanceof _;
    }, S = function(t, e, n) {
        var r;
        if (!t) return D1;
        if ("string" == typeof t) v1[t] && (r = t), e && (v1[t] = e, r = t);
        else {
            var i = t.name;
            v1[i] = t, r = i;
        }
        return !n && r && (D1 = r), r || !n && D1;
    }, w = function(t, e) {
        if (p(t)) return t.clone();
        var n = "object" == typeof e ? e : {
        };
        return n.date = t, n.args = arguments, new _(n);
    }, O = g1;
    O.l = S, O.i = p, O.w = function(t, e) {
        return w(t, {
            locale: e.$L,
            utc: e.$u,
            x: e.$x,
            $offset: e.$offset
        });
    };
    var _ = function() {
        function M2(t) {
            this.$L = S(t.locale, null, !0), this.parse(t);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
            this.$d = (function(t) {
                var e = t.date, n = t.utc;
                if (null === e) return new Date(NaN);
                if (O.u(e)) return new Date;
                if (e instanceof Date) return new Date(e);
                if ("string" == typeof e && !/Z$/i.test(e)) {
                    var r = e.match(l1);
                    if (r) {
                        var i = r[2] - 1 || 0, s = (r[7] || "0").substring(0, 3);
                        return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
                    }
                }
                return new Date(e);
            })(t2), this.$x = t2.x || {
            }, this.init();
        }, m2.init = function() {
            var t = this.$d;
            this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
        }, m2.$utils = function() {
            return O;
        }, m2.isValid = function() {
            return !(this.$d.toString() === $1);
        }, m2.isSame = function(t, e) {
            var n = w(t);
            return this.startOf(e) <= n && n <= this.endOf(e);
        }, m2.isAfter = function(t, e) {
            return w(t) < this.startOf(e);
        }, m2.isBefore = function(t, e) {
            return this.endOf(e) < w(t);
        }, m2.$g = function(t, e, n) {
            return O.u(t) ? this[e] : this.set(n, t);
        }, m2.unix = function() {
            return Math.floor(this.valueOf() / 1000);
        }, m2.valueOf = function() {
            return this.$d.getTime();
        }, m2.startOf = function(t3, e2) {
            var n = this, r = !!O.u(e2) || e2, h = O.p(t3), $ = function(t, e) {
                var i = O.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
                return r ? i : i.endOf(a1);
            }, l = function(t, e) {
                return O.w(n.toDate()[t].apply(n.toDate("s"), (r ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    23,
                    59,
                    59,
                    999
                ]).slice(e)), n);
            }, y = this.$W, M = this.$M, m = this.$D, g = "set" + (this.$u ? "UTC" : "");
            switch(h){
                case c1:
                    return r ? $(1, 0) : $(31, 11);
                case f1:
                    return r ? $(1, M) : $(0, M + 1);
                case o1:
                    var D = this.$locale().weekStart || 0, v = (y < D ? y + 7 : y) - D;
                    return $(r ? m - v : m + (6 - v), M);
                case a1:
                case d1:
                    return l(g + "Hours", 0);
                case u1:
                    return l(g + "Minutes", 1);
                case s1:
                    return l(g + "Seconds", 2);
                case i1:
                    return l(g + "Milliseconds", 3);
                default:
                    return this.clone();
            }
        }, m2.endOf = function(t) {
            return this.startOf(t, !1);
        }, m2.$set = function(t, e) {
            var n, o = O.p(t), h = "set" + (this.$u ? "UTC" : ""), $ = (n = {
            }, n[a1] = h + "Date", n[d1] = h + "Date", n[f1] = h + "Month", n[c1] = h + "FullYear", n[u1] = h + "Hours", n[s1] = h + "Minutes", n[i1] = h + "Seconds", n[r1] = h + "Milliseconds", n)[o], l = o === a1 ? this.$D + (e - this.$W) : e;
            if (o === f1 || o === c1) {
                var y = this.clone().set(d1, 1);
                y.$d[$](l), y.init(), this.$d = y.set(d1, Math.min(this.$D, y.daysInMonth())).$d;
            } else $ && this.$d[$](l);
            return this.init(), this;
        }, m2.set = function(t, e) {
            return this.clone().$set(t, e);
        }, m2.get = function(t) {
            return this[O.p(t)]();
        }, m2.add = function(r, h) {
            var d, $ = this;
            r = Number(r);
            var l = O.p(h), y = function(t) {
                var e = w($);
                return O.w(e.date(e.date() + Math.round(t * r)), $);
            };
            if (l === f1) return this.set(f1, this.$M + r);
            if (l === c1) return this.set(c1, this.$y + r);
            if (l === a1) return y(1);
            if (l === o1) return y(7);
            var M = (d = {
            }, d[s1] = e1, d[u1] = n1, d[i1] = t1, d)[l] || 1, m = this.$d.getTime() + r * M;
            return O.w(m, this);
        }, m2.subtract = function(t, e) {
            return this.add(-1 * t, e);
        }, m2.format = function(t4) {
            var e3 = this, n2 = this.$locale();
            if (!this.isValid()) return n2.invalidDate || $1;
            var r2 = t4 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u = this.$m, a = this.$M, o = n2.weekdays, f = n2.months, h = function(t, n, i, s) {
                return t && (t[n] || t(e3, r2)) || i[n].substr(0, s);
            }, c = function(t) {
                return O.s(s2 % 12 || 12, t, "0");
            }, d = n2.meridiem || function(t, e, n) {
                var r = t < 12 ? "AM" : "PM";
                return n ? r.toLowerCase() : r;
            }, l = {
                YY: String(this.$y).slice(-2),
                YYYY: this.$y,
                M: a + 1,
                MM: O.s(a + 1, 2, "0"),
                MMM: h(n2.monthsShort, a, f, 3),
                MMMM: h(f, a),
                D: this.$D,
                DD: O.s(this.$D, 2, "0"),
                d: String(this.$W),
                dd: h(n2.weekdaysMin, this.$W, o, 2),
                ddd: h(n2.weekdaysShort, this.$W, o, 3),
                dddd: o[this.$W],
                H: String(s2),
                HH: O.s(s2, 2, "0"),
                h: c(1),
                hh: c(2),
                a: d(s2, u, !0),
                A: d(s2, u, !1),
                m: String(u),
                mm: O.s(u, 2, "0"),
                s: String(this.$s),
                ss: O.s(this.$s, 2, "0"),
                SSS: O.s(this.$ms, 3, "0"),
                Z: i2
            };
            return r2.replace(y1, function(t, e) {
                return e || l[t] || i2.replace(":", "");
            });
        }, m2.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r, d, $) {
            var l, y = O.p(d), M = w(r), m = (M.utcOffset() - this.utcOffset()) * e1, g = this - M, D = O.m(this, M);
            return D = (l = {
            }, l[c1] = D / 12, l[f1] = D, l[h1] = D / 3, l[o1] = (g - m) / 604800000, l[a1] = (g - m) / 86400000, l[u1] = g / n1, l[s1] = g / e1, l[i1] = g / t1, l)[y] || g, $ ? D : O.a(D);
        }, m2.daysInMonth = function() {
            return this.endOf(f1).$D;
        }, m2.$locale = function() {
            return v1[this.$L];
        }, m2.locale = function(t, e) {
            if (!t) return this.$L;
            var n = this.clone(), r = S(t, e, !0);
            return r && (n.$L = r), n;
        }, m2.clone = function() {
            return O.w(this.$d, this);
        }, m2.toDate = function() {
            return new Date(this.valueOf());
        }, m2.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
            return this.$d.toISOString();
        }, m2.toString = function() {
            return this.$d.toUTCString();
        }, M2;
    }(), b = _.prototype;
    return w.prototype = b, [
        [
            "$ms",
            r1
        ],
        [
            "$s",
            i1
        ],
        [
            "$m",
            s1
        ],
        [
            "$H",
            u1
        ],
        [
            "$W",
            a1
        ],
        [
            "$M",
            f1
        ],
        [
            "$y",
            c1
        ],
        [
            "$D",
            d1
        ]
    ].forEach(function(t) {
        b[t[1]] = function(e) {
            return this.$g(e, t[0], t[1]);
        };
    }), w.extend = function(t, e) {
        return t.$i || (t(e, _, w), t.$i = !0), w;
    }, w.locale = S, w.isDayjs = p, w.unix = function(t) {
        return w(1000 * t);
    }, w.en = v1[D1], w.Ls = v1, w.p = {
    }, w;
});

},{}],"9GISS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>DateTable
);
parcelHelpers.export(exports, "getMonthDays", ()=>getMonthDays
);
parcelHelpers.export(exports, "getPrevMonthLastDays", ()=>getPrevMonthLastDays
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _localeData = require("dayjs/plugin/localeData");
var _localeDataDefault = parcelHelpers.interopDefault(_localeData);
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../time-picker/index.mjs");
var _dateTableMjs = require("./date-table.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _dateUtilsMjs = require("../../time-picker/src/common/date-utils.mjs");
var _indexMjs2 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
_dayjsDefault.default.extend(_localeDataDefault.default);
const WEEK_DAYS = [
    "sun",
    "mon",
    "tue",
    "wed",
    "thu",
    "fri",
    "sat"
];
const getPrevMonthLastDays = (date, count)=>{
    const lastDay = date.subtract(1, "month").endOf("month").date();
    return _dateUtilsMjs.rangeArr(count).map((_, index)=>lastDay - (count - index - 1)
    );
};
const getMonthDays = (date)=>{
    const days = date.daysInMonth();
    return _dateUtilsMjs.rangeArr(days).map((_, index)=>index + 1
    );
};
const toNestedArr = (days)=>_dateUtilsMjs.rangeArr(days.length / 7).map((index)=>{
        const start = index * 7;
        return days.slice(start, start + 7);
    })
;
const _sfc_main = _vue.defineComponent({
    props: _dateTableMjs.dateTableProps,
    emits: _dateTableMjs.dateTableEmits,
    setup (props, { emit  }) {
        const { t , lang  } = _indexMjs2.useLocale();
        const nsTable = _indexMjs3.useNamespace("calendar-table");
        const nsDay = _indexMjs3.useNamespace("calendar-day");
        const now = _dayjsDefault.default().locale(lang.value);
        const firstDayOfWeek = now.$locale().weekStart || 0;
        const isInRange = _vue.computed(()=>!!props.range && !!props.range.length
        );
        const rows = _vue.computed(()=>{
            let days = [];
            if (isInRange.value) {
                const [start, end] = props.range;
                const currentMonthRange = _dateUtilsMjs.rangeArr(end.date() - start.date() + 1).map((index)=>({
                        text: start.date() + index,
                        type: "current"
                    })
                );
                let remaining = currentMonthRange.length % 7;
                remaining = remaining === 0 ? 0 : 7 - remaining;
                const nextMonthRange = _dateUtilsMjs.rangeArr(remaining).map((_, index)=>({
                        text: index + 1,
                        type: "next"
                    })
                );
                days = currentMonthRange.concat(nextMonthRange);
            } else {
                const firstDay = props.date.startOf("month").day() || 7;
                const prevMonthDays = getPrevMonthLastDays(props.date, firstDay - firstDayOfWeek).map((day)=>({
                        text: day,
                        type: "prev"
                    })
                );
                const currentMonthDays = getMonthDays(props.date).map((day)=>({
                        text: day,
                        type: "current"
                    })
                );
                days = [
                    ...prevMonthDays,
                    ...currentMonthDays
                ];
                const nextMonthDays = _dateUtilsMjs.rangeArr(42 - days.length).map((_, index)=>({
                        text: index + 1,
                        type: "next"
                    })
                );
                days = days.concat(nextMonthDays);
            }
            return toNestedArr(days);
        });
        const weekDays = _vue.computed(()=>{
            const start = firstDayOfWeek;
            if (start === 0) return WEEK_DAYS.map((_)=>t(`el.datepicker.weeks.${_}`)
            );
            else return WEEK_DAYS.slice(start).concat(WEEK_DAYS.slice(0, start)).map((_)=>t(`el.datepicker.weeks.${_}`)
            );
        });
        const getFormattedDate = (day, type)=>{
            switch(type){
                case "prev":
                    return props.date.startOf("month").subtract(1, "month").date(day);
                case "next":
                    return props.date.startOf("month").add(1, "month").date(day);
                case "current":
                    return props.date.date(day);
            }
        };
        const getCellClass = ({ text , type  })=>{
            const classes = [
                type
            ];
            if (type === "current") {
                const date = getFormattedDate(text, type);
                if (date.isSame(props.selectedDay, "day")) classes.push("is-selected");
                if (date.isSame(now, "day")) classes.push("is-today");
            }
            return classes;
        };
        const handlePickDay = ({ text , type  })=>{
            const date = getFormattedDate(text, type);
            emit("pick", date);
        };
        const getSlotData = ({ text , type  })=>{
            const day = getFormattedDate(text, type);
            return {
                isSelected: day.isSame(props.selectedDay),
                type: `${type}-month`,
                day: day.format("YYYY-MM-DD"),
                date: day.toDate()
            };
        };
        return {
            isInRange,
            weekDays,
            rows,
            getCellClass,
            handlePickDay,
            getSlotData,
            nsTable,
            nsDay
        };
    }
});
const _hoisted_1 = {
    key: 0
};
const _hoisted_2 = [
    "onClick"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("table", {
        class: _vue.normalizeClass([
            _ctx.nsTable.b(),
            _ctx.nsTable.is("range", _ctx.isInRange)
        ]),
        cellspacing: "0",
        cellpadding: "0"
    }, [
        !_ctx.hideHeader ? (_vue.openBlock(), _vue.createElementBlock("thead", _hoisted_1, [
            (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.weekDays, (day)=>{
                return _vue.openBlock(), _vue.createElementBlock("th", {
                    key: day
                }, _vue.toDisplayString(day), 1);
            }), 128))
        ])) : _vue.createCommentVNode("v-if", true),
        _vue.createElementVNode("tbody", null, [
            (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.rows, (row, index)=>{
                return _vue.openBlock(), _vue.createElementBlock("tr", {
                    key: index,
                    class: _vue.normalizeClass({
                        [_ctx.nsTable.e("row")]: true,
                        [_ctx.nsTable.em("row", "hide-border")]: index === 0 && _ctx.hideHeader
                    })
                }, [
                    (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(row, (cell, key)=>{
                        return _vue.openBlock(), _vue.createElementBlock("td", {
                            key,
                            class: _vue.normalizeClass(_ctx.getCellClass(cell)),
                            onClick: ($event)=>_ctx.handlePickDay(cell)
                        }, [
                            _vue.createElementVNode("div", {
                                class: _vue.normalizeClass(_ctx.nsDay.b())
                            }, [
                                _vue.renderSlot(_ctx.$slots, "dateCell", {
                                    data: _ctx.getSlotData(cell)
                                }, ()=>[
                                        _vue.createElementVNode("span", null, _vue.toDisplayString(cell.text), 1)
                                    ]
                                )
                            ], 2)
                        ], 10, _hoisted_2);
                    }), 128))
                ], 2);
            }), 128))
        ])
    ], 2);
}
var DateTable = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","dayjs":"NJZFB","dayjs/plugin/localeData":"31yM4","../../../hooks/index.mjs":"1Ansp","../../time-picker/index.mjs":"4TaeO","./date-table.mjs":"llevA","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../time-picker/src/common/date-utils.mjs":"3CJdm","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"31yM4":[function(require,module,exports) {
!function(n, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (n = "undefined" != typeof globalThis ? globalThis : n || self).dayjs_plugin_localeData = e();
}(this, function() {
    "use strict";
    return function(n1, e1, t1) {
        var r1 = e1.prototype, o = function(n) {
            return n && (n.indexOf ? n : n.s);
        }, u1 = function(n2, e, t, r, u) {
            var i = n2.name ? n2 : n2.$locale(), a = o(i[e]), s = o(i[t]), f = a || s.map(function(n) {
                return n.substr(0, r);
            });
            if (!u) return f;
            var d = i.weekStart;
            return f.map(function(n, e) {
                return f[(e + (d || 0)) % 7];
            });
        }, i1 = function() {
            return t1.Ls[t1.locale()];
        }, a1 = function(n3, e2) {
            return n3.formats[e2] || (function(n) {
                return n.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n, e, t) {
                    return e || t.slice(1);
                });
            })(n3.formats[e2.toUpperCase()]);
        }, s1 = function() {
            var n = this;
            return {
                months: function(e) {
                    return e ? e.format("MMMM") : u1(n, "months");
                },
                monthsShort: function(e) {
                    return e ? e.format("MMM") : u1(n, "monthsShort", "months", 3);
                },
                firstDayOfWeek: function() {
                    return n.$locale().weekStart || 0;
                },
                weekdays: function(e) {
                    return e ? e.format("dddd") : u1(n, "weekdays");
                },
                weekdaysMin: function(e) {
                    return e ? e.format("dd") : u1(n, "weekdaysMin", "weekdays", 2);
                },
                weekdaysShort: function(e) {
                    return e ? e.format("ddd") : u1(n, "weekdaysShort", "weekdays", 3);
                },
                longDateFormat: function(e) {
                    return a1(n.$locale(), e);
                },
                meridiem: this.$locale().meridiem,
                ordinal: this.$locale().ordinal
            };
        };
        r1.localeData = function() {
            return s1.bind(this)();
        }, t1.localeData = function() {
            var n = i1();
            return {
                firstDayOfWeek: function() {
                    return n.weekStart || 0;
                },
                weekdays: function() {
                    return t1.weekdays();
                },
                weekdaysShort: function() {
                    return t1.weekdaysShort();
                },
                weekdaysMin: function() {
                    return t1.weekdaysMin();
                },
                months: function() {
                    return t1.months();
                },
                monthsShort: function() {
                    return t1.monthsShort();
                },
                longDateFormat: function(e) {
                    return a1(n, e);
                },
                meridiem: n.meridiem,
                ordinal: n.ordinal
            };
        }, t1.months = function() {
            return u1(i1(), "months");
        }, t1.monthsShort = function() {
            return u1(i1(), "monthsShort", "months", 3);
        }, t1.weekdays = function(n) {
            return u1(i1(), "weekdays", null, null, n);
        }, t1.weekdaysShort = function(n) {
            return u1(i1(), "weekdaysShort", "weekdays", 3, n);
        }, t1.weekdaysMin = function(n) {
            return u1(i1(), "weekdaysMin", "weekdays", 2, n);
        };
    };
});

},{}],"4TaeO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CommonPicker", ()=>_pickerMjsDefault.default
);
parcelHelpers.export(exports, "TimePickPanel", ()=>_panelTimePickMjsDefault.default
);
parcelHelpers.export(exports, "extractDateFormat", ()=>_dateUtilsMjs.extractDateFormat
);
parcelHelpers.export(exports, "extractTimeFormat", ()=>_dateUtilsMjs.extractTimeFormat
);
parcelHelpers.export(exports, "rangeArr", ()=>_dateUtilsMjs.rangeArr
);
parcelHelpers.export(exports, "DEFAULT_FORMATS_DATE", ()=>_constantMjs.DEFAULT_FORMATS_DATE
);
parcelHelpers.export(exports, "DEFAULT_FORMATS_DATEPICKER", ()=>_constantMjs.DEFAULT_FORMATS_DATEPICKER
);
parcelHelpers.export(exports, "DEFAULT_FORMATS_TIME", ()=>_constantMjs.DEFAULT_FORMATS_TIME
);
parcelHelpers.export(exports, "timePickerDefaultProps", ()=>_propsMjs.timePickerDefaultProps
);
parcelHelpers.export(exports, "ElTimePicker", ()=>ElTimePicker
);
parcelHelpers.export(exports, "default", ()=>_TimePicker
);
var _timePickerMjs = require("./src/time-picker.mjs");
var _timePickerMjsDefault = parcelHelpers.interopDefault(_timePickerMjs);
var _pickerMjs = require("./src/common/picker.mjs");
var _pickerMjsDefault = parcelHelpers.interopDefault(_pickerMjs);
var _panelTimePickMjs = require("./src/time-picker-com/panel-time-pick.mjs");
var _panelTimePickMjsDefault = parcelHelpers.interopDefault(_panelTimePickMjs);
var _dateUtilsMjs = require("./src/common/date-utils.mjs");
var _constantMjs = require("./src/common/constant.mjs");
var _propsMjs = require("./src/common/props.mjs");
const _TimePicker = _timePickerMjsDefault.default;
_TimePicker.install = (app)=>{
    app.component(_TimePicker.name, _TimePicker);
};
const ElTimePicker = _TimePicker;

},{"./src/time-picker.mjs":"759Hv","./src/common/picker.mjs":"3jAyz","./src/time-picker-com/panel-time-pick.mjs":"351Kw","./src/common/date-utils.mjs":"3CJdm","./src/common/constant.mjs":"b75g0","./src/common/props.mjs":"gx1qH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"759Hv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TimePicker
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _customParseFormat = require("dayjs/plugin/customParseFormat");
var _customParseFormatDefault = parcelHelpers.interopDefault(_customParseFormat);
var _constantMjs = require("./common/constant.mjs");
var _pickerMjs = require("./common/picker.mjs");
var _pickerMjsDefault = parcelHelpers.interopDefault(_pickerMjs);
var _panelTimePickMjs = require("./time-picker-com/panel-time-pick.mjs");
var _panelTimePickMjsDefault = parcelHelpers.interopDefault(_panelTimePickMjs);
var _panelTimeRangeMjs = require("./time-picker-com/panel-time-range.mjs");
var _panelTimeRangeMjsDefault = parcelHelpers.interopDefault(_panelTimeRangeMjs);
var _propsMjs = require("./common/props.mjs");
_dayjsDefault.default.extend(_customParseFormatDefault.default);
var TimePicker = _vue.defineComponent({
    name: "ElTimePicker",
    install: null,
    props: {
        ..._propsMjs.timePickerDefaultProps,
        isRange: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "update:modelValue"
    ],
    setup (props, ctx) {
        const commonPicker = _vue.ref(null);
        const type = props.isRange ? "timerange" : "time";
        const panel = props.isRange ? _panelTimeRangeMjsDefault.default : _panelTimePickMjsDefault.default;
        const refProps = {
            ...props,
            focus: ()=>{
                var _a;
                (_a = commonPicker.value) == null || _a.handleFocus();
            },
            blur: ()=>{
                var _a;
                (_a = commonPicker.value) == null || _a.handleBlur();
            }
        };
        _vue.provide("ElPopperOptions", props.popperOptions);
        ctx.expose(refProps);
        return ()=>{
            var _a;
            const format = (_a = props.format) != null ? _a : _constantMjs.DEFAULT_FORMATS_TIME;
            return _vue.h(_pickerMjsDefault.default, {
                ...props,
                format,
                type,
                ref: commonPicker,
                "onUpdate:modelValue": (value)=>ctx.emit("update:modelValue", value)
            }, {
                default: (scopedProps)=>_vue.h(panel, scopedProps)
            });
        };
    }
});

},{"vue":"gzxs9","dayjs":"NJZFB","dayjs/plugin/customParseFormat":"dmrpe","./common/constant.mjs":"b75g0","./common/picker.mjs":"3jAyz","./time-picker-com/panel-time-pick.mjs":"351Kw","./time-picker-com/panel-time-range.mjs":"3aly5","./common/props.mjs":"gx1qH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dmrpe":[function(require,module,exports) {
!function(t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_customParseFormat = e();
}(this, function() {
    "use strict";
    var t1 = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
    }, e1 = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n1 = /\d\d/, r1 = /\d\d?/, i1 = /\d*[^\s\d-_:/()]+/, o1 = {
    }, s1 = function(t) {
        return (t = +t) + (t > 68 ? 1900 : 2000);
    };
    var a1 = function(t) {
        return function(e) {
            this[t] = +e;
        };
    }, f1 = [
        /[+-]\d\d:?(\d\d)?|Z/,
        function(t2) {
            (this.zone || (this.zone = {
            })).offset = (function(t) {
                if (!t) return 0;
                if ("Z" === t) return 0;
                var e = t.match(/([+-]|\d\d)/g), n = 60 * e[1] + (+e[2] || 0);
                return 0 === n ? 0 : "+" === e[0] ? -n : n;
            })(t2);
        }
    ], u1 = function(t) {
        var e = o1[t];
        return e && (e.indexOf ? e : e.s.concat(e.f));
    }, h1 = function(t, e) {
        var n, r = o1.meridiem;
        if (r) {
            for(var i = 1; i <= 24; i += 1)if (t.indexOf(r(i, 0, e)) > -1) {
                n = i > 12;
                break;
            }
        } else n = t === (e ? "pm" : "PM");
        return n;
    }, d1 = {
        A: [
            i1,
            function(t) {
                this.afternoon = h1(t, !1);
            }
        ],
        a: [
            i1,
            function(t) {
                this.afternoon = h1(t, !0);
            }
        ],
        S: [
            /\d/,
            function(t) {
                this.milliseconds = 100 * +t;
            }
        ],
        SS: [
            n1,
            function(t) {
                this.milliseconds = 10 * +t;
            }
        ],
        SSS: [
            /\d{3}/,
            function(t) {
                this.milliseconds = +t;
            }
        ],
        s: [
            r1,
            a1("seconds")
        ],
        ss: [
            r1,
            a1("seconds")
        ],
        m: [
            r1,
            a1("minutes")
        ],
        mm: [
            r1,
            a1("minutes")
        ],
        H: [
            r1,
            a1("hours")
        ],
        h: [
            r1,
            a1("hours")
        ],
        HH: [
            r1,
            a1("hours")
        ],
        hh: [
            r1,
            a1("hours")
        ],
        D: [
            r1,
            a1("day")
        ],
        DD: [
            n1,
            a1("day")
        ],
        Do: [
            i1,
            function(t) {
                var e = o1.ordinal, n = t.match(/\d+/);
                if (this.day = n[0], e) for(var r = 1; r <= 31; r += 1)e(r).replace(/\[|\]/g, "") === t && (this.day = r);
            }
        ],
        M: [
            r1,
            a1("month")
        ],
        MM: [
            n1,
            a1("month")
        ],
        MMM: [
            i1,
            function(t3) {
                var e = u1("months"), n = (u1("monthsShort") || e.map(function(t) {
                    return t.substr(0, 3);
                })).indexOf(t3) + 1;
                if (n < 1) throw new Error;
                this.month = n % 12 || n;
            }
        ],
        MMMM: [
            i1,
            function(t) {
                var e = u1("months").indexOf(t) + 1;
                if (e < 1) throw new Error;
                this.month = e % 12 || e;
            }
        ],
        Y: [
            /[+-]?\d+/,
            a1("year")
        ],
        YY: [
            n1,
            function(t) {
                this.year = s1(t);
            }
        ],
        YYYY: [
            /\d{4}/,
            a1("year")
        ],
        Z: f1,
        ZZ: f1
    };
    function c1(n2) {
        var r2, i2;
        r2 = n2, i2 = o1 && o1.formats;
        for(var s = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(e2, n3, r) {
            var o = r && r.toUpperCase();
            return n3 || i2[r] || t1[r] || i2[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(t, e, n) {
                return e || n.slice(1);
            });
        })).match(e1), a = s.length, f2 = 0; f2 < a; f2 += 1){
            var u = s[f2], h = d1[u], c = h && h[0], l = h && h[1];
            s[f2] = l ? {
                regex: c,
                parser: l
            } : u.replace(/^\[|\]$/g, "");
        }
        return function(t4) {
            for(var e3 = {
            }, n4 = 0, r = 0; n4 < a; n4 += 1){
                var i = s[n4];
                if ("string" == typeof i) r += i.length;
                else {
                    var o = i.regex, f = i.parser, u = t4.substr(r), h = o.exec(u)[0];
                    f.call(e3, h), t4 = t4.replace(h, "");
                }
            }
            return (function(t) {
                var e = t.afternoon;
                if (void 0 !== e) {
                    var n = t.hours;
                    e ? n < 12 && (t.hours += 12) : 12 === n && (t.hours = 0), delete t.afternoon;
                }
            })(e3), e3;
        };
    }
    return function(t5, e4, n5) {
        n5.p.customParseFormat = !0, t5 && t5.parseTwoDigitYear && (s1 = t5.parseTwoDigitYear);
        var r3 = e4.prototype, i3 = r3.parse;
        r3.parse = function(t6) {
            var e5 = t6.date, r4 = t6.utc, s2 = t6.args;
            this.$u = r4;
            var a2 = s2[1];
            if ("string" == typeof a2) {
                var f3 = !0 === s2[2], u2 = !0 === s2[3], h2 = f3 || u2, d2 = s2[2];
                u2 && (d2 = s2[2]), o1 = this.$locale(), !f3 && d2 && (o1 = n5.Ls[d2]), this.$d = (function(t, e, n) {
                    try {
                        if ([
                            "x",
                            "X"
                        ].indexOf(e) > -1) return new Date(("X" === e ? 1000 : 1) * t);
                        var r = c1(e)(t), i = r.year, o = r.month, s = r.day, a = r.hours, f = r.minutes, u = r.seconds, h = r.milliseconds, d = r.zone, l = new Date, m = s || (i || o ? 1 : l.getDate()), M = i || l.getFullYear(), Y = 0;
                        i && !o || (Y = o > 0 ? o - 1 : l.getMonth());
                        var p = a || 0, v = f || 0, D = u || 0, g = h || 0;
                        return d ? new Date(Date.UTC(M, Y, m, p, v, D, g + 60 * d.offset * 1000)) : n ? new Date(Date.UTC(M, Y, m, p, v, D, g)) : new Date(M, Y, m, p, v, D, g);
                    } catch (t7) {
                        return new Date("");
                    }
                })(e5, a2, r4), this.init(), d2 && !0 !== d2 && (this.$L = this.locale(d2).$L), h2 && e5 != this.format(a2) && (this.$d = new Date("")), o1 = {
                };
            } else if (a2 instanceof Array) for(var l1 = a2.length, m1 = 1; m1 <= l1; m1 += 1){
                s2[1] = a2[m1 - 1];
                var M1 = n5.apply(this, s2);
                if (M1.isValid()) {
                    this.$d = M1.$d, this.$L = M1.$L, this.init();
                    break;
                }
                m1 === l1 && (this.$d = new Date(""));
            }
            else i3.call(this, t6);
        };
    };
});

},{}],"b75g0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_FORMATS_DATE", ()=>DEFAULT_FORMATS_DATE
);
parcelHelpers.export(exports, "DEFAULT_FORMATS_DATEPICKER", ()=>DEFAULT_FORMATS_DATEPICKER
);
parcelHelpers.export(exports, "DEFAULT_FORMATS_TIME", ()=>DEFAULT_FORMATS_TIME
);
const DEFAULT_FORMATS_TIME = "HH:mm:ss";
const DEFAULT_FORMATS_DATE = "YYYY-MM-DD";
const DEFAULT_FORMATS_DATEPICKER = {
    date: DEFAULT_FORMATS_DATE,
    week: "gggg[w]ww",
    year: "YYYY",
    month: "YYYY-MM",
    datetime: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
    monthrange: "YYYY-MM",
    daterange: DEFAULT_FORMATS_DATE,
    datetimerange: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3jAyz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CommonPicker
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _lodashUnified = require("lodash-unified");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../../hooks/index.mjs");
var _indexMjs1 = require("../../../../tokens/index.mjs");
var _indexMjs2 = require("../../../input/index.mjs");
var _indexMjs3 = require("../../../icon/index.mjs");
var _indexMjs4 = require("../../../tooltip/index.mjs");
var _indexMjs5 = require("../../../../utils/index.mjs");
var _indexMjs6 = require("../../../../constants/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _propsMjs = require("./props.mjs");
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _typesMjs = require("../../../../utils/types.mjs");
var _indexMjs7 = require("../../../../hooks/use-locale/index.mjs");
var _formMjs = require("../../../../tokens/form.mjs");
var _indexMjs8 = require("../../../../hooks/use-common-props/index.mjs");
var _ariaMjs = require("../../../../constants/aria.mjs");
const dateEquals = function(a, b) {
    const aIsDate = a instanceof Date;
    const bIsDate = b instanceof Date;
    if (aIsDate && bIsDate) return a.getTime() === b.getTime();
    if (!aIsDate && !bIsDate) return a === b;
    return false;
};
const valueEquals = function(a, b) {
    const aIsArray = a instanceof Array;
    const bIsArray = b instanceof Array;
    if (aIsArray && bIsArray) {
        if (a.length !== b.length) return false;
        return a.every((item, index)=>dateEquals(item, b[index])
        );
    }
    if (!aIsArray && !bIsArray) return dateEquals(a, b);
    return false;
};
const parser = function(date, format, lang) {
    const day = _typesMjs.isEmpty(format) || format === "x" ? _dayjsDefault.default(date).locale(lang) : _dayjsDefault.default(date, format).locale(lang);
    return day.isValid() ? day : void 0;
};
const formatter = function(date, format, lang) {
    if (_typesMjs.isEmpty(format)) return date;
    if (format === "x") return +date;
    return _dayjsDefault.default(date).locale(lang).format(format);
};
const _sfc_main = _vue.defineComponent({
    name: "Picker",
    components: {
        ElInput: _indexMjs2.ElInput,
        ElTooltip: _indexMjs4.ElTooltip,
        ElIcon: _indexMjs3.ElIcon
    },
    props: _propsMjs.timePickerDefaultProps,
    emits: [
        "update:modelValue",
        "change",
        "focus",
        "blur",
        "calendar-change",
        "panel-change",
        "visible-change"
    ],
    setup (props, ctx) {
        const { lang  } = _indexMjs7.useLocale();
        const elForm = _vue.inject(_formMjs.elFormKey, {
        });
        const elFormItem = _vue.inject(_formMjs.elFormItemKey, {
        });
        const elPopperOptions = _vue.inject("ElPopperOptions", {
        });
        const refPopper = _vue.ref();
        const inputRef = _vue.ref();
        const pickerVisible = _vue.ref(false);
        const pickerActualVisible = _vue.ref(false);
        const valueOnOpen = _vue.ref(null);
        _vue.watch(pickerVisible, (val)=>{
            var _a;
            if (!val) {
                userInput.value = null;
                _vue.nextTick(()=>{
                    emitChange(props.modelValue);
                });
                ctx.emit("blur");
                blurInput();
                props.validateEvent && ((_a = elFormItem.validate) == null || _a.call(elFormItem, "blur"));
            } else valueOnOpen.value = props.modelValue;
        });
        const emitChange = (val, isClear)=>{
            var _a;
            if (isClear || !valueEquals(val, valueOnOpen.value)) {
                ctx.emit("change", val);
                props.validateEvent && ((_a = elFormItem.validate) == null || _a.call(elFormItem, "change"));
            }
        };
        const emitInput = (val)=>{
            if (!valueEquals(props.modelValue, val)) {
                let formatValue;
                if (Array.isArray(val)) formatValue = val.map((_)=>formatter(_, props.valueFormat, lang.value)
                );
                else if (val) formatValue = formatter(val, props.valueFormat, lang.value);
                ctx.emit("update:modelValue", val ? formatValue : val, lang.value);
            }
        };
        const refInput = _vue.computed(()=>{
            if (inputRef.value) {
                const _r = isRangeInput.value ? inputRef.value : inputRef.value.$el;
                return Array.from(_r.querySelectorAll("input"));
            }
            return [];
        });
        const refStartInput = _vue.computed(()=>{
            return refInput == null ? void 0 : refInput.value[0];
        });
        const refEndInput = _vue.computed(()=>{
            return refInput == null ? void 0 : refInput.value[1];
        });
        const setSelectionRange = (start, end, pos)=>{
            const _inputs = refInput.value;
            if (!_inputs.length) return;
            if (!pos || pos === "min") {
                _inputs[0].setSelectionRange(start, end);
                _inputs[0].focus();
            } else if (pos === "max") {
                _inputs[1].setSelectionRange(start, end);
                _inputs[1].focus();
            }
        };
        const onPick = (date = "", visible = false)=>{
            pickerVisible.value = visible;
            let result;
            if (Array.isArray(date)) result = date.map((_)=>_.toDate()
            );
            else result = date ? date.toDate() : date;
            userInput.value = null;
            emitInput(result);
        };
        const onShow = ()=>{
            pickerActualVisible.value = true;
            ctx.emit("visible-change", true);
        };
        const onHide = ()=>{
            pickerActualVisible.value = false;
            ctx.emit("visible-change", false);
        };
        const focus = (focusStartInput = true)=>{
            let input = refStartInput.value;
            if (!focusStartInput && isRangeInput.value) input = refEndInput.value;
            if (input) input.focus();
        };
        const handleFocus = (e)=>{
            if (props.readonly || pickerDisabled.value || pickerVisible.value) return;
            pickerVisible.value = true;
            ctx.emit("focus", e);
        };
        const handleBlur = ()=>{
            var _a;
            (_a = refPopper.value) == null || _a.onClose();
            blurInput();
        };
        const pickerDisabled = _vue.computed(()=>{
            return props.disabled || elForm.disabled;
        });
        const parsedValue = _vue.computed(()=>{
            let result;
            if (valueIsEmpty.value) {
                if (pickerOptions.value.getDefaultValue) result = pickerOptions.value.getDefaultValue();
            } else if (Array.isArray(props.modelValue)) result = props.modelValue.map((_)=>parser(_, props.valueFormat, lang.value)
            );
            else result = parser(props.modelValue, props.valueFormat, lang.value);
            if (pickerOptions.value.getRangeAvailableTime) {
                const availableResult = pickerOptions.value.getRangeAvailableTime(result);
                if (!_lodashUnified.isEqual(availableResult, result)) {
                    result = availableResult;
                    emitInput(Array.isArray(result) ? result.map((_)=>_.toDate()
                    ) : result.toDate());
                }
            }
            if (Array.isArray(result) && result.some((_)=>!_
            )) result = [];
            return result;
        });
        const displayValue = _vue.computed(()=>{
            if (!pickerOptions.value.panelReady) return;
            const formattedValue = formatDayjsToString(parsedValue.value);
            if (Array.isArray(userInput.value)) return [
                userInput.value[0] || formattedValue && formattedValue[0] || "",
                userInput.value[1] || formattedValue && formattedValue[1] || ""
            ];
            else if (userInput.value !== null) return userInput.value;
            if (!isTimePicker.value && valueIsEmpty.value) return;
            if (!pickerVisible.value && valueIsEmpty.value) return;
            if (formattedValue) return isDatesPicker.value ? formattedValue.join(", ") : formattedValue;
            return "";
        });
        const isTimeLikePicker = _vue.computed(()=>props.type.includes("time")
        );
        const isTimePicker = _vue.computed(()=>props.type.startsWith("time")
        );
        const isDatesPicker = _vue.computed(()=>props.type === "dates"
        );
        const triggerIcon = _vue.computed(()=>props.prefixIcon || (isTimeLikePicker.value ? _iconsVue.Clock : _iconsVue.Calendar)
        );
        const showClose = _vue.ref(false);
        const onClearIconClick = (event)=>{
            if (props.readonly || pickerDisabled.value) return;
            if (showClose.value) {
                event.stopPropagation();
                emitInput(null);
                emitChange(null, true);
                showClose.value = false;
                pickerVisible.value = false;
                pickerOptions.value.handleClear && pickerOptions.value.handleClear();
            }
        };
        const valueIsEmpty = _vue.computed(()=>{
            return !props.modelValue || Array.isArray(props.modelValue) && !props.modelValue.length;
        });
        const onMouseEnter = ()=>{
            if (props.readonly || pickerDisabled.value) return;
            if (!valueIsEmpty.value && props.clearable) showClose.value = true;
        };
        const onMouseLeave = ()=>{
            showClose.value = false;
        };
        const isRangeInput = _vue.computed(()=>{
            return props.type.indexOf("range") > -1;
        });
        const pickerSize = _indexMjs8.useSize();
        const popperPaneRef = _vue.computed(()=>{
            var _a, _b;
            return (_b = (_a = refPopper.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
        });
        const popperEl = _vue.computed(()=>{
            var _a, _b;
            return (_b = (_a = _vue.unref(refPopper)) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
        });
        const actualInputRef = _vue.computed(()=>{
            var _a;
            if (_vue.unref(isRangeInput)) return _vue.unref(inputRef);
            return (_a = _vue.unref(inputRef)) == null ? void 0 : _a.$el;
        });
        _core.onClickOutside(actualInputRef, (e)=>{
            const unrefedPopperEl = _vue.unref(popperEl);
            const inputEl = _vue.unref(actualInputRef);
            if (unrefedPopperEl && (e.target === unrefedPopperEl || e.composedPath().includes(unrefedPopperEl)) || e.target === inputEl || e.composedPath().includes(inputEl)) return;
            pickerVisible.value = false;
        });
        const userInput = _vue.ref(null);
        const handleChange = ()=>{
            if (userInput.value) {
                const value = parseUserInputToDayjs(displayValue.value);
                if (value) {
                    if (isValidValue(value)) {
                        emitInput(Array.isArray(value) ? value.map((_)=>_.toDate()
                        ) : value.toDate());
                        userInput.value = null;
                    }
                }
            }
            if (userInput.value === "") {
                emitInput(null);
                emitChange(null);
                userInput.value = null;
            }
        };
        const blurInput = ()=>{
            refInput.value.forEach((input)=>input.blur()
            );
        };
        const parseUserInputToDayjs = (value)=>{
            if (!value) return null;
            return pickerOptions.value.parseUserInput(value);
        };
        const formatDayjsToString = (value)=>{
            if (!value) return null;
            return pickerOptions.value.formatToString(value);
        };
        const isValidValue = (value)=>{
            return pickerOptions.value.isValidValue(value);
        };
        const handleKeydown = (event)=>{
            const code = event.code;
            if (code === _ariaMjs.EVENT_CODE.esc) {
                pickerVisible.value = false;
                event.stopPropagation();
                return;
            }
            if (code === _ariaMjs.EVENT_CODE.tab) {
                if (!isRangeInput.value) {
                    handleChange();
                    pickerVisible.value = false;
                    event.stopPropagation();
                } else setTimeout(()=>{
                    if (refInput.value.indexOf(document.activeElement) === -1) {
                        pickerVisible.value = false;
                        blurInput();
                    }
                }, 0);
                return;
            }
            if (code === _ariaMjs.EVENT_CODE.enter || code === _ariaMjs.EVENT_CODE.numpadEnter) {
                if (userInput.value === null || userInput.value === "" || isValidValue(parseUserInputToDayjs(displayValue.value))) {
                    handleChange();
                    pickerVisible.value = false;
                }
                event.stopPropagation();
                return;
            }
            if (userInput.value) {
                event.stopPropagation();
                return;
            }
            if (pickerOptions.value.handleKeydown) pickerOptions.value.handleKeydown(event);
        };
        const onUserInput = (e)=>{
            userInput.value = e;
        };
        const handleStartInput = (event)=>{
            if (userInput.value) userInput.value = [
                event.target.value,
                userInput.value[1]
            ];
            else userInput.value = [
                event.target.value,
                null
            ];
        };
        const handleEndInput = (event)=>{
            if (userInput.value) userInput.value = [
                userInput.value[0],
                event.target.value
            ];
            else userInput.value = [
                null,
                event.target.value
            ];
        };
        const handleStartChange = ()=>{
            const value = parseUserInputToDayjs(userInput.value && userInput.value[0]);
            if (value && value.isValid()) {
                userInput.value = [
                    formatDayjsToString(value),
                    displayValue.value[1]
                ];
                const newValue = [
                    value,
                    parsedValue.value && parsedValue.value[1]
                ];
                if (isValidValue(newValue)) {
                    emitInput(newValue);
                    userInput.value = null;
                }
            }
        };
        const handleEndChange = ()=>{
            const value = parseUserInputToDayjs(userInput.value && userInput.value[1]);
            if (value && value.isValid()) {
                userInput.value = [
                    displayValue.value[0],
                    formatDayjsToString(value)
                ];
                const newValue = [
                    parsedValue.value && parsedValue.value[0],
                    value
                ];
                if (isValidValue(newValue)) {
                    emitInput(newValue);
                    userInput.value = null;
                }
            }
        };
        const pickerOptions = _vue.ref({
        });
        const onSetPickerOption = (e)=>{
            pickerOptions.value[e[0]] = e[1];
            pickerOptions.value.panelReady = true;
        };
        const onCalendarChange = (e)=>{
            ctx.emit("calendar-change", e);
        };
        const onPanelChange = (value, mode, view)=>{
            ctx.emit("panel-change", value, mode, view);
        };
        _vue.provide("EP_PICKER_BASE", {
            props
        });
        return {
            elPopperOptions,
            isDatesPicker,
            handleEndChange,
            handleStartChange,
            handleStartInput,
            handleEndInput,
            onUserInput,
            handleChange,
            handleKeydown,
            popperPaneRef,
            onClickOutside: _core.onClickOutside,
            pickerSize,
            isRangeInput,
            onMouseLeave,
            onMouseEnter,
            onClearIconClick,
            showClose,
            triggerIcon,
            onPick,
            handleFocus,
            handleBlur,
            pickerVisible,
            pickerActualVisible,
            displayValue,
            parsedValue,
            setSelectionRange,
            refPopper,
            inputRef,
            pickerDisabled,
            onSetPickerOption,
            onCalendarChange,
            onPanelChange,
            focus,
            onShow,
            onHide
        };
    }
});
const _hoisted_1 = [
    "id",
    "name",
    "placeholder",
    "value",
    "disabled",
    "readonly"
];
const _hoisted_2 = {
    class: "el-range-separator"
};
const _hoisted_3 = [
    "id",
    "name",
    "placeholder",
    "value",
    "disabled",
    "readonly"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_input = _vue.resolveComponent("el-input");
    const _component_el_tooltip = _vue.resolveComponent("el-tooltip");
    return _vue.openBlock(), _vue.createBlock(_component_el_tooltip, _vue.mergeProps({
        ref: "refPopper",
        visible: _ctx.pickerVisible,
        "onUpdate:visible": _cache[17] || (_cache[17] = ($event)=>_ctx.pickerVisible = $event
        ),
        effect: "light",
        pure: "",
        trigger: "click"
    }, _ctx.$attrs, {
        "append-to-body": "",
        transition: "el-zoom-in-top",
        "popper-class": `el-picker__popper ${_ctx.popperClass}`,
        "popper-options": _ctx.elPopperOptions,
        "fallback-placements": [
            "bottom",
            "top",
            "right",
            "left"
        ],
        "gpu-acceleration": false,
        "stop-popper-mouse-event": false,
        "hide-after": 0,
        persistent: "",
        onShow: _ctx.onShow,
        onHide: _ctx.onHide
    }), {
        default: _vue.withCtx(()=>[
                !_ctx.isRangeInput ? (_vue.openBlock(), _vue.createBlock(_component_el_input, {
                    key: 0,
                    id: _ctx.id,
                    ref: "inputRef",
                    "model-value": _ctx.displayValue,
                    name: _ctx.name,
                    size: _ctx.pickerSize,
                    disabled: _ctx.pickerDisabled,
                    placeholder: _ctx.placeholder,
                    class: _vue.normalizeClass([
                        "el-date-editor",
                        [
                            "el-date-editor--" + _ctx.type,
                            _ctx.$attrs.class || void 0
                        ]
                    ]),
                    style: _vue.normalizeStyle(_ctx.$attrs.style || void 0),
                    readonly: !_ctx.editable || _ctx.readonly || _ctx.isDatesPicker || _ctx.type === "week",
                    onInput: _ctx.onUserInput,
                    onFocus: _ctx.handleFocus,
                    onKeydown: _ctx.handleKeydown,
                    onChange: _ctx.handleChange,
                    onMouseenter: _ctx.onMouseEnter,
                    onMouseleave: _ctx.onMouseLeave,
                    onClick: _cache[0] || (_cache[0] = _vue.withModifiers(()=>{
                    }, [
                        "stop"
                    ]))
                }, {
                    prefix: _vue.withCtx(()=>[
                            _ctx.triggerIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                key: 0,
                                class: "el-input__icon",
                                onClick: _ctx.handleFocus
                            }, {
                                default: _vue.withCtx(()=>[
                                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.triggerIcon)))
                                    ]
                                ),
                                _: 1
                            }, 8, [
                                "onClick"
                            ])) : _vue.createCommentVNode("v-if", true)
                        ]
                    ),
                    suffix: _vue.withCtx(()=>[
                            _ctx.showClose && _ctx.clearIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                key: 0,
                                class: "el-input__icon clear-icon",
                                onClick: _ctx.onClearIconClick
                            }, {
                                default: _vue.withCtx(()=>[
                                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.clearIcon)))
                                    ]
                                ),
                                _: 1
                            }, 8, [
                                "onClick"
                            ])) : _vue.createCommentVNode("v-if", true)
                        ]
                    ),
                    _: 1
                }, 8, [
                    "id",
                    "model-value",
                    "name",
                    "size",
                    "disabled",
                    "placeholder",
                    "class",
                    "style",
                    "readonly",
                    "onInput",
                    "onFocus",
                    "onKeydown",
                    "onChange",
                    "onMouseenter",
                    "onMouseleave"
                ])) : (_vue.openBlock(), _vue.createElementBlock("div", {
                    key: 1,
                    ref: "inputRef",
                    class: _vue.normalizeClass([
                        "el-date-editor el-range-editor el-input__inner",
                        [
                            "el-date-editor--" + _ctx.type,
                            _ctx.pickerSize ? `el-range-editor--${_ctx.pickerSize}` : "",
                            _ctx.pickerDisabled ? "is-disabled" : "",
                            _ctx.pickerVisible ? "is-active" : "",
                            _ctx.$attrs.class || void 0
                        ]
                    ]),
                    style: _vue.normalizeStyle(_ctx.$attrs.style || void 0),
                    onClick: _cache[7] || (_cache[7] = (...args)=>_ctx.handleFocus && _ctx.handleFocus(...args)
                    ),
                    onMouseenter: _cache[8] || (_cache[8] = (...args)=>_ctx.onMouseEnter && _ctx.onMouseEnter(...args)
                    ),
                    onMouseleave: _cache[9] || (_cache[9] = (...args)=>_ctx.onMouseLeave && _ctx.onMouseLeave(...args)
                    ),
                    onKeydown: _cache[10] || (_cache[10] = (...args)=>_ctx.handleKeydown && _ctx.handleKeydown(...args)
                    )
                }, [
                    _ctx.triggerIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 0,
                        class: "el-input__icon el-range__icon",
                        onClick: _ctx.handleFocus
                    }, {
                        default: _vue.withCtx(()=>[
                                (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.triggerIcon)))
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "onClick"
                    ])) : _vue.createCommentVNode("v-if", true),
                    _vue.createElementVNode("input", {
                        id: _ctx.id && _ctx.id[0],
                        autocomplete: "off",
                        name: _ctx.name && _ctx.name[0],
                        placeholder: _ctx.startPlaceholder,
                        value: _ctx.displayValue && _ctx.displayValue[0],
                        disabled: _ctx.pickerDisabled,
                        readonly: !_ctx.editable || _ctx.readonly,
                        class: "el-range-input",
                        onInput: _cache[1] || (_cache[1] = (...args)=>_ctx.handleStartInput && _ctx.handleStartInput(...args)
                        ),
                        onChange: _cache[2] || (_cache[2] = (...args)=>_ctx.handleStartChange && _ctx.handleStartChange(...args)
                        ),
                        onFocus: _cache[3] || (_cache[3] = (...args)=>_ctx.handleFocus && _ctx.handleFocus(...args)
                        )
                    }, null, 40, _hoisted_1),
                    _vue.renderSlot(_ctx.$slots, "range-separator", {
                    }, ()=>[
                            _vue.createElementVNode("span", _hoisted_2, _vue.toDisplayString(_ctx.rangeSeparator), 1)
                        ]
                    ),
                    _vue.createElementVNode("input", {
                        id: _ctx.id && _ctx.id[1],
                        autocomplete: "off",
                        name: _ctx.name && _ctx.name[1],
                        placeholder: _ctx.endPlaceholder,
                        value: _ctx.displayValue && _ctx.displayValue[1],
                        disabled: _ctx.pickerDisabled,
                        readonly: !_ctx.editable || _ctx.readonly,
                        class: "el-range-input",
                        onFocus: _cache[4] || (_cache[4] = (...args)=>_ctx.handleFocus && _ctx.handleFocus(...args)
                        ),
                        onInput: _cache[5] || (_cache[5] = (...args)=>_ctx.handleEndInput && _ctx.handleEndInput(...args)
                        ),
                        onChange: _cache[6] || (_cache[6] = (...args)=>_ctx.handleEndChange && _ctx.handleEndChange(...args)
                        )
                    }, null, 40, _hoisted_3),
                    _ctx.clearIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 1,
                        class: _vue.normalizeClass([
                            "el-input__icon el-range__close-icon",
                            {
                                "el-range__close-icon--hidden": !_ctx.showClose
                            }
                        ]),
                        onClick: _ctx.onClearIconClick
                    }, {
                        default: _vue.withCtx(()=>[
                                (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.clearIcon)))
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "class",
                        "onClick"
                    ])) : _vue.createCommentVNode("v-if", true)
                ], 38))
            ]
        ),
        content: _vue.withCtx(()=>[
                _vue.renderSlot(_ctx.$slots, "default", {
                    visible: _ctx.pickerVisible,
                    actualVisible: _ctx.pickerActualVisible,
                    parsedValue: _ctx.parsedValue,
                    format: _ctx.format,
                    unlinkPanels: _ctx.unlinkPanels,
                    type: _ctx.type,
                    defaultValue: _ctx.defaultValue,
                    onPick: _cache[11] || (_cache[11] = (...args)=>_ctx.onPick && _ctx.onPick(...args)
                    ),
                    onSelectRange: _cache[12] || (_cache[12] = (...args)=>_ctx.setSelectionRange && _ctx.setSelectionRange(...args)
                    ),
                    onSetPickerOption: _cache[13] || (_cache[13] = (...args)=>_ctx.onSetPickerOption && _ctx.onSetPickerOption(...args)
                    ),
                    onCalendarChange: _cache[14] || (_cache[14] = (...args)=>_ctx.onCalendarChange && _ctx.onCalendarChange(...args)
                    ),
                    onPanelChange: _cache[15] || (_cache[15] = (...args)=>_ctx.onPanelChange && _ctx.onPanelChange(...args)
                    ),
                    onMousedown: _cache[16] || (_cache[16] = _vue.withModifiers(()=>{
                    }, [
                        "stop"
                    ]))
                })
            ]
        ),
        _: 3
    }, 16, [
        "visible",
        "popper-class",
        "popper-options",
        "onShow",
        "onHide"
    ]);
}
var CommonPicker = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","dayjs":"NJZFB","lodash-unified":"4Oj4p","@vueuse/core":"eEHP9","../../../../hooks/index.mjs":"1Ansp","../../../../tokens/index.mjs":"wVNQi","../../../input/index.mjs":"18eQI","../../../icon/index.mjs":"hnNTG","../../../tooltip/index.mjs":"kiwBC","../../../../utils/index.mjs":"dsdeP","../../../../constants/index.mjs":"74Fbn","@element-plus/icons-vue":"b18uu","./props.mjs":"gx1qH","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../utils/types.mjs":"4VsDK","../../../../hooks/use-locale/index.mjs":"c1HoA","../../../../tokens/form.mjs":"2r4O0","../../../../hooks/use-common-props/index.mjs":"05czU","../../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gx1qH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timePickerDefaultProps", ()=>timePickerDefaultProps
);
var _indexMjs = require("../../../../utils/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _validatorMjs = require("../../../../utils/vue/validator.mjs");
const timePickerDefaultProps = {
    id: {
        type: [
            Array,
            String
        ]
    },
    name: {
        type: [
            Array,
            String
        ],
        default: ""
    },
    popperClass: {
        type: String,
        default: ""
    },
    format: {
        type: String
    },
    valueFormat: {
        type: String
    },
    type: {
        type: String,
        default: ""
    },
    clearable: {
        type: Boolean,
        default: true
    },
    clearIcon: {
        type: [
            String,
            Object
        ],
        default: _iconsVue.CircleClose
    },
    editable: {
        type: Boolean,
        default: true
    },
    prefixIcon: {
        type: [
            String,
            Object
        ],
        default: ""
    },
    size: {
        type: String,
        validator: _validatorMjs.isValidComponentSize
    },
    readonly: {
        type: Boolean,
        default: false
    },
    disabled: {
        type: Boolean,
        default: false
    },
    placeholder: {
        type: String,
        default: ""
    },
    popperOptions: {
        type: Object,
        default: ()=>({
            })
    },
    modelValue: {
        type: [
            Date,
            Array,
            String,
            Number
        ],
        default: ""
    },
    rangeSeparator: {
        type: String,
        default: "-"
    },
    startPlaceholder: String,
    endPlaceholder: String,
    defaultValue: {
        type: [
            Date,
            Array
        ]
    },
    defaultTime: {
        type: [
            Date,
            Array
        ]
    },
    isRange: {
        type: Boolean,
        default: false
    },
    disabledHours: {
        type: Function
    },
    disabledMinutes: {
        type: Function
    },
    disabledSeconds: {
        type: Function
    },
    disabledDate: {
        type: Function
    },
    cellClassName: {
        type: Function
    },
    shortcuts: {
        type: Array,
        default: ()=>[]
    },
    arrowControl: {
        type: Boolean,
        default: false
    },
    validateEvent: {
        type: Boolean,
        default: true
    },
    unlinkPanels: Boolean
};

},{"../../../../utils/index.mjs":"dsdeP","@element-plus/icons-vue":"b18uu","../../../../utils/vue/validator.mjs":"4UnBa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"351Kw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TimePickPanel
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _indexMjs = require("../../../../constants/index.mjs");
var _indexMjs1 = require("../../../../hooks/index.mjs");
var _basicTimeSpinnerMjs = require("./basic-time-spinner.mjs");
var _basicTimeSpinnerMjsDefault = parcelHelpers.interopDefault(_basicTimeSpinnerMjs);
var _useTimePickerMjs = require("./useTimePicker.mjs");
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../../hooks/use-locale/index.mjs");
var _ariaMjs = require("../../../../constants/aria.mjs");
const _sfc_main = _vue.defineComponent({
    components: {
        TimeSpinner: _basicTimeSpinnerMjsDefault.default
    },
    props: {
        visible: Boolean,
        actualVisible: {
            type: Boolean,
            default: void 0
        },
        datetimeRole: {
            type: String
        },
        parsedValue: {
            type: [
                Object,
                String
            ]
        },
        format: {
            type: String,
            default: ""
        }
    },
    emits: [
        "pick",
        "select-range",
        "set-picker-option"
    ],
    setup (props, ctx) {
        const { t , lang  } = _indexMjs2.useLocale();
        const selectionRange = _vue.ref([
            0,
            2
        ]);
        const oldValue = _useTimePickerMjs.useOldValue(props);
        const transitionName = _vue.computed(()=>{
            return props.actualVisible === void 0 ? "el-zoom-in-top" : "";
        });
        const showSeconds = _vue.computed(()=>{
            return props.format.includes("ss");
        });
        const amPmMode = _vue.computed(()=>{
            if (props.format.includes("A")) return "A";
            if (props.format.includes("a")) return "a";
            return "";
        });
        const isValidValue = (_date)=>{
            const parsedDate = _dayjsDefault.default(_date).locale(lang.value);
            const result = getRangeAvailableTime(parsedDate);
            return parsedDate.isSame(result);
        };
        const handleCancel = ()=>{
            ctx.emit("pick", oldValue.value, false);
        };
        const handleConfirm = (visible = false, first = false)=>{
            if (first) return;
            ctx.emit("pick", props.parsedValue, visible);
        };
        const handleChange = (_date)=>{
            if (!props.visible) return;
            const result = getRangeAvailableTime(_date).millisecond(0);
            ctx.emit("pick", result, true);
        };
        const setSelectionRange = (start, end)=>{
            ctx.emit("select-range", start, end);
            selectionRange.value = [
                start,
                end
            ];
        };
        const changeSelectionRange = (step)=>{
            const list = [
                0,
                3
            ].concat(showSeconds.value ? [
                6
            ] : []);
            const mapping = [
                "hours",
                "minutes"
            ].concat(showSeconds.value ? [
                "seconds"
            ] : []);
            const index = list.indexOf(selectionRange.value[0]);
            const next = (index + step + list.length) % list.length;
            timePickerOptions["start_emitSelectRange"](mapping[next]);
        };
        const handleKeydown = (event)=>{
            const code = event.code;
            if (code === _ariaMjs.EVENT_CODE.left || code === _ariaMjs.EVENT_CODE.right) {
                const step = code === _ariaMjs.EVENT_CODE.left ? -1 : 1;
                changeSelectionRange(step);
                event.preventDefault();
                return;
            }
            if (code === _ariaMjs.EVENT_CODE.up || code === _ariaMjs.EVENT_CODE.down) {
                const step = code === _ariaMjs.EVENT_CODE.up ? -1 : 1;
                timePickerOptions["start_scrollDown"](step);
                event.preventDefault();
                return;
            }
        };
        const getRangeAvailableTime = (date)=>{
            const availableMap = {
                hour: getAvailableHours,
                minute: getAvailableMinutes,
                second: getAvailableSeconds
            };
            let result = date;
            [
                "hour",
                "minute",
                "second"
            ].forEach((_)=>{
                if (availableMap[_]) {
                    let availableArr;
                    const method = availableMap[_];
                    if (_ === "minute") availableArr = method(result.hour(), props.datetimeRole);
                    else if (_ === "second") availableArr = method(result.hour(), result.minute(), props.datetimeRole);
                    else availableArr = method(props.datetimeRole);
                    if (availableArr && availableArr.length && !availableArr.includes(result[_]())) result = result[_](availableArr[0]);
                }
            });
            return result;
        };
        const parseUserInput = (value)=>{
            if (!value) return null;
            return _dayjsDefault.default(value, props.format).locale(lang.value);
        };
        const formatToString = (value)=>{
            if (!value) return null;
            return value.format(props.format);
        };
        const getDefaultValue = ()=>{
            return _dayjsDefault.default(defaultValue).locale(lang.value);
        };
        ctx.emit("set-picker-option", [
            "isValidValue",
            isValidValue
        ]);
        ctx.emit("set-picker-option", [
            "formatToString",
            formatToString
        ]);
        ctx.emit("set-picker-option", [
            "parseUserInput",
            parseUserInput
        ]);
        ctx.emit("set-picker-option", [
            "handleKeydown",
            handleKeydown
        ]);
        ctx.emit("set-picker-option", [
            "getRangeAvailableTime",
            getRangeAvailableTime
        ]);
        ctx.emit("set-picker-option", [
            "getDefaultValue",
            getDefaultValue
        ]);
        const timePickerOptions = {
        };
        const onSetOption = (e)=>{
            timePickerOptions[e[0]] = e[1];
        };
        const pickerBase = _vue.inject("EP_PICKER_BASE");
        const { arrowControl , disabledHours , disabledMinutes , disabledSeconds , defaultValue  } = pickerBase.props;
        const { getAvailableHours , getAvailableMinutes , getAvailableSeconds  } = _useTimePickerMjs.getAvailableArrs(disabledHours, disabledMinutes, disabledSeconds);
        return {
            transitionName,
            arrowControl,
            onSetOption,
            t,
            handleConfirm,
            handleChange,
            setSelectionRange,
            amPmMode,
            showSeconds,
            handleCancel,
            disabledHours,
            disabledMinutes,
            disabledSeconds
        };
    }
});
const _hoisted_1 = {
    key: 0,
    class: "el-time-panel"
};
const _hoisted_2 = {
    class: "el-time-panel__footer"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_time_spinner = _vue.resolveComponent("time-spinner");
    return _vue.openBlock(), _vue.createBlock(_vue.Transition, {
        name: _ctx.transitionName
    }, {
        default: _vue.withCtx(()=>[
                _ctx.actualVisible || _ctx.visible ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_1, [
                    _vue.createElementVNode("div", {
                        class: _vue.normalizeClass([
                            "el-time-panel__content",
                            {
                                "has-seconds": _ctx.showSeconds
                            }
                        ])
                    }, [
                        _vue.createVNode(_component_time_spinner, {
                            ref: "spinner",
                            role: _ctx.datetimeRole || "start",
                            "arrow-control": _ctx.arrowControl,
                            "show-seconds": _ctx.showSeconds,
                            "am-pm-mode": _ctx.amPmMode,
                            "spinner-date": _ctx.parsedValue,
                            "disabled-hours": _ctx.disabledHours,
                            "disabled-minutes": _ctx.disabledMinutes,
                            "disabled-seconds": _ctx.disabledSeconds,
                            onChange: _ctx.handleChange,
                            onSetOption: _ctx.onSetOption,
                            onSelectRange: _ctx.setSelectionRange
                        }, null, 8, [
                            "role",
                            "arrow-control",
                            "show-seconds",
                            "am-pm-mode",
                            "spinner-date",
                            "disabled-hours",
                            "disabled-minutes",
                            "disabled-seconds",
                            "onChange",
                            "onSetOption",
                            "onSelectRange"
                        ])
                    ], 2),
                    _vue.createElementVNode("div", _hoisted_2, [
                        _vue.createElementVNode("button", {
                            type: "button",
                            class: "el-time-panel__btn cancel",
                            onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleCancel && _ctx.handleCancel(...args)
                            )
                        }, _vue.toDisplayString(_ctx.t("el.datepicker.cancel")), 1),
                        _vue.createElementVNode("button", {
                            type: "button",
                            class: "el-time-panel__btn confirm",
                            onClick: _cache[1] || (_cache[1] = ($event)=>_ctx.handleConfirm()
                            )
                        }, _vue.toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
                    ])
                ])) : _vue.createCommentVNode("v-if", true)
            ]
        ),
        _: 1
    }, 8, [
        "name"
    ]);
}
var TimePickPanel = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","dayjs":"NJZFB","../../../../constants/index.mjs":"74Fbn","../../../../hooks/index.mjs":"1Ansp","./basic-time-spinner.mjs":"lzBU5","./useTimePicker.mjs":"iYEIA","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../hooks/use-locale/index.mjs":"c1HoA","../../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lzBU5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TimeSpinner
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../../directives/index.mjs");
var _indexMjs1 = require("../../../scrollbar/index.mjs");
var _indexMjs2 = require("../../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _useTimePickerMjs = require("./useTimePicker.mjs");
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../../directives/repeat-click/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs3);
const _sfc_main = _vue.defineComponent({
    directives: {
        repeatClick: _indexMjsDefault.default
    },
    components: {
        ElScrollbar: _indexMjs1.ElScrollbar,
        ElIcon: _indexMjs2.ElIcon,
        ArrowUp: _iconsVue.ArrowUp,
        ArrowDown: _iconsVue.ArrowDown
    },
    props: {
        role: {
            type: String,
            required: true
        },
        spinnerDate: {
            type: Object,
            required: true
        },
        showSeconds: {
            type: Boolean,
            default: true
        },
        arrowControl: Boolean,
        amPmMode: {
            type: String,
            default: ""
        },
        disabledHours: {
            type: Function
        },
        disabledMinutes: {
            type: Function
        },
        disabledSeconds: {
            type: Function
        }
    },
    emits: [
        "change",
        "select-range",
        "set-option"
    ],
    setup (props, ctx) {
        let isScrolling = false;
        const debouncedResetScroll = _lodashUnified.debounce((type)=>{
            isScrolling = false;
            adjustCurrentSpinner(type);
        }, 200);
        const currentScrollbar = _vue.ref(null);
        const listHoursRef = _vue.ref(null);
        const listMinutesRef = _vue.ref(null);
        const listSecondsRef = _vue.ref(null);
        const listRefsMap = {
            hours: listHoursRef,
            minutes: listMinutesRef,
            seconds: listSecondsRef
        };
        const spinnerItems = _vue.computed(()=>{
            const arr = [
                "hours",
                "minutes",
                "seconds"
            ];
            return props.showSeconds ? arr : arr.slice(0, 2);
        });
        const hours = _vue.computed(()=>{
            return props.spinnerDate.hour();
        });
        const minutes = _vue.computed(()=>{
            return props.spinnerDate.minute();
        });
        const seconds = _vue.computed(()=>{
            return props.spinnerDate.second();
        });
        const timePartsMap = _vue.computed(()=>({
                hours,
                minutes,
                seconds
            })
        );
        const hoursList = _vue.computed(()=>{
            return getHoursList(props.role);
        });
        const minutesList = _vue.computed(()=>{
            return getMinutesList(hours.value, props.role);
        });
        const secondsList = _vue.computed(()=>{
            return getSecondsList(hours.value, minutes.value, props.role);
        });
        const listMap = _vue.computed(()=>({
                hours: hoursList,
                minutes: minutesList,
                seconds: secondsList
            })
        );
        const arrowHourList = _vue.computed(()=>{
            const hour = hours.value;
            return [
                hour > 0 ? hour - 1 : void 0,
                hour,
                hour < 23 ? hour + 1 : void 0
            ];
        });
        const arrowMinuteList = _vue.computed(()=>{
            const minute = minutes.value;
            return [
                minute > 0 ? minute - 1 : void 0,
                minute,
                minute < 59 ? minute + 1 : void 0
            ];
        });
        const arrowSecondList = _vue.computed(()=>{
            const second = seconds.value;
            return [
                second > 0 ? second - 1 : void 0,
                second,
                second < 59 ? second + 1 : void 0
            ];
        });
        const arrowListMap = _vue.computed(()=>({
                hours: arrowHourList,
                minutes: arrowMinuteList,
                seconds: arrowSecondList
            })
        );
        const getAmPmFlag = (hour)=>{
            const shouldShowAmPm = !!props.amPmMode;
            if (!shouldShowAmPm) return "";
            const isCapital = props.amPmMode === "A";
            let content = hour < 12 ? " am" : " pm";
            if (isCapital) content = content.toUpperCase();
            return content;
        };
        const emitSelectRange = (type)=>{
            if (type === "hours") ctx.emit("select-range", 0, 2);
            else if (type === "minutes") ctx.emit("select-range", 3, 5);
            else if (type === "seconds") ctx.emit("select-range", 6, 8);
            currentScrollbar.value = type;
        };
        const adjustCurrentSpinner = (type)=>{
            adjustSpinner(type, timePartsMap.value[type].value);
        };
        const adjustSpinners = ()=>{
            adjustCurrentSpinner("hours");
            adjustCurrentSpinner("minutes");
            adjustCurrentSpinner("seconds");
        };
        const adjustSpinner = (type, value)=>{
            if (props.arrowControl) return;
            const el = listRefsMap[type];
            if (el && el.$el) el.$el.querySelector(".el-scrollbar__wrap").scrollTop = Math.max(0, value * typeItemHeight(type));
        };
        const typeItemHeight = (type)=>{
            const el = listRefsMap[type];
            return el.$el.querySelector("li").offsetHeight;
        };
        const onIncreaseClick = ()=>{
            scrollDown(1);
        };
        const onDecreaseClick = ()=>{
            scrollDown(-1);
        };
        const scrollDown = (step)=>{
            if (!currentScrollbar.value) emitSelectRange("hours");
            const label = currentScrollbar.value;
            let now = timePartsMap.value[label].value;
            const total = currentScrollbar.value === "hours" ? 24 : 60;
            now = (now + step + total) % total;
            modifyDateField(label, now);
            adjustSpinner(label, now);
            _vue.nextTick(()=>emitSelectRange(currentScrollbar.value)
            );
        };
        const modifyDateField = (type, value)=>{
            const list = listMap.value[type].value;
            const isDisabled = list[value];
            if (isDisabled) return;
            switch(type){
                case "hours":
                    ctx.emit("change", props.spinnerDate.hour(value).minute(minutes.value).second(seconds.value));
                    break;
                case "minutes":
                    ctx.emit("change", props.spinnerDate.hour(hours.value).minute(value).second(seconds.value));
                    break;
                case "seconds":
                    ctx.emit("change", props.spinnerDate.hour(hours.value).minute(minutes.value).second(value));
                    break;
            }
        };
        const handleClick = (type, { value , disabled  })=>{
            if (!disabled) {
                modifyDateField(type, value);
                emitSelectRange(type);
                adjustSpinner(type, value);
            }
        };
        const handleScroll = (type)=>{
            isScrolling = true;
            debouncedResetScroll(type);
            const value = Math.min(Math.round((listRefsMap[type].$el.querySelector(".el-scrollbar__wrap").scrollTop - (scrollBarHeight(type) * 0.5 - 10) / typeItemHeight(type) + 3) / typeItemHeight(type)), type === "hours" ? 23 : 59);
            modifyDateField(type, value);
        };
        const scrollBarHeight = (type)=>{
            return listRefsMap[type].$el.offsetHeight;
        };
        const bindScrollEvent = ()=>{
            const bindFuntion = (type)=>{
                if (listRefsMap[type] && listRefsMap[type].$el) listRefsMap[type].$el.querySelector(".el-scrollbar__wrap").onscroll = ()=>{
                    handleScroll(type);
                };
            };
            bindFuntion("hours");
            bindFuntion("minutes");
            bindFuntion("seconds");
        };
        _vue.onMounted(()=>{
            _vue.nextTick(()=>{
                !props.arrowControl && bindScrollEvent();
                adjustSpinners();
                if (props.role === "start") emitSelectRange("hours");
            });
        });
        const setRef = (scrollbar, type)=>{
            listRefsMap[type] = scrollbar;
        };
        ctx.emit("set-option", [
            `${props.role}_scrollDown`,
            scrollDown
        ]);
        ctx.emit("set-option", [
            `${props.role}_emitSelectRange`,
            emitSelectRange
        ]);
        const { getHoursList , getMinutesList , getSecondsList  } = _useTimePickerMjs.getTimeLists(props.disabledHours, props.disabledMinutes, props.disabledSeconds);
        _vue.watch(()=>props.spinnerDate
        , ()=>{
            if (isScrolling) return;
            adjustSpinners();
        });
        return {
            setRef,
            spinnerItems,
            currentScrollbar,
            hours,
            minutes,
            seconds,
            hoursList,
            minutesList,
            arrowHourList,
            arrowMinuteList,
            arrowSecondList,
            getAmPmFlag,
            emitSelectRange,
            adjustCurrentSpinner,
            typeItemHeight,
            listHoursRef,
            listMinutesRef,
            listSecondsRef,
            onIncreaseClick,
            onDecreaseClick,
            handleClick,
            secondsList,
            timePartsMap,
            arrowListMap,
            listMap
        };
    }
});
const _hoisted_1 = [
    "onClick"
];
const _hoisted_2 = [
    "onMouseenter"
];
const _hoisted_3 = {
    class: "el-time-spinner__list"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_scrollbar = _vue.resolveComponent("el-scrollbar");
    const _component_arrow_up = _vue.resolveComponent("arrow-up");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_arrow_down = _vue.resolveComponent("arrow-down");
    const _directive_repeat_click = _vue.resolveDirective("repeat-click");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            "el-time-spinner",
            {
                "has-seconds": _ctx.showSeconds
            }
        ])
    }, [
        !_ctx.arrowControl ? (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, {
            key: 0
        }, _vue.renderList(_ctx.spinnerItems, (item)=>{
            return _vue.openBlock(), _vue.createBlock(_component_el_scrollbar, {
                key: item,
                ref_for: true,
                ref: (scollbar)=>_ctx.setRef(scollbar, item)
                ,
                class: "el-time-spinner__wrapper",
                "wrap-style": "max-height: inherit;",
                "view-class": "el-time-spinner__list",
                noresize: "",
                tag: "ul",
                onMouseenter: ($event)=>_ctx.emitSelectRange(item)
                ,
                onMousemove: ($event)=>_ctx.adjustCurrentSpinner(item)
            }, {
                default: _vue.withCtx(()=>[
                        (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.listMap[item].value, (disabled, key)=>{
                            return _vue.openBlock(), _vue.createElementBlock("li", {
                                key,
                                class: _vue.normalizeClass([
                                    "el-time-spinner__item",
                                    {
                                        active: key === _ctx.timePartsMap[item].value,
                                        disabled
                                    }
                                ]),
                                onClick: ($event)=>_ctx.handleClick(item, {
                                        value: key,
                                        disabled
                                    })
                            }, [
                                item === "hours" ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                                    key: 0
                                }, [
                                    _vue.createTextVNode(_vue.toDisplayString(("0" + (_ctx.amPmMode ? key % 12 || 12 : key)).slice(-2)) + _vue.toDisplayString(_ctx.getAmPmFlag(key)), 1)
                                ], 2112)) : (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                                    key: 1
                                }, [
                                    _vue.createTextVNode(_vue.toDisplayString(("0" + key).slice(-2)), 1)
                                ], 2112))
                            ], 10, _hoisted_1);
                        }), 128))
                    ]
                ),
                _: 2
            }, 1032, [
                "onMouseenter",
                "onMousemove"
            ]);
        }), 128)) : _vue.createCommentVNode("v-if", true),
        _ctx.arrowControl ? (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, {
            key: 1
        }, _vue.renderList(_ctx.spinnerItems, (item)=>{
            return _vue.openBlock(), _vue.createElementBlock("div", {
                key: item,
                class: "el-time-spinner__wrapper is-arrow",
                onMouseenter: ($event)=>_ctx.emitSelectRange(item)
            }, [
                _vue.withDirectives((_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                    class: "el-time-spinner__arrow arrow-up"
                }, {
                    default: _vue.withCtx(()=>[
                            _vue.createVNode(_component_arrow_up)
                        ]
                    ),
                    _: 1
                })), [
                    [
                        _directive_repeat_click,
                        _ctx.onDecreaseClick
                    ]
                ]),
                _vue.withDirectives((_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                    class: "el-time-spinner__arrow arrow-down"
                }, {
                    default: _vue.withCtx(()=>[
                            _vue.createVNode(_component_arrow_down)
                        ]
                    ),
                    _: 1
                })), [
                    [
                        _directive_repeat_click,
                        _ctx.onIncreaseClick
                    ]
                ]),
                _vue.createElementVNode("ul", _hoisted_3, [
                    (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.arrowListMap[item].value, (time, key)=>{
                        return _vue.openBlock(), _vue.createElementBlock("li", {
                            key,
                            class: _vue.normalizeClass([
                                "el-time-spinner__item",
                                {
                                    active: time === _ctx.timePartsMap[item].value,
                                    disabled: _ctx.listMap[item].value[time]
                                }
                            ])
                        }, [
                            typeof time === "number" ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                                key: 0
                            }, [
                                item === "hours" ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                                    key: 0
                                }, [
                                    _vue.createTextVNode(_vue.toDisplayString(("0" + (_ctx.amPmMode ? time % 12 || 12 : time)).slice(-2)) + _vue.toDisplayString(_ctx.getAmPmFlag(time)), 1)
                                ], 2112)) : (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                                    key: 1
                                }, [
                                    _vue.createTextVNode(_vue.toDisplayString(("0" + time).slice(-2)), 1)
                                ], 2112))
                            ], 2112)) : _vue.createCommentVNode("v-if", true)
                        ], 2);
                    }), 128))
                ])
            ], 40, _hoisted_2);
        }), 128)) : _vue.createCommentVNode("v-if", true)
    ], 2);
}
var TimeSpinner = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","lodash-unified":"4Oj4p","../../../../directives/index.mjs":"aRbJ2","../../../scrollbar/index.mjs":"kXLHt","../../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","./useTimePicker.mjs":"iYEIA","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../directives/repeat-click/index.mjs":"3krgJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iYEIA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAvailableArrs", ()=>getAvailableArrs
);
parcelHelpers.export(exports, "getTimeLists", ()=>getTimeLists
);
parcelHelpers.export(exports, "useOldValue", ()=>useOldValue
);
var _vue = require("vue");
const makeList = (total, method, methodFunc)=>{
    const arr = [];
    const disabledArr = method && methodFunc();
    for(let i = 0; i < total; i++)arr[i] = disabledArr ? disabledArr.includes(i) : false;
    return arr;
};
const makeAvailableArr = (list)=>{
    return list.map((_, index)=>!_ ? index : _
    ).filter((_)=>_ !== true
    );
};
const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds)=>{
    const getHoursList = (role, compare)=>{
        return makeList(24, disabledHours, ()=>disabledHours(role, compare)
        );
    };
    const getMinutesList = (hour, role, compare)=>{
        return makeList(60, disabledMinutes, ()=>disabledMinutes(hour, role, compare)
        );
    };
    const getSecondsList = (hour, minute, role, compare)=>{
        return makeList(60, disabledSeconds, ()=>disabledSeconds(hour, minute, role, compare)
        );
    };
    return {
        getHoursList,
        getMinutesList,
        getSecondsList
    };
};
const getAvailableArrs = (disabledHours, disabledMinutes, disabledSeconds)=>{
    const { getHoursList , getMinutesList , getSecondsList  } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);
    const getAvailableHours = (role, compare)=>{
        return makeAvailableArr(getHoursList(role, compare));
    };
    const getAvailableMinutes = (hour, role, compare)=>{
        return makeAvailableArr(getMinutesList(hour, role, compare));
    };
    const getAvailableSeconds = (hour, minute, role, compare)=>{
        return makeAvailableArr(getSecondsList(hour, minute, role, compare));
    };
    return {
        getAvailableHours,
        getAvailableMinutes,
        getAvailableSeconds
    };
};
const useOldValue = (props)=>{
    const oldValue = _vue.ref(props.parsedValue);
    _vue.watch(()=>props.visible
    , (val)=>{
        if (!val) oldValue.value = props.parsedValue;
    });
    return oldValue;
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3aly5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TimeRangePanel
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../../hooks/index.mjs");
var _indexMjs1 = require("../../../../constants/index.mjs");
var _basicTimeSpinnerMjs = require("./basic-time-spinner.mjs");
var _basicTimeSpinnerMjsDefault = parcelHelpers.interopDefault(_basicTimeSpinnerMjs);
var _useTimePickerMjs = require("./useTimePicker.mjs");
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../../hooks/use-locale/index.mjs");
var _ariaMjs = require("../../../../constants/aria.mjs");
const makeSelectRange = (start, end)=>{
    const result = [];
    for(let i = start; i <= end; i++)result.push(i);
    return result;
};
const _sfc_main = _vue.defineComponent({
    components: {
        TimeSpinner: _basicTimeSpinnerMjsDefault.default
    },
    props: {
        visible: Boolean,
        actualVisible: Boolean,
        parsedValue: {
            type: [
                Array
            ]
        },
        format: {
            type: String,
            default: ""
        }
    },
    emits: [
        "pick",
        "select-range",
        "set-picker-option"
    ],
    setup (props, ctx) {
        const { t , lang  } = _indexMjs2.useLocale();
        const minDate = _vue.computed(()=>props.parsedValue[0]
        );
        const maxDate = _vue.computed(()=>props.parsedValue[1]
        );
        const oldValue = _useTimePickerMjs.useOldValue(props);
        const handleCancel = ()=>{
            ctx.emit("pick", oldValue.value, null);
        };
        const showSeconds = _vue.computed(()=>{
            return props.format.includes("ss");
        });
        const amPmMode = _vue.computed(()=>{
            if (props.format.includes("A")) return "A";
            if (props.format.includes("a")) return "a";
            return "";
        });
        const minSelectableRange = _vue.ref([]);
        const maxSelectableRange = _vue.ref([]);
        const handleConfirm = (visible = false)=>{
            ctx.emit("pick", [
                minDate.value,
                maxDate.value
            ], visible);
        };
        const handleMinChange = (date)=>{
            handleChange(date.millisecond(0), maxDate.value);
        };
        const handleMaxChange = (date)=>{
            handleChange(minDate.value, date.millisecond(0));
        };
        const isValidValue = (_date)=>{
            const parsedDate = _date.map((_)=>_dayjsDefault.default(_).locale(lang.value)
            );
            const result = getRangeAvailableTime(parsedDate);
            return parsedDate[0].isSame(result[0]) && parsedDate[1].isSame(result[1]);
        };
        const handleChange = (_minDate, _maxDate)=>{
            ctx.emit("pick", [
                _minDate,
                _maxDate
            ], true);
        };
        const btnConfirmDisabled = _vue.computed(()=>{
            return minDate.value > maxDate.value;
        });
        const selectionRange = _vue.ref([
            0,
            2
        ]);
        const setMinSelectionRange = (start, end)=>{
            ctx.emit("select-range", start, end, "min");
            selectionRange.value = [
                start,
                end
            ];
        };
        const offset = _vue.computed(()=>showSeconds.value ? 11 : 8
        );
        const setMaxSelectionRange = (start, end)=>{
            ctx.emit("select-range", start, end, "max");
            selectionRange.value = [
                start + offset.value,
                end + offset.value
            ];
        };
        const changeSelectionRange = (step)=>{
            const list = showSeconds.value ? [
                0,
                3,
                6,
                11,
                14,
                17
            ] : [
                0,
                3,
                8,
                11
            ];
            const mapping = [
                "hours",
                "minutes"
            ].concat(showSeconds.value ? [
                "seconds"
            ] : []);
            const index = list.indexOf(selectionRange.value[0]);
            const next = (index + step + list.length) % list.length;
            const half = list.length / 2;
            if (next < half) timePickerOptions["start_emitSelectRange"](mapping[next]);
            else timePickerOptions["end_emitSelectRange"](mapping[next - half]);
        };
        const handleKeydown = (event)=>{
            const code = event.code;
            if (code === _ariaMjs.EVENT_CODE.left || code === _ariaMjs.EVENT_CODE.right) {
                const step = code === _ariaMjs.EVENT_CODE.left ? -1 : 1;
                changeSelectionRange(step);
                event.preventDefault();
                return;
            }
            if (code === _ariaMjs.EVENT_CODE.up || code === _ariaMjs.EVENT_CODE.down) {
                const step = code === _ariaMjs.EVENT_CODE.up ? -1 : 1;
                const role = selectionRange.value[0] < offset.value ? "start" : "end";
                timePickerOptions[`${role}_scrollDown`](step);
                event.preventDefault();
                return;
            }
        };
        const disabledHours_ = (role, compare)=>{
            const defaultDisable = disabledHours ? disabledHours(role) : [];
            const isStart = role === "start";
            const compareDate = compare || (isStart ? maxDate.value : minDate.value);
            const compareHour = compareDate.hour();
            const nextDisable = isStart ? makeSelectRange(compareHour + 1, 23) : makeSelectRange(0, compareHour - 1);
            return _lodashUnified.union(defaultDisable, nextDisable);
        };
        const disabledMinutes_ = (hour, role, compare)=>{
            const defaultDisable = disabledMinutes ? disabledMinutes(hour, role) : [];
            const isStart = role === "start";
            const compareDate = compare || (isStart ? maxDate.value : minDate.value);
            const compareHour = compareDate.hour();
            if (hour !== compareHour) return defaultDisable;
            const compareMinute = compareDate.minute();
            const nextDisable = isStart ? makeSelectRange(compareMinute + 1, 59) : makeSelectRange(0, compareMinute - 1);
            return _lodashUnified.union(defaultDisable, nextDisable);
        };
        const disabledSeconds_ = (hour, minute, role, compare)=>{
            const defaultDisable = disabledSeconds ? disabledSeconds(hour, minute, role) : [];
            const isStart = role === "start";
            const compareDate = compare || (isStart ? maxDate.value : minDate.value);
            const compareHour = compareDate.hour();
            const compareMinute = compareDate.minute();
            if (hour !== compareHour || minute !== compareMinute) return defaultDisable;
            const compareSecond = compareDate.second();
            const nextDisable = isStart ? makeSelectRange(compareSecond + 1, 59) : makeSelectRange(0, compareSecond - 1);
            return _lodashUnified.union(defaultDisable, nextDisable);
        };
        const getRangeAvailableTime = (dates)=>{
            return dates.map((_, index)=>getRangeAvailableTimeEach(dates[0], dates[1], index === 0 ? "start" : "end")
            );
        };
        const { getAvailableHours , getAvailableMinutes , getAvailableSeconds  } = _useTimePickerMjs.getAvailableArrs(disabledHours_, disabledMinutes_, disabledSeconds_);
        const getRangeAvailableTimeEach = (startDate, endDate, role)=>{
            const availableMap = {
                hour: getAvailableHours,
                minute: getAvailableMinutes,
                second: getAvailableSeconds
            };
            const isStart = role === "start";
            let result = isStart ? startDate : endDate;
            const compareDate = isStart ? endDate : startDate;
            [
                "hour",
                "minute",
                "second"
            ].forEach((_)=>{
                if (availableMap[_]) {
                    let availableArr;
                    const method = availableMap[_];
                    if (_ === "minute") availableArr = method(result.hour(), role, compareDate);
                    else if (_ === "second") availableArr = method(result.hour(), result.minute(), role, compareDate);
                    else availableArr = method(role, compareDate);
                    if (availableArr && availableArr.length && !availableArr.includes(result[_]())) {
                        const pos = isStart ? 0 : availableArr.length - 1;
                        result = result[_](availableArr[pos]);
                    }
                }
            });
            return result;
        };
        const parseUserInput = (value)=>{
            if (!value) return null;
            if (Array.isArray(value)) return value.map((_)=>_dayjsDefault.default(_, props.format).locale(lang.value)
            );
            return _dayjsDefault.default(value, props.format).locale(lang.value);
        };
        const formatToString = (value)=>{
            if (!value) return null;
            if (Array.isArray(value)) return value.map((_)=>_.format(props.format)
            );
            return value.format(props.format);
        };
        const getDefaultValue = ()=>{
            if (Array.isArray(defaultValue)) return defaultValue.map((_)=>_dayjsDefault.default(_).locale(lang.value)
            );
            const defaultDay = _dayjsDefault.default(defaultValue).locale(lang.value);
            return [
                defaultDay,
                defaultDay.add(60, "m")
            ];
        };
        ctx.emit("set-picker-option", [
            "formatToString",
            formatToString
        ]);
        ctx.emit("set-picker-option", [
            "parseUserInput",
            parseUserInput
        ]);
        ctx.emit("set-picker-option", [
            "isValidValue",
            isValidValue
        ]);
        ctx.emit("set-picker-option", [
            "handleKeydown",
            handleKeydown
        ]);
        ctx.emit("set-picker-option", [
            "getDefaultValue",
            getDefaultValue
        ]);
        ctx.emit("set-picker-option", [
            "getRangeAvailableTime",
            getRangeAvailableTime
        ]);
        const timePickerOptions = {
        };
        const onSetOption = (e)=>{
            timePickerOptions[e[0]] = e[1];
        };
        const pickerBase = _vue.inject("EP_PICKER_BASE");
        const { arrowControl , disabledHours , disabledMinutes , disabledSeconds , defaultValue  } = pickerBase.props;
        return {
            arrowControl,
            onSetOption,
            setMaxSelectionRange,
            setMinSelectionRange,
            btnConfirmDisabled,
            handleCancel,
            handleConfirm,
            t,
            showSeconds,
            minDate,
            maxDate,
            amPmMode,
            handleMinChange,
            handleMaxChange,
            minSelectableRange,
            maxSelectableRange,
            disabledHours_,
            disabledMinutes_,
            disabledSeconds_
        };
    }
});
const _hoisted_1 = {
    key: 0,
    class: "el-time-range-picker el-picker-panel"
};
const _hoisted_2 = {
    class: "el-time-range-picker__content"
};
const _hoisted_3 = {
    class: "el-time-range-picker__cell"
};
const _hoisted_4 = {
    class: "el-time-range-picker__header"
};
const _hoisted_5 = {
    class: "el-time-range-picker__cell"
};
const _hoisted_6 = {
    class: "el-time-range-picker__header"
};
const _hoisted_7 = {
    class: "el-time-panel__footer"
};
const _hoisted_8 = [
    "disabled"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_time_spinner = _vue.resolveComponent("time-spinner");
    return _ctx.actualVisible ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_1, [
        _vue.createElementVNode("div", _hoisted_2, [
            _vue.createElementVNode("div", _hoisted_3, [
                _vue.createElementVNode("div", _hoisted_4, _vue.toDisplayString(_ctx.t("el.datepicker.startTime")), 1),
                _vue.createElementVNode("div", {
                    class: _vue.normalizeClass([
                        {
                            "has-seconds": _ctx.showSeconds,
                            "is-arrow": _ctx.arrowControl
                        },
                        "el-time-range-picker__body el-time-panel__content"
                    ])
                }, [
                    _vue.createVNode(_component_time_spinner, {
                        ref: "minSpinner",
                        role: "start",
                        "show-seconds": _ctx.showSeconds,
                        "am-pm-mode": _ctx.amPmMode,
                        "arrow-control": _ctx.arrowControl,
                        "spinner-date": _ctx.minDate,
                        "disabled-hours": _ctx.disabledHours_,
                        "disabled-minutes": _ctx.disabledMinutes_,
                        "disabled-seconds": _ctx.disabledSeconds_,
                        onChange: _ctx.handleMinChange,
                        onSetOption: _ctx.onSetOption,
                        onSelectRange: _ctx.setMinSelectionRange
                    }, null, 8, [
                        "show-seconds",
                        "am-pm-mode",
                        "arrow-control",
                        "spinner-date",
                        "disabled-hours",
                        "disabled-minutes",
                        "disabled-seconds",
                        "onChange",
                        "onSetOption",
                        "onSelectRange"
                    ])
                ], 2)
            ]),
            _vue.createElementVNode("div", _hoisted_5, [
                _vue.createElementVNode("div", _hoisted_6, _vue.toDisplayString(_ctx.t("el.datepicker.endTime")), 1),
                _vue.createElementVNode("div", {
                    class: _vue.normalizeClass([
                        {
                            "has-seconds": _ctx.showSeconds,
                            "is-arrow": _ctx.arrowControl
                        },
                        "el-time-range-picker__body el-time-panel__content"
                    ])
                }, [
                    _vue.createVNode(_component_time_spinner, {
                        ref: "maxSpinner",
                        role: "end",
                        "show-seconds": _ctx.showSeconds,
                        "am-pm-mode": _ctx.amPmMode,
                        "arrow-control": _ctx.arrowControl,
                        "spinner-date": _ctx.maxDate,
                        "disabled-hours": _ctx.disabledHours_,
                        "disabled-minutes": _ctx.disabledMinutes_,
                        "disabled-seconds": _ctx.disabledSeconds_,
                        onChange: _ctx.handleMaxChange,
                        onSetOption: _ctx.onSetOption,
                        onSelectRange: _ctx.setMaxSelectionRange
                    }, null, 8, [
                        "show-seconds",
                        "am-pm-mode",
                        "arrow-control",
                        "spinner-date",
                        "disabled-hours",
                        "disabled-minutes",
                        "disabled-seconds",
                        "onChange",
                        "onSetOption",
                        "onSelectRange"
                    ])
                ], 2)
            ])
        ]),
        _vue.createElementVNode("div", _hoisted_7, [
            _vue.createElementVNode("button", {
                type: "button",
                class: "el-time-panel__btn cancel",
                onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.handleCancel()
                )
            }, _vue.toDisplayString(_ctx.t("el.datepicker.cancel")), 1),
            _vue.createElementVNode("button", {
                type: "button",
                class: "el-time-panel__btn confirm",
                disabled: _ctx.btnConfirmDisabled,
                onClick: _cache[1] || (_cache[1] = ($event)=>_ctx.handleConfirm()
                )
            }, _vue.toDisplayString(_ctx.t("el.datepicker.confirm")), 9, _hoisted_8)
        ])
    ])) : _vue.createCommentVNode("v-if", true);
}
var TimeRangePanel = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","dayjs":"NJZFB","lodash-unified":"4Oj4p","../../../../hooks/index.mjs":"1Ansp","../../../../constants/index.mjs":"74Fbn","./basic-time-spinner.mjs":"lzBU5","./useTimePicker.mjs":"iYEIA","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../hooks/use-locale/index.mjs":"c1HoA","../../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3CJdm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractDateFormat", ()=>extractDateFormat
);
parcelHelpers.export(exports, "extractTimeFormat", ()=>extractTimeFormat
);
parcelHelpers.export(exports, "rangeArr", ()=>rangeArr
);
const rangeArr = (n)=>Array.from(Array(n).keys())
;
const extractDateFormat = (format)=>{
    return format.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim();
};
const extractTimeFormat = (format)=>{
    return format.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim();
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"llevA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dateTableEmits", ()=>dateTableEmits
);
parcelHelpers.export(exports, "dateTableProps", ()=>dateTableProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _shared = require("@vue/shared");
const dateTableProps = _propsMjs.buildProps({
    selectedDay: {
        type: _propsMjs.definePropType(Object)
    },
    range: {
        type: _propsMjs.definePropType(Array)
    },
    date: {
        type: _propsMjs.definePropType(Object),
        required: true
    },
    hideHeader: {
        type: Boolean
    }
});
const dateTableEmits = {
    pick: (value)=>_shared.isObject(value)
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4X2do":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "calendarEmits", ()=>calendarEmits
);
parcelHelpers.export(exports, "calendarProps", ()=>calendarProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _eventMjs = require("../../../constants/event.mjs");
const calendarProps = _propsMjs.buildProps({
    modelValue: {
        type: Date
    },
    range: {
        type: _propsMjs.definePropType(Array),
        validator: (range)=>Array.isArray(range) && range.length === 2 && range.every((item)=>item instanceof Date
            )
    }
});
const calendarEmits = {
    [_eventMjs.UPDATE_MODEL_EVENT]: (value)=>value instanceof Date
    ,
    input: (value)=>value instanceof Date
};

},{"../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../../utils/vue/props.mjs":"cpwWK","../../../constants/event.mjs":"92xVn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ftRFC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cardProps", ()=>_cardMjs.cardProps
);
parcelHelpers.export(exports, "ElCard", ()=>ElCard
);
parcelHelpers.export(exports, "default", ()=>ElCard
);
var _indexMjs = require("../../utils/index.mjs");
var _card2Mjs = require("./src/card2.mjs");
var _card2MjsDefault = parcelHelpers.interopDefault(_card2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _cardMjs = require("./src/card.mjs");
const ElCard = _installMjs.withInstall(_card2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/card2.mjs":"f8P38","../../utils/vue/install.mjs":"4TMmv","./src/card.mjs":"a9FEd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f8P38":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Card
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _cardMjs = require("./card.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElCard",
    props: _cardMjs.cardProps,
    setup () {
        const ns = _indexMjs1.useNamespace("card");
        return {
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.is(`${_ctx.shadow}-shadow`)
        ])
    }, [
        _ctx.$slots.header || _ctx.header ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.e("header"))
        }, [
            _vue.renderSlot(_ctx.$slots, "header", {
            }, ()=>[
                    _vue.createTextVNode(_vue.toDisplayString(_ctx.header), 1)
                ]
            )
        ], 2)) : _vue.createCommentVNode("v-if", true),
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("body")),
            style: _vue.normalizeStyle(_ctx.bodyStyle)
        }, [
            _vue.renderSlot(_ctx.$slots, "default")
        ], 6)
    ], 2);
}
var Card = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./card.mjs":"a9FEd","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a9FEd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cardProps", ()=>cardProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const cardProps = _propsMjs.buildProps({
    header: {
        type: String,
        default: ""
    },
    bodyStyle: {
        type: _propsMjs.definePropType([
            String,
            Object,
            Array
        ]),
        default: ""
    },
    shadow: {
        type: String,
        default: "always"
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"DjiER":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElCarousel", ()=>ElCarousel
);
parcelHelpers.export(exports, "ElCarouselItem", ()=>ElCarouselItem
);
parcelHelpers.export(exports, "default", ()=>ElCarousel
);
var _indexMjs = require("../../utils/index.mjs");
var _mainMjs = require("./src/main.mjs");
var _mainMjsDefault = parcelHelpers.interopDefault(_mainMjs);
var _itemMjs = require("./src/item.mjs");
var _itemMjsDefault = parcelHelpers.interopDefault(_itemMjs);
var _installMjs = require("../../utils/vue/install.mjs");
const ElCarousel = _installMjs.withInstall(_mainMjsDefault.default, {
    CarouselItem: _itemMjsDefault.default
});
const ElCarouselItem = _installMjs.withNoopInstall(_itemMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/main.mjs":"h5koD","./src/item.mjs":"get3r","../../utils/vue/install.mjs":"4TMmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h5koD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Carousel
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
var _errorMjs = require("../../../utils/error.mjs");
var _resizeEventMjs = require("../../../utils/dom/resize-event.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElCarousel",
    components: {
        ElIcon: _indexMjs1.ElIcon,
        ArrowLeft: _iconsVue.ArrowLeft,
        ArrowRight: _iconsVue.ArrowRight
    },
    props: {
        initialIndex: {
            type: Number,
            default: 0
        },
        height: {
            type: String,
            default: ""
        },
        trigger: {
            type: String,
            default: "hover"
        },
        autoplay: {
            type: Boolean,
            default: true
        },
        interval: {
            type: Number,
            default: 3000
        },
        indicatorPosition: {
            type: String,
            default: ""
        },
        indicator: {
            type: Boolean,
            default: true
        },
        arrow: {
            type: String,
            default: "hover"
        },
        type: {
            type: String,
            default: ""
        },
        loop: {
            type: Boolean,
            default: true
        },
        direction: {
            type: String,
            default: "horizontal",
            validator (val) {
                return [
                    "horizontal",
                    "vertical"
                ].includes(val);
            }
        },
        pauseOnHover: {
            type: Boolean,
            default: true
        }
    },
    emits: [
        "change"
    ],
    setup (props, { emit  }) {
        const ns = _indexMjs3.useNamespace("carousel");
        const data = _vue.reactive({
            activeIndex: -1,
            containerWidth: 0,
            timer: null,
            hover: false
        });
        const root = _vue.ref(null);
        const items = _vue.ref([]);
        const arrowDisplay = _vue.computed(()=>props.arrow !== "never" && props.direction !== "vertical"
        );
        const hasLabel = _vue.computed(()=>{
            return items.value.some((item)=>item.label.toString().length > 0
            );
        });
        const carouselClasses = _vue.computed(()=>{
            const classes = [
                ns.b(),
                ns.m(props.direction)
            ];
            if (props.type === "card") classes.push(ns.m("card"));
            return classes;
        });
        const indicatorsClasses = _vue.computed(()=>{
            const classes = [
                ns.e("indicators"),
                ns.em("indicators", props.direction)
            ];
            if (hasLabel.value) classes.push(ns.em("indicators", "labels"));
            if (props.indicatorPosition === "outside" || props.type === "card") classes.push(ns.em("indicators", "outside"));
            return classes;
        });
        const throttledArrowClick = _lodashUnified.throttle((index)=>{
            setActiveItem(index);
        }, 300, {
            trailing: true
        });
        const throttledIndicatorHover = _lodashUnified.throttle((index)=>{
            handleIndicatorHover(index);
        }, 300);
        function pauseTimer() {
            if (data.timer) {
                clearInterval(data.timer);
                data.timer = null;
            }
        }
        function startTimer() {
            if (props.interval <= 0 || !props.autoplay || data.timer) return;
            data.timer = setInterval(()=>playSlides()
            , props.interval);
        }
        const playSlides = ()=>{
            if (data.activeIndex < items.value.length - 1) data.activeIndex = data.activeIndex + 1;
            else if (props.loop) data.activeIndex = 0;
        };
        function setActiveItem(index) {
            if (typeof index === "string") {
                const filteredItems = items.value.filter((item)=>item.name === index
                );
                if (filteredItems.length > 0) index = items.value.indexOf(filteredItems[0]);
            }
            index = Number(index);
            if (isNaN(index) || index !== Math.floor(index)) {
                _errorMjs.debugWarn("Carousel", "index must be an integer.");
                return;
            }
            const length = items.value.length;
            const oldIndex = data.activeIndex;
            if (index < 0) data.activeIndex = props.loop ? length - 1 : 0;
            else if (index >= length) data.activeIndex = props.loop ? 0 : length - 1;
            else data.activeIndex = index;
            if (oldIndex === data.activeIndex) resetItemPosition(oldIndex);
        }
        function resetItemPosition(oldIndex) {
            items.value.forEach((item, index)=>{
                item.translateItem(index, data.activeIndex, oldIndex);
            });
        }
        function addItem(item) {
            items.value.push(item);
        }
        function removeItem(uid) {
            const index = items.value.findIndex((item)=>item.uid === uid
            );
            if (index !== -1) {
                items.value.splice(index, 1);
                if (data.activeIndex === index) next();
            }
        }
        function itemInStage(item, index) {
            const length = items.value.length;
            if (index === length - 1 && item.inStage && items.value[0].active || item.inStage && items.value[index + 1] && items.value[index + 1].active) return "left";
            else if (index === 0 && item.inStage && items.value[length - 1].active || item.inStage && items.value[index - 1] && items.value[index - 1].active) return "right";
            return false;
        }
        function handleMouseEnter() {
            data.hover = true;
            if (props.pauseOnHover) pauseTimer();
        }
        function handleMouseLeave() {
            data.hover = false;
            startTimer();
        }
        function handleButtonEnter(arrow) {
            if (props.direction === "vertical") return;
            items.value.forEach((item, index)=>{
                if (arrow === itemInStage(item, index)) item.hover = true;
            });
        }
        function handleButtonLeave() {
            if (props.direction === "vertical") return;
            items.value.forEach((item)=>{
                item.hover = false;
            });
        }
        function handleIndicatorClick(index) {
            data.activeIndex = index;
        }
        function handleIndicatorHover(index) {
            if (props.trigger === "hover" && index !== data.activeIndex) data.activeIndex = index;
        }
        function prev() {
            setActiveItem(data.activeIndex - 1);
        }
        function next() {
            setActiveItem(data.activeIndex + 1);
        }
        _vue.watch(()=>data.activeIndex
        , (current, prev2)=>{
            resetItemPosition(prev2);
            if (prev2 > -1) emit("change", current, prev2);
        });
        _vue.watch(()=>props.autoplay
        , (current)=>{
            current ? startTimer() : pauseTimer();
        });
        _vue.watch(()=>props.loop
        , ()=>{
            setActiveItem(data.activeIndex);
        });
        _vue.onMounted(()=>{
            _vue.nextTick(()=>{
                _resizeEventMjs.addResizeListener(root.value, resetItemPosition);
                if (props.initialIndex < items.value.length && props.initialIndex >= 0) data.activeIndex = props.initialIndex;
                startTimer();
            });
        });
        _vue.onBeforeUnmount(()=>{
            if (root.value) _resizeEventMjs.removeResizeListener(root.value, resetItemPosition);
            pauseTimer();
        });
        _vue.provide("injectCarouselScope", {
            root,
            direction: props.direction,
            type: props.type,
            items,
            loop: props.loop,
            addItem,
            removeItem,
            setActiveItem
        });
        return {
            data,
            props,
            items,
            arrowDisplay,
            carouselClasses,
            indicatorsClasses,
            hasLabel,
            handleMouseEnter,
            handleMouseLeave,
            handleIndicatorClick,
            throttledArrowClick,
            throttledIndicatorHover,
            handleButtonEnter,
            handleButtonLeave,
            prev,
            next,
            setActiveItem,
            root,
            ns
        };
    }
});
const _hoisted_1 = [
    "onMouseenter",
    "onClick"
];
const _hoisted_2 = {
    key: 0
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_arrow_left = _vue.resolveComponent("arrow-left");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_arrow_right = _vue.resolveComponent("arrow-right");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "root",
        class: _vue.normalizeClass(_ctx.carouselClasses),
        onMouseenter: _cache[6] || (_cache[6] = _vue.withModifiers((...args)=>_ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)
        , [
            "stop"
        ])),
        onMouseleave: _cache[7] || (_cache[7] = _vue.withModifiers((...args)=>_ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)
        , [
            "stop"
        ]))
    }, [
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("container")),
            style: _vue.normalizeStyle({
                height: _ctx.height
            })
        }, [
            _ctx.arrowDisplay ? (_vue.openBlock(), _vue.createBlock(_vue.Transition, {
                key: 0,
                name: "carousel-arrow-left"
            }, {
                default: _vue.withCtx(()=>[
                        _vue.withDirectives(_vue.createElementVNode("button", {
                            type: "button",
                            class: _vue.normalizeClass([
                                _ctx.ns.e("arrow"),
                                _ctx.ns.em("arrow", "left")
                            ]),
                            onMouseenter: _cache[0] || (_cache[0] = ($event)=>_ctx.handleButtonEnter("left")
                            ),
                            onMouseleave: _cache[1] || (_cache[1] = (...args)=>_ctx.handleButtonLeave && _ctx.handleButtonLeave(...args)
                            ),
                            onClick: _cache[2] || (_cache[2] = _vue.withModifiers(($event)=>_ctx.throttledArrowClick(_ctx.data.activeIndex - 1)
                            , [
                                "stop"
                            ]))
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_arrow_left)
                                    ]
                                ),
                                _: 1
                            })
                        ], 34), [
                            [
                                _vue.vShow,
                                (_ctx.arrow === "always" || _ctx.data.hover) && (_ctx.props.loop || _ctx.data.activeIndex > 0)
                            ]
                        ])
                    ]
                ),
                _: 1
            })) : _vue.createCommentVNode("v-if", true),
            _ctx.arrowDisplay ? (_vue.openBlock(), _vue.createBlock(_vue.Transition, {
                key: 1,
                name: "carousel-arrow-right"
            }, {
                default: _vue.withCtx(()=>[
                        _vue.withDirectives(_vue.createElementVNode("button", {
                            type: "button",
                            class: _vue.normalizeClass([
                                _ctx.ns.e("arrow"),
                                _ctx.ns.em("arrow", "right")
                            ]),
                            onMouseenter: _cache[3] || (_cache[3] = ($event)=>_ctx.handleButtonEnter("right")
                            ),
                            onMouseleave: _cache[4] || (_cache[4] = (...args)=>_ctx.handleButtonLeave && _ctx.handleButtonLeave(...args)
                            ),
                            onClick: _cache[5] || (_cache[5] = _vue.withModifiers(($event)=>_ctx.throttledArrowClick(_ctx.data.activeIndex + 1)
                            , [
                                "stop"
                            ]))
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_arrow_right)
                                    ]
                                ),
                                _: 1
                            })
                        ], 34), [
                            [
                                _vue.vShow,
                                (_ctx.arrow === "always" || _ctx.data.hover) && (_ctx.props.loop || _ctx.data.activeIndex < _ctx.items.length - 1)
                            ]
                        ])
                    ]
                ),
                _: 1
            })) : _vue.createCommentVNode("v-if", true),
            _vue.renderSlot(_ctx.$slots, "default")
        ], 6),
        _ctx.indicatorPosition !== "none" ? (_vue.openBlock(), _vue.createElementBlock("ul", {
            key: 0,
            class: _vue.normalizeClass(_ctx.indicatorsClasses)
        }, [
            (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.items, (item, index)=>{
                return _vue.openBlock(), _vue.createElementBlock("li", {
                    key: index,
                    class: _vue.normalizeClass([
                        _ctx.ns.e("indicator"),
                        _ctx.ns.em("indicator", _ctx.direction),
                        _ctx.ns.is("active", index === _ctx.data.activeIndex)
                    ]),
                    onMouseenter: ($event)=>_ctx.throttledIndicatorHover(index)
                    ,
                    onClick: _vue.withModifiers(($event)=>_ctx.handleIndicatorClick(index)
                    , [
                        "stop"
                    ])
                }, [
                    _vue.createElementVNode("button", {
                        class: _vue.normalizeClass(_ctx.ns.e("button"))
                    }, [
                        _ctx.hasLabel ? (_vue.openBlock(), _vue.createElementBlock("span", _hoisted_2, _vue.toDisplayString(item.label), 1)) : _vue.createCommentVNode("v-if", true)
                    ], 2)
                ], 42, _hoisted_1);
            }), 128))
        ], 2)) : _vue.createCommentVNode("v-if", true)
    ], 34);
}
var Carousel = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","lodash-unified":"4Oj4p","../../../utils/index.mjs":"dsdeP","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/error.mjs":"2zPBN","../../../utils/dom/resize-event.mjs":"TzEEU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"get3r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CarouselItem
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const CARD_SCALE = 0.83;
const _sfc_main = _vue.defineComponent({
    name: "ElCarouselItem",
    props: {
        name: {
            type: String,
            default: ""
        },
        label: {
            type: [
                String,
                Number
            ],
            default: ""
        }
    },
    setup (props) {
        const ns = _indexMjs2.useNamespace("carousel");
        const instance = _vue.getCurrentInstance();
        const data = _vue.reactive({
            hover: false,
            translate: 0,
            scale: 1,
            active: false,
            ready: false,
            inStage: false,
            animating: false
        });
        const injectCarouselScope = _vue.inject("injectCarouselScope");
        const parentDirection = _vue.computed(()=>{
            return injectCarouselScope.direction;
        });
        const itemStyle = _vue.computed(()=>{
            const translateType = parentDirection.value === "vertical" ? "translateY" : "translateX";
            const value = `${translateType}(${data.translate}px) scale(${data.scale})`;
            const style = {
                transform: value
            };
            return style;
        });
        function processIndex(index, activeIndex, length) {
            if (activeIndex === 0 && index === length - 1) return -1;
            else if (activeIndex === length - 1 && index === 0) return length;
            else if (index < activeIndex - 1 && activeIndex - index >= length / 2) return length + 1;
            else if (index > activeIndex + 1 && index - activeIndex >= length / 2) return -2;
            return index;
        }
        function calcCardTranslate(index, activeIndex) {
            var _a;
            const parentWidth = ((_a = injectCarouselScope.root.value) == null ? void 0 : _a.offsetWidth) || 0;
            if (data.inStage) return parentWidth * ((2 - CARD_SCALE) * (index - activeIndex) + 1) / 4;
            else if (index < activeIndex) return -(1 + CARD_SCALE) * parentWidth / 4;
            else return (3 + CARD_SCALE) * parentWidth / 4;
        }
        function calcTranslate(index, activeIndex, isVertical) {
            var _a, _b;
            const distance = (isVertical ? (_a = injectCarouselScope.root.value) == null ? void 0 : _a.offsetHeight : (_b = injectCarouselScope.root.value) == null ? void 0 : _b.offsetWidth) || 0;
            return distance * (index - activeIndex);
        }
        const translateItem = (index, activeIndex, oldIndex)=>{
            const parentType = injectCarouselScope.type;
            const length = injectCarouselScope.items.value.length;
            if (parentType !== "card" && oldIndex !== void 0) data.animating = index === activeIndex || index === oldIndex;
            if (index !== activeIndex && length > 2 && injectCarouselScope.loop) index = processIndex(index, activeIndex, length);
            if (parentType === "card") {
                if (parentDirection.value === "vertical") _errorMjs.debugWarn("Carousel", "vertical direction is not supported in card mode");
                data.inStage = Math.round(Math.abs(index - activeIndex)) <= 1;
                data.active = index === activeIndex;
                data.translate = calcCardTranslate(index, activeIndex);
                data.scale = data.active ? 1 : CARD_SCALE;
            } else {
                data.active = index === activeIndex;
                const isVertical = parentDirection.value === "vertical";
                data.translate = calcTranslate(index, activeIndex, isVertical);
            }
            data.ready = true;
        };
        function handleItemClick() {
            if (injectCarouselScope && injectCarouselScope.type === "card") {
                const index = injectCarouselScope.items.value.map((d)=>d.uid
                ).indexOf(instance.uid);
                injectCarouselScope.setActiveItem(index);
            }
        }
        _vue.onMounted(()=>{
            if (injectCarouselScope.addItem) injectCarouselScope.addItem({
                uid: instance.uid,
                ...props,
                ..._vue.toRefs(data),
                translateItem
            });
        });
        _vue.onUnmounted(()=>{
            if (injectCarouselScope.removeItem) injectCarouselScope.removeItem(instance.uid);
        });
        return {
            data,
            itemStyle,
            translateItem,
            type: injectCarouselScope.type,
            handleItemClick,
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.ns.e("item"),
            _ctx.ns.is("active", _ctx.data.active),
            _ctx.ns.is("in-stage", _ctx.data.inStage),
            _ctx.ns.is("hover", _ctx.data.hover),
            _ctx.ns.is("animating", _ctx.data.animating),
            {
                [_ctx.ns.em("item", "card")]: _ctx.type === "card"
            }
        ]),
        style: _vue.normalizeStyle(_ctx.itemStyle),
        onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleItemClick && _ctx.handleItemClick(...args)
        )
    }, [
        _ctx.type === "card" ? _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.e("mask"))
        }, null, 2)), [
            [
                _vue.vShow,
                !_ctx.data.active
            ]
        ]) : _vue.createCommentVNode("v-if", true),
        _vue.renderSlot(_ctx.$slots, "default")
    ], 6)), [
        [
            _vue.vShow,
            _ctx.data.ready
        ]
    ]);
}
var CarouselItem = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hgxNT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElCascader", ()=>ElCascader
);
parcelHelpers.export(exports, "default", ()=>_Cascader
);
var _indexMjs = require("./src/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
_indexMjsDefault.default.install = (app)=>{
    app.component(_indexMjsDefault.default.name, _indexMjsDefault.default);
};
const _Cascader = _indexMjsDefault.default;
const ElCascader = _Cascader;

},{"./src/index.mjs":"2XAvg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2XAvg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Cascader
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _lodashUnified = require("lodash-unified");
var _core = require("@vueuse/core");
var _indexMjs = require("../../cascader-panel/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _indexMjs1 = require("../../input/index.mjs");
var _indexMjs2 = require("../../tooltip/index.mjs");
var _indexMjs3 = require("../../popper/index.mjs");
var _indexMjs4 = require("../../scrollbar/index.mjs");
var _indexMjs5 = require("../../tag/index.mjs");
var _indexMjs6 = require("../../icon/index.mjs");
var _indexMjs7 = require("../../../tokens/index.mjs");
var _indexMjs8 = require("../../../directives/index.mjs");
var _indexMjs9 = require("../../../hooks/index.mjs");
var _indexMjs10 = require("../../../utils/index.mjs");
var _indexMjs11 = require("../../../constants/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs12 = require("../../../directives/click-outside/index.mjs");
var _indexMjsDefault1 = parcelHelpers.interopDefault(_indexMjs12);
var _configMjs = require("../../cascader-panel/src/config.mjs");
var _validatorMjs = require("../../../utils/vue/validator.mjs");
var _tooltipMjs = require("../../tooltip/src/tooltip.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _deprecationMjs = require("../../popper/src/deprecation.mjs");
var _indexMjs13 = require("../../../hooks/use-locale/index.mjs");
var _formMjs = require("../../../tokens/form.mjs");
var _indexMjs14 = require("../../../hooks/use-common-props/index.mjs");
var _i18NMjs = require("../../../utils/i18n.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
var _ariaMjs1 = require("../../../utils/dom/aria.mjs");
var _resizeEventMjs = require("../../../utils/dom/resize-event.mjs");
const DEFAULT_INPUT_HEIGHT = 40;
const INPUT_HEIGHT_MAP = {
    large: 36,
    default: 32,
    small: 28
};
const popperOptions = {
    modifiers: [
        {
            name: "arrowPosition",
            enabled: true,
            phase: "main",
            fn: ({ state  })=>{
                const { modifiersData , placement  } = state;
                if ([
                    "right",
                    "left",
                    "bottom",
                    "top"
                ].includes(placement)) return;
                modifiersData.arrow.x = 35;
            },
            requires: [
                "arrow"
            ]
        }
    ]
};
const COMPONENT_NAME = "ElCascader";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    components: {
        ElCascaderPanel: _indexMjsDefault.default,
        ElInput: _indexMjs1.ElInput,
        ElTooltip: _indexMjs2.ElTooltip,
        ElScrollbar: _indexMjs4.ElScrollbar,
        ElTag: _indexMjs5.ElTag,
        ElIcon: _indexMjs6.ElIcon,
        CircleClose: _iconsVue.CircleClose,
        Check: _iconsVue.Check,
        ArrowDown: _iconsVue.ArrowDown
    },
    directives: {
        Clickoutside: _indexMjsDefault1.default
    },
    props: {
        ..._configMjs.CommonProps,
        size: {
            type: String,
            validator: _validatorMjs.isValidComponentSize
        },
        placeholder: {
            type: String
        },
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        filterMethod: {
            type: Function,
            default: (node, keyword)=>node.text.includes(keyword)
        },
        separator: {
            type: String,
            default: " / "
        },
        showAllLevels: {
            type: Boolean,
            default: true
        },
        collapseTags: Boolean,
        debounce: {
            type: Number,
            default: 300
        },
        beforeFilter: {
            type: Function,
            default: ()=>true
        },
        popperClass: {
            type: String,
            default: ""
        },
        popperAppendToBody: {
            type: Boolean,
            default: void 0
        },
        teleported: _tooltipMjs.useTooltipContentProps.teleported
    },
    emits: [
        _eventMjs.UPDATE_MODEL_EVENT,
        _eventMjs.CHANGE_EVENT,
        "focus",
        "blur",
        "visible-change",
        "expand-change",
        "remove-tag"
    ],
    setup (props, { emit  }) {
        let inputInitialHeight = 0;
        let pressDeleteCount = 0;
        const { compatTeleported  } = _deprecationMjs.useDeprecateAppendToBody(COMPONENT_NAME, "popperAppendToBody");
        const { t  } = _indexMjs13.useLocale();
        const elForm = _vue.inject(_formMjs.elFormKey, {
        });
        const elFormItem = _vue.inject(_formMjs.elFormItemKey, {
        });
        const tooltipRef = _vue.ref(null);
        const input = _vue.ref(null);
        const tagWrapper = _vue.ref(null);
        const panel = _vue.ref(null);
        const suggestionPanel = _vue.ref(null);
        const popperVisible = _vue.ref(false);
        const inputHover = _vue.ref(false);
        const filtering = _vue.ref(false);
        const inputValue = _vue.ref("");
        const searchInputValue = _vue.ref("");
        const presentTags = _vue.ref([]);
        const suggestions = _vue.ref([]);
        const isOnComposition = _vue.ref(false);
        const isDisabled = _vue.computed(()=>props.disabled || elForm.disabled
        );
        const inputPlaceholder = _vue.computed(()=>props.placeholder || t("el.cascader.placeholder")
        );
        const realSize = _indexMjs14.useSize();
        const tagSize = _vue.computed(()=>[
                "small"
            ].includes(realSize.value) ? "small" : "default"
        );
        const multiple = _vue.computed(()=>!!props.props.multiple
        );
        const readonly = _vue.computed(()=>!props.filterable || multiple.value
        );
        const searchKeyword = _vue.computed(()=>multiple.value ? searchInputValue.value : inputValue.value
        );
        const checkedNodes = _vue.computed(()=>{
            var _a;
            return ((_a = panel.value) == null ? void 0 : _a.checkedNodes) || [];
        });
        const clearBtnVisible = _vue.computed(()=>{
            if (!props.clearable || isDisabled.value || filtering.value || !inputHover.value) return false;
            return !!checkedNodes.value.length;
        });
        const presentText = _vue.computed(()=>{
            const { showAllLevels , separator  } = props;
            const nodes = checkedNodes.value;
            return nodes.length ? multiple.value ? " " : nodes[0].calcText(showAllLevels, separator) : "";
        });
        const checkedValue = _vue.computed({
            get () {
                return props.modelValue;
            },
            set (val) {
                var _a;
                emit(_eventMjs.UPDATE_MODEL_EVENT, val);
                emit(_eventMjs.CHANGE_EVENT, val);
                (_a = elFormItem.validate) == null || _a.call(elFormItem, "change");
            }
        });
        const popperPaneRef = _vue.computed(()=>{
            var _a, _b;
            return (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
        });
        const togglePopperVisible = (visible)=>{
            var _a, _b, _c;
            if (isDisabled.value) return;
            visible = visible != null ? visible : !popperVisible.value;
            if (visible !== popperVisible.value) {
                popperVisible.value = visible;
                (_b = (_a = input.value) == null ? void 0 : _a.input) == null || _b.setAttribute("aria-expanded", `${visible}`);
                if (visible) {
                    updatePopperPosition();
                    _vue.nextTick((_c = panel.value) == null ? void 0 : _c.scrollToExpandingNode);
                } else if (props.filterable) {
                    const { value  } = presentText;
                    inputValue.value = value;
                    searchInputValue.value = value;
                }
                emit("visible-change", visible);
            }
        };
        const updatePopperPosition = ()=>{
            _vue.nextTick(()=>{
                var _a;
                (_a = tooltipRef.value) == null || _a.updatePopper();
            });
        };
        const hideSuggestionPanel = ()=>{
            filtering.value = false;
        };
        const genTag = (node)=>{
            const { showAllLevels , separator  } = props;
            return {
                node,
                key: node.uid,
                text: node.calcText(showAllLevels, separator),
                hitState: false,
                closable: !isDisabled.value && !node.isDisabled
            };
        };
        const deleteTag = (tag)=>{
            var _a;
            const node = tag.node;
            node.doCheck(false);
            (_a = panel.value) == null || _a.calculateCheckedValue();
            emit("remove-tag", node.valueByOption);
        };
        const calculatePresentTags = ()=>{
            if (!multiple.value) return;
            const nodes = checkedNodes.value;
            const tags = [];
            if (nodes.length) {
                const [first, ...rest] = nodes;
                const restCount = rest.length;
                tags.push(genTag(first));
                if (restCount) {
                    if (props.collapseTags) tags.push({
                        key: -1,
                        text: `+ ${restCount}`,
                        closable: false
                    });
                    else rest.forEach((node)=>tags.push(genTag(node))
                    );
                }
            }
            presentTags.value = tags;
        };
        const calculateSuggestions = ()=>{
            var _a, _b;
            const { filterMethod , showAllLevels , separator  } = props;
            const res = (_b = (_a = panel.value) == null ? void 0 : _a.getFlattedNodes(!props.props.checkStrictly)) == null ? void 0 : _b.filter((node)=>{
                if (node.isDisabled) return false;
                node.calcText(showAllLevels, separator);
                return filterMethod(node, searchKeyword.value);
            });
            if (multiple.value) presentTags.value.forEach((tag)=>{
                tag.hitState = false;
            });
            filtering.value = true;
            suggestions.value = res;
            updatePopperPosition();
        };
        const focusFirstNode = ()=>{
            var _a;
            let firstNode;
            if (filtering.value && suggestionPanel.value) firstNode = suggestionPanel.value.$el.querySelector(".el-cascader__suggestion-item");
            else firstNode = (_a = panel.value) == null ? void 0 : _a.$el.querySelector('.el-cascader-node[tabindex="-1"]');
            if (firstNode) {
                firstNode.focus();
                !filtering.value && firstNode.click();
            }
        };
        const updateStyle = ()=>{
            var _a, _b;
            const inputInner = (_a = input.value) == null ? void 0 : _a.input;
            const tagWrapperEl = tagWrapper.value;
            const suggestionPanelEl = (_b = suggestionPanel.value) == null ? void 0 : _b.$el;
            if (!_core.isClient || !inputInner) return;
            if (suggestionPanelEl) {
                const suggestionList = suggestionPanelEl.querySelector(".el-cascader__suggestion-list");
                suggestionList.style.minWidth = `${inputInner.offsetWidth}px`;
            }
            if (tagWrapperEl) {
                const { offsetHeight  } = tagWrapperEl;
                const height = presentTags.value.length > 0 ? `${Math.max(offsetHeight + 6, inputInitialHeight)}px` : `${inputInitialHeight}px`;
                inputInner.style.height = height;
                updatePopperPosition();
            }
        };
        const getCheckedNodes = (leafOnly)=>{
            var _a;
            return (_a = panel.value) == null ? void 0 : _a.getCheckedNodes(leafOnly);
        };
        const handleExpandChange = (value)=>{
            updatePopperPosition();
            emit("expand-change", value);
        };
        const handleComposition = (event)=>{
            var _a;
            const text = (_a = event.target) == null ? void 0 : _a.value;
            if (event.type === "compositionend") {
                isOnComposition.value = false;
                _vue.nextTick(()=>handleInput(text)
                );
            } else {
                const lastCharacter = text[text.length - 1] || "";
                isOnComposition.value = !_i18NMjs.isKorean(lastCharacter);
            }
        };
        const handleKeyDown = (e)=>{
            if (isOnComposition.value) return;
            switch(e.code){
                case _ariaMjs.EVENT_CODE.enter:
                    togglePopperVisible();
                    break;
                case _ariaMjs.EVENT_CODE.down:
                    togglePopperVisible(true);
                    _vue.nextTick(focusFirstNode);
                    e.preventDefault();
                    break;
                case _ariaMjs.EVENT_CODE.esc:
                case _ariaMjs.EVENT_CODE.tab:
                    togglePopperVisible(false);
                    break;
            }
        };
        const handleClear = ()=>{
            var _a;
            (_a = panel.value) == null || _a.clearCheckedNodes();
            togglePopperVisible(false);
        };
        const handleSuggestionClick = (node)=>{
            var _a, _b;
            const { checked  } = node;
            if (multiple.value) (_a = panel.value) == null || _a.handleCheckChange(node, !checked, false);
            else {
                !checked && ((_b = panel.value) == null || _b.handleCheckChange(node, true, false));
                togglePopperVisible(false);
            }
        };
        const handleSuggestionKeyDown = (e)=>{
            const target = e.target;
            const { code  } = e;
            switch(code){
                case _ariaMjs.EVENT_CODE.up:
                case _ariaMjs.EVENT_CODE.down:
                    {
                        const distance = code === _ariaMjs.EVENT_CODE.up ? -1 : 1;
                        _ariaMjs1.focusNode(_ariaMjs1.getSibling(target, distance, '.el-cascader__suggestion-item[tabindex="-1"]'));
                        break;
                    }
                case _ariaMjs.EVENT_CODE.enter:
                    target.click();
                    break;
                case _ariaMjs.EVENT_CODE.esc:
                case _ariaMjs.EVENT_CODE.tab:
                    togglePopperVisible(false);
                    break;
            }
        };
        const handleDelete = ()=>{
            const tags = presentTags.value;
            const lastTag = tags[tags.length - 1];
            pressDeleteCount = searchInputValue.value ? 0 : pressDeleteCount + 1;
            if (!lastTag || !pressDeleteCount) return;
            if (lastTag.hitState) deleteTag(lastTag);
            else lastTag.hitState = true;
        };
        const handleFilter = _lodashUnified.debounce(()=>{
            const { value  } = searchKeyword;
            if (!value) return;
            const passed = props.beforeFilter(value);
            if (_shared.isPromise(passed)) passed.then(calculateSuggestions).catch(()=>{
            });
            else if (passed !== false) calculateSuggestions();
            else hideSuggestionPanel();
        }, props.debounce);
        const handleInput = (val, e)=>{
            !popperVisible.value && togglePopperVisible(true);
            if (e == null ? void 0 : e.isComposing) return;
            val ? handleFilter() : hideSuggestionPanel();
        };
        _vue.watch(filtering, updatePopperPosition);
        _vue.watch([
            checkedNodes,
            isDisabled
        ], calculatePresentTags);
        _vue.watch(presentTags, ()=>{
            _vue.nextTick(()=>updateStyle()
            );
        });
        _vue.watch(presentText, (val)=>inputValue.value = val
        , {
            immediate: true
        });
        _vue.onMounted(()=>{
            var _a;
            const inputEl = (_a = input.value) == null ? void 0 : _a.$el;
            inputInitialHeight = (inputEl == null ? void 0 : inputEl.offsetHeight) || INPUT_HEIGHT_MAP[realSize.value] || DEFAULT_INPUT_HEIGHT;
            _resizeEventMjs.addResizeListener(inputEl, updateStyle);
        });
        _vue.onBeforeUnmount(()=>{
            var _a;
            _resizeEventMjs.removeResizeListener((_a = input.value) == null ? void 0 : _a.$el, updateStyle);
        });
        return {
            popperOptions,
            tooltipRef,
            popperPaneRef,
            input,
            tagWrapper,
            panel,
            suggestionPanel,
            popperVisible,
            inputHover,
            inputPlaceholder,
            filtering,
            presentText,
            checkedValue,
            inputValue,
            searchInputValue,
            presentTags,
            suggestions,
            isDisabled,
            isOnComposition,
            realSize,
            tagSize,
            multiple,
            readonly,
            clearBtnVisible,
            compatTeleported,
            t,
            togglePopperVisible,
            hideSuggestionPanel,
            deleteTag,
            focusFirstNode,
            getCheckedNodes,
            handleExpandChange,
            handleKeyDown,
            handleComposition,
            handleClear,
            handleSuggestionClick,
            handleSuggestionKeyDown,
            handleDelete,
            handleInput
        };
    }
});
const _hoisted_1 = {
    key: 0,
    ref: "tagWrapper",
    class: "el-cascader__tags"
};
const _hoisted_2 = [
    "placeholder"
];
const _hoisted_3 = [
    "onClick"
];
const _hoisted_4 = {
    class: "el-cascader__empty-text"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_circle_close = _vue.resolveComponent("circle-close");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_arrow_down = _vue.resolveComponent("arrow-down");
    const _component_el_input = _vue.resolveComponent("el-input");
    const _component_el_tag = _vue.resolveComponent("el-tag");
    const _component_el_cascader_panel = _vue.resolveComponent("el-cascader-panel");
    const _component_check = _vue.resolveComponent("check");
    const _component_el_scrollbar = _vue.resolveComponent("el-scrollbar");
    const _component_el_tooltip = _vue.resolveComponent("el-tooltip");
    const _directive_clickoutside = _vue.resolveDirective("clickoutside");
    return _vue.openBlock(), _vue.createBlock(_component_el_tooltip, {
        ref: "tooltipRef",
        visible: _ctx.popperVisible,
        "onUpdate:visible": _cache[17] || (_cache[17] = ($event)=>_ctx.popperVisible = $event
        ),
        teleported: _ctx.compatTeleported,
        "popper-class": `el-cascader__dropdown ${_ctx.popperClass}`,
        "popper-options": _ctx.popperOptions,
        "fallback-placements": [
            "bottom-start",
            "bottom",
            "top-start",
            "top",
            "right",
            "left"
        ],
        "stop-popper-mouse-event": false,
        "gpu-acceleration": false,
        placement: "bottom-start",
        transition: "el-zoom-in-top",
        effect: "light",
        pure: "",
        persistent: "",
        onHide: _ctx.hideSuggestionPanel
    }, {
        default: _vue.withCtx(()=>[
                _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
                    class: _vue.normalizeClass([
                        "el-cascader",
                        _ctx.realSize && `el-cascader--${_ctx.realSize}`,
                        {
                            "is-disabled": _ctx.isDisabled
                        },
                        _ctx.$attrs.class
                    ]),
                    style: _vue.normalizeStyle(_ctx.$attrs.style),
                    onClick: _cache[11] || (_cache[11] = ()=>_ctx.togglePopperVisible(_ctx.readonly ? void 0 : true)
                    ),
                    onKeydown: _cache[12] || (_cache[12] = (...args)=>_ctx.handleKeyDown && _ctx.handleKeyDown(...args)
                    ),
                    onMouseenter: _cache[13] || (_cache[13] = ($event)=>_ctx.inputHover = true
                    ),
                    onMouseleave: _cache[14] || (_cache[14] = ($event)=>_ctx.inputHover = false
                    )
                }, [
                    _vue.createVNode(_component_el_input, {
                        ref: "input",
                        modelValue: _ctx.inputValue,
                        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>_ctx.inputValue = $event
                        ),
                        placeholder: _ctx.inputPlaceholder,
                        readonly: _ctx.readonly,
                        disabled: _ctx.isDisabled,
                        "validate-event": false,
                        size: _ctx.realSize,
                        class: _vue.normalizeClass({
                            "is-focus": _ctx.popperVisible
                        }),
                        onCompositionstart: _ctx.handleComposition,
                        onCompositionupdate: _ctx.handleComposition,
                        onCompositionend: _ctx.handleComposition,
                        onFocus: _cache[2] || (_cache[2] = (e)=>_ctx.$emit("focus", e)
                        ),
                        onBlur: _cache[3] || (_cache[3] = (e)=>_ctx.$emit("blur", e)
                        ),
                        onInput: _ctx.handleInput
                    }, {
                        suffix: _vue.withCtx(()=>[
                                _ctx.clearBtnVisible ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                    key: "clear",
                                    class: "el-input__icon icon-circle-close",
                                    onClick: _vue.withModifiers(_ctx.handleClear, [
                                        "stop"
                                    ])
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_circle_close)
                                        ]
                                    ),
                                    _: 1
                                }, 8, [
                                    "onClick"
                                ])) : (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                    key: "arrow-down",
                                    class: _vue.normalizeClass([
                                        "el-input__icon",
                                        "icon-arrow-down",
                                        _ctx.popperVisible && "is-reverse"
                                    ]),
                                    onClick: _cache[0] || (_cache[0] = _vue.withModifiers(($event)=>_ctx.togglePopperVisible()
                                    , [
                                        "stop"
                                    ]))
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_arrow_down)
                                        ]
                                    ),
                                    _: 1
                                }, 8, [
                                    "class"
                                ]))
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "modelValue",
                        "placeholder",
                        "readonly",
                        "disabled",
                        "size",
                        "class",
                        "onCompositionstart",
                        "onCompositionupdate",
                        "onCompositionend",
                        "onInput"
                    ]),
                    _ctx.multiple ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_1, [
                        (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.presentTags, (tag)=>{
                            return _vue.openBlock(), _vue.createBlock(_component_el_tag, {
                                key: tag.key,
                                type: "info",
                                size: _ctx.tagSize,
                                hit: tag.hitState,
                                closable: tag.closable,
                                "disable-transitions": "",
                                onClose: ($event)=>_ctx.deleteTag(tag)
                            }, {
                                default: _vue.withCtx(()=>[
                                        _vue.createElementVNode("span", null, _vue.toDisplayString(tag.text), 1)
                                    ]
                                ),
                                _: 2
                            }, 1032, [
                                "size",
                                "hit",
                                "closable",
                                "onClose"
                            ]);
                        }), 128)),
                        _ctx.filterable && !_ctx.isDisabled ? _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("input", {
                            key: 0,
                            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event)=>_ctx.searchInputValue = $event
                            ),
                            type: "text",
                            class: "el-cascader__search-input",
                            placeholder: _ctx.presentText ? "" : _ctx.inputPlaceholder,
                            onInput: _cache[5] || (_cache[5] = (e)=>_ctx.handleInput(_ctx.searchInputValue, e)
                            ),
                            onClick: _cache[6] || (_cache[6] = _vue.withModifiers(($event)=>_ctx.togglePopperVisible(true)
                            , [
                                "stop"
                            ])),
                            onKeydown: _cache[7] || (_cache[7] = _vue.withKeys((...args)=>_ctx.handleDelete && _ctx.handleDelete(...args)
                            , [
                                "delete"
                            ])),
                            onCompositionstart: _cache[8] || (_cache[8] = (...args)=>_ctx.handleComposition && _ctx.handleComposition(...args)
                            ),
                            onCompositionupdate: _cache[9] || (_cache[9] = (...args)=>_ctx.handleComposition && _ctx.handleComposition(...args)
                            ),
                            onCompositionend: _cache[10] || (_cache[10] = (...args)=>_ctx.handleComposition && _ctx.handleComposition(...args)
                            )
                        }, null, 40, _hoisted_2)), [
                            [
                                _vue.vModelText,
                                _ctx.searchInputValue
                            ]
                        ]) : _vue.createCommentVNode("v-if", true)
                    ], 512)) : _vue.createCommentVNode("v-if", true)
                ], 38)), [
                    [
                        _directive_clickoutside,
                        ()=>_ctx.togglePopperVisible(false)
                        ,
                        _ctx.popperPaneRef
                    ]
                ])
            ]
        ),
        content: _vue.withCtx(()=>[
                _vue.withDirectives(_vue.createVNode(_component_el_cascader_panel, {
                    ref: "panel",
                    modelValue: _ctx.checkedValue,
                    "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event)=>_ctx.checkedValue = $event
                    ),
                    options: _ctx.options,
                    props: _ctx.props,
                    border: false,
                    "render-label": _ctx.$slots.default,
                    onExpandChange: _ctx.handleExpandChange,
                    onClose: _cache[16] || (_cache[16] = ($event)=>_ctx.$nextTick(()=>_ctx.togglePopperVisible(false)
                        )
                    )
                }, null, 8, [
                    "modelValue",
                    "options",
                    "props",
                    "render-label",
                    "onExpandChange"
                ]), [
                    [
                        _vue.vShow,
                        !_ctx.filtering
                    ]
                ]),
                _ctx.filterable ? _vue.withDirectives((_vue.openBlock(), _vue.createBlock(_component_el_scrollbar, {
                    key: 0,
                    ref: "suggestionPanel",
                    tag: "ul",
                    class: "el-cascader__suggestion-panel",
                    "view-class": "el-cascader__suggestion-list",
                    onKeydown: _ctx.handleSuggestionKeyDown
                }, {
                    default: _vue.withCtx(()=>[
                            _ctx.suggestions.length ? (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, {
                                key: 0
                            }, _vue.renderList(_ctx.suggestions, (item)=>{
                                return _vue.openBlock(), _vue.createElementBlock("li", {
                                    key: item.uid,
                                    class: _vue.normalizeClass([
                                        "el-cascader__suggestion-item",
                                        item.checked && "is-checked"
                                    ]),
                                    tabindex: -1,
                                    onClick: ($event)=>_ctx.handleSuggestionClick(item)
                                }, [
                                    _vue.createElementVNode("span", null, _vue.toDisplayString(item.text), 1),
                                    item.checked ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                        key: 0
                                    }, {
                                        default: _vue.withCtx(()=>[
                                                _vue.createVNode(_component_check)
                                            ]
                                        ),
                                        _: 1
                                    })) : _vue.createCommentVNode("v-if", true)
                                ], 10, _hoisted_3);
                            }), 128)) : _vue.renderSlot(_ctx.$slots, "empty", {
                                key: 1
                            }, ()=>[
                                    _vue.createElementVNode("li", _hoisted_4, _vue.toDisplayString(_ctx.t("el.cascader.noMatch")), 1)
                                ]
                            )
                        ]
                    ),
                    _: 3
                }, 8, [
                    "onKeydown"
                ])), [
                    [
                        _vue.vShow,
                        _ctx.filtering
                    ]
                ]) : _vue.createCommentVNode("v-if", true)
            ]
        ),
        _: 3
    }, 8, [
        "visible",
        "teleported",
        "popper-class",
        "popper-options",
        "onHide"
    ]);
}
var Cascader = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vue/shared":"3SM3y","lodash-unified":"4Oj4p","@vueuse/core":"eEHP9","../../cascader-panel/index.mjs":"cvCE6","../../input/index.mjs":"18eQI","../../tooltip/index.mjs":"kiwBC","../../popper/index.mjs":"kIV7g","../../scrollbar/index.mjs":"kXLHt","../../tag/index.mjs":"96fQG","../../icon/index.mjs":"hnNTG","../../../tokens/index.mjs":"wVNQi","../../../directives/index.mjs":"aRbJ2","../../../hooks/index.mjs":"1Ansp","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","@element-plus/icons-vue":"b18uu","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../directives/click-outside/index.mjs":"cdlLW","../../cascader-panel/src/config.mjs":"8uFuI","../../../utils/vue/validator.mjs":"4UnBa","../../tooltip/src/tooltip.mjs":"7LVFi","../../../constants/event.mjs":"92xVn","../../popper/src/deprecation.mjs":"jm0Kb","../../../hooks/use-locale/index.mjs":"c1HoA","../../../tokens/form.mjs":"2r4O0","../../../hooks/use-common-props/index.mjs":"05czU","../../../utils/i18n.mjs":"5xQne","../../../constants/aria.mjs":"jS6iK","../../../utils/dom/aria.mjs":"6roYP","../../../utils/dom/resize-event.mjs":"TzEEU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cvCE6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CASCADER_PANEL_INJECTION_KEY", ()=>_typesMjs.CASCADER_PANEL_INJECTION_KEY
);
parcelHelpers.export(exports, "ExpandTrigger", ()=>_typesMjs.ExpandTrigger
);
parcelHelpers.export(exports, "CommonProps", ()=>_configMjs.CommonProps
);
parcelHelpers.export(exports, "DefaultProps", ()=>_configMjs.DefaultProps
);
parcelHelpers.export(exports, "useCascaderConfig", ()=>_configMjs.useCascaderConfig
);
parcelHelpers.export(exports, "ElCascaderPanel", ()=>ElCascaderPanel
);
parcelHelpers.export(exports, "default", ()=>_CascaderPanel
);
var _indexMjs = require("./src/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _typesMjs = require("./src/types.mjs");
var _configMjs = require("./src/config.mjs");
_indexMjsDefault.default.install = (app)=>{
    app.component(_indexMjsDefault.default.name, _indexMjsDefault.default);
};
const _CascaderPanel = _indexMjsDefault.default;
const ElCascaderPanel = _CascaderPanel;

},{"./src/index.mjs":"lUq1t","./src/types.mjs":"5MNj5","./src/config.mjs":"8uFuI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lUq1t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CascaderPanel
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _menuMjs = require("./menu.mjs");
var _menuMjsDefault = parcelHelpers.interopDefault(_menuMjs);
var _storeMjs = require("./store.mjs");
var _storeMjsDefault = parcelHelpers.interopDefault(_storeMjs);
var _nodeMjs = require("./node.mjs");
var _nodeMjsDefault = parcelHelpers.interopDefault(_nodeMjs);
var _configMjs = require("./config.mjs");
var _utilsMjs = require("./utils.mjs");
var _typesMjs = require("./types.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _eventMjs = require("../../../constants/event.mjs");
var _typesMjs1 = require("../../../utils/types.mjs");
var _arraysMjs = require("../../../utils/arrays.mjs");
var _scrollMjs = require("../../../utils/dom/scroll.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
var _ariaMjs1 = require("../../../utils/dom/aria.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElCascaderPanel",
    components: {
        ElCascaderMenu: _menuMjsDefault.default
    },
    props: {
        ..._configMjs.CommonProps,
        border: {
            type: Boolean,
            default: true
        },
        renderLabel: Function
    },
    emits: [
        _eventMjs.UPDATE_MODEL_EVENT,
        _eventMjs.CHANGE_EVENT,
        "close",
        "expand-change"
    ],
    setup (props, { emit , slots  }) {
        let manualChecked = false;
        const config = _configMjs.useCascaderConfig(props);
        let store = null;
        const initialLoaded = _vue.ref(true);
        const menuList = _vue.ref([]);
        const checkedValue = _vue.ref(null);
        const menus = _vue.ref([]);
        const expandingNode = _vue.ref(null);
        const checkedNodes = _vue.ref([]);
        const isHoverMenu = _vue.computed(()=>config.value.expandTrigger === _nodeMjs.ExpandTrigger.HOVER
        );
        const renderLabelFn = _vue.computed(()=>props.renderLabel || slots.default
        );
        const initStore = ()=>{
            const { options  } = props;
            const cfg = config.value;
            manualChecked = false;
            store = new _storeMjsDefault.default(options, cfg);
            menus.value = [
                store.getNodes()
            ];
            if (cfg.lazy && _typesMjs1.isEmpty(props.options)) {
                initialLoaded.value = false;
                lazyLoad(void 0, (list)=>{
                    if (list) {
                        store = new _storeMjsDefault.default(list, cfg);
                        menus.value = [
                            store.getNodes()
                        ];
                    }
                    initialLoaded.value = true;
                    syncCheckedValue(false, true);
                });
            } else syncCheckedValue(false, true);
        };
        const lazyLoad = (node, cb)=>{
            const cfg = config.value;
            node = node || new _nodeMjsDefault.default({
            }, cfg, void 0, true);
            node.loading = true;
            const resolve = (dataList)=>{
                const _node = node;
                const parent = _node.root ? null : _node;
                dataList && (store == null || store.appendNodes(dataList, parent));
                _node.loading = false;
                _node.loaded = true;
                _node.childrenData = _node.childrenData || [];
                cb && cb(dataList);
            };
            cfg.lazyLoad(node, resolve);
        };
        const expandNode = (node, silent)=>{
            var _a;
            const { level  } = node;
            const newMenus = menus.value.slice(0, level);
            let newExpandingNode;
            if (node.isLeaf) newExpandingNode = node.pathNodes[level - 2];
            else {
                newExpandingNode = node;
                newMenus.push(node.children);
            }
            if (((_a = expandingNode.value) == null ? void 0 : _a.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {
                expandingNode.value = node;
                menus.value = newMenus;
                !silent && emit("expand-change", (node == null ? void 0 : node.pathValues) || []);
            }
        };
        const handleCheckChange = (node, checked, emitClose = true)=>{
            const { checkStrictly , multiple  } = config.value;
            const oldNode = checkedNodes.value[0];
            manualChecked = true;
            !multiple && (oldNode == null || oldNode.doCheck(false));
            node.doCheck(checked);
            calculateCheckedValue();
            emitClose && !multiple && !checkStrictly && emit("close");
            !emitClose && !multiple && !checkStrictly && expandParentNode(node);
        };
        const expandParentNode = (node)=>{
            if (!node) return;
            node = node.parent;
            expandParentNode(node);
            node && expandNode(node);
        };
        const getFlattedNodes = (leafOnly)=>{
            return store == null ? void 0 : store.getFlattedNodes(leafOnly);
        };
        const getCheckedNodes = (leafOnly)=>{
            var _a;
            return (_a = getFlattedNodes(leafOnly)) == null ? void 0 : _a.filter((node)=>node.checked !== false
            );
        };
        const clearCheckedNodes = ()=>{
            checkedNodes.value.forEach((node)=>node.doCheck(false)
            );
            calculateCheckedValue();
        };
        const calculateCheckedValue = ()=>{
            var _a;
            const { checkStrictly , multiple  } = config.value;
            const oldNodes = checkedNodes.value;
            const newNodes = getCheckedNodes(!checkStrictly);
            const nodes = _utilsMjs.sortByOriginalOrder(oldNodes, newNodes);
            const values = nodes.map((node)=>node.valueByOption
            );
            checkedNodes.value = nodes;
            checkedValue.value = multiple ? values : (_a = values[0]) != null ? _a : null;
        };
        const syncCheckedValue = (loaded = false, forced = false)=>{
            const { modelValue  } = props;
            const { lazy , multiple , checkStrictly  } = config.value;
            const leafOnly = !checkStrictly;
            if (!initialLoaded.value || manualChecked || !forced && _lodashUnified.isEqual(modelValue, checkedValue.value)) return;
            if (lazy && !loaded) {
                const values = _arraysMjs.unique(_lodashUnified.flattenDeep(_arraysMjs.castArray(modelValue)));
                const nodes = values.map((val)=>store == null ? void 0 : store.getNodeByValue(val)
                ).filter((node)=>!!node && !node.loaded && !node.loading
                );
                if (nodes.length) nodes.forEach((node)=>{
                    lazyLoad(node, ()=>syncCheckedValue(false, forced)
                    );
                });
                else syncCheckedValue(true, forced);
            } else {
                const values = multiple ? _arraysMjs.castArray(modelValue) : [
                    modelValue
                ];
                const nodes = _arraysMjs.unique(values.map((val)=>store == null ? void 0 : store.getNodeByValue(val, leafOnly)
                ));
                syncMenuState(nodes, false);
                checkedValue.value = modelValue;
            }
        };
        const syncMenuState = (newCheckedNodes, reserveExpandingState = true)=>{
            const { checkStrictly  } = config.value;
            const oldNodes = checkedNodes.value;
            const newNodes = newCheckedNodes.filter((node)=>!!node && (checkStrictly || node.isLeaf)
            );
            const oldExpandingNode = store == null ? void 0 : store.getSameNode(expandingNode.value);
            const newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];
            if (newExpandingNode) newExpandingNode.pathNodes.forEach((node)=>expandNode(node, true)
            );
            else expandingNode.value = null;
            oldNodes.forEach((node)=>node.doCheck(false)
            );
            newNodes.forEach((node)=>node.doCheck(true)
            );
            checkedNodes.value = newNodes;
            _vue.nextTick(scrollToExpandingNode);
        };
        const scrollToExpandingNode = ()=>{
            if (!_core.isClient) return;
            menuList.value.forEach((menu)=>{
                const menuElement = menu == null ? void 0 : menu.$el;
                if (menuElement) {
                    const container = menuElement.querySelector(".el-scrollbar__wrap");
                    const activeNode = menuElement.querySelector(".el-cascader-node.is-active") || menuElement.querySelector(".el-cascader-node.in-active-path");
                    _scrollMjs.scrollIntoView(container, activeNode);
                }
            });
        };
        const handleKeyDown = (e)=>{
            const target = e.target;
            const { code  } = e;
            switch(code){
                case _ariaMjs.EVENT_CODE.up:
                case _ariaMjs.EVENT_CODE.down:
                    {
                        e.preventDefault();
                        const distance = code === _ariaMjs.EVENT_CODE.up ? -1 : 1;
                        _ariaMjs1.focusNode(_ariaMjs1.getSibling(target, distance, '.el-cascader-node[tabindex="-1"]'));
                        break;
                    }
                case _ariaMjs.EVENT_CODE.left:
                    {
                        e.preventDefault();
                        const preMenu = menuList.value[_utilsMjs.getMenuIndex(target) - 1];
                        const expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector('.el-cascader-node[aria-expanded="true"]');
                        _ariaMjs1.focusNode(expandedNode);
                        break;
                    }
                case _ariaMjs.EVENT_CODE.right:
                    {
                        e.preventDefault();
                        const nextMenu = menuList.value[_utilsMjs.getMenuIndex(target) + 1];
                        const firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector('.el-cascader-node[tabindex="-1"]');
                        _ariaMjs1.focusNode(firstNode);
                        break;
                    }
                case _ariaMjs.EVENT_CODE.enter:
                    _utilsMjs.checkNode(target);
                    break;
                case _ariaMjs.EVENT_CODE.esc:
                case _ariaMjs.EVENT_CODE.tab:
                    emit("close");
                    break;
            }
        };
        _vue.provide(_typesMjs.CASCADER_PANEL_INJECTION_KEY, _vue.reactive({
            config,
            expandingNode,
            checkedNodes,
            isHoverMenu,
            initialLoaded,
            renderLabelFn,
            lazyLoad,
            expandNode,
            handleCheckChange
        }));
        _vue.watch([
            config,
            ()=>props.options
        ], initStore, {
            deep: true,
            immediate: true
        });
        _vue.watch(()=>props.modelValue
        , ()=>{
            manualChecked = false;
            syncCheckedValue();
        });
        _vue.watch(checkedValue, (val)=>{
            if (!_lodashUnified.isEqual(val, props.modelValue)) {
                emit(_eventMjs.UPDATE_MODEL_EVENT, val);
                emit(_eventMjs.CHANGE_EVENT, val);
            }
        });
        _vue.onBeforeUpdate(()=>menuList.value = []
        );
        _vue.onMounted(()=>!_typesMjs1.isEmpty(props.modelValue) && syncCheckedValue()
        );
        return {
            menuList,
            menus,
            checkedNodes,
            handleKeyDown,
            handleCheckChange,
            getFlattedNodes,
            getCheckedNodes,
            clearCheckedNodes,
            calculateCheckedValue,
            scrollToExpandingNode
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_cascader_menu = _vue.resolveComponent("el-cascader-menu");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            "el-cascader-panel",
            _ctx.border && "is-bordered"
        ]),
        onKeydown: _cache[0] || (_cache[0] = (...args)=>_ctx.handleKeyDown && _ctx.handleKeyDown(...args)
        )
    }, [
        (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.menus, (menu, index)=>{
            return _vue.openBlock(), _vue.createBlock(_component_el_cascader_menu, {
                key: index,
                ref_for: true,
                ref: (item)=>_ctx.menuList[index] = item
                ,
                index,
                nodes: menu
            }, null, 8, [
                "index",
                "nodes"
            ]);
        }), 128))
    ], 34);
}
var CascaderPanel = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","lodash-unified":"4Oj4p","@vueuse/core":"eEHP9","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","./menu.mjs":"52feT","./store.mjs":"7limu","./node.mjs":"2209H","./config.mjs":"8uFuI","./utils.mjs":"6j1MX","./types.mjs":"5MNj5","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../constants/event.mjs":"92xVn","../../../utils/types.mjs":"4VsDK","../../../utils/arrays.mjs":"e9h0v","../../../utils/dom/scroll.mjs":"hpitc","../../../constants/aria.mjs":"jS6iK","../../../utils/dom/aria.mjs":"6roYP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"52feT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElCascaderMenu
);
var _vue = require("vue");
var _indexMjs = require("../../scrollbar/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _indexMjs2 = require("../../../utils/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs3 = require("../../icon/index.mjs");
var _node2Mjs = require("./node2.mjs");
var _node2MjsDefault = parcelHelpers.interopDefault(_node2Mjs);
var _typesMjs = require("./types.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs4 = require("../../../hooks/use-locale/index.mjs");
var _randMjs = require("../../../utils/rand.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElCascaderMenu",
    components: {
        Loading: _iconsVue.Loading,
        ElIcon: _indexMjs3.ElIcon,
        ElScrollbar: _indexMjs.ElScrollbar,
        ElCascaderNode: _node2MjsDefault.default
    },
    props: {
        nodes: {
            type: Array,
            required: true
        },
        index: {
            type: Number,
            required: true
        }
    },
    setup (props) {
        const instance = _vue.getCurrentInstance();
        const { t  } = _indexMjs4.useLocale();
        const id = _randMjs.generateId();
        let activeNode = null;
        let hoverTimer = null;
        const panel = _vue.inject(_typesMjs.CASCADER_PANEL_INJECTION_KEY);
        const hoverZone = _vue.ref(null);
        const isEmpty = _vue.computed(()=>!props.nodes.length
        );
        const isLoading = _vue.computed(()=>!panel.initialLoaded
        );
        const menuId = _vue.computed(()=>`cascader-menu-${id}-${props.index}`
        );
        const handleExpand = (e)=>{
            activeNode = e.target;
        };
        const handleMouseMove = (e)=>{
            if (!panel.isHoverMenu || !activeNode || !hoverZone.value) return;
            if (activeNode.contains(e.target)) {
                clearHoverTimer();
                const el = instance.vnode.el;
                const { left  } = el.getBoundingClientRect();
                const { offsetWidth , offsetHeight  } = el;
                const startX = e.clientX - left;
                const top = activeNode.offsetTop;
                const bottom = top + activeNode.offsetHeight;
                hoverZone.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top} L${offsetWidth} 0 V${top} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom} L${offsetWidth} ${offsetHeight} V${bottom} Z" />
        `;
            } else if (!hoverTimer) hoverTimer = window.setTimeout(clearHoverZone, panel.config.hoverThreshold);
        };
        const clearHoverTimer = ()=>{
            if (!hoverTimer) return;
            clearTimeout(hoverTimer);
            hoverTimer = null;
        };
        const clearHoverZone = ()=>{
            if (!hoverZone.value) return;
            hoverZone.value.innerHTML = "";
            clearHoverTimer();
        };
        return {
            panel,
            hoverZone,
            isEmpty,
            isLoading,
            menuId,
            t,
            handleExpand,
            handleMouseMove,
            clearHoverZone
        };
    }
});
const _hoisted_1 = {
    key: 0,
    class: "el-cascader-menu__empty-text"
};
const _hoisted_2 = {
    key: 1,
    class: "el-cascader-menu__empty-text"
};
const _hoisted_3 = {
    key: 2,
    ref: "hoverZone",
    class: "el-cascader-menu__hover-zone"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_cascader_node = _vue.resolveComponent("el-cascader-node");
    const _component_loading = _vue.resolveComponent("loading");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_scrollbar = _vue.resolveComponent("el-scrollbar");
    return _vue.openBlock(), _vue.createBlock(_component_el_scrollbar, {
        key: _ctx.menuId,
        tag: "ul",
        role: "menu",
        class: "el-cascader-menu",
        "wrap-class": "el-cascader-menu__wrap",
        "view-class": [
            "el-cascader-menu__list",
            _ctx.isEmpty && "is-empty"
        ],
        onMousemove: _ctx.handleMouseMove,
        onMouseleave: _ctx.clearHoverZone
    }, {
        default: _vue.withCtx(()=>{
            var _a;
            return [
                (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.nodes, (node)=>{
                    return _vue.openBlock(), _vue.createBlock(_component_el_cascader_node, {
                        key: node.uid,
                        node,
                        "menu-id": _ctx.menuId,
                        onExpand: _ctx.handleExpand
                    }, null, 8, [
                        "node",
                        "menu-id",
                        "onExpand"
                    ]);
                }), 128)),
                _ctx.isLoading ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_1, [
                    _vue.createVNode(_component_el_icon, {
                        size: "14",
                        class: "is-loading"
                    }, {
                        default: _vue.withCtx(()=>[
                                _vue.createVNode(_component_loading)
                            ]
                        ),
                        _: 1
                    }),
                    _vue.createTextVNode(" " + _vue.toDisplayString(_ctx.t("el.cascader.loading")), 1)
                ])) : _ctx.isEmpty ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_2, _vue.toDisplayString(_ctx.t("el.cascader.noData")), 1)) : ((_a = _ctx.panel) == null ? void 0 : _a.isHoverMenu) ? (_vue.openBlock(), _vue.createElementBlock("svg", _hoisted_3, null, 512)) : _vue.createCommentVNode("v-if", true)
            ];
        }),
        _: 1
    }, 8, [
        "view-class",
        "onMousemove",
        "onMouseleave"
    ]);
}
var ElCascaderMenu = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../scrollbar/index.mjs":"kXLHt","../../../hooks/index.mjs":"1Ansp","../../../utils/index.mjs":"dsdeP","@element-plus/icons-vue":"b18uu","../../icon/index.mjs":"hnNTG","./node2.mjs":"bOdsZ","./types.mjs":"5MNj5","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-locale/index.mjs":"c1HoA","../../../utils/rand.mjs":"6d823","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bOdsZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElCascaderNode
);
var _vue = require("vue");
var _indexMjs = require("../../checkbox/index.mjs");
var _indexMjs1 = require("../../radio/index.mjs");
var _indexMjs2 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _nodeContentMjs = require("./node-content.mjs");
var _nodeContentMjsDefault = parcelHelpers.interopDefault(_nodeContentMjs);
var _typesMjs = require("./types.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ElCascaderNode",
    components: {
        ElCheckbox: _indexMjs.ElCheckbox,
        ElRadio: _indexMjs1.ElRadio,
        NodeContent: _nodeContentMjsDefault.default,
        ElIcon: _indexMjs2.ElIcon,
        Check: _iconsVue.Check,
        Loading: _iconsVue.Loading,
        ArrowRight: _iconsVue.ArrowRight
    },
    props: {
        node: {
            type: Object,
            required: true
        },
        menuId: String
    },
    emits: [
        "expand"
    ],
    setup (props, { emit  }) {
        const panel = _vue.inject(_typesMjs.CASCADER_PANEL_INJECTION_KEY);
        const isHoverMenu = _vue.computed(()=>panel.isHoverMenu
        );
        const multiple = _vue.computed(()=>panel.config.multiple
        );
        const checkStrictly = _vue.computed(()=>panel.config.checkStrictly
        );
        const checkedNodeId = _vue.computed(()=>{
            var _a;
            return (_a = panel.checkedNodes[0]) == null ? void 0 : _a.uid;
        });
        const isDisabled = _vue.computed(()=>props.node.isDisabled
        );
        const isLeaf = _vue.computed(()=>props.node.isLeaf
        );
        const expandable = _vue.computed(()=>checkStrictly.value && !isLeaf.value || !isDisabled.value
        );
        const inExpandingPath = _vue.computed(()=>isInPath(panel.expandingNode)
        );
        const inCheckedPath = _vue.computed(()=>checkStrictly.value && panel.checkedNodes.some(isInPath)
        );
        const isInPath = (node)=>{
            var _a;
            const { level , uid  } = props.node;
            return ((_a = node == null ? void 0 : node.pathNodes[level - 1]) == null ? void 0 : _a.uid) === uid;
        };
        const doExpand = ()=>{
            if (inExpandingPath.value) return;
            panel.expandNode(props.node);
        };
        const doCheck = (checked)=>{
            const { node  } = props;
            if (checked === node.checked) return;
            panel.handleCheckChange(node, checked);
        };
        const doLoad = ()=>{
            panel.lazyLoad(props.node, ()=>{
                if (!isLeaf.value) doExpand();
            });
        };
        const handleHoverExpand = (e)=>{
            if (!isHoverMenu.value) return;
            handleExpand();
            !isLeaf.value && emit("expand", e);
        };
        const handleExpand = ()=>{
            const { node  } = props;
            if (!expandable.value || node.loading) return;
            node.loaded ? doExpand() : doLoad();
        };
        const handleClick = ()=>{
            if (isHoverMenu.value && !isLeaf.value) return;
            if (isLeaf.value && !isDisabled.value && !checkStrictly.value && !multiple.value) handleCheck(true);
            else handleExpand();
        };
        const handleSelectCheck = (checked)=>{
            if (checkStrictly.value) {
                doCheck(checked);
                if (props.node.loaded) doExpand();
            } else handleCheck(checked);
        };
        const handleCheck = (checked)=>{
            if (!props.node.loaded) doLoad();
            else {
                doCheck(checked);
                !checkStrictly.value && doExpand();
            }
        };
        return {
            panel,
            isHoverMenu,
            multiple,
            checkStrictly,
            checkedNodeId,
            isDisabled,
            isLeaf,
            expandable,
            inExpandingPath,
            inCheckedPath,
            handleHoverExpand,
            handleExpand,
            handleClick,
            handleCheck,
            handleSelectCheck
        };
    }
});
const _hoisted_1 = [
    "id",
    "aria-haspopup",
    "aria-owns",
    "aria-expanded",
    "tabindex"
];
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("span", null, null, -1);
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_checkbox = _vue.resolveComponent("el-checkbox");
    const _component_el_radio = _vue.resolveComponent("el-radio");
    const _component_check = _vue.resolveComponent("check");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_node_content = _vue.resolveComponent("node-content");
    const _component_loading = _vue.resolveComponent("loading");
    const _component_arrow_right = _vue.resolveComponent("arrow-right");
    return _vue.openBlock(), _vue.createElementBlock("li", {
        id: `${_ctx.menuId}-${_ctx.node.uid}`,
        role: "menuitem",
        "aria-haspopup": !_ctx.isLeaf,
        "aria-owns": _ctx.isLeaf ? null : _ctx.menuId,
        "aria-expanded": _ctx.inExpandingPath,
        tabindex: _ctx.expandable ? -1 : void 0,
        class: _vue.normalizeClass([
            "el-cascader-node",
            _ctx.checkStrictly && "is-selectable",
            _ctx.inExpandingPath && "in-active-path",
            _ctx.inCheckedPath && "in-checked-path",
            _ctx.node.checked && "is-active",
            !_ctx.expandable && "is-disabled"
        ]),
        onMouseenter: _cache[2] || (_cache[2] = (...args)=>_ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)
        ),
        onFocus: _cache[3] || (_cache[3] = (...args)=>_ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)
        ),
        onClick: _cache[4] || (_cache[4] = (...args)=>_ctx.handleClick && _ctx.handleClick(...args)
        )
    }, [
        _vue.createCommentVNode(" prefix "),
        _ctx.multiple ? (_vue.openBlock(), _vue.createBlock(_component_el_checkbox, {
            key: 0,
            "model-value": _ctx.node.checked,
            indeterminate: _ctx.node.indeterminate,
            disabled: _ctx.isDisabled,
            onClick: _cache[0] || (_cache[0] = _vue.withModifiers(()=>{
            }, [
                "stop"
            ])),
            "onUpdate:modelValue": _ctx.handleSelectCheck
        }, null, 8, [
            "model-value",
            "indeterminate",
            "disabled",
            "onUpdate:modelValue"
        ])) : _ctx.checkStrictly ? (_vue.openBlock(), _vue.createBlock(_component_el_radio, {
            key: 1,
            "model-value": _ctx.checkedNodeId,
            label: _ctx.node.uid,
            disabled: _ctx.isDisabled,
            "onUpdate:modelValue": _ctx.handleSelectCheck,
            onClick: _cache[1] || (_cache[1] = _vue.withModifiers(()=>{
            }, [
                "stop"
            ]))
        }, {
            default: _vue.withCtx(()=>[
                    _vue.createCommentVNode("\n        Add an empty element to avoid render label,\n        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485\n      "),
                    _hoisted_2
                ]
            ),
            _: 1
        }, 8, [
            "model-value",
            "label",
            "disabled",
            "onUpdate:modelValue"
        ])) : _ctx.isLeaf && _ctx.node.checked ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
            key: 2,
            class: "el-cascader-node__prefix"
        }, {
            default: _vue.withCtx(()=>[
                    _vue.createVNode(_component_check)
                ]
            ),
            _: 1
        })) : _vue.createCommentVNode("v-if", true),
        _vue.createCommentVNode(" content "),
        _vue.createVNode(_component_node_content),
        _vue.createCommentVNode(" postfix "),
        !_ctx.isLeaf ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
            key: 3
        }, [
            _ctx.node.loading ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                key: 0,
                class: "is-loading el-cascader-node__postfix"
            }, {
                default: _vue.withCtx(()=>[
                        _vue.createVNode(_component_loading)
                    ]
                ),
                _: 1
            })) : (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                key: 1,
                class: "arrow-right el-cascader-node__postfix"
            }, {
                default: _vue.withCtx(()=>[
                        _vue.createVNode(_component_arrow_right)
                    ]
                ),
                _: 1
            }))
        ], 2112)) : _vue.createCommentVNode("v-if", true)
    ], 42, _hoisted_1);
}
var ElCascaderNode = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../checkbox/index.mjs":"jMNjD","../../radio/index.mjs":"fekfn","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","./node-content.mjs":"5ZCy1","./types.mjs":"5MNj5","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jMNjD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElCheckbox", ()=>ElCheckbox
);
parcelHelpers.export(exports, "ElCheckboxButton", ()=>ElCheckboxButton
);
parcelHelpers.export(exports, "ElCheckboxGroup", ()=>ElCheckboxGroup
);
parcelHelpers.export(exports, "default", ()=>ElCheckbox
);
var _indexMjs = require("../../utils/index.mjs");
var _checkboxMjs = require("./src/checkbox.mjs");
var _checkboxMjsDefault = parcelHelpers.interopDefault(_checkboxMjs);
var _checkboxButtonMjs = require("./src/checkbox-button.mjs");
var _checkboxButtonMjsDefault = parcelHelpers.interopDefault(_checkboxButtonMjs);
var _checkboxGroupMjs = require("./src/checkbox-group.mjs");
var _checkboxGroupMjsDefault = parcelHelpers.interopDefault(_checkboxGroupMjs);
var _installMjs = require("../../utils/vue/install.mjs");
const ElCheckbox = _installMjs.withInstall(_checkboxMjsDefault.default, {
    CheckboxButton: _checkboxButtonMjsDefault.default,
    CheckboxGroup: _checkboxGroupMjsDefault.default
});
const ElCheckboxButton = _installMjs.withNoopInstall(_checkboxButtonMjsDefault.default);
const ElCheckboxGroup = _installMjs.withNoopInstall(_checkboxGroupMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/checkbox.mjs":"7VyjD","./src/checkbox-button.mjs":"PWUil","./src/checkbox-group.mjs":"3ynGw","../../utils/vue/install.mjs":"4TMmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7VyjD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Checkbox
);
var _vue = require("vue");
var _indexMjs = require("../../../constants/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _useCheckboxMjs = require("./useCheckbox.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _validatorMjs = require("../../../utils/vue/validator.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElCheckbox",
    props: {
        modelValue: {
            type: [
                Boolean,
                Number,
                String
            ],
            default: ()=>void 0
        },
        label: {
            type: [
                String,
                Boolean,
                Number,
                Object
            ]
        },
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: {
            type: String,
            default: void 0
        },
        trueLabel: {
            type: [
                String,
                Number
            ],
            default: void 0
        },
        falseLabel: {
            type: [
                String,
                Number
            ],
            default: void 0
        },
        id: {
            type: String,
            default: void 0
        },
        controls: {
            type: String,
            default: void 0
        },
        border: Boolean,
        size: {
            type: String,
            validator: _validatorMjs.isValidComponentSize
        },
        tabindex: [
            String,
            Number
        ]
    },
    emits: [
        _eventMjs.UPDATE_MODEL_EVENT,
        "change"
    ],
    setup (props) {
        const ns = _indexMjs3.useNamespace("checkbox");
        return {
            ns,
            ..._useCheckboxMjs.useCheckbox(props)
        };
    }
});
const _hoisted_1 = [
    "id",
    "aria-controls"
];
const _hoisted_2 = [
    "tabindex",
    "role",
    "aria-checked"
];
const _hoisted_3 = [
    "aria-hidden",
    "name",
    "tabindex",
    "disabled",
    "true-value",
    "false-value"
];
const _hoisted_4 = [
    "aria-hidden",
    "disabled",
    "value",
    "name",
    "tabindex"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("label", {
        id: _ctx.id,
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.m(_ctx.checkboxSize),
            _ctx.ns.is("disabled", _ctx.isDisabled),
            _ctx.ns.is("bordered", _ctx.border),
            _ctx.ns.is("checked", _ctx.isChecked)
        ]),
        "aria-controls": _ctx.indeterminate ? _ctx.controls : null
    }, [
        _vue.createElementVNode("span", {
            class: _vue.normalizeClass([
                _ctx.ns.e("input"),
                _ctx.ns.is("disabled", _ctx.isDisabled),
                _ctx.ns.is("checked", _ctx.isChecked),
                _ctx.ns.is("indeterminate", _ctx.indeterminate),
                _ctx.ns.is("focus", _ctx.focus)
            ]),
            tabindex: _ctx.indeterminate ? 0 : void 0,
            role: _ctx.indeterminate ? "checkbox" : void 0,
            "aria-checked": _ctx.indeterminate ? "mixed" : false
        }, [
            _vue.createElementVNode("span", {
                class: _vue.normalizeClass(_ctx.ns.e("inner"))
            }, null, 2),
            _ctx.trueLabel || _ctx.falseLabel ? _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>_ctx.model = $event
                ),
                class: _vue.normalizeClass(_ctx.ns.e("original")),
                type: "checkbox",
                "aria-hidden": _ctx.indeterminate ? "true" : "false",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: _ctx.isDisabled,
                "true-value": _ctx.trueLabel,
                "false-value": _ctx.falseLabel,
                onChange: _cache[1] || (_cache[1] = (...args)=>_ctx.handleChange && _ctx.handleChange(...args)
                ),
                onFocus: _cache[2] || (_cache[2] = ($event)=>_ctx.focus = true
                ),
                onBlur: _cache[3] || (_cache[3] = ($event)=>_ctx.focus = false
                )
            }, null, 42, _hoisted_3)), [
                [
                    _vue.vModelCheckbox,
                    _ctx.model
                ]
            ]) : _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event)=>_ctx.model = $event
                ),
                class: _vue.normalizeClass(_ctx.ns.e("original")),
                type: "checkbox",
                "aria-hidden": _ctx.indeterminate ? "true" : "false",
                disabled: _ctx.isDisabled,
                value: _ctx.label,
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                onChange: _cache[5] || (_cache[5] = (...args)=>_ctx.handleChange && _ctx.handleChange(...args)
                ),
                onFocus: _cache[6] || (_cache[6] = ($event)=>_ctx.focus = true
                ),
                onBlur: _cache[7] || (_cache[7] = ($event)=>_ctx.focus = false
                )
            }, null, 42, _hoisted_4)), [
                [
                    _vue.vModelCheckbox,
                    _ctx.model
                ]
            ])
        ], 10, _hoisted_2),
        _ctx.$slots.default || _ctx.label ? (_vue.openBlock(), _vue.createElementBlock("span", {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.e("label"))
        }, [
            _vue.renderSlot(_ctx.$slots, "default"),
            !_ctx.$slots.default ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                key: 0
            }, [
                _vue.createTextVNode(_vue.toDisplayString(_ctx.label), 1)
            ], 2112)) : _vue.createCommentVNode("v-if", true)
        ], 2)) : _vue.createCommentVNode("v-if", true)
    ], 10, _hoisted_1);
}
var Checkbox = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../constants/index.mjs":"74Fbn","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./useCheckbox.mjs":"a9SlC","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/vue/validator.mjs":"4UnBa","../../../constants/event.mjs":"92xVn","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a9SlC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useCheckbox", ()=>useCheckbox
);
parcelHelpers.export(exports, "useCheckboxGroup", ()=>useCheckboxGroup
);
parcelHelpers.export(exports, "useCheckboxProps", ()=>useCheckboxProps
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _indexMjs = require("../../../constants/index.mjs");
var _indexMjs1 = require("../../../tokens/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _formMjs = require("../../../tokens/form.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs3 = require("../../../hooks/use-common-props/index.mjs");
const useCheckboxProps = {
    modelValue: {
        type: [
            Boolean,
            Number,
            String
        ],
        default: ()=>void 0
    },
    label: {
        type: [
            String,
            Boolean,
            Number,
            Object
        ]
    },
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: {
        type: String,
        default: void 0
    },
    trueLabel: {
        type: [
            String,
            Number
        ],
        default: void 0
    },
    falseLabel: {
        type: [
            String,
            Number
        ],
        default: void 0
    },
    tabindex: [
        String,
        Number
    ],
    size: String
};
const useCheckboxGroup = ()=>{
    const elForm = _vue.inject(_formMjs.elFormKey, {
    });
    const elFormItem = _vue.inject(_formMjs.elFormItemKey, {
    });
    const checkboxGroup = _vue.inject("CheckboxGroup", {
    });
    const isGroup = _vue.computed(()=>checkboxGroup && (checkboxGroup == null ? void 0 : checkboxGroup.name) === "ElCheckboxGroup"
    );
    const elFormItemSize = _vue.computed(()=>{
        return elFormItem.size;
    });
    return {
        isGroup,
        checkboxGroup,
        elForm,
        elFormItemSize,
        elFormItem
    };
};
const useModel = (props)=>{
    const selfModel = _vue.ref(false);
    const { emit  } = _vue.getCurrentInstance();
    const { isGroup , checkboxGroup  } = useCheckboxGroup();
    const isLimitExceeded = _vue.ref(false);
    const model = _vue.computed({
        get () {
            var _a, _b;
            return isGroup.value ? (_a = checkboxGroup.modelValue) == null ? void 0 : _a.value : (_b = props.modelValue) != null ? _b : selfModel.value;
        },
        set (val) {
            var _a;
            if (isGroup.value && Array.isArray(val)) {
                isLimitExceeded.value = checkboxGroup.max !== void 0 && val.length > checkboxGroup.max.value;
                isLimitExceeded.value === false && ((_a = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null || _a.call(checkboxGroup, val));
            } else {
                emit(_eventMjs.UPDATE_MODEL_EVENT, val);
                selfModel.value = val;
            }
        }
    });
    return {
        model,
        isLimitExceeded
    };
};
const useCheckboxStatus = (props, { model  })=>{
    const { isGroup , checkboxGroup  } = useCheckboxGroup();
    const focus = _vue.ref(false);
    const size = _indexMjs3.useSize(checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize, {
        prop: true
    });
    const isChecked = _vue.computed(()=>{
        const value = model.value;
        if (_shared.toTypeString(value) === "[object Boolean]") return value;
        else if (Array.isArray(value)) return value.includes(props.label);
        else if (value !== null && value !== void 0) return value === props.trueLabel;
        else return !!value;
    });
    const checkboxSize = _indexMjs3.useSize(_vue.computed(()=>{
        var _a;
        return isGroup.value ? (_a = checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize) == null ? void 0 : _a.value : void 0;
    }));
    return {
        isChecked,
        focus,
        size,
        checkboxSize
    };
};
const useDisabled = (props, { model , isChecked  })=>{
    const { elForm , isGroup , checkboxGroup  } = useCheckboxGroup();
    const isLimitDisabled = _vue.computed(()=>{
        var _a, _b;
        const max = (_a = checkboxGroup.max) == null ? void 0 : _a.value;
        const min = (_b = checkboxGroup.min) == null ? void 0 : _b.value;
        return !!(max || min) && model.value.length >= max && !isChecked.value || model.value.length <= min && isChecked.value;
    });
    const isDisabled = _vue.computed(()=>{
        var _a, _b;
        const disabled = props.disabled || elForm.disabled;
        return (_b = isGroup.value ? ((_a = checkboxGroup.disabled) == null ? void 0 : _a.value) || disabled || isLimitDisabled.value : props.disabled || elForm.disabled) != null ? _b : false;
    });
    return {
        isDisabled,
        isLimitDisabled
    };
};
const setStoreValue = (props, { model  })=>{
    function addToStore() {
        if (Array.isArray(model.value) && !model.value.includes(props.label)) model.value.push(props.label);
        else model.value = props.trueLabel || true;
    }
    props.checked && addToStore();
};
const useEvent = (props, { isLimitExceeded  })=>{
    const { elFormItem  } = useCheckboxGroup();
    const { emit  } = _vue.getCurrentInstance();
    function handleChange(e) {
        var _a, _b;
        if (isLimitExceeded.value) return;
        const target = e.target;
        const value = target.checked ? (_a = props.trueLabel) != null ? _a : true : (_b = props.falseLabel) != null ? _b : false;
        emit("change", value, e);
    }
    _vue.watch(()=>props.modelValue
    , ()=>{
        var _a;
        (_a = elFormItem.validate) == null || _a.call(elFormItem, "change");
    });
    return {
        handleChange
    };
};
const useCheckbox = (props)=>{
    const { model , isLimitExceeded  } = useModel(props);
    const { focus , size , isChecked , checkboxSize  } = useCheckboxStatus(props, {
        model
    });
    const { isDisabled  } = useDisabled(props, {
        model,
        isChecked
    });
    const { handleChange  } = useEvent(props, {
        isLimitExceeded
    });
    setStoreValue(props, {
        model
    });
    return {
        isChecked,
        isDisabled,
        checkboxSize,
        model,
        handleChange,
        focus,
        size
    };
};

},{"vue":"gzxs9","@vue/shared":"3SM3y","../../../constants/index.mjs":"74Fbn","../../../tokens/index.mjs":"wVNQi","../../../hooks/index.mjs":"1Ansp","../../../tokens/form.mjs":"2r4O0","../../../constants/event.mjs":"92xVn","../../../hooks/use-common-props/index.mjs":"05czU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"PWUil":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CheckboxButton
);
var _vue = require("vue");
var _indexMjs = require("../../../constants/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _useCheckboxMjs = require("./useCheckbox.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElCheckboxButton",
    props: _useCheckboxMjs.useCheckboxProps,
    emits: [
        _eventMjs.UPDATE_MODEL_EVENT,
        "change"
    ],
    setup (props) {
        const { focus , isChecked , isDisabled , size , model , handleChange  } = _useCheckboxMjs.useCheckbox(props);
        const { checkboxGroup  } = _useCheckboxMjs.useCheckboxGroup();
        const ns = _indexMjs2.useNamespace("checkbox");
        const activeStyle = _vue.computed(()=>{
            var _a, _b, _c, _d;
            const fillValue = (_b = (_a = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a.value) != null ? _b : "";
            return {
                backgroundColor: fillValue,
                borderColor: fillValue,
                color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
                boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : null
            };
        });
        return {
            focus,
            isChecked,
            isDisabled,
            model,
            handleChange,
            activeStyle,
            size,
            ns
        };
    }
});
const _hoisted_1 = [
    "aria-checked",
    "aria-disabled"
];
const _hoisted_2 = [
    "name",
    "tabindex",
    "disabled",
    "true-value",
    "false-value"
];
const _hoisted_3 = [
    "name",
    "tabindex",
    "disabled",
    "value"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("label", {
        class: _vue.normalizeClass([
            _ctx.ns.b("button"),
            _ctx.ns.bm("button", _ctx.size),
            _ctx.ns.is("disabled", _ctx.isDisabled),
            _ctx.ns.is("checked", _ctx.isChecked),
            _ctx.ns.is("focus", _ctx.focus)
        ]),
        role: "checkbox",
        "aria-checked": _ctx.isChecked,
        "aria-disabled": _ctx.isDisabled
    }, [
        _ctx.trueLabel || _ctx.falseLabel ? _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("input", {
            key: 0,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>_ctx.model = $event
            ),
            class: _vue.normalizeClass(_ctx.ns.be("button", "original")),
            type: "checkbox",
            name: _ctx.name,
            tabindex: _ctx.tabindex,
            disabled: _ctx.isDisabled,
            "true-value": _ctx.trueLabel,
            "false-value": _ctx.falseLabel,
            onChange: _cache[1] || (_cache[1] = (...args)=>_ctx.handleChange && _ctx.handleChange(...args)
            ),
            onFocus: _cache[2] || (_cache[2] = ($event)=>_ctx.focus = true
            ),
            onBlur: _cache[3] || (_cache[3] = ($event)=>_ctx.focus = false
            )
        }, null, 42, _hoisted_2)), [
            [
                _vue.vModelCheckbox,
                _ctx.model
            ]
        ]) : _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("input", {
            key: 1,
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event)=>_ctx.model = $event
            ),
            class: _vue.normalizeClass(_ctx.ns.be("button", "original")),
            type: "checkbox",
            name: _ctx.name,
            tabindex: _ctx.tabindex,
            disabled: _ctx.isDisabled,
            value: _ctx.label,
            onChange: _cache[5] || (_cache[5] = (...args)=>_ctx.handleChange && _ctx.handleChange(...args)
            ),
            onFocus: _cache[6] || (_cache[6] = ($event)=>_ctx.focus = true
            ),
            onBlur: _cache[7] || (_cache[7] = ($event)=>_ctx.focus = false
            )
        }, null, 42, _hoisted_3)), [
            [
                _vue.vModelCheckbox,
                _ctx.model
            ]
        ]),
        _ctx.$slots.default || _ctx.label ? (_vue.openBlock(), _vue.createElementBlock("span", {
            key: 2,
            class: _vue.normalizeClass(_ctx.ns.be("button", "inner")),
            style: _vue.normalizeStyle(_ctx.isChecked ? _ctx.activeStyle : null)
        }, [
            _vue.renderSlot(_ctx.$slots, "default", {
            }, ()=>[
                    _vue.createTextVNode(_vue.toDisplayString(_ctx.label), 1)
                ]
            )
        ], 6)) : _vue.createCommentVNode("v-if", true)
    ], 10, _hoisted_1);
}
var CheckboxButton = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../constants/index.mjs":"74Fbn","../../../hooks/index.mjs":"1Ansp","./useCheckbox.mjs":"a9SlC","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../constants/event.mjs":"92xVn","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ynGw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_sfc_main
);
var _vue = require("vue");
var _indexMjs = require("../../../constants/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _useCheckboxMjs = require("./useCheckbox.mjs");
var _validatorMjs = require("../../../utils/vue/validator.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs3 = require("../../../hooks/use-common-props/index.mjs");
var _indexMjs4 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElCheckboxGroup",
    props: {
        modelValue: {
            type: Array,
            default: ()=>[]
        },
        disabled: Boolean,
        min: {
            type: Number,
            default: void 0
        },
        max: {
            type: Number,
            default: void 0
        },
        size: {
            type: String,
            validator: _validatorMjs.isValidComponentSize
        },
        fill: {
            type: String,
            default: void 0
        },
        textColor: {
            type: String,
            default: void 0
        },
        tag: {
            type: String,
            default: "div"
        }
    },
    emits: [
        _eventMjs.UPDATE_MODEL_EVENT,
        "change"
    ],
    setup (props, { emit , slots  }) {
        const { elFormItem  } = _useCheckboxMjs.useCheckboxGroup();
        const checkboxGroupSize = _indexMjs3.useSize();
        const ns = _indexMjs4.useNamespace("checkbox");
        const changeEvent = (value)=>{
            emit(_eventMjs.UPDATE_MODEL_EVENT, value);
            _vue.nextTick(()=>{
                emit("change", value);
            });
        };
        const modelValue = _vue.computed({
            get () {
                return props.modelValue;
            },
            set (val) {
                changeEvent(val);
            }
        });
        _vue.provide("CheckboxGroup", {
            name: "ElCheckboxGroup",
            modelValue,
            ..._vue.toRefs(props),
            checkboxGroupSize,
            changeEvent
        });
        _vue.watch(()=>props.modelValue
        , ()=>{
            var _a;
            (_a = elFormItem.validate) == null || _a.call(elFormItem, "change");
        });
        return ()=>{
            return _vue.h(props.tag, {
                class: ns.b("group"),
                role: "group",
                "aria-label": "checkbox-group"
            }, [
                _vue.renderSlot(slots, "default")
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../constants/index.mjs":"74Fbn","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./useCheckbox.mjs":"a9SlC","../../../utils/vue/validator.mjs":"4UnBa","../../../constants/event.mjs":"92xVn","../../../hooks/use-common-props/index.mjs":"05czU","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fekfn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "radioEmits", ()=>_radioMjs.radioEmits
);
parcelHelpers.export(exports, "radioProps", ()=>_radioMjs.radioProps
);
parcelHelpers.export(exports, "radioPropsBase", ()=>_radioMjs.radioPropsBase
);
parcelHelpers.export(exports, "useRadio", ()=>_radioMjs.useRadio
);
parcelHelpers.export(exports, "radioGroupEmits", ()=>_radioGroupMjs.radioGroupEmits
);
parcelHelpers.export(exports, "radioGroupProps", ()=>_radioGroupMjs.radioGroupProps
);
parcelHelpers.export(exports, "radioButtonProps", ()=>_radioButtonMjs.radioButtonProps
);
parcelHelpers.export(exports, "ElRadio", ()=>ElRadio
);
parcelHelpers.export(exports, "ElRadioButton", ()=>ElRadioButton
);
parcelHelpers.export(exports, "ElRadioGroup", ()=>ElRadioGroup
);
parcelHelpers.export(exports, "default", ()=>ElRadio
);
var _indexMjs = require("../../utils/index.mjs");
var _radio2Mjs = require("./src/radio2.mjs");
var _radio2MjsDefault = parcelHelpers.interopDefault(_radio2Mjs);
var _radioButton2Mjs = require("./src/radio-button2.mjs");
var _radioButton2MjsDefault = parcelHelpers.interopDefault(_radioButton2Mjs);
var _radioGroup2Mjs = require("./src/radio-group2.mjs");
var _radioGroup2MjsDefault = parcelHelpers.interopDefault(_radioGroup2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _radioMjs = require("./src/radio.mjs");
var _radioGroupMjs = require("./src/radio-group.mjs");
var _radioButtonMjs = require("./src/radio-button.mjs");
const ElRadio = _installMjs.withInstall(_radio2MjsDefault.default, {
    RadioButton: _radioButton2MjsDefault.default,
    RadioGroup: _radioGroup2MjsDefault.default
});
const ElRadioGroup = _installMjs.withNoopInstall(_radioGroup2MjsDefault.default);
const ElRadioButton = _installMjs.withNoopInstall(_radioButton2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/radio2.mjs":"1yDt3","./src/radio-button2.mjs":"8MQ5U","./src/radio-group2.mjs":"65IsY","../../utils/vue/install.mjs":"4TMmv","./src/radio.mjs":"gDfxw","./src/radio-group.mjs":"ifp6r","./src/radio-button.mjs":"eTDbS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1yDt3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Radio
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _radioMjs = require("./radio.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElRadio",
    props: _radioMjs.radioProps,
    emits: _radioMjs.radioEmits,
    setup (props, { emit  }) {
        const ns = _indexMjs1.useNamespace("radio");
        const { radioRef , isGroup , focus , size , disabled , tabIndex , modelValue  } = _radioMjs.useRadio(props, emit);
        function handleChange() {
            _vue.nextTick(()=>emit("change", modelValue.value)
            );
        }
        return {
            ns,
            focus,
            isGroup,
            modelValue,
            tabIndex,
            size,
            disabled,
            radioRef,
            handleChange
        };
    }
});
const _hoisted_1 = [
    "aria-checked",
    "aria-disabled",
    "tabindex"
];
const _hoisted_2 = [
    "value",
    "name",
    "disabled"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("label", {
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.is("disabled", _ctx.disabled),
            _ctx.ns.is("focus", _ctx.focus),
            _ctx.ns.is("bordered", _ctx.border),
            _ctx.ns.is("checked", _ctx.modelValue === _ctx.label),
            _ctx.ns.m(_ctx.size)
        ]),
        role: "radio",
        "aria-checked": _ctx.modelValue === _ctx.label,
        "aria-disabled": _ctx.disabled,
        tabindex: _ctx.tabIndex,
        onKeydown: _cache[5] || (_cache[5] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.modelValue = _ctx.disabled ? _ctx.modelValue : _ctx.label
        , [
            "stop",
            "prevent"
        ]), [
            "space"
        ]))
    }, [
        _vue.createElementVNode("span", {
            class: _vue.normalizeClass([
                _ctx.ns.e("input"),
                _ctx.ns.is("disabled", _ctx.disabled),
                _ctx.ns.is("checked", _ctx.modelValue === _ctx.label)
            ])
        }, [
            _vue.createElementVNode("span", {
                class: _vue.normalizeClass(_ctx.ns.e("inner"))
            }, null, 2),
            _vue.withDirectives(_vue.createElementVNode("input", {
                ref: "radioRef",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>_ctx.modelValue = $event
                ),
                class: _vue.normalizeClass(_ctx.ns.e("original")),
                value: _ctx.label,
                type: "radio",
                "aria-hidden": "true",
                name: _ctx.name,
                disabled: _ctx.disabled,
                tabindex: "-1",
                onFocus: _cache[1] || (_cache[1] = ($event)=>_ctx.focus = true
                ),
                onBlur: _cache[2] || (_cache[2] = ($event)=>_ctx.focus = false
                ),
                onChange: _cache[3] || (_cache[3] = (...args)=>_ctx.handleChange && _ctx.handleChange(...args)
                )
            }, null, 42, _hoisted_2), [
                [
                    _vue.vModelRadio,
                    _ctx.modelValue
                ]
            ])
        ], 2),
        _vue.createElementVNode("span", {
            class: _vue.normalizeClass(_ctx.ns.e("label")),
            onKeydown: _cache[4] || (_cache[4] = _vue.withModifiers(()=>{
            }, [
                "stop"
            ]))
        }, [
            _vue.renderSlot(_ctx.$slots, "default", {
            }, ()=>[
                    _vue.createTextVNode(_vue.toDisplayString(_ctx.label), 1)
                ]
            )
        ], 34)
    ], 42, _hoisted_1);
}
var Radio = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./radio.mjs":"gDfxw","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gDfxw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "radioEmits", ()=>radioEmits
);
parcelHelpers.export(exports, "radioProps", ()=>radioProps
);
parcelHelpers.export(exports, "radioPropsBase", ()=>radioPropsBase
);
parcelHelpers.export(exports, "useRadio", ()=>useRadio
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../../tokens/index.mjs");
var _indexMjs3 = require("../../../hooks/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _indexMjs4 = require("../../../hooks/use-common-props/index.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _shared = require("@vue/shared");
var _core = require("@vueuse/core");
var _radioMjs = require("../../../tokens/radio.mjs");
const radioPropsBase = _propsMjs.buildProps({
    size: _indexMjs4.useSizeProp,
    disabled: Boolean,
    label: {
        type: [
            String,
            Number,
            Boolean
        ],
        default: ""
    }
});
const radioProps = _propsMjs.buildProps({
    ...radioPropsBase,
    modelValue: {
        type: [
            String,
            Number,
            Boolean
        ],
        default: ""
    },
    name: {
        type: String,
        default: ""
    },
    border: Boolean
});
const radioEmits = {
    [_eventMjs.UPDATE_MODEL_EVENT]: (val)=>_shared.isString(val) || _core.isNumber(val) || _core.isBoolean(val)
    ,
    change: (val)=>_shared.isString(val) || _core.isNumber(val) || _core.isBoolean(val)
};
const useRadio = (props, emit)=>{
    const radioRef = _vue.ref();
    const radioGroup = _vue.inject(_radioMjs.radioGroupKey, void 0);
    const isGroup = _vue.computed(()=>!!radioGroup
    );
    const modelValue = _vue.computed({
        get () {
            return isGroup.value ? radioGroup.modelValue : props.modelValue;
        },
        set (val) {
            if (isGroup.value) radioGroup.changeEvent(val);
            else emit(_eventMjs.UPDATE_MODEL_EVENT, val);
            radioRef.value.checked = props.modelValue === props.label;
        }
    });
    const size = _indexMjs4.useSize(_vue.computed(()=>radioGroup == null ? void 0 : radioGroup.size
    ));
    const disabled = _indexMjs4.useDisabled(_vue.computed(()=>radioGroup == null ? void 0 : radioGroup.disabled
    ));
    const focus = _vue.ref(false);
    const tabIndex = _vue.computed(()=>{
        return disabled.value || isGroup.value && modelValue.value !== props.label ? -1 : 0;
    });
    return {
        radioRef,
        isGroup,
        radioGroup,
        focus,
        size,
        disabled,
        tabIndex,
        modelValue
    };
};

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../../tokens/index.mjs":"wVNQi","../../../hooks/index.mjs":"1Ansp","../../../utils/vue/props.mjs":"cpwWK","../../../hooks/use-common-props/index.mjs":"05czU","../../../constants/event.mjs":"92xVn","@vue/shared":"3SM3y","@vueuse/core":"eEHP9","../../../tokens/radio.mjs":"3tXVv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8MQ5U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>RadioButton
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _radioMjs = require("./radio.mjs");
var _radioButtonMjs = require("./radio-button.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElRadioButton",
    props: _radioButtonMjs.radioButtonProps,
    setup (props, { emit  }) {
        const ns = _indexMjs1.useNamespace("radio");
        const { radioRef , isGroup , focus , size , disabled , tabIndex , modelValue , radioGroup  } = _radioMjs.useRadio(props, emit);
        const activeStyle = _vue.computed(()=>{
            return {
                backgroundColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
                borderColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
                boxShadow: (radioGroup == null ? void 0 : radioGroup.fill) ? `-1px 0 0 0 ${radioGroup.fill}` : "",
                color: (radioGroup == null ? void 0 : radioGroup.textColor) || ""
            };
        });
        return {
            ns,
            isGroup,
            size,
            disabled,
            tabIndex,
            modelValue,
            focus,
            activeStyle,
            radioRef
        };
    }
});
const _hoisted_1 = [
    "aria-checked",
    "aria-disabled",
    "tabindex"
];
const _hoisted_2 = [
    "value",
    "name",
    "disabled"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("label", {
        class: _vue.normalizeClass([
            _ctx.ns.b("button"),
            _ctx.ns.is("active", _ctx.modelValue === _ctx.label),
            _ctx.ns.is("disabled", _ctx.disabled),
            _ctx.ns.is("focus", _ctx.focus),
            _ctx.ns.bm("button", _ctx.size)
        ]),
        role: "radio",
        "aria-checked": _ctx.modelValue === _ctx.label,
        "aria-disabled": _ctx.disabled,
        tabindex: _ctx.tabIndex,
        onKeydown: _cache[4] || (_cache[4] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.modelValue = _ctx.disabled ? _ctx.modelValue : _ctx.label
        , [
            "stop",
            "prevent"
        ]), [
            "space"
        ]))
    }, [
        _vue.withDirectives(_vue.createElementVNode("input", {
            ref: "radioRef",
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>_ctx.modelValue = $event
            ),
            class: _vue.normalizeClass(_ctx.ns.be("button", "original-radio")),
            value: _ctx.label,
            type: "radio",
            name: _ctx.name,
            disabled: _ctx.disabled,
            tabindex: "-1",
            onFocus: _cache[1] || (_cache[1] = ($event)=>_ctx.focus = true
            ),
            onBlur: _cache[2] || (_cache[2] = ($event)=>_ctx.focus = false
            )
        }, null, 42, _hoisted_2), [
            [
                _vue.vModelRadio,
                _ctx.modelValue
            ]
        ]),
        _vue.createElementVNode("span", {
            class: _vue.normalizeClass(_ctx.ns.be("button", "inner")),
            style: _vue.normalizeStyle(_ctx.modelValue === _ctx.label ? _ctx.activeStyle : {
            }),
            onKeydown: _cache[3] || (_cache[3] = _vue.withModifiers(()=>{
            }, [
                "stop"
            ]))
        }, [
            _vue.renderSlot(_ctx.$slots, "default", {
            }, ()=>[
                    _vue.createTextVNode(_vue.toDisplayString(_ctx.label), 1)
                ]
            )
        ], 38)
    ], 42, _hoisted_1);
}
var RadioButton = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./radio.mjs":"gDfxw","./radio-button.mjs":"eTDbS","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eTDbS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "radioButtonProps", ()=>radioButtonProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _radioMjs = require("./radio.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const radioButtonProps = _propsMjs.buildProps({
    ..._radioMjs.radioPropsBase,
    name: {
        type: String,
        default: ""
    }
});

},{"../../../utils/index.mjs":"dsdeP","./radio.mjs":"gDfxw","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"65IsY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>RadioGroup
);
var _vue = require("vue");
var _indexMjs = require("../../../constants/index.mjs");
var _indexMjs1 = require("../../../tokens/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _radioGroupMjs = require("./radio-group.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
var _indexMjs4 = require("../../../hooks/use-form-item/index.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
var _radioMjs = require("../../../tokens/radio.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElRadioGroup",
    props: _radioGroupMjs.radioGroupProps,
    emits: _radioGroupMjs.radioGroupEmits,
    setup (props, ctx) {
        const ns = _indexMjs3.useNamespace("radio");
        const radioGroupRef = _vue.ref();
        const { formItem  } = _indexMjs4.useFormItem();
        const changeEvent = (value)=>{
            ctx.emit(_eventMjs.UPDATE_MODEL_EVENT, value);
            _vue.nextTick(()=>ctx.emit("change", value)
            );
        };
        const handleKeydown = (e)=>{
            if (!radioGroupRef.value) return;
            const target = e.target;
            const className = target.nodeName === "INPUT" ? "[type=radio]" : "[role=radio]";
            const radios = radioGroupRef.value.querySelectorAll(className);
            const length = radios.length;
            const index = Array.from(radios).indexOf(target);
            const roleRadios = radioGroupRef.value.querySelectorAll("[role=radio]");
            let nextIndex = null;
            switch(e.code){
                case _ariaMjs.EVENT_CODE.left:
                case _ariaMjs.EVENT_CODE.up:
                    e.stopPropagation();
                    e.preventDefault();
                    nextIndex = index === 0 ? length - 1 : index - 1;
                    break;
                case _ariaMjs.EVENT_CODE.right:
                case _ariaMjs.EVENT_CODE.down:
                    e.stopPropagation();
                    e.preventDefault();
                    nextIndex = index === length - 1 ? 0 : index + 1;
                    break;
                default:
                    break;
            }
            if (nextIndex === null) return;
            roleRadios[nextIndex].click();
            roleRadios[nextIndex].focus();
        };
        _vue.onMounted(()=>{
            const radios = radioGroupRef.value.querySelectorAll("[type=radio]");
            const firstLabel = radios[0];
            if (!Array.from(radios).some((radio)=>radio.checked
            ) && firstLabel) firstLabel.tabIndex = 0;
        });
        _vue.provide(_radioMjs.radioGroupKey, _vue.reactive({
            ..._vue.toRefs(props),
            changeEvent
        }));
        _vue.watch(()=>props.modelValue
        , ()=>formItem == null ? void 0 : formItem.validate("change")
        );
        return {
            ns,
            radioGroupRef,
            handleKeydown
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "radioGroupRef",
        class: _vue.normalizeClass(_ctx.ns.b("group")),
        role: "radiogroup",
        onKeydown: _cache[0] || (_cache[0] = (...args)=>_ctx.handleKeydown && _ctx.handleKeydown(...args)
        )
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 34);
}
var RadioGroup = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../constants/index.mjs":"74Fbn","../../../tokens/index.mjs":"wVNQi","../../../hooks/index.mjs":"1Ansp","./radio-group.mjs":"ifp6r","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../hooks/use-form-item/index.mjs":"jSs21","../../../constants/event.mjs":"92xVn","../../../constants/aria.mjs":"jS6iK","../../../tokens/radio.mjs":"3tXVv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ifp6r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "radioGroupEmits", ()=>radioGroupEmits
);
parcelHelpers.export(exports, "radioGroupProps", ()=>radioGroupProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _radioMjs = require("./radio.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _indexMjs2 = require("../../../hooks/use-common-props/index.mjs");
const radioGroupProps = _propsMjs.buildProps({
    size: _indexMjs2.useSizeProp,
    disabled: Boolean,
    modelValue: {
        type: [
            String,
            Number,
            Boolean
        ],
        default: ""
    },
    fill: {
        type: String,
        default: ""
    },
    textColor: {
        type: String,
        default: ""
    }
});
const radioGroupEmits = _radioMjs.radioEmits;

},{"../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./radio.mjs":"gDfxw","../../../utils/vue/props.mjs":"cpwWK","../../../hooks/use-common-props/index.mjs":"05czU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5ZCy1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>NodeContent
);
var _vue = require("vue");
var NodeContent = _vue.defineComponent({
    name: "NodeContent",
    render () {
        const { node , panel  } = this.$parent;
        const { data , label  } = node;
        const { renderLabelFn  } = panel;
        return _vue.h("span", {
            class: "el-cascader-node__label"
        }, renderLabelFn ? renderLabelFn({
            node,
            data
        }) : label);
    }
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5MNj5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CASCADER_PANEL_INJECTION_KEY", ()=>CASCADER_PANEL_INJECTION_KEY
);
parcelHelpers.export(exports, "ExpandTrigger", ()=>ExpandTrigger
);
var ExpandTrigger = /* @__PURE__ */ ((ExpandTrigger2)=>{
    ExpandTrigger2["CLICK"] = "click";
    ExpandTrigger2["HOVER"] = "hover";
    return ExpandTrigger2;
})(ExpandTrigger || {
});
const CASCADER_PANEL_INJECTION_KEY = Symbol();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7limu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Store
);
var _lodashUnified = require("lodash-unified");
var _nodeMjs = require("./node.mjs");
var _nodeMjsDefault = parcelHelpers.interopDefault(_nodeMjs);
const flatNodes = (nodes, leafOnly)=>{
    return nodes.reduce((res, node)=>{
        if (node.isLeaf) res.push(node);
        else {
            !leafOnly && res.push(node);
            res = res.concat(flatNodes(node.children, leafOnly));
        }
        return res;
    }, []);
};
class Store {
    constructor(data, config){
        this.config = config;
        const nodes = (data || []).map((nodeData)=>new _nodeMjsDefault.default(nodeData, this.config)
        );
        this.nodes = nodes;
        this.allNodes = flatNodes(nodes, false);
        this.leafNodes = flatNodes(nodes, true);
    }
    getNodes() {
        return this.nodes;
    }
    getFlattedNodes(leafOnly) {
        return leafOnly ? this.leafNodes : this.allNodes;
    }
    appendNode(nodeData, parentNode) {
        const node = parentNode ? parentNode.appendChild(nodeData) : new _nodeMjsDefault.default(nodeData, this.config);
        if (!parentNode) this.nodes.push(node);
        this.allNodes.push(node);
        node.isLeaf && this.leafNodes.push(node);
    }
    appendNodes(nodeDataList, parentNode) {
        nodeDataList.forEach((nodeData)=>this.appendNode(nodeData, parentNode)
        );
    }
    getNodeByValue(value, leafOnly = false) {
        if (!value && value !== 0) return null;
        const nodes = this.getFlattedNodes(leafOnly).filter((node)=>_lodashUnified.isEqual(node.value, value) || _lodashUnified.isEqual(node.pathValues, value)
        );
        return nodes[0] || null;
    }
    getSameNode(node) {
        if (!node) return null;
        const nodes = this.getFlattedNodes(false).filter(({ value , level  })=>_lodashUnified.isEqual(node.value, value) && node.level === level
        );
        return nodes[0] || null;
    }
}

},{"lodash-unified":"4Oj4p","./node.mjs":"2209H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2209H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExpandTrigger", ()=>ExpandTrigger
);
parcelHelpers.export(exports, "default", ()=>Node
);
var _shared = require("@vue/shared");
var _indexMjs = require("../../../utils/index.mjs");
var _typesMjs = require("../../../utils/types.mjs");
var ExpandTrigger = /* @__PURE__ */ ((ExpandTrigger2)=>{
    ExpandTrigger2["CLICK"] = "click";
    ExpandTrigger2["HOVER"] = "hover";
    return ExpandTrigger2;
})(ExpandTrigger || {
});
let uid = 0;
const calculatePathNodes = (node)=>{
    const nodes = [
        node
    ];
    let { parent  } = node;
    while(parent){
        nodes.unshift(parent);
        parent = parent.parent;
    }
    return nodes;
};
class Node {
    constructor(data, config, parent, root = false){
        this.data = data;
        this.config = config;
        this.parent = parent;
        this.root = root;
        this.uid = uid++;
        this.checked = false;
        this.indeterminate = false;
        this.loading = false;
        const { value: valueKey , label: labelKey , children: childrenKey  } = config;
        const childrenData = data[childrenKey];
        const pathNodes = calculatePathNodes(this);
        this.level = root ? 0 : parent ? parent.level + 1 : 1;
        this.value = data[valueKey];
        this.label = data[labelKey];
        this.pathNodes = pathNodes;
        this.pathValues = pathNodes.map((node)=>node.value
        );
        this.pathLabels = pathNodes.map((node)=>node.label
        );
        this.childrenData = childrenData;
        this.children = (childrenData || []).map((child)=>new Node(child, config, this)
        );
        this.loaded = !config.lazy || this.isLeaf || !_typesMjs.isEmpty(childrenData);
    }
    get isDisabled() {
        const { data , parent , config  } = this;
        const { disabled , checkStrictly  } = config;
        const isDisabled = _shared.isFunction(disabled) ? disabled(data, this) : !!data[disabled];
        return isDisabled || !checkStrictly && (parent == null ? void 0 : parent.isDisabled);
    }
    get isLeaf() {
        const { data , config , childrenData , loaded  } = this;
        const { lazy , leaf  } = config;
        const isLeaf = _shared.isFunction(leaf) ? leaf(data, this) : data[leaf];
        return _typesMjs.isUndefined(isLeaf) ? lazy && !loaded ? false : !(Array.isArray(childrenData) && childrenData.length) : !!isLeaf;
    }
    get valueByOption() {
        return this.config.emitPath ? this.pathValues : this.value;
    }
    appendChild(childData) {
        const { childrenData , children  } = this;
        const node = new Node(childData, this.config, this);
        if (Array.isArray(childrenData)) childrenData.push(childData);
        else this.childrenData = [
            childData
        ];
        children.push(node);
        return node;
    }
    calcText(allLevels, separator) {
        const text = allLevels ? this.pathLabels.join(separator) : this.label;
        this.text = text;
        return text;
    }
    broadcast(event, ...args) {
        const handlerName = `onParent${_shared.capitalize(event)}`;
        this.children.forEach((child)=>{
            if (child) {
                child.broadcast(event, ...args);
                child[handlerName] && child[handlerName](...args);
            }
        });
    }
    emit(event, ...args) {
        const { parent  } = this;
        const handlerName = `onChild${_shared.capitalize(event)}`;
        if (parent) {
            parent[handlerName] && parent[handlerName](...args);
            parent.emit(event, ...args);
        }
    }
    onParentCheck(checked) {
        if (!this.isDisabled) this.setCheckState(checked);
    }
    onChildCheck() {
        const { children  } = this;
        const validChildren = children.filter((child)=>!child.isDisabled
        );
        const checked = validChildren.length ? validChildren.every((child)=>child.checked
        ) : false;
        this.setCheckState(checked);
    }
    setCheckState(checked) {
        const totalNum = this.children.length;
        const checkedNum = this.children.reduce((c, p)=>{
            const num = p.checked ? 1 : p.indeterminate ? 0.5 : 0;
            return c + num;
        }, 0);
        this.checked = this.loaded && this.children.every((child)=>child.loaded && child.checked
        ) && checked;
        this.indeterminate = this.loaded && checkedNum !== totalNum && checkedNum > 0;
    }
    doCheck(checked) {
        if (this.checked === checked) return;
        const { checkStrictly , multiple  } = this.config;
        if (checkStrictly || !multiple) this.checked = checked;
        else {
            this.broadcast("check", checked);
            this.setCheckState(checked);
            this.emit("check");
        }
    }
}

},{"@vue/shared":"3SM3y","../../../utils/index.mjs":"dsdeP","../../../utils/types.mjs":"4VsDK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8uFuI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CommonProps", ()=>CommonProps
);
parcelHelpers.export(exports, "DefaultProps", ()=>DefaultProps
);
parcelHelpers.export(exports, "useCascaderConfig", ()=>useCascaderConfig
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _nodeMjs = require("./node.mjs");
const CommonProps = {
    modelValue: [
        Number,
        String,
        Array
    ],
    options: {
        type: Array,
        default: ()=>[]
    },
    props: {
        type: Object,
        default: ()=>({
            })
    }
};
const DefaultProps = {
    expandTrigger: _nodeMjs.ExpandTrigger.CLICK,
    multiple: false,
    checkStrictly: false,
    emitPath: true,
    lazy: false,
    lazyLoad: _shared.NOOP,
    value: "value",
    label: "label",
    children: "children",
    leaf: "leaf",
    disabled: "disabled",
    hoverThreshold: 500
};
const useCascaderConfig = (props)=>{
    return _vue.computed(()=>({
            ...DefaultProps,
            ...props.props
        })
    );
};

},{"vue":"gzxs9","@vue/shared":"3SM3y","./node.mjs":"2209H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6j1MX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checkNode", ()=>checkNode
);
parcelHelpers.export(exports, "getMenuIndex", ()=>getMenuIndex
);
parcelHelpers.export(exports, "sortByOriginalOrder", ()=>sortByOriginalOrder
);
var _indexMjs = require("../../../utils/index.mjs");
var _ariaMjs = require("../../../utils/dom/aria.mjs");
const getMenuIndex = (el)=>{
    if (!el) return 0;
    const pieces = el.id.split("-");
    return Number(pieces[pieces.length - 2]);
};
const checkNode = (el)=>{
    if (!el) return;
    const input = el.querySelector("input");
    if (input) input.click();
    else if (_ariaMjs.isLeaf(el)) el.click();
};
const sortByOriginalOrder = (oldNodes, newNodes)=>{
    const newNodesCopy = newNodes.slice(0);
    const newIds = newNodesCopy.map((node)=>node.uid
    );
    const res = oldNodes.reduce((acc, item)=>{
        const index = newIds.indexOf(item.uid);
        if (index > -1) {
            acc.push(item);
            newNodesCopy.splice(index, 1);
            newIds.splice(index, 1);
        }
        return acc;
    }, []);
    res.push(...newNodesCopy);
    return res;
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/dom/aria.mjs":"6roYP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"96fQG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tagEmits", ()=>_tagMjs.tagEmits
);
parcelHelpers.export(exports, "tagProps", ()=>_tagMjs.tagProps
);
parcelHelpers.export(exports, "ElTag", ()=>ElTag
);
parcelHelpers.export(exports, "default", ()=>ElTag
);
var _indexMjs = require("../../utils/index.mjs");
var _tag2Mjs = require("./src/tag2.mjs");
var _tag2MjsDefault = parcelHelpers.interopDefault(_tag2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _tagMjs = require("./src/tag.mjs");
const ElTag = _installMjs.withInstall(_tag2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/tag2.mjs":"57TL2","../../utils/vue/install.mjs":"4TMmv","./src/tag.mjs":"i4Ov7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"57TL2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Tag
);
var _vue = require("vue");
var _indexMjs = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _tagMjs = require("./tag.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../hooks/use-common-props/index.mjs");
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElTag",
    components: {
        ElIcon: _indexMjs.ElIcon,
        Close: _iconsVue.Close
    },
    props: _tagMjs.tagProps,
    emits: _tagMjs.tagEmits,
    setup (props, { emit  }) {
        const tagSize = _indexMjs2.useSize();
        const ns = _indexMjs3.useNamespace("tag");
        const classes = _vue.computed(()=>{
            const { type , hit , effect , closable  } = props;
            return [
                ns.b(),
                ns.is("closable", closable),
                ns.m(type),
                ns.m(tagSize.value),
                ns.m(effect),
                ns.is("hit", hit)
            ];
        });
        const handleClose = (event)=>{
            event.stopPropagation();
            emit("close", event);
        };
        const handleClick = (event)=>{
            emit("click", event);
        };
        return {
            ns,
            classes,
            handleClose,
            handleClick
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_close = _vue.resolveComponent("close");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    return !_ctx.disableTransitions ? (_vue.openBlock(), _vue.createElementBlock("span", {
        key: 0,
        class: _vue.normalizeClass(_ctx.classes),
        style: _vue.normalizeStyle({
            backgroundColor: _ctx.color
        }),
        onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleClick && _ctx.handleClick(...args)
        )
    }, [
        _vue.createElementVNode("span", {
            class: _vue.normalizeClass(_ctx.ns.e("content"))
        }, [
            _vue.renderSlot(_ctx.$slots, "default")
        ], 2),
        _ctx.closable ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.e("close")),
            onClick: _ctx.handleClose
        }, {
            default: _vue.withCtx(()=>[
                    _vue.createVNode(_component_close)
                ]
            ),
            _: 1
        }, 8, [
            "class",
            "onClick"
        ])) : _vue.createCommentVNode("v-if", true)
    ], 6)) : (_vue.openBlock(), _vue.createBlock(_vue.Transition, {
        key: 1,
        name: `${_ctx.ns.namespace.value}-zoom-in-center`
    }, {
        default: _vue.withCtx(()=>[
                _vue.createElementVNode("span", {
                    class: _vue.normalizeClass(_ctx.classes),
                    style: _vue.normalizeStyle({
                        backgroundColor: _ctx.color
                    }),
                    onClick: _cache[1] || (_cache[1] = (...args)=>_ctx.handleClick && _ctx.handleClick(...args)
                    )
                }, [
                    _vue.createElementVNode("span", {
                        class: _vue.normalizeClass(_ctx.ns.e("content"))
                    }, [
                        _vue.renderSlot(_ctx.$slots, "default")
                    ], 2),
                    _ctx.closable ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 0,
                        class: _vue.normalizeClass(_ctx.ns.e("close")),
                        onClick: _ctx.handleClose
                    }, {
                        default: _vue.withCtx(()=>[
                                _vue.createVNode(_component_close)
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "class",
                        "onClick"
                    ])) : _vue.createCommentVNode("v-if", true)
                ], 6)
            ]
        ),
        _: 3
    }, 8, [
        "name"
    ]));
}
var Tag = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../hooks/index.mjs":"1Ansp","./tag.mjs":"i4Ov7","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-common-props/index.mjs":"05czU","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i4Ov7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tagEmits", ()=>tagEmits
);
parcelHelpers.export(exports, "tagProps", ()=>tagProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const tagProps = _propsMjs.buildProps({
    closable: Boolean,
    type: {
        type: String,
        values: [
            "success",
            "info",
            "warning",
            "danger",
            ""
        ],
        default: ""
    },
    hit: Boolean,
    disableTransitions: Boolean,
    color: {
        type: String,
        default: ""
    },
    size: {
        type: String,
        values: [
            "large",
            "default",
            "small"
        ]
    },
    effect: {
        type: String,
        values: [
            "dark",
            "light",
            "plain"
        ],
        default: "light"
    }
});
const tagEmits = {
    close: (evt)=>evt instanceof MouseEvent
    ,
    click: (evt)=>evt instanceof MouseEvent
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2yvIi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checkTagEmits", ()=>_checkTagMjs.checkTagEmits
);
parcelHelpers.export(exports, "checkTagProps", ()=>_checkTagMjs.checkTagProps
);
parcelHelpers.export(exports, "ElCheckTag", ()=>ElCheckTag
);
parcelHelpers.export(exports, "default", ()=>ElCheckTag
);
var _indexMjs = require("../../utils/index.mjs");
var _checkTag2Mjs = require("./src/check-tag2.mjs");
var _checkTag2MjsDefault = parcelHelpers.interopDefault(_checkTag2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _checkTagMjs = require("./src/check-tag.mjs");
const ElCheckTag = _installMjs.withInstall(_checkTag2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/check-tag2.mjs":"f1lOV","../../utils/vue/install.mjs":"4TMmv","./src/check-tag.mjs":"fL3TX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f1lOV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CheckTag
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _checkTagMjs = require("./check-tag.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElCheckTag",
    props: _checkTagMjs.checkTagProps,
    emits: _checkTagMjs.checkTagEmits,
    setup (props, { emit  }) {
        const ns = _indexMjs1.useNamespace("check-tag");
        const onChange = ()=>{
            const checked = !props.checked;
            emit("change", checked);
            emit("update:checked", checked);
        };
        return {
            ns,
            onChange
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("span", {
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.is("checked", _ctx.checked)
        ]),
        onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.onChange && _ctx.onChange(...args)
        )
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 2);
}
var CheckTag = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./check-tag.mjs":"fL3TX","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fL3TX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checkTagEmits", ()=>checkTagEmits
);
parcelHelpers.export(exports, "checkTagProps", ()=>checkTagProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _core = require("@vueuse/core");
const checkTagProps = _propsMjs.buildProps({
    checked: {
        type: Boolean,
        default: false
    }
});
const checkTagEmits = {
    "update:checked": (value)=>_core.isBoolean(value)
    ,
    change: (value)=>_core.isBoolean(value)
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iutZ4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "colProps", ()=>_colMjs.colProps
);
parcelHelpers.export(exports, "ElCol", ()=>ElCol
);
parcelHelpers.export(exports, "default", ()=>ElCol
);
var _indexMjs = require("../../utils/index.mjs");
var _colMjs = require("./src/col.mjs");
var _colMjsDefault = parcelHelpers.interopDefault(_colMjs);
var _installMjs = require("../../utils/vue/install.mjs");
const ElCol = _installMjs.withInstall(_colMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/col.mjs":"hxnIP","../../utils/vue/install.mjs":"4TMmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hxnIP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "colProps", ()=>colProps
);
parcelHelpers.export(exports, "default", ()=>Col
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _typescriptMjs = require("../../../utils/typescript.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const colProps = _propsMjs.buildProps({
    tag: {
        type: String,
        default: "div"
    },
    span: {
        type: Number,
        default: 24
    },
    offset: {
        type: Number,
        default: 0
    },
    pull: {
        type: Number,
        default: 0
    },
    push: {
        type: Number,
        default: 0
    },
    xs: {
        type: _propsMjs.definePropType([
            Number,
            Object
        ]),
        default: ()=>_typescriptMjs.mutable({
            })
    },
    sm: {
        type: _propsMjs.definePropType([
            Number,
            Object
        ]),
        default: ()=>_typescriptMjs.mutable({
            })
    },
    md: {
        type: _propsMjs.definePropType([
            Number,
            Object
        ]),
        default: ()=>_typescriptMjs.mutable({
            })
    },
    lg: {
        type: _propsMjs.definePropType([
            Number,
            Object
        ]),
        default: ()=>_typescriptMjs.mutable({
            })
    },
    xl: {
        type: _propsMjs.definePropType([
            Number,
            Object
        ]),
        default: ()=>_typescriptMjs.mutable({
            })
    }
});
var Col = _vue.defineComponent({
    name: "ElCol",
    props: colProps,
    setup (props, { slots  }) {
        const { gutter  } = _vue.inject("ElRow", {
            gutter: {
                value: 0
            }
        });
        const ns = _indexMjs2.useNamespace("col");
        const style = _vue.computed(()=>{
            if (gutter.value) return {
                paddingLeft: `${gutter.value / 2}px`,
                paddingRight: `${gutter.value / 2}px`
            };
            return {
            };
        });
        const classList = _vue.computed(()=>{
            const classes = [];
            const pos = [
                "span",
                "offset",
                "pull",
                "push"
            ];
            pos.forEach((prop)=>{
                const size = props[prop];
                if (typeof size === "number") {
                    if (prop === "span") classes.push(ns.b(`${props[prop]}`));
                    else if (size > 0) classes.push(ns.b(`${prop}-${props[prop]}`));
                }
            });
            const sizes = [
                "xs",
                "sm",
                "md",
                "lg",
                "xl"
            ];
            sizes.forEach((size)=>{
                if (typeof props[size] === "number") classes.push(ns.b(`${size}-${props[size]}`));
                else if (typeof props[size] === "object") {
                    const sizeProps = props[size];
                    Object.keys(sizeProps).forEach((prop)=>{
                        classes.push(prop !== "span" ? ns.b(`${size}-${prop}-${sizeProps[prop]}`) : ns.b(`${size}-${sizeProps[prop]}`));
                    });
                }
            });
            if (gutter.value) classes.push("is-guttered");
            return classes;
        });
        return ()=>_vue.h(props.tag, {
                class: [
                    ns.b(),
                    classList.value
                ],
                style: style.value
            }, [
                _vue.renderSlot(slots, "default")
            ])
        ;
    }
});

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","../../../utils/vue/props.mjs":"cpwWK","../../../utils/typescript.mjs":"bRl53","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2aUAi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElCollapse", ()=>ElCollapse
);
parcelHelpers.export(exports, "ElCollapseItem", ()=>ElCollapseItem
);
parcelHelpers.export(exports, "default", ()=>ElCollapse
);
var _indexMjs = require("../../utils/index.mjs");
var _collapseMjs = require("./src/collapse.mjs");
var _collapseMjsDefault = parcelHelpers.interopDefault(_collapseMjs);
var _collapseItemMjs = require("./src/collapse-item.mjs");
var _collapseItemMjsDefault = parcelHelpers.interopDefault(_collapseItemMjs);
var _installMjs = require("../../utils/vue/install.mjs");
const ElCollapse = _installMjs.withInstall(_collapseMjsDefault.default, {
    CollapseItem: _collapseItemMjsDefault.default
});
const ElCollapseItem = _installMjs.withNoopInstall(_collapseItemMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/collapse.mjs":"gzgLG","./src/collapse-item.mjs":"iFqvD","../../utils/vue/install.mjs":"4TMmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gzgLG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Collapse
);
var _vue = require("vue");
var _indexMjs = require("../../../constants/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElCollapse",
    props: {
        accordion: Boolean,
        modelValue: {
            type: [
                Array,
                String,
                Number
            ],
            default: ()=>[]
        }
    },
    emits: [
        _eventMjs.UPDATE_MODEL_EVENT,
        _eventMjs.CHANGE_EVENT
    ],
    setup (props, { emit  }) {
        const ns = _indexMjs2.useNamespace("collapse");
        const activeNames = _vue.ref([].concat(props.modelValue));
        const setActiveNames = (_activeNames)=>{
            activeNames.value = [].concat(_activeNames);
            const value = props.accordion ? activeNames.value[0] : activeNames.value;
            emit(_eventMjs.UPDATE_MODEL_EVENT, value);
            emit(_eventMjs.CHANGE_EVENT, value);
        };
        const handleItemClick = (name)=>{
            if (props.accordion) setActiveNames((activeNames.value[0] || activeNames.value[0] === 0) && activeNames.value[0] === name ? "" : name);
            else {
                const _activeNames = activeNames.value.slice(0);
                const index = _activeNames.indexOf(name);
                if (index > -1) _activeNames.splice(index, 1);
                else _activeNames.push(name);
                setActiveNames(_activeNames);
            }
        };
        _vue.watch(()=>props.modelValue
        , ()=>{
            activeNames.value = [].concat(props.modelValue);
        }, {
            deep: true
        });
        _vue.provide("collapse", {
            activeNames,
            handleItemClick
        });
        return {
            ns,
            activeNames,
            setActiveNames,
            handleItemClick
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.ns.b()),
        role: "tablist",
        "aria-multiselectable": "true"
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 2);
}
var Collapse = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../constants/index.mjs":"74Fbn","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../constants/event.mjs":"92xVn","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iFqvD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CollapseItem
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../collapse-transition/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _indexMjs2 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs3 = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _randMjs = require("../../../utils/rand.mjs");
var _indexMjs4 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElCollapseItem",
    components: {
        ElCollapseTransition: _indexMjsDefault.default,
        ElIcon: _indexMjs2.ElIcon,
        ArrowRight: _iconsVue.ArrowRight
    },
    props: {
        title: {
            type: String,
            default: ""
        },
        name: {
            type: [
                String,
                Number
            ],
            default: ()=>{
                return _randMjs.generateId();
            }
        },
        disabled: Boolean
    },
    setup (props) {
        const collapse = _vue.inject("collapse");
        const ns = _indexMjs4.useNamespace("collapse");
        const contentWrapStyle = _vue.ref({
            height: "auto",
            display: "block"
        });
        const contentHeight = _vue.ref(0);
        const focusing = _vue.ref(false);
        const isClick = _vue.ref(false);
        const id = _vue.ref(_randMjs.generateId());
        const isActive = _vue.computed(()=>{
            return (collapse == null ? void 0 : collapse.activeNames.value.indexOf(props.name)) > -1;
        });
        const handleFocus = ()=>{
            setTimeout(()=>{
                if (!isClick.value) focusing.value = true;
                else isClick.value = false;
            }, 50);
        };
        const handleHeaderClick = ()=>{
            if (props.disabled) return;
            collapse == null || collapse.handleItemClick(props.name);
            focusing.value = false;
            isClick.value = true;
        };
        const handleEnterClick = ()=>{
            collapse == null || collapse.handleItemClick(props.name);
        };
        return {
            isActive,
            contentWrapStyle,
            contentHeight,
            focusing,
            isClick,
            id,
            ns,
            handleFocus,
            handleHeaderClick,
            handleEnterClick,
            collapse
        };
    }
});
const _hoisted_1 = [
    "aria-expanded",
    "aria-controls",
    "aria-describedby"
];
const _hoisted_2 = [
    "id",
    "tabindex"
];
const _hoisted_3 = [
    "id",
    "aria-hidden",
    "aria-labelledby"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_arrow_right = _vue.resolveComponent("arrow-right");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_collapse_transition = _vue.resolveComponent("el-collapse-transition");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.ns.b("item"),
            _ctx.ns.is("active", _ctx.isActive),
            _ctx.ns.is("disabled", _ctx.disabled)
        ])
    }, [
        _vue.createElementVNode("div", {
            role: "tab",
            "aria-expanded": _ctx.isActive,
            "aria-controls": _ctx.ns.b(`content-${_ctx.id}`),
            "aria-describedby": _ctx.ns.b(`content-${_ctx.id}`)
        }, [
            _vue.createElementVNode("div", {
                id: _ctx.ns.b(`head-${_ctx.id}`),
                class: _vue.normalizeClass([
                    _ctx.ns.be("item", "header"),
                    _ctx.ns.is("active", _ctx.isActive),
                    {
                        focusing: _ctx.focusing
                    }
                ]),
                role: "button",
                tabindex: _ctx.disabled ? -1 : 0,
                onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleHeaderClick && _ctx.handleHeaderClick(...args)
                ),
                onKeyup: _cache[1] || (_cache[1] = _vue.withKeys(_vue.withModifiers((...args)=>_ctx.handleEnterClick && _ctx.handleEnterClick(...args)
                , [
                    "stop"
                ]), [
                    "space",
                    "enter"
                ])),
                onFocus: _cache[2] || (_cache[2] = (...args)=>_ctx.handleFocus && _ctx.handleFocus(...args)
                ),
                onBlur: _cache[3] || (_cache[3] = ($event)=>_ctx.focusing = false
                )
            }, [
                _vue.renderSlot(_ctx.$slots, "title", {
                }, ()=>[
                        _vue.createTextVNode(_vue.toDisplayString(_ctx.title), 1)
                    ]
                ),
                _vue.createVNode(_component_el_icon, {
                    class: _vue.normalizeClass([
                        _ctx.ns.be("item", "arrow"),
                        _ctx.ns.is("active", _ctx.isActive)
                    ])
                }, {
                    default: _vue.withCtx(()=>[
                            _vue.createVNode(_component_arrow_right)
                        ]
                    ),
                    _: 1
                }, 8, [
                    "class"
                ])
            ], 42, _hoisted_2)
        ], 8, _hoisted_1),
        _vue.createVNode(_component_el_collapse_transition, null, {
            default: _vue.withCtx(()=>[
                    _vue.withDirectives(_vue.createElementVNode("div", {
                        id: _ctx.ns.b(`content-${_ctx.id}`),
                        class: _vue.normalizeClass(_ctx.ns.be("item", "wrap")),
                        role: "tabpanel",
                        "aria-hidden": !_ctx.isActive,
                        "aria-labelledby": _ctx.ns.b(`head-${_ctx.id}`)
                    }, [
                        _vue.createElementVNode("div", {
                            class: _vue.normalizeClass(_ctx.ns.be("item", "content"))
                        }, [
                            _vue.renderSlot(_ctx.$slots, "default")
                        ], 2)
                    ], 10, _hoisted_3), [
                        [
                            _vue.vShow,
                            _ctx.isActive
                        ]
                    ])
                ]
            ),
            _: 3
        })
    ], 2);
}
var CollapseItem = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../collapse-transition/index.mjs":"kOsra","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/rand.mjs":"6d823","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kOsra":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElCollapseTransition", ()=>ElCollapseTransition
);
parcelHelpers.export(exports, "default", ()=>_CollapseTransition
);
var _collapseTransitionMjs = require("./src/collapse-transition.mjs");
var _collapseTransitionMjsDefault = parcelHelpers.interopDefault(_collapseTransitionMjs);
_collapseTransitionMjsDefault.default.install = (app)=>{
    app.component(_collapseTransitionMjsDefault.default.name, _collapseTransitionMjsDefault.default);
};
const _CollapseTransition = _collapseTransitionMjsDefault.default;
const ElCollapseTransition = _CollapseTransition;

},{"./src/collapse-transition.mjs":"jUQvA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jUQvA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CollapseTransition
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElCollapseTransition",
    setup () {
        const ns = _indexMjs1.useNamespace("collapse-transition");
        return {
            ns,
            on: {
                beforeEnter (el) {
                    if (!el.dataset) el.dataset = {
                    };
                    el.dataset.oldPaddingTop = el.style.paddingTop;
                    el.dataset.oldPaddingBottom = el.style.paddingBottom;
                    el.style.maxHeight = 0;
                    el.style.paddingTop = 0;
                    el.style.paddingBottom = 0;
                },
                enter (el) {
                    el.dataset.oldOverflow = el.style.overflow;
                    if (el.scrollHeight !== 0) {
                        el.style.maxHeight = `${el.scrollHeight}px`;
                        el.style.paddingTop = el.dataset.oldPaddingTop;
                        el.style.paddingBottom = el.dataset.oldPaddingBottom;
                    } else {
                        el.style.maxHeight = 0;
                        el.style.paddingTop = el.dataset.oldPaddingTop;
                        el.style.paddingBottom = el.dataset.oldPaddingBottom;
                    }
                    el.style.overflow = "hidden";
                },
                afterEnter (el) {
                    el.style.maxHeight = "";
                    el.style.overflow = el.dataset.oldOverflow;
                },
                beforeLeave (el) {
                    if (!el.dataset) el.dataset = {
                    };
                    el.dataset.oldPaddingTop = el.style.paddingTop;
                    el.dataset.oldPaddingBottom = el.style.paddingBottom;
                    el.dataset.oldOverflow = el.style.overflow;
                    el.style.maxHeight = `${el.scrollHeight}px`;
                    el.style.overflow = "hidden";
                },
                leave (el) {
                    if (el.scrollHeight !== 0) {
                        el.style.maxHeight = 0;
                        el.style.paddingTop = 0;
                        el.style.paddingBottom = 0;
                    }
                },
                afterLeave (el) {
                    el.style.maxHeight = "";
                    el.style.overflow = el.dataset.oldOverflow;
                    el.style.paddingTop = el.dataset.oldPaddingTop;
                    el.style.paddingBottom = el.dataset.oldPaddingBottom;
                }
            }
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createBlock(_vue.Transition, _vue.mergeProps({
        name: _ctx.ns.b()
    }, _vue.toHandlers(_ctx.on)), {
        default: _vue.withCtx(()=>[
                _vue.renderSlot(_ctx.$slots, "default")
            ]
        ),
        _: 3
    }, 16, [
        "name"
    ]);
}
var CollapseTransition = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kWiGH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElColorPicker", ()=>ElColorPicker
);
parcelHelpers.export(exports, "default", ()=>_ColorPicker
);
var _indexMjs = require("./src/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
_indexMjsDefault.default.install = (app)=>{
    app.component(_indexMjsDefault.default.name, _indexMjsDefault.default);
};
const _ColorPicker = _indexMjsDefault.default;
const ElColorPicker = _ColorPicker;

},{"./src/index.mjs":"lXQYL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lXQYL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ColorPicker
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../button/index.mjs");
var _indexMjs1 = require("../../icon/index.mjs");
var _indexMjs2 = require("../../../directives/index.mjs");
var _indexMjs3 = require("../../../tokens/index.mjs");
var _indexMjs4 = require("../../../hooks/index.mjs");
var _indexMjs5 = require("../../tooltip/index.mjs");
var _indexMjs6 = require("../../input/index.mjs");
var _indexMjs7 = require("../../../constants/index.mjs");
var _indexMjs8 = require("../../../utils/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _alphaSliderMjs = require("./components/alpha-slider.mjs");
var _alphaSliderMjsDefault = parcelHelpers.interopDefault(_alphaSliderMjs);
var _hueSliderMjs = require("./components/hue-slider.mjs");
var _hueSliderMjsDefault = parcelHelpers.interopDefault(_hueSliderMjs);
var _predefineMjs = require("./components/predefine.mjs");
var _predefineMjsDefault = parcelHelpers.interopDefault(_predefineMjs);
var _svPanelMjs = require("./components/sv-panel.mjs");
var _svPanelMjsDefault = parcelHelpers.interopDefault(_svPanelMjs);
var _colorMjs = require("./color.mjs");
var _colorMjsDefault = parcelHelpers.interopDefault(_colorMjs);
var _useOptionMjs = require("./useOption.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs9 = require("../../../directives/click-outside/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs9);
var _validatorMjs = require("../../../utils/vue/validator.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs10 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs11 = require("../../../hooks/use-namespace/index.mjs");
var _formMjs = require("../../../tokens/form.mjs");
var _indexMjs12 = require("../../../hooks/use-common-props/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElColorPicker",
    components: {
        ElButton: _indexMjs.ElButton,
        ElTooltip: _indexMjs5.ElTooltip,
        ElInput: _indexMjs6.ElInput,
        ElIcon: _indexMjs1.ElIcon,
        Close: _iconsVue.Close,
        ArrowDown: _iconsVue.ArrowDown,
        SvPanel: _svPanelMjsDefault.default,
        HueSlider: _hueSliderMjsDefault.default,
        AlphaSlider: _alphaSliderMjsDefault.default,
        Predefine: _predefineMjsDefault.default
    },
    directives: {
        ClickOutside: _indexMjsDefault.default
    },
    props: {
        modelValue: String,
        showAlpha: Boolean,
        colorFormat: String,
        disabled: Boolean,
        size: {
            type: String,
            validator: _validatorMjs.isValidComponentSize
        },
        popperClass: String,
        predefine: Array
    },
    emits: [
        "change",
        "active-change",
        _eventMjs.UPDATE_MODEL_EVENT
    ],
    setup (props, { emit  }) {
        const { t  } = _indexMjs10.useLocale();
        const ns = _indexMjs11.useNamespace("color");
        const elForm = _vue.inject(_formMjs.elFormKey, {
        });
        const elFormItem = _vue.inject(_formMjs.elFormItemKey, {
        });
        const hue = _vue.ref(null);
        const svPanel = _vue.ref(null);
        const alpha = _vue.ref(null);
        const popper = _vue.ref(null);
        const color = _vue.reactive(new _colorMjsDefault.default({
            enableAlpha: props.showAlpha,
            format: props.colorFormat,
            value: props.modelValue
        }));
        const showPicker = _vue.ref(false);
        const showPanelColor = _vue.ref(false);
        const customInput = _vue.ref("");
        const displayedColor = _vue.computed(()=>{
            if (!props.modelValue && !showPanelColor.value) return "transparent";
            return displayedRgb(color, props.showAlpha);
        });
        const colorSize = _indexMjs12.useSize();
        const colorDisabled = _vue.computed(()=>{
            return !!(props.disabled || elForm.disabled);
        });
        const currentColor = _vue.computed(()=>{
            return !props.modelValue && !showPanelColor.value ? "" : color.value;
        });
        _vue.watch(()=>props.modelValue
        , (newVal)=>{
            if (!newVal) showPanelColor.value = false;
            else if (newVal && newVal !== color.value) color.fromString(newVal);
        });
        _vue.watch(()=>currentColor.value
        , (val)=>{
            customInput.value = val;
            emit("active-change", val);
        });
        _vue.watch(()=>color.value
        , ()=>{
            if (!props.modelValue && !showPanelColor.value) showPanelColor.value = true;
        });
        function displayedRgb(color2, showAlpha) {
            if (!(color2 instanceof _colorMjsDefault.default)) throw Error("color should be instance of _color Class");
            const { r , g , b  } = color2.toRgb();
            return showAlpha ? `rgba(${r}, ${g}, ${b}, ${color2.get("alpha") / 100})` : `rgb(${r}, ${g}, ${b})`;
        }
        function setShowPicker(value) {
            showPicker.value = value;
        }
        const debounceSetShowPicker = _lodashUnified.debounce(setShowPicker, 100);
        function hide() {
            debounceSetShowPicker(false);
            resetColor();
        }
        function resetColor() {
            _vue.nextTick(()=>{
                if (props.modelValue) color.fromString(props.modelValue);
                else showPanelColor.value = false;
            });
        }
        function handleTrigger() {
            if (colorDisabled.value) return;
            debounceSetShowPicker(!showPicker.value);
        }
        function handleConfirm() {
            color.fromString(customInput.value);
        }
        function confirmValue() {
            var _a;
            const value = color.value;
            emit(_eventMjs.UPDATE_MODEL_EVENT, value);
            emit("change", value);
            (_a = elFormItem.validate) == null || _a.call(elFormItem, "change");
            debounceSetShowPicker(false);
            _vue.nextTick(()=>{
                const newColor = new _colorMjsDefault.default({
                    enableAlpha: props.showAlpha,
                    format: props.colorFormat,
                    value: props.modelValue
                });
                if (!color.compare(newColor)) resetColor();
            });
        }
        function clear() {
            var _a;
            debounceSetShowPicker(false);
            emit(_eventMjs.UPDATE_MODEL_EVENT, null);
            emit("change", null);
            if (props.modelValue !== null) (_a = elFormItem.validate) == null || _a.call(elFormItem, "change");
            resetColor();
        }
        _vue.onMounted(()=>{
            if (props.modelValue) customInput.value = currentColor.value;
        });
        _vue.watch(()=>showPicker.value
        , ()=>{
            _vue.nextTick(()=>{
                var _a, _b, _c;
                (_a = hue.value) == null || _a.update();
                (_b = svPanel.value) == null || _b.update();
                (_c = alpha.value) == null || _c.update();
            });
        });
        _vue.provide(_useOptionMjs.OPTIONS_KEY, {
            currentColor
        });
        return {
            color,
            colorDisabled,
            colorSize,
            displayedColor,
            showPanelColor,
            showPicker,
            customInput,
            handleConfirm,
            hide,
            handleTrigger,
            clear,
            confirmValue,
            t,
            ns,
            hue,
            svPanel,
            alpha,
            popper
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_hue_slider = _vue.resolveComponent("hue-slider");
    const _component_sv_panel = _vue.resolveComponent("sv-panel");
    const _component_alpha_slider = _vue.resolveComponent("alpha-slider");
    const _component_predefine = _vue.resolveComponent("predefine");
    const _component_el_input = _vue.resolveComponent("el-input");
    const _component_el_button = _vue.resolveComponent("el-button");
    const _component_arrow_down = _vue.resolveComponent("arrow-down");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_close = _vue.resolveComponent("close");
    const _component_el_tooltip = _vue.resolveComponent("el-tooltip");
    const _directive_click_outside = _vue.resolveDirective("click-outside");
    return _vue.openBlock(), _vue.createBlock(_component_el_tooltip, {
        ref: "popper",
        visible: _ctx.showPicker,
        "onUpdate:visible": _cache[2] || (_cache[2] = ($event)=>_ctx.showPicker = $event
        ),
        "show-arrow": false,
        "fallback-placements": [
            "bottom",
            "top",
            "right",
            "left"
        ],
        offset: 0,
        "gpu-acceleration": false,
        "popper-class": [
            _ctx.ns.be("picker", "panel"),
            _ctx.ns.b("dropdown"),
            _ctx.popperClass
        ],
        "stop-popper-mouse-event": false,
        effect: "light",
        trigger: "click",
        transition: "el-zoom-in-top",
        persistent: ""
    }, {
        content: _vue.withCtx(()=>[
                _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", null, [
                    _vue.createElementVNode("div", {
                        class: _vue.normalizeClass(_ctx.ns.be("dropdown", "main-wrapper"))
                    }, [
                        _vue.createVNode(_component_hue_slider, {
                            ref: "hue",
                            class: "hue-slider",
                            color: _ctx.color,
                            vertical: ""
                        }, null, 8, [
                            "color"
                        ]),
                        _vue.createVNode(_component_sv_panel, {
                            ref: "svPanel",
                            color: _ctx.color
                        }, null, 8, [
                            "color"
                        ])
                    ], 2),
                    _ctx.showAlpha ? (_vue.openBlock(), _vue.createBlock(_component_alpha_slider, {
                        key: 0,
                        ref: "alpha",
                        color: _ctx.color
                    }, null, 8, [
                        "color"
                    ])) : _vue.createCommentVNode("v-if", true),
                    _ctx.predefine ? (_vue.openBlock(), _vue.createBlock(_component_predefine, {
                        key: 1,
                        ref: "predefine",
                        color: _ctx.color,
                        colors: _ctx.predefine
                    }, null, 8, [
                        "color",
                        "colors"
                    ])) : _vue.createCommentVNode("v-if", true),
                    _vue.createElementVNode("div", {
                        class: _vue.normalizeClass(_ctx.ns.be("dropdown", "btns"))
                    }, [
                        _vue.createElementVNode("span", {
                            class: _vue.normalizeClass(_ctx.ns.be("dropdown", "value"))
                        }, [
                            _vue.createVNode(_component_el_input, {
                                modelValue: _ctx.customInput,
                                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>_ctx.customInput = $event
                                ),
                                "validate-event": false,
                                size: "small",
                                onKeyup: _vue.withKeys(_ctx.handleConfirm, [
                                    "enter"
                                ]),
                                onBlur: _ctx.handleConfirm
                            }, null, 8, [
                                "modelValue",
                                "onKeyup",
                                "onBlur"
                            ])
                        ], 2),
                        _vue.createVNode(_component_el_button, {
                            size: "small",
                            type: "text",
                            class: _vue.normalizeClass(_ctx.ns.be("dropdown", "link-btn")),
                            onClick: _ctx.clear
                        }, {
                            default: _vue.withCtx(()=>[
                                    _vue.createTextVNode(_vue.toDisplayString(_ctx.t("el.colorpicker.clear")), 1)
                                ]
                            ),
                            _: 1
                        }, 8, [
                            "class",
                            "onClick"
                        ]),
                        _vue.createVNode(_component_el_button, {
                            plain: "",
                            size: "small",
                            class: _vue.normalizeClass(_ctx.ns.be("dropdown", "btn")),
                            onClick: _ctx.confirmValue
                        }, {
                            default: _vue.withCtx(()=>[
                                    _vue.createTextVNode(_vue.toDisplayString(_ctx.t("el.colorpicker.confirm")), 1)
                                ]
                            ),
                            _: 1
                        }, 8, [
                            "class",
                            "onClick"
                        ])
                    ], 2)
                ])), [
                    [
                        _directive_click_outside,
                        _ctx.hide
                    ]
                ])
            ]
        ),
        default: _vue.withCtx(()=>[
                _vue.createElementVNode("div", {
                    class: _vue.normalizeClass([
                        _ctx.ns.b("picker"),
                        _ctx.ns.is("disabled", _ctx.colorDisabled),
                        _ctx.ns.bm("picker", _ctx.colorSize)
                    ])
                }, [
                    _ctx.colorDisabled ? (_vue.openBlock(), _vue.createElementBlock("div", {
                        key: 0,
                        class: _vue.normalizeClass(_ctx.ns.be("picker", "mask"))
                    }, null, 2)) : _vue.createCommentVNode("v-if", true),
                    _vue.createElementVNode("div", {
                        class: _vue.normalizeClass(_ctx.ns.be("picker", "trigger")),
                        onClick: _cache[1] || (_cache[1] = (...args)=>_ctx.handleTrigger && _ctx.handleTrigger(...args)
                        )
                    }, [
                        _vue.createElementVNode("span", {
                            class: _vue.normalizeClass([
                                _ctx.ns.be("picker", "color"),
                                _ctx.ns.is("alpha", _ctx.showAlpha)
                            ])
                        }, [
                            _vue.createElementVNode("span", {
                                class: _vue.normalizeClass(_ctx.ns.be("picker", "color-inner")),
                                style: _vue.normalizeStyle({
                                    backgroundColor: _ctx.displayedColor
                                })
                            }, [
                                _vue.withDirectives(_vue.createVNode(_component_el_icon, {
                                    class: _vue.normalizeClass([
                                        _ctx.ns.be("picker", "icon"),
                                        _ctx.ns.is("icon-arrow-down")
                                    ])
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_arrow_down)
                                        ]
                                    ),
                                    _: 1
                                }, 8, [
                                    "class"
                                ]), [
                                    [
                                        _vue.vShow,
                                        _ctx.modelValue || _ctx.showPanelColor
                                    ]
                                ]),
                                !_ctx.modelValue && !_ctx.showPanelColor ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                    key: 0,
                                    class: _vue.normalizeClass([
                                        _ctx.ns.be("picker", "empty"),
                                        _ctx.ns.is("icon-close")
                                    ])
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_close)
                                        ]
                                    ),
                                    _: 1
                                }, 8, [
                                    "class"
                                ])) : _vue.createCommentVNode("v-if", true)
                            ], 6)
                        ], 2)
                    ], 2)
                ], 2)
            ]
        ),
        _: 1
    }, 8, [
        "visible",
        "popper-class"
    ]);
}
var ColorPicker = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","lodash-unified":"4Oj4p","../../button/index.mjs":"64Ym1","../../icon/index.mjs":"hnNTG","../../../directives/index.mjs":"aRbJ2","../../../tokens/index.mjs":"wVNQi","../../../hooks/index.mjs":"1Ansp","../../tooltip/index.mjs":"kiwBC","../../input/index.mjs":"18eQI","../../../constants/index.mjs":"74Fbn","../../../utils/index.mjs":"dsdeP","@element-plus/icons-vue":"b18uu","./components/alpha-slider.mjs":"cpUEL","./components/hue-slider.mjs":"hVs34","./components/predefine.mjs":"gki5Z","./components/sv-panel.mjs":"7VLPy","./color.mjs":"5I6V8","./useOption.mjs":"8cey1","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../directives/click-outside/index.mjs":"cdlLW","../../../utils/vue/validator.mjs":"4UnBa","../../../constants/event.mjs":"92xVn","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../tokens/form.mjs":"2r4O0","../../../hooks/use-common-props/index.mjs":"05czU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cpUEL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>AlphaSlider
);
var _vue = require("vue");
var _indexMjs = require("../../../../utils/index.mjs");
var _draggableMjs = require("../draggable.mjs");
var _draggableMjsDefault = parcelHelpers.interopDefault(_draggableMjs);
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _positionMjs = require("../../../../utils/dom/position.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElColorAlphaSlider",
    props: {
        color: {
            type: Object,
            required: true
        },
        vertical: {
            type: Boolean,
            default: false
        }
    },
    setup (props) {
        const instance = _vue.getCurrentInstance();
        const thumb = _vue.shallowRef(null);
        const bar = _vue.shallowRef(null);
        const thumbLeft = _vue.ref(0);
        const thumbTop = _vue.ref(0);
        const background = _vue.ref(null);
        _vue.watch(()=>props.color.get("alpha")
        , ()=>{
            update();
        });
        _vue.watch(()=>props.color.value
        , ()=>{
            update();
        });
        function getThumbLeft() {
            if (props.vertical) return 0;
            const el = instance.vnode.el;
            const alpha = props.color.get("alpha");
            if (!el) return 0;
            return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);
        }
        function getThumbTop() {
            const el = instance.vnode.el;
            if (!props.vertical) return 0;
            const alpha = props.color.get("alpha");
            if (!el) return 0;
            return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);
        }
        function getBackground() {
            if (props.color && props.color.value) {
                const { r , g , b  } = props.color.toRgb();
                return `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`;
            }
            return null;
        }
        function handleClick(event) {
            const target = event.target;
            if (target !== thumb.value) handleDrag(event);
        }
        function handleDrag(event) {
            const el = instance.vnode.el;
            const rect = el.getBoundingClientRect();
            const { clientX , clientY  } = _positionMjs.getClientXY(event);
            if (!props.vertical) {
                let left = clientX - rect.left;
                left = Math.max(thumb.value.offsetWidth / 2, left);
                left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
                props.color.set("alpha", Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));
            } else {
                let top = clientY - rect.top;
                top = Math.max(thumb.value.offsetHeight / 2, top);
                top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
                props.color.set("alpha", Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));
            }
        }
        function update() {
            thumbLeft.value = getThumbLeft();
            thumbTop.value = getThumbTop();
            background.value = getBackground();
        }
        _vue.onMounted(()=>{
            const dragConfig = {
                drag: (event)=>{
                    handleDrag(event);
                },
                end: (event)=>{
                    handleDrag(event);
                }
            };
            _draggableMjsDefault.default(bar.value, dragConfig);
            _draggableMjsDefault.default(thumb.value, dragConfig);
            update();
        });
        return {
            thumb,
            bar,
            thumbLeft,
            thumbTop,
            background,
            handleClick,
            update
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            "el-color-alpha-slider",
            {
                "is-vertical": _ctx.vertical
            }
        ])
    }, [
        _vue.createElementVNode("div", {
            ref: "bar",
            class: "el-color-alpha-slider__bar",
            style: _vue.normalizeStyle({
                background: _ctx.background
            }),
            onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleClick && _ctx.handleClick(...args)
            )
        }, null, 4),
        _vue.createElementVNode("div", {
            ref: "thumb",
            class: "el-color-alpha-slider__thumb",
            style: _vue.normalizeStyle({
                left: _ctx.thumbLeft + "px",
                top: _ctx.thumbTop + "px"
            })
        }, null, 4)
    ], 2);
}
var AlphaSlider = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../../utils/index.mjs":"dsdeP","../draggable.mjs":"jqJCf","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../utils/dom/position.mjs":"cYzxx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jqJCf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>draggable
);
var _core = require("@vueuse/core");
var _indexMjs = require("../../../utils/index.mjs");
var _eventMjs = require("../../../utils/dom/event.mjs");
let isDragging = false;
function draggable(element, options) {
    if (!_core.isClient) return;
    const moveFn = function(event) {
        var _a;
        (_a = options.drag) == null || _a.call(options, event);
    };
    const upFn = function(event) {
        var _a;
        _eventMjs.off(document, "mousemove", moveFn);
        _eventMjs.off(document, "mouseup", upFn);
        _eventMjs.off(document, "touchmove", moveFn);
        _eventMjs.off(document, "touchend", upFn);
        document.onselectstart = null;
        document.ondragstart = null;
        isDragging = false;
        (_a = options.end) == null || _a.call(options, event);
    };
    const downFn = function(event) {
        var _a;
        if (isDragging) return;
        event.preventDefault();
        document.onselectstart = ()=>false
        ;
        document.ondragstart = ()=>false
        ;
        _eventMjs.on(document, "mousemove", moveFn);
        _eventMjs.on(document, "mouseup", upFn);
        _eventMjs.on(document, "touchmove", moveFn);
        _eventMjs.on(document, "touchend", upFn);
        isDragging = true;
        (_a = options.start) == null || _a.call(options, event);
    };
    _eventMjs.on(element, "mousedown", downFn);
    _eventMjs.on(element, "touchstart", downFn);
}

},{"@vueuse/core":"eEHP9","../../../utils/index.mjs":"dsdeP","../../../utils/dom/event.mjs":"fnXSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hVs34":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>HueSlider
);
var _vue = require("vue");
var _indexMjs = require("../../../../utils/index.mjs");
var _draggableMjs = require("../draggable.mjs");
var _draggableMjsDefault = parcelHelpers.interopDefault(_draggableMjs);
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _positionMjs = require("../../../../utils/dom/position.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElColorHueSlider",
    props: {
        color: {
            type: Object,
            required: true
        },
        vertical: Boolean
    },
    setup (props) {
        const instance = _vue.getCurrentInstance();
        const thumb = _vue.ref(null);
        const bar = _vue.ref(null);
        const thumbLeft = _vue.ref(0);
        const thumbTop = _vue.ref(0);
        const hueValue = _vue.computed(()=>{
            return props.color.get("hue");
        });
        _vue.watch(()=>hueValue.value
        , ()=>{
            update();
        });
        function handleClick(event) {
            const target = event.target;
            if (target !== thumb.value) handleDrag(event);
        }
        function handleDrag(event) {
            const el = instance.vnode.el;
            const rect = el.getBoundingClientRect();
            const { clientX , clientY  } = _positionMjs.getClientXY(event);
            let hue;
            if (!props.vertical) {
                let left = clientX - rect.left;
                left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
                left = Math.max(thumb.value.offsetWidth / 2, left);
                hue = Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 360);
            } else {
                let top = clientY - rect.top;
                top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
                top = Math.max(thumb.value.offsetHeight / 2, top);
                hue = Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 360);
            }
            props.color.set("hue", hue);
        }
        function getThumbLeft() {
            const el = instance.vnode.el;
            if (props.vertical) return 0;
            const hue = props.color.get("hue");
            if (!el) return 0;
            return Math.round(hue * (el.offsetWidth - thumb.value.offsetWidth / 2) / 360);
        }
        function getThumbTop() {
            const el = instance.vnode.el;
            if (!props.vertical) return 0;
            const hue = props.color.get("hue");
            if (!el) return 0;
            return Math.round(hue * (el.offsetHeight - thumb.value.offsetHeight / 2) / 360);
        }
        function update() {
            thumbLeft.value = getThumbLeft();
            thumbTop.value = getThumbTop();
        }
        _vue.onMounted(()=>{
            const dragConfig = {
                drag: (event)=>{
                    handleDrag(event);
                },
                end: (event)=>{
                    handleDrag(event);
                }
            };
            _draggableMjsDefault.default(bar.value, dragConfig);
            _draggableMjsDefault.default(thumb.value, dragConfig);
            update();
        });
        return {
            bar,
            thumb,
            thumbLeft,
            thumbTop,
            hueValue,
            handleClick,
            update
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            "el-color-hue-slider",
            {
                "is-vertical": _ctx.vertical
            }
        ])
    }, [
        _vue.createElementVNode("div", {
            ref: "bar",
            class: "el-color-hue-slider__bar",
            onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleClick && _ctx.handleClick(...args)
            )
        }, null, 512),
        _vue.createElementVNode("div", {
            ref: "thumb",
            class: "el-color-hue-slider__thumb",
            style: _vue.normalizeStyle({
                left: _ctx.thumbLeft + "px",
                top: _ctx.thumbTop + "px"
            })
        }, null, 4)
    ], 2);
}
var HueSlider = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../../utils/index.mjs":"dsdeP","../draggable.mjs":"jqJCf","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../utils/dom/position.mjs":"cYzxx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gki5Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Predefine
);
var _vue = require("vue");
var _useOptionMjs = require("../useOption.mjs");
var _colorMjs = require("../color.mjs");
var _colorMjsDefault = parcelHelpers.interopDefault(_colorMjs);
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    props: {
        colors: {
            type: Array,
            required: true
        },
        color: {
            type: Object,
            required: true
        }
    },
    setup (props) {
        const { currentColor  } = _useOptionMjs.useOptions();
        const rgbaColors = _vue.ref(parseColors(props.colors, props.color));
        _vue.watch(()=>currentColor.value
        , (val)=>{
            const color = new _colorMjsDefault.default();
            color.fromString(val);
            rgbaColors.value.forEach((item)=>{
                item.selected = color.compare(item);
            });
        });
        _vue.watchEffect(()=>{
            rgbaColors.value = parseColors(props.colors, props.color);
        });
        function handleSelect(index) {
            props.color.fromString(props.colors[index]);
        }
        function parseColors(colors, color) {
            return colors.map((value)=>{
                const c = new _colorMjsDefault.default();
                c.enableAlpha = true;
                c.format = "rgba";
                c.fromString(value);
                c.selected = c.value === color.value;
                return c;
            });
        }
        return {
            rgbaColors,
            handleSelect
        };
    }
});
const _hoisted_1 = {
    class: "el-color-predefine"
};
const _hoisted_2 = {
    class: "el-color-predefine__colors"
};
const _hoisted_3 = [
    "onClick"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", _hoisted_1, [
        _vue.createElementVNode("div", _hoisted_2, [
            (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.rgbaColors, (item, index)=>{
                return _vue.openBlock(), _vue.createElementBlock("div", {
                    key: _ctx.colors[index],
                    class: _vue.normalizeClass([
                        "el-color-predefine__color-selector",
                        {
                            selected: item.selected,
                            "is-alpha": item._alpha < 100
                        }
                    ]),
                    onClick: ($event)=>_ctx.handleSelect(index)
                }, [
                    _vue.createElementVNode("div", {
                        style: _vue.normalizeStyle({
                            backgroundColor: item.value
                        })
                    }, null, 4)
                ], 10, _hoisted_3);
            }), 128))
        ])
    ]);
}
var Predefine = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../useOption.mjs":"8cey1","../color.mjs":"5I6V8","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8cey1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OPTIONS_KEY", ()=>OPTIONS_KEY
);
parcelHelpers.export(exports, "useOptions", ()=>useOptions
);
var _vue = require("vue");
const OPTIONS_KEY = Symbol();
const useOptions = ()=>{
    return _vue.inject(OPTIONS_KEY);
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5I6V8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Color
);
var _indexMjs = require("../../../utils/index.mjs");
var _shared = require("@vue/shared");
const hsv2hsl = function(hue, sat, val) {
    return [
        hue,
        sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0,
        hue / 2
    ];
};
const isOnePointZero = function(n) {
    return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
};
const isPercentage = function(n) {
    return typeof n === "string" && n.indexOf("%") !== -1;
};
const bound01 = function(value, max) {
    if (isOnePointZero(value)) value = "100%";
    const processPercent = isPercentage(value);
    value = Math.min(max, Math.max(0, parseFloat(`${value}`)));
    if (processPercent) value = parseInt(`${value * max}`, 10) / 100;
    if (Math.abs(value - max) < 0.000001) return 1;
    return value % max / parseFloat(max);
};
const INT_HEX_MAP = {
    10: "A",
    11: "B",
    12: "C",
    13: "D",
    14: "E",
    15: "F"
};
const hexOne = function(value) {
    value = Math.min(Math.round(value), 255);
    const high = Math.floor(value / 16);
    const low = value % 16;
    return `${INT_HEX_MAP[high] || high}${INT_HEX_MAP[low] || low}`;
};
const toHex = function({ r , g , b  }) {
    if (isNaN(r) || isNaN(g) || isNaN(b)) return "";
    return `#${hexOne(r)}${hexOne(g)}${hexOne(b)}`;
};
const HEX_INT_MAP = {
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15
};
const parseHexChannel = function(hex) {
    if (hex.length === 2) return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
    return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
};
const hsl2hsv = function(hue, sat, light) {
    sat = sat / 100;
    light = light / 100;
    let smin = sat;
    const lmin = Math.max(light, 0.01);
    light *= 2;
    sat *= light <= 1 ? light : 2 - light;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (light + sat) / 2;
    const sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);
    return {
        h: hue,
        s: sv * 100,
        v: v * 100
    };
};
const rgb2hsv = function(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h;
    const v = max;
    const d = max - min;
    const s = max === 0 ? 0 : d / max;
    if (max === min) h = 0;
    else {
        switch(max){
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    return {
        h: h * 360,
        s: s * 100,
        v: v * 100
    };
};
const hsv2rgb = function(h, s, v) {
    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);
    const i = Math.floor(h);
    const f = h - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    const mod = i % 6;
    const r = [
        v,
        q,
        p,
        p,
        t,
        v
    ][mod];
    const g = [
        t,
        v,
        v,
        q,
        p,
        p
    ][mod];
    const b = [
        p,
        p,
        t,
        v,
        v,
        q
    ][mod];
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
};
class Color {
    constructor(options){
        this._hue = 0;
        this._saturation = 100;
        this._value = 100;
        this._alpha = 100;
        this.enableAlpha = false;
        this.format = "hex";
        this.value = "";
        options = options || {
        };
        for(const option in options)if (_shared.hasOwn(options, option)) this[option] = options[option];
        if (options.value) this.fromString(options.value);
        else this.doOnChange();
    }
    set(prop, value) {
        if (arguments.length === 1 && typeof prop === "object") {
            for(const p in prop)if (_shared.hasOwn(prop, p)) this.set(p, prop[p]);
            return;
        }
        this[`_${prop}`] = value;
        this.doOnChange();
    }
    get(prop) {
        if (prop === "alpha") return Math.floor(this[`_${prop}`]);
        return this[`_${prop}`];
    }
    toRgb() {
        return hsv2rgb(this._hue, this._saturation, this._value);
    }
    fromString(value) {
        if (!value) {
            this._hue = 0;
            this._saturation = 100;
            this._value = 100;
            this.doOnChange();
            return;
        }
        const fromHSV = (h, s, v)=>{
            this._hue = Math.max(0, Math.min(360, h));
            this._saturation = Math.max(0, Math.min(100, s));
            this._value = Math.max(0, Math.min(100, v));
            this.doOnChange();
        };
        if (value.indexOf("hsl") !== -1) {
            const parts = value.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((val)=>val !== ""
            ).map((val, index)=>index > 2 ? parseFloat(val) : parseInt(val, 10)
            );
            if (parts.length === 4) this._alpha = parseFloat(parts[3]) * 100;
            else if (parts.length === 3) this._alpha = 100;
            if (parts.length >= 3) {
                const { h , s , v  } = hsl2hsv(parts[0], parts[1], parts[2]);
                fromHSV(h, s, v);
            }
        } else if (value.indexOf("hsv") !== -1) {
            const parts = value.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((val)=>val !== ""
            ).map((val, index)=>index > 2 ? parseFloat(val) : parseInt(val, 10)
            );
            if (parts.length === 4) this._alpha = parseFloat(parts[3]) * 100;
            else if (parts.length === 3) this._alpha = 100;
            if (parts.length >= 3) fromHSV(parts[0], parts[1], parts[2]);
        } else if (value.indexOf("rgb") !== -1) {
            const parts = value.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((val)=>val !== ""
            ).map((val, index)=>index > 2 ? parseFloat(val) : parseInt(val, 10)
            );
            if (parts.length === 4) this._alpha = parseFloat(parts[3]) * 100;
            else if (parts.length === 3) this._alpha = 100;
            if (parts.length >= 3) {
                const { h , s , v  } = rgb2hsv(parts[0], parts[1], parts[2]);
                fromHSV(h, s, v);
            }
        } else if (value.indexOf("#") !== -1) {
            const hex = value.replace("#", "").trim();
            if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex)) return;
            let r, g, b;
            if (hex.length === 3) {
                r = parseHexChannel(hex[0] + hex[0]);
                g = parseHexChannel(hex[1] + hex[1]);
                b = parseHexChannel(hex[2] + hex[2]);
            } else if (hex.length === 6 || hex.length === 8) {
                r = parseHexChannel(hex.substring(0, 2));
                g = parseHexChannel(hex.substring(2, 4));
                b = parseHexChannel(hex.substring(4, 6));
            }
            if (hex.length === 8) this._alpha = parseHexChannel(hex.substring(6)) / 255 * 100;
            else if (hex.length === 3 || hex.length === 6) this._alpha = 100;
            const { h , s , v  } = rgb2hsv(r, g, b);
            fromHSV(h, s, v);
        }
    }
    compare(color) {
        return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;
    }
    doOnChange() {
        const { _hue , _saturation , _value , _alpha , format  } = this;
        if (this.enableAlpha) switch(format){
            case "hsl":
                {
                    const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
                    this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${this.get("alpha") / 100})`;
                    break;
                }
            case "hsv":
                this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${this.get("alpha") / 100})`;
                break;
            case "hex":
                this.value = `${toHex(hsv2rgb(_hue, _saturation, _value))}${hexOne(_alpha * 255 / 100)}`;
                break;
            default:
                {
                    const { r , g , b  } = hsv2rgb(_hue, _saturation, _value);
                    this.value = `rgba(${r}, ${g}, ${b}, ${this.get("alpha") / 100})`;
                }
        }
        else switch(format){
            case "hsl":
                {
                    const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
                    this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
                    break;
                }
            case "hsv":
                this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
                break;
            case "rgb":
                {
                    const { r , g , b  } = hsv2rgb(_hue, _saturation, _value);
                    this.value = `rgb(${r}, ${g}, ${b})`;
                    break;
                }
            default:
                this.value = toHex(hsv2rgb(_hue, _saturation, _value));
        }
    }
}

},{"../../../utils/index.mjs":"dsdeP","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7VLPy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>SvPanel
);
var _vue = require("vue");
var _indexMjs = require("../../../../utils/index.mjs");
var _draggableMjs = require("../draggable.mjs");
var _draggableMjsDefault = parcelHelpers.interopDefault(_draggableMjs);
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _positionMjs = require("../../../../utils/dom/position.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElSlPanel",
    props: {
        color: {
            type: Object,
            required: true
        }
    },
    setup (props) {
        const instance = _vue.getCurrentInstance();
        const cursorTop = _vue.ref(0);
        const cursorLeft = _vue.ref(0);
        const background = _vue.ref("hsl(0, 100%, 50%)");
        const colorValue = _vue.computed(()=>{
            const hue = props.color.get("hue");
            const value = props.color.get("value");
            return {
                hue,
                value
            };
        });
        function update() {
            const saturation = props.color.get("saturation");
            const value = props.color.get("value");
            const el = instance.vnode.el;
            const { clientWidth: width , clientHeight: height  } = el;
            cursorLeft.value = saturation * width / 100;
            cursorTop.value = (100 - value) * height / 100;
            background.value = `hsl(${props.color.get("hue")}, 100%, 50%)`;
        }
        function handleDrag(event) {
            const el = instance.vnode.el;
            const rect = el.getBoundingClientRect();
            const { clientX , clientY  } = _positionMjs.getClientXY(event);
            let left = clientX - rect.left;
            let top = clientY - rect.top;
            left = Math.max(0, left);
            left = Math.min(left, rect.width);
            top = Math.max(0, top);
            top = Math.min(top, rect.height);
            cursorLeft.value = left;
            cursorTop.value = top;
            props.color.set({
                saturation: left / rect.width * 100,
                value: 100 - top / rect.height * 100
            });
        }
        _vue.watch(()=>colorValue.value
        , ()=>{
            update();
        });
        _vue.onMounted(()=>{
            _draggableMjsDefault.default(instance.vnode.el, {
                drag: (event)=>{
                    handleDrag(event);
                },
                end: (event)=>{
                    handleDrag(event);
                }
            });
            update();
        });
        return {
            cursorTop,
            cursorLeft,
            background,
            colorValue,
            handleDrag,
            update
        };
    }
});
const _hoisted_1 = /* @__PURE__ */ _vue.createElementVNode("div", {
    class: "el-color-svpanel__white"
}, null, -1);
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("div", {
    class: "el-color-svpanel__black"
}, null, -1);
const _hoisted_3 = /* @__PURE__ */ _vue.createElementVNode("div", null, null, -1);
const _hoisted_4 = [
    _hoisted_3
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: "el-color-svpanel",
        style: _vue.normalizeStyle({
            backgroundColor: _ctx.background
        })
    }, [
        _hoisted_1,
        _hoisted_2,
        _vue.createElementVNode("div", {
            class: "el-color-svpanel__cursor",
            style: _vue.normalizeStyle({
                top: _ctx.cursorTop + "px",
                left: _ctx.cursorLeft + "px"
            })
        }, _hoisted_4, 4)
    ], 4);
}
var SvPanel = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../../utils/index.mjs":"dsdeP","../draggable.mjs":"jqJCf","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../utils/dom/position.mjs":"cYzxx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5LcSW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "configProviderProps", ()=>_configProviderMjs.configProviderProps
);
parcelHelpers.export(exports, "messageConfig", ()=>_configProviderMjs.messageConfig
);
parcelHelpers.export(exports, "ElConfigProvider", ()=>ElConfigProvider
);
parcelHelpers.export(exports, "default", ()=>ElConfigProvider
);
var _indexMjs = require("../../utils/index.mjs");
var _configProviderMjs = require("./src/config-provider.mjs");
var _configProviderMjsDefault = parcelHelpers.interopDefault(_configProviderMjs);
var _installMjs = require("../../utils/vue/install.mjs");
const ElConfigProvider = _installMjs.withInstall(_configProviderMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/config-provider.mjs":"jXq22","../../utils/vue/install.mjs":"4TMmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jXq22":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "configProviderProps", ()=>configProviderProps
);
parcelHelpers.export(exports, "default", ()=>ConfigProvider
);
parcelHelpers.export(exports, "messageConfig", ()=>messageConfig
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _indexMjs2 = require("../../../hooks/use-global-config/index.mjs");
const messageConfig = {
};
const configProviderProps = _propsMjs.buildProps({
    locale: {
        type: _propsMjs.definePropType(Object)
    },
    size: {
        type: String,
        values: [
            "large",
            "default",
            "small"
        ]
    },
    button: {
        type: _propsMjs.definePropType(Object)
    },
    message: {
        type: _propsMjs.definePropType(Object)
    },
    zIndex: {
        type: Number
    },
    namespace: {
        type: String,
        default: "el"
    }
});
var ConfigProvider = _vue.defineComponent({
    name: "ElConfigProvider",
    props: configProviderProps,
    setup (props, { slots  }) {
        _vue.watch(()=>props.message
        , (val)=>{
            Object.assign(messageConfig, val != null ? val : {
            });
        }, {
            immediate: true,
            deep: true
        });
        const config = _indexMjs2.provideGlobalConfig(props);
        return ()=>_vue.renderSlot(slots, "default", {
                config: config == null ? void 0 : config.value
            })
        ;
    }
});

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","../../../utils/vue/props.mjs":"cpwWK","../../../hooks/use-global-config/index.mjs":"jLlCF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7nKg2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElAside", ()=>ElAside
);
parcelHelpers.export(exports, "ElContainer", ()=>ElContainer
);
parcelHelpers.export(exports, "ElFooter", ()=>ElFooter
);
parcelHelpers.export(exports, "ElHeader", ()=>ElHeader
);
parcelHelpers.export(exports, "ElMain", ()=>ElMain
);
parcelHelpers.export(exports, "default", ()=>ElContainer
);
var _indexMjs = require("../../utils/index.mjs");
var _containerMjs = require("./src/container.mjs");
var _containerMjsDefault = parcelHelpers.interopDefault(_containerMjs);
var _asideMjs = require("./src/aside.mjs");
var _asideMjsDefault = parcelHelpers.interopDefault(_asideMjs);
var _footerMjs = require("./src/footer.mjs");
var _footerMjsDefault = parcelHelpers.interopDefault(_footerMjs);
var _headerMjs = require("./src/header.mjs");
var _headerMjsDefault = parcelHelpers.interopDefault(_headerMjs);
var _mainMjs = require("./src/main.mjs");
var _mainMjsDefault = parcelHelpers.interopDefault(_mainMjs);
var _installMjs = require("../../utils/vue/install.mjs");
const ElContainer = _installMjs.withInstall(_containerMjsDefault.default, {
    Aside: _asideMjsDefault.default,
    Footer: _footerMjsDefault.default,
    Header: _headerMjsDefault.default,
    Main: _mainMjsDefault.default
});
const ElAside = _installMjs.withNoopInstall(_asideMjsDefault.default);
const ElFooter = _installMjs.withNoopInstall(_footerMjsDefault.default);
const ElHeader = _installMjs.withNoopInstall(_headerMjsDefault.default);
const ElMain = _installMjs.withNoopInstall(_mainMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/container.mjs":"coOtu","./src/aside.mjs":"i79Ah","./src/footer.mjs":"exuGN","./src/header.mjs":"7yYcc","./src/main.mjs":"dyLi6","../../utils/vue/install.mjs":"4TMmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"coOtu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Container
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElContainer",
    props: {
        direction: {
            type: String,
            default: ""
        }
    },
    setup (props, { slots  }) {
        const ns = _indexMjs1.useNamespace("container");
        const isVertical = _vue.computed(()=>{
            if (props.direction === "vertical") return true;
            else if (props.direction === "horizontal") return false;
            if (slots && slots.default) {
                const vNodes = slots.default();
                return vNodes.some((vNode)=>{
                    const tag = vNode.type.name;
                    return tag === "ElHeader" || tag === "ElFooter";
                });
            } else return false;
        });
        return {
            isVertical,
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("section", {
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.is("vertical", _ctx.isVertical)
        ])
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 2);
}
var Container = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i79Ah":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Aside
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElAside",
    props: {
        width: {
            type: String,
            default: null
        }
    },
    setup (props) {
        const ns = _indexMjs1.useNamespace("aside");
        return {
            style: _vue.computed(()=>{
                return props.width ? {
                    "--el-aside-width": props.width
                } : {
                };
            }),
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("aside", {
        class: _vue.normalizeClass(_ctx.ns.b()),
        style: _vue.normalizeStyle(_ctx.style)
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 6);
}
var Aside = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"exuGN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Footer
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElFooter",
    props: {
        height: {
            type: String,
            default: null
        }
    },
    setup (props) {
        const ns = _indexMjs1.useNamespace("footer");
        return {
            style: _vue.computed(()=>props.height ? {
                    "--el-footer-height": props.height
                } : {
                }
            ),
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("footer", {
        class: _vue.normalizeClass(_ctx.ns.b()),
        style: _vue.normalizeStyle(_ctx.style)
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 6);
}
var Footer = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7yYcc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Header
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElHeader",
    props: {
        height: {
            type: String,
            default: null
        }
    },
    setup (props) {
        const ns = _indexMjs1.useNamespace("header");
        return {
            style: _vue.computed(()=>props.height ? {
                    "--el-header-height": props.height
                } : {
                }
            ),
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("header", {
        class: _vue.normalizeClass(_ctx.ns.b()),
        style: _vue.normalizeStyle(_ctx.style)
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 6);
}
var Header = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dyLi6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Main
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElMain",
    setup () {
        const ns = _indexMjs1.useNamespace("main");
        return {
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("main", {
        class: _vue.normalizeClass(_ctx.ns.b())
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 2);
}
var Main = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fdWz7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElDatePicker", ()=>ElDatePicker
);
parcelHelpers.export(exports, "default", ()=>_DatePicker
);
var _datePickerMjs = require("./src/date-picker.mjs");
var _datePickerMjsDefault = parcelHelpers.interopDefault(_datePickerMjs);
const _DatePicker = _datePickerMjsDefault.default;
_DatePicker.install = (app)=>{
    app.component(_DatePicker.name, _DatePicker);
};
const ElDatePicker = _DatePicker;

},{"./src/date-picker.mjs":"8FAsC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8FAsC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>DatePicker
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _customParseFormat = require("dayjs/plugin/customParseFormat");
var _customParseFormatDefault = parcelHelpers.interopDefault(_customParseFormat);
var _advancedFormat = require("dayjs/plugin/advancedFormat");
var _advancedFormatDefault = parcelHelpers.interopDefault(_advancedFormat);
var _localeData = require("dayjs/plugin/localeData");
var _localeDataDefault = parcelHelpers.interopDefault(_localeData);
var _weekOfYear = require("dayjs/plugin/weekOfYear");
var _weekOfYearDefault = parcelHelpers.interopDefault(_weekOfYear);
var _weekYear = require("dayjs/plugin/weekYear");
var _weekYearDefault = parcelHelpers.interopDefault(_weekYear);
var _dayOfYear = require("dayjs/plugin/dayOfYear");
var _dayOfYearDefault = parcelHelpers.interopDefault(_dayOfYear);
var _isSameOrAfter = require("dayjs/plugin/isSameOrAfter");
var _isSameOrAfterDefault = parcelHelpers.interopDefault(_isSameOrAfter);
var _isSameOrBefore = require("dayjs/plugin/isSameOrBefore");
var _isSameOrBeforeDefault = parcelHelpers.interopDefault(_isSameOrBefore);
var _indexMjs = require("../../time-picker/index.mjs");
var _panelDatePickMjs = require("./date-picker-com/panel-date-pick.mjs");
var _panelDatePickMjsDefault = parcelHelpers.interopDefault(_panelDatePickMjs);
var _panelDateRangeMjs = require("./date-picker-com/panel-date-range.mjs");
var _panelDateRangeMjsDefault = parcelHelpers.interopDefault(_panelDateRangeMjs);
var _panelMonthRangeMjs = require("./date-picker-com/panel-month-range.mjs");
var _panelMonthRangeMjsDefault = parcelHelpers.interopDefault(_panelMonthRangeMjs);
var _datePickerTypeMjs = require("./date-picker.type.mjs");
var _propsMjs = require("../../time-picker/src/common/props.mjs");
var _constantMjs = require("../../time-picker/src/common/constant.mjs");
var _pickerMjs = require("../../time-picker/src/common/picker.mjs");
var _pickerMjsDefault = parcelHelpers.interopDefault(_pickerMjs);
_dayjsDefault.default.extend(_localeDataDefault.default);
_dayjsDefault.default.extend(_advancedFormatDefault.default);
_dayjsDefault.default.extend(_customParseFormatDefault.default);
_dayjsDefault.default.extend(_weekOfYearDefault.default);
_dayjsDefault.default.extend(_weekYearDefault.default);
_dayjsDefault.default.extend(_dayOfYearDefault.default);
_dayjsDefault.default.extend(_isSameOrAfterDefault.default);
_dayjsDefault.default.extend(_isSameOrBeforeDefault.default);
const getPanel = function(type) {
    if (type === "daterange" || type === "datetimerange") return _panelDateRangeMjsDefault.default;
    else if (type === "monthrange") return _panelMonthRangeMjsDefault.default;
    return _panelDatePickMjsDefault.default;
};
var DatePicker = _vue.defineComponent({
    name: "ElDatePicker",
    install: null,
    props: {
        ..._propsMjs.timePickerDefaultProps,
        type: {
            type: String,
            default: "date"
        }
    },
    emits: [
        "update:modelValue"
    ],
    setup (props, ctx) {
        _vue.provide("ElPopperOptions", props.popperOptions);
        _vue.provide(_datePickerTypeMjs.ROOT_PICKER_INJECTION_KEY, {
            ctx
        });
        const commonPicker = _vue.ref(null);
        const refProps = {
            ...props,
            focus: (focusStartInput = true)=>{
                var _a;
                (_a = commonPicker.value) == null || _a.focus(focusStartInput);
            }
        };
        ctx.expose(refProps);
        return ()=>{
            var _a;
            const format = (_a = props.format) != null ? _a : _constantMjs.DEFAULT_FORMATS_DATEPICKER[props.type] || _constantMjs.DEFAULT_FORMATS_DATE;
            return _vue.h(_pickerMjsDefault.default, {
                ...props,
                format,
                type: props.type,
                ref: commonPicker,
                "onUpdate:modelValue": (value)=>ctx.emit("update:modelValue", value)
            }, {
                default: (scopedProps)=>_vue.h(getPanel(props.type), scopedProps)
                ,
                "range-separator": ()=>_vue.renderSlot(ctx.slots, "range-separator")
            });
        };
    }
});

},{"vue":"gzxs9","dayjs":"NJZFB","dayjs/plugin/customParseFormat":"dmrpe","dayjs/plugin/advancedFormat":"aH65B","dayjs/plugin/localeData":"31yM4","dayjs/plugin/weekOfYear":"eNun4","dayjs/plugin/weekYear":"f0tGO","dayjs/plugin/dayOfYear":"dJkxW","dayjs/plugin/isSameOrAfter":"3fKJ2","dayjs/plugin/isSameOrBefore":"2FuTZ","../../time-picker/index.mjs":"4TaeO","./date-picker-com/panel-date-pick.mjs":"8Xip5","./date-picker-com/panel-date-range.mjs":"iKuDr","./date-picker-com/panel-month-range.mjs":"fAsjC","./date-picker.type.mjs":"bezpf","../../time-picker/src/common/props.mjs":"gx1qH","../../time-picker/src/common/constant.mjs":"b75g0","../../time-picker/src/common/picker.mjs":"3jAyz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aH65B":[function(require,module,exports) {
!function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_advancedFormat = t();
}(this, function() {
    "use strict";
    return function(e1, t1, r1) {
        var n1 = t1.prototype, s = n1.format;
        r1.en.ordinal = function(e) {
            var t = [
                "th",
                "st",
                "nd",
                "rd"
            ], r = e % 100;
            return "[" + e + (t[(r - 20) % 10] || t[r] || t[0]) + "]";
        }, n1.format = function(e2) {
            var t = this, r = this.$locale();
            if (!this.isValid()) return s.bind(this)(e2);
            var n = this.$utils(), a = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e) {
                switch(e){
                    case "Q":
                        return Math.ceil((t.$M + 1) / 3);
                    case "Do":
                        return r.ordinal(t.$D);
                    case "gggg":
                        return t.weekYear();
                    case "GGGG":
                        return t.isoWeekYear();
                    case "wo":
                        return r.ordinal(t.week(), "W");
                    case "w":
                    case "ww":
                        return n.s(t.week(), "w" === e ? 1 : 2, "0");
                    case "W":
                    case "WW":
                        return n.s(t.isoWeek(), "W" === e ? 1 : 2, "0");
                    case "k":
                    case "kk":
                        return n.s(String(0 === t.$H ? 24 : t.$H), "k" === e ? 1 : 2, "0");
                    case "X":
                        return Math.floor(t.$d.getTime() / 1000);
                    case "x":
                        return t.$d.getTime();
                    case "z":
                        return "[" + t.offsetName() + "]";
                    case "zzz":
                        return "[" + t.offsetName("long") + "]";
                    default:
                        return e;
                }
            });
            return s.bind(this)(a);
        };
    };
});

},{}],"eNun4":[function(require,module,exports) {
!function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_weekOfYear = t();
}(this, function() {
    "use strict";
    var e1 = "week", t = "year";
    return function(i1, n1, r) {
        var f1 = n1.prototype;
        f1.week = function(i) {
            if (void 0 === i && (i = null), null !== i) return this.add(7 * (i - this.week()), "day");
            var n = this.$locale().yearStart || 1;
            if (11 === this.month() && this.date() > 25) {
                var f = r(this).startOf(t).add(1, t).date(n), s = r(this).endOf(e1);
                if (f.isBefore(s)) return 1;
            }
            var a = r(this).startOf(t).date(n).startOf(e1).subtract(1, "millisecond"), o = this.diff(a, e1, !0);
            return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
        }, f1.weeks = function(e) {
            return void 0 === e && (e = null), this.week(e);
        };
    };
});

},{}],"f0tGO":[function(require,module,exports) {
!function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_weekYear = t();
}(this, function() {
    "use strict";
    return function(e1, t1) {
        t1.prototype.weekYear = function() {
            var e = this.month(), t = this.week(), n = this.year();
            return 1 === t && 11 === e ? n + 1 : 0 === e && t >= 52 ? n - 1 : n;
        };
    };
});

},{}],"dJkxW":[function(require,module,exports) {
!function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_dayOfYear = t();
}(this, function() {
    "use strict";
    return function(e1, t1, n) {
        t1.prototype.dayOfYear = function(e) {
            var t = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 86400000) + 1;
            return null == e ? t : this.add(e - t, "day");
        };
    };
});

},{}],"3fKJ2":[function(require,module,exports) {
!function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_isSameOrAfter = t();
}(this, function() {
    "use strict";
    return function(e1, t1) {
        t1.prototype.isSameOrAfter = function(e, t) {
            return this.isSame(e, t) || this.isAfter(e, t);
        };
    };
});

},{}],"2FuTZ":[function(require,module,exports) {
!function(e, i) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_isSameOrBefore = i();
}(this, function() {
    "use strict";
    return function(e1, i1) {
        i1.prototype.isSameOrBefore = function(e, i) {
            return this.isSame(e, i) || this.isBefore(e, i);
        };
    };
});

},{}],"8Xip5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>DatePickPanel
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _indexMjs = require("../../../button/index.mjs");
var _indexMjs1 = require("../../../../directives/index.mjs");
var _indexMjs2 = require("../../../../hooks/index.mjs");
var _indexMjs3 = require("../../../input/index.mjs");
var _indexMjs4 = require("../../../time-picker/index.mjs");
var _indexMjs5 = require("../../../icon/index.mjs");
var _indexMjs6 = require("../../../../utils/index.mjs");
var _indexMjs7 = require("../../../../constants/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs8 = require("../../../tooltip/index.mjs");
var _basicDateTableMjs = require("./basic-date-table.mjs");
var _basicDateTableMjsDefault = parcelHelpers.interopDefault(_basicDateTableMjs);
var _basicMonthTableMjs = require("./basic-month-table.mjs");
var _basicMonthTableMjsDefault = parcelHelpers.interopDefault(_basicMonthTableMjs);
var _basicYearTableMjs = require("./basic-year-table.mjs");
var _basicYearTableMjsDefault = parcelHelpers.interopDefault(_basicYearTableMjs);
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _panelTimePickMjs = require("../../../time-picker/src/time-picker-com/panel-time-pick.mjs");
var _panelTimePickMjsDefault = parcelHelpers.interopDefault(_panelTimePickMjs);
var _indexMjs9 = require("../../../../directives/click-outside/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs9);
var _validatorMjs = require("../../../../utils/vue/validator.mjs");
var _indexMjs10 = require("../../../../hooks/use-locale/index.mjs");
var _tokensMjs = require("../../../tooltip/src/tokens.mjs");
var _dateUtilsMjs = require("../../../time-picker/src/common/date-utils.mjs");
var _ariaMjs = require("../../../../constants/aria.mjs");
const timeWithinRange = (_, __, ___)=>true
;
const _sfc_main = _vue.defineComponent({
    components: {
        DateTable: _basicDateTableMjsDefault.default,
        ElInput: _indexMjs3.ElInput,
        ElButton: _indexMjs.ElButton,
        ElIcon: _indexMjs5.ElIcon,
        TimePickPanel: _panelTimePickMjsDefault.default,
        MonthTable: _basicMonthTableMjsDefault.default,
        YearTable: _basicYearTableMjsDefault.default,
        DArrowLeft: _iconsVue.DArrowLeft,
        ArrowLeft: _iconsVue.ArrowLeft,
        DArrowRight: _iconsVue.DArrowRight,
        ArrowRight: _iconsVue.ArrowRight
    },
    directives: {
        clickoutside: _indexMjsDefault.default
    },
    props: {
        visible: {
            type: Boolean,
            default: false
        },
        parsedValue: {
            type: [
                Object,
                Array
            ]
        },
        format: {
            type: String,
            default: ""
        },
        type: {
            type: String,
            required: true,
            validator: _validatorMjs.isValidDatePickType
        }
    },
    emits: [
        "pick",
        "set-picker-option",
        "panel-change"
    ],
    setup (props, ctx) {
        const { t , lang  } = _indexMjs10.useLocale();
        const pickerBase = _vue.inject("EP_PICKER_BASE");
        const popper = _vue.inject(_tokensMjs.TOOLTIP_INJECTION_KEY);
        const { shortcuts , disabledDate , cellClassName , defaultTime , arrowControl  } = pickerBase.props;
        const defaultValue = _vue.toRef(pickerBase.props, "defaultValue");
        const innerDate = _vue.ref(_dayjsDefault.default().locale(lang.value));
        const defaultTimeD = _vue.computed(()=>{
            return _dayjsDefault.default(defaultTime).locale(lang.value);
        });
        const month = _vue.computed(()=>{
            return innerDate.value.month();
        });
        const year = _vue.computed(()=>{
            return innerDate.value.year();
        });
        const selectableRange = _vue.ref([]);
        const userInputDate = _vue.ref(null);
        const userInputTime = _vue.ref(null);
        const checkDateWithinRange = (date)=>{
            return selectableRange.value.length > 0 ? timeWithinRange(date, selectableRange.value, props.format || "HH:mm:ss") : true;
        };
        const formatEmit = (emitDayjs)=>{
            if (defaultTime && !visibleTime.value) return defaultTimeD.value.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
            if (showTime.value) return emitDayjs.millisecond(0);
            return emitDayjs.startOf("day");
        };
        const emit = (value, ...args)=>{
            if (!value) ctx.emit("pick", value, ...args);
            else if (Array.isArray(value)) {
                const dates = value.map(formatEmit);
                ctx.emit("pick", dates, ...args);
            } else ctx.emit("pick", formatEmit(value), ...args);
            userInputDate.value = null;
            userInputTime.value = null;
        };
        const handleDatePick = (value)=>{
            if (selectionMode.value === "day") {
                let newDate = props.parsedValue ? props.parsedValue.year(value.year()).month(value.month()).date(value.date()) : value;
                if (!checkDateWithinRange(newDate)) newDate = selectableRange.value[0][0].year(value.year()).month(value.month()).date(value.date());
                innerDate.value = newDate;
                emit(newDate, showTime.value);
            } else if (selectionMode.value === "week") emit(value.date);
            else if (selectionMode.value === "dates") emit(value, true);
        };
        const prevMonth_ = ()=>{
            innerDate.value = innerDate.value.subtract(1, "month");
            handlePanelChange("month");
        };
        const nextMonth_ = ()=>{
            innerDate.value = innerDate.value.add(1, "month");
            handlePanelChange("month");
        };
        const prevYear_ = ()=>{
            if (currentView.value === "year") innerDate.value = innerDate.value.subtract(10, "year");
            else innerDate.value = innerDate.value.subtract(1, "year");
            handlePanelChange("year");
        };
        const nextYear_ = ()=>{
            if (currentView.value === "year") innerDate.value = innerDate.value.add(10, "year");
            else innerDate.value = innerDate.value.add(1, "year");
            handlePanelChange("year");
        };
        const currentView = _vue.ref("date");
        const yearLabel = _vue.computed(()=>{
            const yearTranslation = t("el.datepicker.year");
            if (currentView.value === "year") {
                const startYear = Math.floor(year.value / 10) * 10;
                if (yearTranslation) return `${startYear} ${yearTranslation} - ${startYear + 9} ${yearTranslation}`;
                return `${startYear} - ${startYear + 9}`;
            }
            return `${year.value} ${yearTranslation}`;
        });
        const handleShortcutClick = (shortcut)=>{
            const shortcutValue = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
            if (shortcutValue) {
                emit(_dayjsDefault.default(shortcutValue).locale(lang.value));
                return;
            }
            if (shortcut.onClick) shortcut.onClick(ctx);
        };
        const selectionMode = _vue.computed(()=>{
            if ([
                "week",
                "month",
                "year",
                "dates"
            ].includes(props.type)) return props.type;
            return "day";
        });
        _vue.watch(()=>selectionMode.value
        , (val)=>{
            if ([
                "month",
                "year"
            ].includes(val)) {
                currentView.value = val;
                return;
            }
            currentView.value = "date";
        }, {
            immediate: true
        });
        _vue.watch(()=>currentView.value
        , ()=>{
            popper == null || popper.updatePopper();
        });
        const hasShortcuts = _vue.computed(()=>!!shortcuts.length
        );
        const handleMonthPick = (month2)=>{
            innerDate.value = innerDate.value.startOf("month").month(month2);
            if (selectionMode.value === "month") emit(innerDate.value);
            else currentView.value = "date";
            handlePanelChange("month");
        };
        const handleYearPick = (year2)=>{
            if (selectionMode.value === "year") {
                innerDate.value = innerDate.value.startOf("year").year(year2);
                emit(innerDate.value);
            } else {
                innerDate.value = innerDate.value.year(year2);
                currentView.value = "month";
            }
            handlePanelChange("year");
        };
        const showMonthPicker = ()=>{
            currentView.value = "month";
        };
        const showYearPicker = ()=>{
            currentView.value = "year";
        };
        const showTime = _vue.computed(()=>props.type === "datetime" || props.type === "datetimerange"
        );
        const footerVisible = _vue.computed(()=>{
            return showTime.value || selectionMode.value === "dates";
        });
        const onConfirm = ()=>{
            if (selectionMode.value === "dates") emit(props.parsedValue);
            else {
                let result = props.parsedValue;
                if (!result) {
                    const defaultTimeD2 = _dayjsDefault.default(defaultTime).locale(lang.value);
                    const defaultValueD = getDefaultValue();
                    result = defaultTimeD2.year(defaultValueD.year()).month(defaultValueD.month()).date(defaultValueD.date());
                }
                innerDate.value = result;
                emit(result);
            }
        };
        const changeToNow = ()=>{
            const now = _dayjsDefault.default().locale(lang.value);
            const nowDate = now.toDate();
            if ((!disabledDate || !disabledDate(nowDate)) && checkDateWithinRange(nowDate)) {
                innerDate.value = _dayjsDefault.default().locale(lang.value);
                emit(innerDate.value);
            }
        };
        const timeFormat = _vue.computed(()=>{
            return _dateUtilsMjs.extractTimeFormat(props.format);
        });
        const dateFormat = _vue.computed(()=>{
            return _dateUtilsMjs.extractDateFormat(props.format);
        });
        const visibleTime = _vue.computed(()=>{
            if (userInputTime.value) return userInputTime.value;
            if (!props.parsedValue && !defaultValue.value) return;
            return (props.parsedValue || innerDate.value).format(timeFormat.value);
        });
        const visibleDate = _vue.computed(()=>{
            if (userInputDate.value) return userInputDate.value;
            if (!props.parsedValue && !defaultValue.value) return;
            return (props.parsedValue || innerDate.value).format(dateFormat.value);
        });
        const timePickerVisible = _vue.ref(false);
        const onTimePickerInputFocus = ()=>{
            timePickerVisible.value = true;
        };
        const handleTimePickClose = ()=>{
            timePickerVisible.value = false;
        };
        const handleTimePick = (value, visible, first)=>{
            const newDate = props.parsedValue ? props.parsedValue.hour(value.hour()).minute(value.minute()).second(value.second()) : value;
            innerDate.value = newDate;
            emit(innerDate.value, true);
            if (!first) timePickerVisible.value = visible;
        };
        const handleVisibleTimeChange = (value)=>{
            const newDate = _dayjsDefault.default(value, timeFormat.value).locale(lang.value);
            if (newDate.isValid() && checkDateWithinRange(newDate)) {
                innerDate.value = newDate.year(innerDate.value.year()).month(innerDate.value.month()).date(innerDate.value.date());
                userInputTime.value = null;
                timePickerVisible.value = false;
                emit(innerDate.value, true);
            }
        };
        const handleVisibleDateChange = (value)=>{
            const newDate = _dayjsDefault.default(value, dateFormat.value).locale(lang.value);
            if (newDate.isValid()) {
                if (disabledDate && disabledDate(newDate.toDate())) return;
                innerDate.value = newDate.hour(innerDate.value.hour()).minute(innerDate.value.minute()).second(innerDate.value.second());
                userInputDate.value = null;
                emit(innerDate.value, true);
            }
        };
        const isValidValue = (date)=>{
            return _dayjsDefault.default.isDayjs(date) && date.isValid() && (disabledDate ? !disabledDate(date.toDate()) : true);
        };
        const formatToString = (value)=>{
            if (selectionMode.value === "dates") return value.map((_)=>_.format(props.format)
            );
            return value.format(props.format);
        };
        const parseUserInput = (value)=>{
            return _dayjsDefault.default(value, props.format).locale(lang.value);
        };
        const getDefaultValue = ()=>{
            const parseDate = _dayjsDefault.default(defaultValue.value).locale(lang.value);
            if (!defaultValue.value) {
                const defaultTimeDValue = defaultTimeD.value;
                return _dayjsDefault.default().hour(defaultTimeDValue.hour()).minute(defaultTimeDValue.minute()).second(defaultTimeDValue.second()).locale(lang.value);
            }
            return parseDate;
        };
        const handleKeydown = (event)=>{
            const { code , keyCode  } = event;
            const list = [
                _ariaMjs.EVENT_CODE.up,
                _ariaMjs.EVENT_CODE.down,
                _ariaMjs.EVENT_CODE.left,
                _ariaMjs.EVENT_CODE.right
            ];
            if (props.visible && !timePickerVisible.value) {
                if (list.includes(code)) {
                    handleKeyControl(keyCode);
                    event.stopPropagation();
                    event.preventDefault();
                }
                if (code === _ariaMjs.EVENT_CODE.enter && userInputDate.value === null && userInputTime.value === null) emit(innerDate, false);
            }
        };
        const handleKeyControl = (keyCode)=>{
            const mapping = {
                year: {
                    38: -4,
                    40: 4,
                    37: -1,
                    39: 1,
                    offset: (date, step)=>date.setFullYear(date.getFullYear() + step)
                },
                month: {
                    38: -4,
                    40: 4,
                    37: -1,
                    39: 1,
                    offset: (date, step)=>date.setMonth(date.getMonth() + step)
                },
                week: {
                    38: -1,
                    40: 1,
                    37: -1,
                    39: 1,
                    offset: (date, step)=>date.setDate(date.getDate() + step * 7)
                },
                day: {
                    38: -7,
                    40: 7,
                    37: -1,
                    39: 1,
                    offset: (date, step)=>date.setDate(date.getDate() + step)
                }
            };
            const newDate = innerDate.value.toDate();
            while(Math.abs(innerDate.value.diff(newDate, "year", true)) < 1){
                const map = mapping[selectionMode.value];
                map.offset(newDate, map[keyCode]);
                if (disabledDate && disabledDate(newDate)) continue;
                const result = _dayjsDefault.default(newDate).locale(lang.value);
                innerDate.value = result;
                ctx.emit("pick", result, true);
                break;
            }
        };
        const handlePanelChange = (mode)=>{
            ctx.emit("panel-change", innerDate.value.toDate(), mode, currentView.value);
        };
        ctx.emit("set-picker-option", [
            "isValidValue",
            isValidValue
        ]);
        ctx.emit("set-picker-option", [
            "formatToString",
            formatToString
        ]);
        ctx.emit("set-picker-option", [
            "parseUserInput",
            parseUserInput
        ]);
        ctx.emit("set-picker-option", [
            "handleKeydown",
            handleKeydown
        ]);
        _vue.watch(()=>defaultValue.value
        , (val)=>{
            if (val) innerDate.value = getDefaultValue();
        }, {
            immediate: true
        });
        _vue.watch(()=>props.parsedValue
        , (val)=>{
            if (val) {
                if (selectionMode.value === "dates") return;
                if (Array.isArray(val)) return;
                innerDate.value = val;
            } else innerDate.value = getDefaultValue();
        }, {
            immediate: true
        });
        return {
            handleTimePick,
            handleTimePickClose,
            onTimePickerInputFocus,
            timePickerVisible,
            visibleTime,
            visibleDate,
            showTime,
            changeToNow,
            onConfirm,
            footerVisible,
            handleYearPick,
            showMonthPicker,
            showYearPicker,
            handleMonthPick,
            hasShortcuts,
            shortcuts,
            arrowControl,
            disabledDate,
            cellClassName,
            selectionMode,
            handleShortcutClick,
            prevYear_,
            nextYear_,
            prevMonth_,
            nextMonth_,
            innerDate,
            t,
            yearLabel,
            currentView,
            month,
            handleDatePick,
            handleVisibleTimeChange,
            handleVisibleDateChange,
            timeFormat,
            userInputTime,
            userInputDate
        };
    }
});
const _hoisted_1 = {
    class: "el-picker-panel__body-wrapper"
};
const _hoisted_2 = {
    key: 0,
    class: "el-picker-panel__sidebar"
};
const _hoisted_3 = [
    "onClick"
];
const _hoisted_4 = {
    class: "el-picker-panel__body"
};
const _hoisted_5 = {
    key: 0,
    class: "el-date-picker__time-header"
};
const _hoisted_6 = {
    class: "el-date-picker__editor-wrap"
};
const _hoisted_7 = {
    class: "el-date-picker__editor-wrap"
};
const _hoisted_8 = [
    "aria-label"
];
const _hoisted_9 = [
    "aria-label"
];
const _hoisted_10 = [
    "aria-label"
];
const _hoisted_11 = [
    "aria-label"
];
const _hoisted_12 = {
    class: "el-picker-panel__content"
};
const _hoisted_13 = {
    class: "el-picker-panel__footer"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_input = _vue.resolveComponent("el-input");
    const _component_time_pick_panel = _vue.resolveComponent("time-pick-panel");
    const _component_d_arrow_left = _vue.resolveComponent("d-arrow-left");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_arrow_left = _vue.resolveComponent("arrow-left");
    const _component_d_arrow_right = _vue.resolveComponent("d-arrow-right");
    const _component_arrow_right = _vue.resolveComponent("arrow-right");
    const _component_date_table = _vue.resolveComponent("date-table");
    const _component_year_table = _vue.resolveComponent("year-table");
    const _component_month_table = _vue.resolveComponent("month-table");
    const _component_el_button = _vue.resolveComponent("el-button");
    const _directive_clickoutside = _vue.resolveDirective("clickoutside");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            "el-picker-panel el-date-picker",
            [
                {
                    "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts,
                    "has-time": _ctx.showTime
                }
            ]
        ])
    }, [
        _vue.createElementVNode("div", _hoisted_1, [
            _vue.renderSlot(_ctx.$slots, "sidebar", {
                class: "el-picker-panel__sidebar"
            }),
            _ctx.hasShortcuts ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_2, [
                (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.shortcuts, (shortcut, key)=>{
                    return _vue.openBlock(), _vue.createElementBlock("button", {
                        key,
                        type: "button",
                        class: "el-picker-panel__shortcut",
                        onClick: ($event)=>_ctx.handleShortcutClick(shortcut)
                    }, _vue.toDisplayString(shortcut.text), 9, _hoisted_3);
                }), 128))
            ])) : _vue.createCommentVNode("v-if", true),
            _vue.createElementVNode("div", _hoisted_4, [
                _ctx.showTime ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_5, [
                    _vue.createElementVNode("span", _hoisted_6, [
                        _vue.createVNode(_component_el_input, {
                            placeholder: _ctx.t("el.datepicker.selectDate"),
                            "model-value": _ctx.visibleDate,
                            size: "small",
                            onInput: _cache[0] || (_cache[0] = (val)=>_ctx.userInputDate = val
                            ),
                            onChange: _ctx.handleVisibleDateChange
                        }, null, 8, [
                            "placeholder",
                            "model-value",
                            "onChange"
                        ])
                    ]),
                    _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("span", _hoisted_7, [
                        _vue.createVNode(_component_el_input, {
                            placeholder: _ctx.t("el.datepicker.selectTime"),
                            "model-value": _ctx.visibleTime,
                            size: "small",
                            onFocus: _ctx.onTimePickerInputFocus,
                            onInput: _cache[1] || (_cache[1] = (val)=>_ctx.userInputTime = val
                            ),
                            onChange: _ctx.handleVisibleTimeChange
                        }, null, 8, [
                            "placeholder",
                            "model-value",
                            "onFocus",
                            "onChange"
                        ]),
                        _vue.createVNode(_component_time_pick_panel, {
                            visible: _ctx.timePickerVisible,
                            format: _ctx.timeFormat,
                            "time-arrow-control": _ctx.arrowControl,
                            "parsed-value": _ctx.innerDate,
                            onPick: _ctx.handleTimePick
                        }, null, 8, [
                            "visible",
                            "format",
                            "time-arrow-control",
                            "parsed-value",
                            "onPick"
                        ])
                    ])), [
                        [
                            _directive_clickoutside,
                            _ctx.handleTimePickClose
                        ]
                    ])
                ])) : _vue.createCommentVNode("v-if", true),
                _vue.withDirectives(_vue.createElementVNode("div", {
                    class: _vue.normalizeClass([
                        "el-date-picker__header",
                        {
                            "el-date-picker__header--bordered": _ctx.currentView === "year" || _ctx.currentView === "month"
                        }
                    ])
                }, [
                    _vue.createElementVNode("button", {
                        type: "button",
                        "aria-label": _ctx.t(`el.datepicker.prevYear`),
                        class: "el-picker-panel__icon-btn el-date-picker__prev-btn d-arrow-left",
                        onClick: _cache[2] || (_cache[2] = (...args)=>_ctx.prevYear_ && _ctx.prevYear_(...args)
                        )
                    }, [
                        _vue.createVNode(_component_el_icon, null, {
                            default: _vue.withCtx(()=>[
                                    _vue.createVNode(_component_d_arrow_left)
                                ]
                            ),
                            _: 1
                        })
                    ], 8, _hoisted_8),
                    _vue.withDirectives(_vue.createElementVNode("button", {
                        type: "button",
                        "aria-label": _ctx.t(`el.datepicker.prevMonth`),
                        class: "el-picker-panel__icon-btn el-date-picker__prev-btn arrow-left",
                        onClick: _cache[3] || (_cache[3] = (...args)=>_ctx.prevMonth_ && _ctx.prevMonth_(...args)
                        )
                    }, [
                        _vue.createVNode(_component_el_icon, null, {
                            default: _vue.withCtx(()=>[
                                    _vue.createVNode(_component_arrow_left)
                                ]
                            ),
                            _: 1
                        })
                    ], 8, _hoisted_9), [
                        [
                            _vue.vShow,
                            _ctx.currentView === "date"
                        ]
                    ]),
                    _vue.createElementVNode("span", {
                        role: "button",
                        class: "el-date-picker__header-label",
                        onClick: _cache[4] || (_cache[4] = (...args)=>_ctx.showYearPicker && _ctx.showYearPicker(...args)
                        )
                    }, _vue.toDisplayString(_ctx.yearLabel), 1),
                    _vue.withDirectives(_vue.createElementVNode("span", {
                        role: "button",
                        class: _vue.normalizeClass([
                            "el-date-picker__header-label",
                            {
                                active: _ctx.currentView === "month"
                            }
                        ]),
                        onClick: _cache[5] || (_cache[5] = (...args)=>_ctx.showMonthPicker && _ctx.showMonthPicker(...args)
                        )
                    }, _vue.toDisplayString(_ctx.t(`el.datepicker.month${_ctx.month + 1}`)), 3), [
                        [
                            _vue.vShow,
                            _ctx.currentView === "date"
                        ]
                    ]),
                    _vue.createElementVNode("button", {
                        type: "button",
                        "aria-label": _ctx.t(`el.datepicker.nextYear`),
                        class: "el-picker-panel__icon-btn el-date-picker__next-btn d-arrow-right",
                        onClick: _cache[6] || (_cache[6] = (...args)=>_ctx.nextYear_ && _ctx.nextYear_(...args)
                        )
                    }, [
                        _vue.createVNode(_component_el_icon, null, {
                            default: _vue.withCtx(()=>[
                                    _vue.createVNode(_component_d_arrow_right)
                                ]
                            ),
                            _: 1
                        })
                    ], 8, _hoisted_10),
                    _vue.withDirectives(_vue.createElementVNode("button", {
                        type: "button",
                        "aria-label": _ctx.t(`el.datepicker.nextMonth`),
                        class: "el-picker-panel__icon-btn el-date-picker__next-btn arrow-right",
                        onClick: _cache[7] || (_cache[7] = (...args)=>_ctx.nextMonth_ && _ctx.nextMonth_(...args)
                        )
                    }, [
                        _vue.createVNode(_component_el_icon, null, {
                            default: _vue.withCtx(()=>[
                                    _vue.createVNode(_component_arrow_right)
                                ]
                            ),
                            _: 1
                        })
                    ], 8, _hoisted_11), [
                        [
                            _vue.vShow,
                            _ctx.currentView === "date"
                        ]
                    ])
                ], 2), [
                    [
                        _vue.vShow,
                        _ctx.currentView !== "time"
                    ]
                ]),
                _vue.createElementVNode("div", _hoisted_12, [
                    _ctx.currentView === "date" ? (_vue.openBlock(), _vue.createBlock(_component_date_table, {
                        key: 0,
                        "selection-mode": _ctx.selectionMode,
                        date: _ctx.innerDate,
                        "parsed-value": _ctx.parsedValue,
                        "disabled-date": _ctx.disabledDate,
                        onPick: _ctx.handleDatePick
                    }, null, 8, [
                        "selection-mode",
                        "date",
                        "parsed-value",
                        "disabled-date",
                        "onPick"
                    ])) : _vue.createCommentVNode("v-if", true),
                    _ctx.currentView === "year" ? (_vue.openBlock(), _vue.createBlock(_component_year_table, {
                        key: 1,
                        date: _ctx.innerDate,
                        "disabled-date": _ctx.disabledDate,
                        "parsed-value": _ctx.parsedValue,
                        onPick: _ctx.handleYearPick
                    }, null, 8, [
                        "date",
                        "disabled-date",
                        "parsed-value",
                        "onPick"
                    ])) : _vue.createCommentVNode("v-if", true),
                    _ctx.currentView === "month" ? (_vue.openBlock(), _vue.createBlock(_component_month_table, {
                        key: 2,
                        date: _ctx.innerDate,
                        "parsed-value": _ctx.parsedValue,
                        "disabled-date": _ctx.disabledDate,
                        onPick: _ctx.handleMonthPick
                    }, null, 8, [
                        "date",
                        "parsed-value",
                        "disabled-date",
                        "onPick"
                    ])) : _vue.createCommentVNode("v-if", true)
                ])
            ])
        ]),
        _vue.withDirectives(_vue.createElementVNode("div", _hoisted_13, [
            _vue.withDirectives(_vue.createVNode(_component_el_button, {
                size: "small",
                type: "text",
                class: "el-picker-panel__link-btn",
                onClick: _ctx.changeToNow
            }, {
                default: _vue.withCtx(()=>[
                        _vue.createTextVNode(_vue.toDisplayString(_ctx.t("el.datepicker.now")), 1)
                    ]
                ),
                _: 1
            }, 8, [
                "onClick"
            ]), [
                [
                    _vue.vShow,
                    _ctx.selectionMode !== "dates"
                ]
            ]),
            _vue.createVNode(_component_el_button, {
                plain: "",
                size: "small",
                class: "el-picker-panel__link-btn",
                onClick: _ctx.onConfirm
            }, {
                default: _vue.withCtx(()=>[
                        _vue.createTextVNode(_vue.toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
                    ]
                ),
                _: 1
            }, 8, [
                "onClick"
            ])
        ], 512), [
            [
                _vue.vShow,
                _ctx.footerVisible && _ctx.currentView === "date"
            ]
        ])
    ], 2);
}
var DatePickPanel = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","dayjs":"NJZFB","../../../button/index.mjs":"64Ym1","../../../../directives/index.mjs":"aRbJ2","../../../../hooks/index.mjs":"1Ansp","../../../input/index.mjs":"18eQI","../../../time-picker/index.mjs":"4TaeO","../../../icon/index.mjs":"hnNTG","../../../../utils/index.mjs":"dsdeP","../../../../constants/index.mjs":"74Fbn","@element-plus/icons-vue":"b18uu","../../../tooltip/index.mjs":"kiwBC","./basic-date-table.mjs":"nCvua","./basic-month-table.mjs":"dp2xC","./basic-year-table.mjs":"ikGGQ","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../time-picker/src/time-picker-com/panel-time-pick.mjs":"351Kw","../../../../directives/click-outside/index.mjs":"cdlLW","../../../../utils/vue/validator.mjs":"4UnBa","../../../../hooks/use-locale/index.mjs":"c1HoA","../../../tooltip/src/tokens.mjs":"a6G79","../../../time-picker/src/common/date-utils.mjs":"3CJdm","../../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"nCvua":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>DateTable
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _indexMjs = require("../../../../hooks/index.mjs");
var _indexMjs1 = require("../../../../utils/index.mjs");
var _basicCellRenderMjs = require("./basic-cell-render.mjs");
var _basicCellRenderMjsDefault = parcelHelpers.interopDefault(_basicCellRenderMjs);
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../../hooks/use-locale/index.mjs");
var _arraysMjs = require("../../../../utils/arrays.mjs");
const _sfc_main = _vue.defineComponent({
    components: {
        ElDatePickerCell: _basicCellRenderMjsDefault.default
    },
    props: {
        date: {
            type: Object
        },
        minDate: {
            type: Object
        },
        maxDate: {
            type: Object
        },
        parsedValue: {
            type: [
                Object,
                Array
            ]
        },
        selectionMode: {
            type: String,
            default: "day"
        },
        showWeekNumber: {
            type: Boolean,
            default: false
        },
        disabledDate: {
            type: Function
        },
        cellClassName: {
            type: Function
        },
        rangeState: {
            type: Object,
            default: ()=>({
                    endDate: null,
                    selecting: false
                })
        }
    },
    emits: [
        "changerange",
        "pick",
        "select"
    ],
    setup (props, ctx) {
        const { t , lang  } = _indexMjs2.useLocale();
        const lastRow = _vue.ref(null);
        const lastColumn = _vue.ref(null);
        const tableRows = _vue.ref([
            [],
            [],
            [],
            [],
            [],
            []
        ]);
        const firstDayOfWeek = props.date.$locale().weekStart || 7;
        const WEEKS_CONSTANT = props.date.locale("en").localeData().weekdaysShort().map((_)=>_.toLowerCase()
        );
        const offsetDay = _vue.computed(()=>{
            return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
        });
        const startDate = _vue.computed(()=>{
            const startDayOfMonth = props.date.startOf("month");
            return startDayOfMonth.subtract(startDayOfMonth.day() || 7, "day");
        });
        const WEEKS = _vue.computed(()=>{
            return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);
        });
        const rows = _vue.computed(()=>{
            var _a;
            const startOfMonth = props.date.startOf("month");
            const startOfMonthDay = startOfMonth.day() || 7;
            const dateCountOfMonth = startOfMonth.daysInMonth();
            const dateCountOfLastMonth = startOfMonth.subtract(1, "month").daysInMonth();
            const offset = offsetDay.value;
            const rows_ = tableRows.value;
            let count = 1;
            const selectedDate = props.selectionMode === "dates" ? _arraysMjs.castArray(props.parsedValue) : [];
            const calNow = _dayjsDefault.default().locale(lang.value).startOf("day");
            for(let i = 0; i < 6; i++){
                const row = rows_[i];
                if (props.showWeekNumber) {
                    if (!row[0]) row[0] = {
                        type: "week",
                        text: startDate.value.add(i * 7 + 1, "day").week()
                    };
                }
                for(let j = 0; j < 7; j++){
                    let cell = row[props.showWeekNumber ? j + 1 : j];
                    if (!cell) cell = {
                        row: i,
                        column: j,
                        type: "normal",
                        inRange: false,
                        start: false,
                        end: false
                    };
                    const index = i * 7 + j;
                    const calTime = startDate.value.add(index - offset, "day");
                    cell.dayjs = calTime;
                    cell.date = calTime.toDate();
                    cell.timestamp = calTime.valueOf();
                    cell.type = "normal";
                    const calEndDate = props.rangeState.endDate || props.maxDate || props.rangeState.selecting && props.minDate;
                    cell.inRange = props.minDate && calTime.isSameOrAfter(props.minDate, "day") && calEndDate && calTime.isSameOrBefore(calEndDate, "day") || props.minDate && calTime.isSameOrBefore(props.minDate, "day") && calEndDate && calTime.isSameOrAfter(calEndDate, "day");
                    if ((_a = props.minDate) == null ? void 0 : _a.isSameOrAfter(calEndDate)) {
                        cell.start = calEndDate && calTime.isSame(calEndDate, "day");
                        cell.end = props.minDate && calTime.isSame(props.minDate, "day");
                    } else {
                        cell.start = props.minDate && calTime.isSame(props.minDate, "day");
                        cell.end = calEndDate && calTime.isSame(calEndDate, "day");
                    }
                    const isToday = calTime.isSame(calNow, "day");
                    if (isToday) cell.type = "today";
                    if (i >= 0 && i <= 1) {
                        const numberOfDaysFromPreviousMonth = startOfMonthDay + offset < 0 ? 7 + startOfMonthDay + offset : startOfMonthDay + offset;
                        if (j + i * 7 >= numberOfDaysFromPreviousMonth) cell.text = count++;
                        else {
                            cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - j % 7) + 1 + i * 7;
                            cell.type = "prev-month";
                        }
                    } else if (count <= dateCountOfMonth) cell.text = count++;
                    else {
                        cell.text = (count++) - dateCountOfMonth;
                        cell.type = "next-month";
                    }
                    const cellDate = calTime.toDate();
                    cell.selected = selectedDate.find((_)=>_.valueOf() === calTime.valueOf()
                    );
                    cell.isSelected = !!cell.selected;
                    cell.isCurrent = isCurrent(cell);
                    cell.disabled = props.disabledDate && props.disabledDate(cellDate);
                    cell.customClass = props.cellClassName && props.cellClassName(cellDate);
                    row[props.showWeekNumber ? j + 1 : j] = cell;
                }
                if (props.selectionMode === "week") {
                    const start = props.showWeekNumber ? 1 : 0;
                    const end = props.showWeekNumber ? 7 : 6;
                    const isActive = isWeekActive(row[start + 1]);
                    row[start].inRange = isActive;
                    row[start].start = isActive;
                    row[end].inRange = isActive;
                    row[end].end = isActive;
                }
            }
            return rows_;
        });
        const isCurrent = (cell)=>{
            return props.selectionMode === "day" && (cell.type === "normal" || cell.type === "today") && cellMatchesDate(cell, props.parsedValue);
        };
        const cellMatchesDate = (cell, date)=>{
            if (!date) return false;
            return _dayjsDefault.default(date).locale(lang.value).isSame(props.date.date(Number(cell.text)), "day");
        };
        const getCellClasses = (cell)=>{
            const classes = [];
            if ((cell.type === "normal" || cell.type === "today") && !cell.disabled) {
                classes.push("available");
                if (cell.type === "today") classes.push("today");
            } else classes.push(cell.type);
            if (isCurrent(cell)) classes.push("current");
            if (cell.inRange && (cell.type === "normal" || cell.type === "today" || props.selectionMode === "week")) {
                classes.push("in-range");
                if (cell.start) classes.push("start-date");
                if (cell.end) classes.push("end-date");
            }
            if (cell.disabled) classes.push("disabled");
            if (cell.selected) classes.push("selected");
            if (cell.customClass) classes.push(cell.customClass);
            return classes.join(" ");
        };
        const getDateOfCell = (row, column)=>{
            const offsetFromStart = row * 7 + (column - (props.showWeekNumber ? 1 : 0)) - offsetDay.value;
            return startDate.value.add(offsetFromStart, "day");
        };
        const handleMouseMove = (event)=>{
            if (!props.rangeState.selecting) return;
            let target = event.target;
            if (target.tagName === "SPAN") target = target.parentNode.parentNode;
            if (target.tagName === "DIV") target = target.parentNode;
            if (target.tagName !== "TD") return;
            const row = target.parentNode.rowIndex - 1;
            const column = target.cellIndex;
            if (rows.value[row][column].disabled) return;
            if (row !== lastRow.value || column !== lastColumn.value) {
                lastRow.value = row;
                lastColumn.value = column;
                ctx.emit("changerange", {
                    selecting: true,
                    endDate: getDateOfCell(row, column)
                });
            }
        };
        const handleClick = (event)=>{
            let target = event.target;
            while(target){
                if (target.tagName === "TD") break;
                target = target.parentNode;
            }
            if (!target || target.tagName !== "TD") return;
            const row = target.parentNode.rowIndex - 1;
            const column = target.cellIndex;
            const cell = rows.value[row][column];
            if (cell.disabled || cell.type === "week") return;
            const newDate = getDateOfCell(row, column);
            if (props.selectionMode === "range") {
                if (!props.rangeState.selecting) {
                    ctx.emit("pick", {
                        minDate: newDate,
                        maxDate: null
                    });
                    ctx.emit("select", true);
                } else {
                    if (newDate >= props.minDate) ctx.emit("pick", {
                        minDate: props.minDate,
                        maxDate: newDate
                    });
                    else ctx.emit("pick", {
                        minDate: newDate,
                        maxDate: props.minDate
                    });
                    ctx.emit("select", false);
                }
            } else if (props.selectionMode === "day") ctx.emit("pick", newDate);
            else if (props.selectionMode === "week") {
                const weekNumber = newDate.week();
                const value = `${newDate.year()}w${weekNumber}`;
                ctx.emit("pick", {
                    year: newDate.year(),
                    week: weekNumber,
                    value,
                    date: newDate.startOf("week")
                });
            } else if (props.selectionMode === "dates") {
                const newValue = cell.selected ? _arraysMjs.castArray(props.parsedValue).filter((_)=>_.valueOf() !== newDate.valueOf()
                ) : _arraysMjs.castArray(props.parsedValue).concat([
                    newDate
                ]);
                ctx.emit("pick", newValue);
            }
        };
        const isWeekActive = (cell)=>{
            if (props.selectionMode !== "week") return false;
            let newDate = props.date.startOf("day");
            if (cell.type === "prev-month") newDate = newDate.subtract(1, "month");
            if (cell.type === "next-month") newDate = newDate.add(1, "month");
            newDate = newDate.date(parseInt(cell.text, 10));
            if (props.parsedValue && !Array.isArray(props.parsedValue)) {
                const dayOffset = (props.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;
                const weekDate = props.parsedValue.subtract(dayOffset, "day");
                return weekDate.isSame(newDate, "day");
            }
            return false;
        };
        return {
            handleMouseMove,
            t,
            rows,
            isWeekActive,
            getCellClasses,
            WEEKS,
            handleClick
        };
    }
});
const _hoisted_1 = {
    key: 0
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_date_picker_cell = _vue.resolveComponent("el-date-picker-cell");
    return _vue.openBlock(), _vue.createElementBlock("table", {
        cellspacing: "0",
        cellpadding: "0",
        class: _vue.normalizeClass([
            "el-date-table",
            {
                "is-week-mode": _ctx.selectionMode === "week"
            }
        ]),
        onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleClick && _ctx.handleClick(...args)
        ),
        onMousemove: _cache[1] || (_cache[1] = (...args)=>_ctx.handleMouseMove && _ctx.handleMouseMove(...args)
        )
    }, [
        _vue.createElementVNode("tbody", null, [
            _vue.createElementVNode("tr", null, [
                _ctx.showWeekNumber ? (_vue.openBlock(), _vue.createElementBlock("th", _hoisted_1, _vue.toDisplayString(_ctx.t("el.datepicker.week")), 1)) : _vue.createCommentVNode("v-if", true),
                (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.WEEKS, (week, key)=>{
                    return _vue.openBlock(), _vue.createElementBlock("th", {
                        key
                    }, _vue.toDisplayString(_ctx.t("el.datepicker.weeks." + week)), 1);
                }), 128))
            ]),
            (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.rows, (row, key)=>{
                return _vue.openBlock(), _vue.createElementBlock("tr", {
                    key,
                    class: _vue.normalizeClass([
                        "el-date-table__row",
                        {
                            current: _ctx.isWeekActive(row[1])
                        }
                    ])
                }, [
                    (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(row, (cell, key_)=>{
                        return _vue.openBlock(), _vue.createElementBlock("td", {
                            key: key_,
                            class: _vue.normalizeClass(_ctx.getCellClasses(cell))
                        }, [
                            _vue.createVNode(_component_el_date_picker_cell, {
                                cell
                            }, null, 8, [
                                "cell"
                            ])
                        ], 2);
                    }), 128))
                ], 2);
            }), 128))
        ])
    ], 34);
}
var DateTable = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","dayjs":"NJZFB","../../../../hooks/index.mjs":"1Ansp","../../../../utils/index.mjs":"dsdeP","./basic-cell-render.mjs":"hNfy1","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../hooks/use-locale/index.mjs":"c1HoA","../../../../utils/arrays.mjs":"e9h0v","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hNfy1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElDatePickerCell
);
var _vue = require("vue");
var _indexMjs = require("../../../../utils/index.mjs");
var _datePickerTypeMjs = require("../date-picker.type.mjs");
var _propsMjs = require("../../../../utils/vue/props.mjs");
var ElDatePickerCell = _vue.defineComponent({
    name: "ElDatePickerCell",
    props: _propsMjs.buildProps({
        cell: {
            type: _propsMjs.definePropType(Object)
        }
    }),
    setup (props) {
        const picker = _vue.inject(_datePickerTypeMjs.ROOT_PICKER_INJECTION_KEY);
        return ()=>{
            const cell = props.cell;
            if (picker == null ? void 0 : picker.ctx.slots.default) {
                const list = picker.ctx.slots.default(cell).filter((item)=>{
                    return item.patchFlag !== -2 && item.type.toString() !== "Symbol(Comment)";
                });
                if (list.length) return list;
            }
            return _vue.h("div", {
                class: "el-date-table-cell"
            }, [
                _vue.h("span", {
                    class: "el-date-table-cell__text"
                }, [
                    cell == null ? void 0 : cell.text
                ])
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../../utils/index.mjs":"dsdeP","../date-picker.type.mjs":"bezpf","../../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bezpf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ROOT_PICKER_INJECTION_KEY", ()=>ROOT_PICKER_INJECTION_KEY
);
const ROOT_PICKER_INJECTION_KEY = Symbol();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dp2xC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>MonthTable
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _indexMjs = require("../../../../hooks/index.mjs");
var _indexMjs1 = require("../../../time-picker/index.mjs");
var _indexMjs2 = require("../../../../utils/index.mjs");
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _dateUtilsMjs = require("../../../time-picker/src/common/date-utils.mjs");
var _indexMjs3 = require("../../../../hooks/use-locale/index.mjs");
var _arraysMjs = require("../../../../utils/arrays.mjs");
var _styleMjs = require("../../../../utils/dom/style.mjs");
const datesInMonth = (year, month, lang)=>{
    const firstDay = _dayjsDefault.default().locale(lang).startOf("month").month(month).year(year);
    const numOfDays = firstDay.daysInMonth();
    return _dateUtilsMjs.rangeArr(numOfDays).map((n)=>firstDay.add(n, "day").toDate()
    );
};
const _sfc_main = _vue.defineComponent({
    props: {
        disabledDate: {
            type: Function
        },
        selectionMode: {
            type: String,
            default: "month"
        },
        minDate: {
            type: Object
        },
        maxDate: {
            type: Object
        },
        date: {
            type: Object
        },
        parsedValue: {
            type: Object
        },
        rangeState: {
            type: Object,
            default: ()=>({
                    endDate: null,
                    selecting: false
                })
        }
    },
    emits: [
        "changerange",
        "pick",
        "select"
    ],
    setup (props, ctx) {
        const { t , lang  } = _indexMjs3.useLocale();
        const months = _vue.ref(props.date.locale("en").localeData().monthsShort().map((_)=>_.toLowerCase()
        ));
        const tableRows = _vue.ref([
            [],
            [],
            []
        ]);
        const lastRow = _vue.ref(null);
        const lastColumn = _vue.ref(null);
        const rows = _vue.computed(()=>{
            var _a;
            const rows2 = tableRows.value;
            const now = _dayjsDefault.default().locale(lang.value).startOf("month");
            for(let i = 0; i < 3; i++){
                const row = rows2[i];
                for(let j = 0; j < 4; j++){
                    let cell = row[j];
                    if (!cell) cell = {
                        row: i,
                        column: j,
                        type: "normal",
                        inRange: false,
                        start: false,
                        end: false
                    };
                    cell.type = "normal";
                    const index = i * 4 + j;
                    const calTime = props.date.startOf("year").month(index);
                    const calEndDate = props.rangeState.endDate || props.maxDate || props.rangeState.selecting && props.minDate;
                    cell.inRange = props.minDate && calTime.isSameOrAfter(props.minDate, "month") && calEndDate && calTime.isSameOrBefore(calEndDate, "month") || props.minDate && calTime.isSameOrBefore(props.minDate, "month") && calEndDate && calTime.isSameOrAfter(calEndDate, "month");
                    if ((_a = props.minDate) == null ? void 0 : _a.isSameOrAfter(calEndDate)) {
                        cell.start = calEndDate && calTime.isSame(calEndDate, "month");
                        cell.end = props.minDate && calTime.isSame(props.minDate, "month");
                    } else {
                        cell.start = props.minDate && calTime.isSame(props.minDate, "month");
                        cell.end = calEndDate && calTime.isSame(calEndDate, "month");
                    }
                    const isToday = now.isSame(calTime);
                    if (isToday) cell.type = "today";
                    cell.text = index;
                    const cellDate = calTime.toDate();
                    cell.disabled = props.disabledDate && props.disabledDate(cellDate);
                    row[j] = cell;
                }
            }
            return rows2;
        });
        const getCellStyle = (cell)=>{
            const style = {
            };
            const year = props.date.year();
            const today = new Date();
            const month = cell.text;
            style.disabled = props.disabledDate ? datesInMonth(year, month, lang.value).every(props.disabledDate) : false;
            style.current = _arraysMjs.castArray(props.parsedValue).findIndex((date)=>date.year() === year && date.month() === month
            ) >= 0;
            style.today = today.getFullYear() === year && today.getMonth() === month;
            if (cell.inRange) {
                style["in-range"] = true;
                if (cell.start) style["start-date"] = true;
                if (cell.end) style["end-date"] = true;
            }
            return style;
        };
        const handleMouseMove = (event)=>{
            if (!props.rangeState.selecting) return;
            let target = event.target;
            if (target.tagName === "A") target = target.parentNode.parentNode;
            if (target.tagName === "DIV") target = target.parentNode;
            if (target.tagName !== "TD") return;
            const row = target.parentNode.rowIndex;
            const column = target.cellIndex;
            if (rows.value[row][column].disabled) return;
            if (row !== lastRow.value || column !== lastColumn.value) {
                lastRow.value = row;
                lastColumn.value = column;
                ctx.emit("changerange", {
                    selecting: true,
                    endDate: props.date.startOf("year").month(row * 4 + column)
                });
            }
        };
        const handleMonthTableClick = (event)=>{
            let target = event.target;
            if (target.tagName === "A") target = target.parentNode.parentNode;
            if (target.tagName === "DIV") target = target.parentNode;
            if (target.tagName !== "TD") return;
            if (_styleMjs.hasClass(target, "disabled")) return;
            const column = target.cellIndex;
            const row = target.parentNode.rowIndex;
            const month = row * 4 + column;
            const newDate = props.date.startOf("year").month(month);
            if (props.selectionMode === "range") {
                if (!props.rangeState.selecting) {
                    ctx.emit("pick", {
                        minDate: newDate,
                        maxDate: null
                    });
                    ctx.emit("select", true);
                } else {
                    if (newDate >= props.minDate) ctx.emit("pick", {
                        minDate: props.minDate,
                        maxDate: newDate
                    });
                    else ctx.emit("pick", {
                        minDate: newDate,
                        maxDate: props.minDate
                    });
                    ctx.emit("select", false);
                }
            } else ctx.emit("pick", month);
        };
        return {
            handleMouseMove,
            handleMonthTableClick,
            rows,
            getCellStyle,
            t,
            months
        };
    }
});
const _hoisted_1 = {
    class: "cell"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("table", {
        class: "el-month-table",
        onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleMonthTableClick && _ctx.handleMonthTableClick(...args)
        ),
        onMousemove: _cache[1] || (_cache[1] = (...args)=>_ctx.handleMouseMove && _ctx.handleMouseMove(...args)
        )
    }, [
        _vue.createElementVNode("tbody", null, [
            (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.rows, (row, key)=>{
                return _vue.openBlock(), _vue.createElementBlock("tr", {
                    key
                }, [
                    (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(row, (cell, key_)=>{
                        return _vue.openBlock(), _vue.createElementBlock("td", {
                            key: key_,
                            class: _vue.normalizeClass(_ctx.getCellStyle(cell))
                        }, [
                            _vue.createElementVNode("div", null, [
                                _vue.createElementVNode("a", _hoisted_1, _vue.toDisplayString(_ctx.t("el.datepicker.months." + _ctx.months[cell.text])), 1)
                            ])
                        ], 2);
                    }), 128))
                ]);
            }), 128))
        ])
    ], 32);
}
var MonthTable = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","dayjs":"NJZFB","../../../../hooks/index.mjs":"1Ansp","../../../time-picker/index.mjs":"4TaeO","../../../../utils/index.mjs":"dsdeP","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../time-picker/src/common/date-utils.mjs":"3CJdm","../../../../hooks/use-locale/index.mjs":"c1HoA","../../../../utils/arrays.mjs":"e9h0v","../../../../utils/dom/style.mjs":"cA8Mp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ikGGQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>YearTable
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _indexMjs = require("../../../../hooks/index.mjs");
var _indexMjs1 = require("../../../time-picker/index.mjs");
var _indexMjs2 = require("../../../../utils/index.mjs");
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _dateUtilsMjs = require("../../../time-picker/src/common/date-utils.mjs");
var _indexMjs3 = require("../../../../hooks/use-locale/index.mjs");
var _arraysMjs = require("../../../../utils/arrays.mjs");
var _styleMjs = require("../../../../utils/dom/style.mjs");
const datesInYear = (year, lang)=>{
    const firstDay = _dayjsDefault.default(String(year)).locale(lang).startOf("year");
    const lastDay = firstDay.endOf("year");
    const numOfDays = lastDay.dayOfYear();
    return _dateUtilsMjs.rangeArr(numOfDays).map((n)=>firstDay.add(n, "day").toDate()
    );
};
const _sfc_main = _vue.defineComponent({
    props: {
        disabledDate: {
            type: Function
        },
        parsedValue: {
            type: Object
        },
        date: {
            type: Object
        }
    },
    emits: [
        "pick"
    ],
    setup (props, ctx) {
        const { lang  } = _indexMjs3.useLocale();
        const startYear = _vue.computed(()=>{
            return Math.floor(props.date.year() / 10) * 10;
        });
        const getCellStyle = (year)=>{
            const style = {
            };
            const today = _dayjsDefault.default().locale(lang.value);
            style.disabled = props.disabledDate ? datesInYear(year, lang.value).every(props.disabledDate) : false;
            style.current = _arraysMjs.castArray(props.parsedValue).findIndex((_)=>_.year() === year
            ) >= 0;
            style.today = today.year() === year;
            return style;
        };
        const handleYearTableClick = (event)=>{
            const target = event.target;
            if (target.tagName === "A") {
                if (_styleMjs.hasClass(target.parentNode, "disabled")) return;
                const year = target.textContent || target.innerText;
                ctx.emit("pick", Number(year));
            }
        };
        return {
            startYear,
            getCellStyle,
            handleYearTableClick
        };
    }
});
const _hoisted_1 = {
    class: "cell"
};
const _hoisted_2 = {
    class: "cell"
};
const _hoisted_3 = {
    class: "cell"
};
const _hoisted_4 = {
    class: "cell"
};
const _hoisted_5 = {
    class: "cell"
};
const _hoisted_6 = {
    class: "cell"
};
const _hoisted_7 = {
    class: "cell"
};
const _hoisted_8 = {
    class: "cell"
};
const _hoisted_9 = {
    class: "cell"
};
const _hoisted_10 = {
    class: "cell"
};
const _hoisted_11 = /* @__PURE__ */ _vue.createElementVNode("td", null, null, -1);
const _hoisted_12 = /* @__PURE__ */ _vue.createElementVNode("td", null, null, -1);
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("table", {
        class: "el-year-table",
        onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleYearTableClick && _ctx.handleYearTableClick(...args)
        )
    }, [
        _vue.createElementVNode("tbody", null, [
            _vue.createElementVNode("tr", null, [
                _vue.createElementVNode("td", {
                    class: _vue.normalizeClass([
                        "available",
                        _ctx.getCellStyle(_ctx.startYear + 0)
                    ])
                }, [
                    _vue.createElementVNode("a", _hoisted_1, _vue.toDisplayString(_ctx.startYear), 1)
                ], 2),
                _vue.createElementVNode("td", {
                    class: _vue.normalizeClass([
                        "available",
                        _ctx.getCellStyle(_ctx.startYear + 1)
                    ])
                }, [
                    _vue.createElementVNode("a", _hoisted_2, _vue.toDisplayString(_ctx.startYear + 1), 1)
                ], 2),
                _vue.createElementVNode("td", {
                    class: _vue.normalizeClass([
                        "available",
                        _ctx.getCellStyle(_ctx.startYear + 2)
                    ])
                }, [
                    _vue.createElementVNode("a", _hoisted_3, _vue.toDisplayString(_ctx.startYear + 2), 1)
                ], 2),
                _vue.createElementVNode("td", {
                    class: _vue.normalizeClass([
                        "available",
                        _ctx.getCellStyle(_ctx.startYear + 3)
                    ])
                }, [
                    _vue.createElementVNode("a", _hoisted_4, _vue.toDisplayString(_ctx.startYear + 3), 1)
                ], 2)
            ]),
            _vue.createElementVNode("tr", null, [
                _vue.createElementVNode("td", {
                    class: _vue.normalizeClass([
                        "available",
                        _ctx.getCellStyle(_ctx.startYear + 4)
                    ])
                }, [
                    _vue.createElementVNode("a", _hoisted_5, _vue.toDisplayString(_ctx.startYear + 4), 1)
                ], 2),
                _vue.createElementVNode("td", {
                    class: _vue.normalizeClass([
                        "available",
                        _ctx.getCellStyle(_ctx.startYear + 5)
                    ])
                }, [
                    _vue.createElementVNode("a", _hoisted_6, _vue.toDisplayString(_ctx.startYear + 5), 1)
                ], 2),
                _vue.createElementVNode("td", {
                    class: _vue.normalizeClass([
                        "available",
                        _ctx.getCellStyle(_ctx.startYear + 6)
                    ])
                }, [
                    _vue.createElementVNode("a", _hoisted_7, _vue.toDisplayString(_ctx.startYear + 6), 1)
                ], 2),
                _vue.createElementVNode("td", {
                    class: _vue.normalizeClass([
                        "available",
                        _ctx.getCellStyle(_ctx.startYear + 7)
                    ])
                }, [
                    _vue.createElementVNode("a", _hoisted_8, _vue.toDisplayString(_ctx.startYear + 7), 1)
                ], 2)
            ]),
            _vue.createElementVNode("tr", null, [
                _vue.createElementVNode("td", {
                    class: _vue.normalizeClass([
                        "available",
                        _ctx.getCellStyle(_ctx.startYear + 8)
                    ])
                }, [
                    _vue.createElementVNode("a", _hoisted_9, _vue.toDisplayString(_ctx.startYear + 8), 1)
                ], 2),
                _vue.createElementVNode("td", {
                    class: _vue.normalizeClass([
                        "available",
                        _ctx.getCellStyle(_ctx.startYear + 9)
                    ])
                }, [
                    _vue.createElementVNode("a", _hoisted_10, _vue.toDisplayString(_ctx.startYear + 9), 1)
                ], 2),
                _hoisted_11,
                _hoisted_12
            ])
        ])
    ]);
}
var YearTable = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","dayjs":"NJZFB","../../../../hooks/index.mjs":"1Ansp","../../../time-picker/index.mjs":"4TaeO","../../../../utils/index.mjs":"dsdeP","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../time-picker/src/common/date-utils.mjs":"3CJdm","../../../../hooks/use-locale/index.mjs":"c1HoA","../../../../utils/arrays.mjs":"e9h0v","../../../../utils/dom/style.mjs":"cA8Mp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iKuDr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>DateRangePickPanel
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _indexMjs = require("../../../button/index.mjs");
var _indexMjs1 = require("../../../../directives/index.mjs");
var _indexMjs2 = require("../../../../hooks/index.mjs");
var _indexMjs3 = require("../../../input/index.mjs");
var _indexMjs4 = require("../../../time-picker/index.mjs");
var _indexMjs5 = require("../../../icon/index.mjs");
var _indexMjs6 = require("../../../../utils/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _basicDateTableMjs = require("./basic-date-table.mjs");
var _basicDateTableMjsDefault = parcelHelpers.interopDefault(_basicDateTableMjs);
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs7 = require("../../../../directives/click-outside/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs7);
var _panelTimePickMjs = require("../../../time-picker/src/time-picker-com/panel-time-pick.mjs");
var _panelTimePickMjsDefault = parcelHelpers.interopDefault(_panelTimePickMjs);
var _validatorMjs = require("../../../../utils/vue/validator.mjs");
var _indexMjs8 = require("../../../../hooks/use-locale/index.mjs");
var _dateUtilsMjs = require("../../../time-picker/src/common/date-utils.mjs");
const _sfc_main = _vue.defineComponent({
    directives: {
        clickoutside: _indexMjsDefault.default
    },
    components: {
        TimePickPanel: _panelTimePickMjsDefault.default,
        DateTable: _basicDateTableMjsDefault.default,
        ElInput: _indexMjs3.ElInput,
        ElButton: _indexMjs.ElButton,
        ElIcon: _indexMjs5.ElIcon,
        DArrowLeft: _iconsVue.DArrowLeft,
        ArrowLeft: _iconsVue.ArrowLeft,
        DArrowRight: _iconsVue.DArrowRight,
        ArrowRight: _iconsVue.ArrowRight
    },
    props: {
        unlinkPanels: Boolean,
        parsedValue: {
            type: Array
        },
        type: {
            type: String,
            required: true,
            validator: _validatorMjs.isValidDatePickType
        }
    },
    emits: [
        "pick",
        "set-picker-option",
        "calendar-change",
        "panel-change"
    ],
    setup (props, ctx) {
        const { t , lang  } = _indexMjs8.useLocale();
        const leftDate = _vue.ref(_dayjsDefault.default().locale(lang.value));
        const rightDate = _vue.ref(_dayjsDefault.default().locale(lang.value).add(1, "month"));
        const minDate = _vue.ref(null);
        const maxDate = _vue.ref(null);
        const dateUserInput = _vue.ref({
            min: null,
            max: null
        });
        const timeUserInput = _vue.ref({
            min: null,
            max: null
        });
        const leftLabel = _vue.computed(()=>{
            return `${leftDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${leftDate.value.month() + 1}`)}`;
        });
        const rightLabel = _vue.computed(()=>{
            return `${rightDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${rightDate.value.month() + 1}`)}`;
        });
        const leftYear = _vue.computed(()=>{
            return leftDate.value.year();
        });
        const leftMonth = _vue.computed(()=>{
            return leftDate.value.month();
        });
        const rightYear = _vue.computed(()=>{
            return rightDate.value.year();
        });
        const rightMonth = _vue.computed(()=>{
            return rightDate.value.month();
        });
        const hasShortcuts = _vue.computed(()=>!!shortcuts.length
        );
        const minVisibleDate = _vue.computed(()=>{
            if (dateUserInput.value.min !== null) return dateUserInput.value.min;
            if (minDate.value) return minDate.value.format(dateFormat.value);
            return "";
        });
        const maxVisibleDate = _vue.computed(()=>{
            if (dateUserInput.value.max !== null) return dateUserInput.value.max;
            if (maxDate.value || minDate.value) return (maxDate.value || minDate.value).format(dateFormat.value);
            return "";
        });
        const minVisibleTime = _vue.computed(()=>{
            if (timeUserInput.value.min !== null) return timeUserInput.value.min;
            if (minDate.value) return minDate.value.format(timeFormat.value);
            return "";
        });
        const maxVisibleTime = _vue.computed(()=>{
            if (timeUserInput.value.max !== null) return timeUserInput.value.max;
            if (maxDate.value || minDate.value) return (maxDate.value || minDate.value).format(timeFormat.value);
            return "";
        });
        const timeFormat = _vue.computed(()=>{
            return _dateUtilsMjs.extractTimeFormat(format);
        });
        const dateFormat = _vue.computed(()=>{
            return _dateUtilsMjs.extractDateFormat(format);
        });
        const leftPrevYear = ()=>{
            leftDate.value = leftDate.value.subtract(1, "year");
            if (!props.unlinkPanels) rightDate.value = leftDate.value.add(1, "month");
            handlePanelChange("year");
        };
        const leftPrevMonth = ()=>{
            leftDate.value = leftDate.value.subtract(1, "month");
            if (!props.unlinkPanels) rightDate.value = leftDate.value.add(1, "month");
            handlePanelChange("month");
        };
        const rightNextYear = ()=>{
            if (!props.unlinkPanels) {
                leftDate.value = leftDate.value.add(1, "year");
                rightDate.value = leftDate.value.add(1, "month");
            } else rightDate.value = rightDate.value.add(1, "year");
            handlePanelChange("year");
        };
        const rightNextMonth = ()=>{
            if (!props.unlinkPanels) {
                leftDate.value = leftDate.value.add(1, "month");
                rightDate.value = leftDate.value.add(1, "month");
            } else rightDate.value = rightDate.value.add(1, "month");
            handlePanelChange("month");
        };
        const leftNextYear = ()=>{
            leftDate.value = leftDate.value.add(1, "year");
            handlePanelChange("year");
        };
        const leftNextMonth = ()=>{
            leftDate.value = leftDate.value.add(1, "month");
            handlePanelChange("month");
        };
        const rightPrevYear = ()=>{
            rightDate.value = rightDate.value.subtract(1, "year");
            handlePanelChange("year");
        };
        const rightPrevMonth = ()=>{
            rightDate.value = rightDate.value.subtract(1, "month");
            handlePanelChange("month");
        };
        const handlePanelChange = (mode)=>{
            ctx.emit("panel-change", [
                leftDate.value.toDate(),
                rightDate.value.toDate()
            ], mode);
        };
        const enableMonthArrow = _vue.computed(()=>{
            const nextMonth = (leftMonth.value + 1) % 12;
            const yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
            return props.unlinkPanels && new Date(leftYear.value + yearOffset, nextMonth) < new Date(rightYear.value, rightMonth.value);
        });
        const enableYearArrow = _vue.computed(()=>{
            return props.unlinkPanels && rightYear.value * 12 + rightMonth.value - (leftYear.value * 12 + leftMonth.value + 1) >= 12;
        });
        const isValidValue = (value)=>{
            return Array.isArray(value) && value[0] && value[1] && value[0].valueOf() <= value[1].valueOf();
        };
        const rangeState = _vue.ref({
            endDate: null,
            selecting: false
        });
        const btnDisabled = _vue.computed(()=>{
            return !(minDate.value && maxDate.value && !rangeState.value.selecting && isValidValue([
                minDate.value,
                maxDate.value
            ]));
        });
        const handleChangeRange = (val)=>{
            rangeState.value = val;
        };
        const onSelect = (selecting)=>{
            rangeState.value.selecting = selecting;
            if (!selecting) rangeState.value.endDate = null;
        };
        const showTime = _vue.computed(()=>props.type === "datetime" || props.type === "datetimerange"
        );
        const handleConfirm = (visible = false)=>{
            if (isValidValue([
                minDate.value,
                maxDate.value
            ])) ctx.emit("pick", [
                minDate.value,
                maxDate.value
            ], visible);
        };
        const formatEmit = (emitDayjs, index)=>{
            if (!emitDayjs) return;
            if (defaultTime) {
                const defaultTimeD = _dayjsDefault.default(defaultTime[index] || defaultTime).locale(lang.value);
                return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
            }
            return emitDayjs;
        };
        const handleRangePick = (val, close = true)=>{
            const min_ = val.minDate;
            const max_ = val.maxDate;
            const minDate_ = formatEmit(min_, 0);
            const maxDate_ = formatEmit(max_, 1);
            if (maxDate.value === maxDate_ && minDate.value === minDate_) return;
            ctx.emit("calendar-change", [
                min_.toDate(),
                max_ && max_.toDate()
            ]);
            maxDate.value = maxDate_;
            minDate.value = minDate_;
            if (!close || showTime.value) return;
            handleConfirm();
        };
        const handleShortcutClick = (shortcut)=>{
            const shortcutValues = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
            if (shortcutValues) {
                ctx.emit("pick", [
                    _dayjsDefault.default(shortcutValues[0]).locale(lang.value),
                    _dayjsDefault.default(shortcutValues[1]).locale(lang.value)
                ]);
                return;
            }
            if (shortcut.onClick) shortcut.onClick(ctx);
        };
        const minTimePickerVisible = _vue.ref(false);
        const maxTimePickerVisible = _vue.ref(false);
        const handleMinTimeClose = ()=>{
            minTimePickerVisible.value = false;
        };
        const handleMaxTimeClose = ()=>{
            maxTimePickerVisible.value = false;
        };
        const handleDateInput = (value, type)=>{
            dateUserInput.value[type] = value;
            const parsedValueD = _dayjsDefault.default(value, dateFormat.value).locale(lang.value);
            if (parsedValueD.isValid()) {
                if (disabledDate && disabledDate(parsedValueD.toDate())) return;
                if (type === "min") {
                    leftDate.value = parsedValueD;
                    minDate.value = (minDate.value || leftDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
                    if (!props.unlinkPanels) {
                        rightDate.value = parsedValueD.add(1, "month");
                        maxDate.value = minDate.value.add(1, "month");
                    }
                } else {
                    rightDate.value = parsedValueD;
                    maxDate.value = (maxDate.value || rightDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
                    if (!props.unlinkPanels) {
                        leftDate.value = parsedValueD.subtract(1, "month");
                        minDate.value = maxDate.value.subtract(1, "month");
                    }
                }
            }
        };
        const handleDateChange = (_, type)=>{
            dateUserInput.value[type] = null;
        };
        const handleTimeInput = (value, type)=>{
            timeUserInput.value[type] = value;
            const parsedValueD = _dayjsDefault.default(value, timeFormat.value).locale(lang.value);
            if (parsedValueD.isValid()) {
                if (type === "min") {
                    minTimePickerVisible.value = true;
                    minDate.value = (minDate.value || leftDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
                    if (!maxDate.value || maxDate.value.isBefore(minDate.value)) maxDate.value = minDate.value;
                } else {
                    maxTimePickerVisible.value = true;
                    maxDate.value = (maxDate.value || rightDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
                    rightDate.value = maxDate.value;
                    if (maxDate.value && maxDate.value.isBefore(minDate.value)) minDate.value = maxDate.value;
                }
            }
        };
        const handleTimeChange = (value, type)=>{
            timeUserInput.value[type] = null;
            if (type === "min") {
                leftDate.value = minDate.value;
                minTimePickerVisible.value = false;
            } else {
                rightDate.value = maxDate.value;
                maxTimePickerVisible.value = false;
            }
        };
        const handleMinTimePick = (value, visible, first)=>{
            if (timeUserInput.value.min) return;
            if (value) {
                leftDate.value = value;
                minDate.value = (minDate.value || leftDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
            }
            if (!first) minTimePickerVisible.value = visible;
            if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
                maxDate.value = minDate.value;
                rightDate.value = value;
            }
        };
        const handleMaxTimePick = (value, visible, first)=>{
            if (timeUserInput.value.max) return;
            if (value) {
                rightDate.value = value;
                maxDate.value = (maxDate.value || rightDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
            }
            if (!first) maxTimePickerVisible.value = visible;
            if (maxDate.value && maxDate.value.isBefore(minDate.value)) minDate.value = maxDate.value;
        };
        const handleClear = ()=>{
            leftDate.value = getDefaultValue()[0];
            rightDate.value = leftDate.value.add(1, "month");
            ctx.emit("pick", null);
        };
        const formatToString = (value)=>{
            return Array.isArray(value) ? value.map((_)=>_.format(format)
            ) : value.format(format);
        };
        const parseUserInput = (value)=>{
            return Array.isArray(value) ? value.map((_)=>_dayjsDefault.default(_, format).locale(lang.value)
            ) : _dayjsDefault.default(value, format).locale(lang.value);
        };
        const getDefaultValue = ()=>{
            let start;
            if (Array.isArray(defaultValue.value)) {
                const left = _dayjsDefault.default(defaultValue.value[0]);
                let right = _dayjsDefault.default(defaultValue.value[1]);
                if (!props.unlinkPanels) right = left.add(1, "month");
                return [
                    left,
                    right
                ];
            } else if (defaultValue.value) start = _dayjsDefault.default(defaultValue.value);
            else start = _dayjsDefault.default();
            start = start.locale(lang.value);
            return [
                start,
                start.add(1, "month")
            ];
        };
        ctx.emit("set-picker-option", [
            "isValidValue",
            isValidValue
        ]);
        ctx.emit("set-picker-option", [
            "parseUserInput",
            parseUserInput
        ]);
        ctx.emit("set-picker-option", [
            "formatToString",
            formatToString
        ]);
        ctx.emit("set-picker-option", [
            "handleClear",
            handleClear
        ]);
        const pickerBase = _vue.inject("EP_PICKER_BASE");
        const { shortcuts , disabledDate , cellClassName , format , defaultTime , arrowControl , clearable  } = pickerBase.props;
        const defaultValue = _vue.toRef(pickerBase.props, "defaultValue");
        _vue.watch(()=>defaultValue.value
        , (val)=>{
            if (val) {
                const defaultArr = getDefaultValue();
                minDate.value = null;
                maxDate.value = null;
                leftDate.value = defaultArr[0];
                rightDate.value = defaultArr[1];
            }
        }, {
            immediate: true
        });
        _vue.watch(()=>props.parsedValue
        , (newVal)=>{
            if (newVal && newVal.length === 2) {
                minDate.value = newVal[0];
                maxDate.value = newVal[1];
                leftDate.value = minDate.value;
                if (props.unlinkPanels && maxDate.value) {
                    const minDateYear = minDate.value.year();
                    const minDateMonth = minDate.value.month();
                    const maxDateYear = maxDate.value.year();
                    const maxDateMonth = maxDate.value.month();
                    rightDate.value = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? maxDate.value.add(1, "month") : maxDate.value;
                } else {
                    rightDate.value = leftDate.value.add(1, "month");
                    if (maxDate.value) rightDate.value = rightDate.value.hour(maxDate.value.hour()).minute(maxDate.value.minute()).second(maxDate.value.second());
                }
            } else {
                const defaultArr = getDefaultValue();
                minDate.value = null;
                maxDate.value = null;
                leftDate.value = defaultArr[0];
                rightDate.value = defaultArr[1];
            }
        }, {
            immediate: true
        });
        return {
            shortcuts,
            disabledDate,
            cellClassName,
            minTimePickerVisible,
            maxTimePickerVisible,
            handleMinTimeClose,
            handleMaxTimeClose,
            handleShortcutClick,
            rangeState,
            minDate,
            maxDate,
            handleRangePick,
            onSelect,
            handleChangeRange,
            btnDisabled,
            enableYearArrow,
            enableMonthArrow,
            rightPrevMonth,
            rightPrevYear,
            rightNextMonth,
            rightNextYear,
            leftPrevMonth,
            leftPrevYear,
            leftNextMonth,
            leftNextYear,
            hasShortcuts,
            leftLabel,
            rightLabel,
            leftDate,
            rightDate,
            showTime,
            t,
            minVisibleDate,
            maxVisibleDate,
            minVisibleTime,
            maxVisibleTime,
            arrowControl,
            handleDateInput,
            handleDateChange,
            handleTimeInput,
            handleTimeChange,
            handleMinTimePick,
            handleMaxTimePick,
            handleClear,
            handleConfirm,
            timeFormat,
            clearable
        };
    }
});
const _hoisted_1 = {
    class: "el-picker-panel__body-wrapper"
};
const _hoisted_2 = {
    key: 0,
    class: "el-picker-panel__sidebar"
};
const _hoisted_3 = [
    "onClick"
];
const _hoisted_4 = {
    class: "el-picker-panel__body"
};
const _hoisted_5 = {
    key: 0,
    class: "el-date-range-picker__time-header"
};
const _hoisted_6 = {
    class: "el-date-range-picker__editors-wrap"
};
const _hoisted_7 = {
    class: "el-date-range-picker__time-picker-wrap"
};
const _hoisted_8 = {
    class: "el-date-range-picker__time-picker-wrap"
};
const _hoisted_9 = {
    class: "el-date-range-picker__editors-wrap is-right"
};
const _hoisted_10 = {
    class: "el-date-range-picker__time-picker-wrap"
};
const _hoisted_11 = {
    class: "el-date-range-picker__time-picker-wrap"
};
const _hoisted_12 = {
    class: "el-picker-panel__content el-date-range-picker__content is-left"
};
const _hoisted_13 = {
    class: "el-date-range-picker__header"
};
const _hoisted_14 = [
    "disabled"
];
const _hoisted_15 = [
    "disabled"
];
const _hoisted_16 = {
    class: "el-picker-panel__content el-date-range-picker__content is-right"
};
const _hoisted_17 = {
    class: "el-date-range-picker__header"
};
const _hoisted_18 = [
    "disabled"
];
const _hoisted_19 = [
    "disabled"
];
const _hoisted_20 = {
    key: 0,
    class: "el-picker-panel__footer"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_input = _vue.resolveComponent("el-input");
    const _component_time_pick_panel = _vue.resolveComponent("time-pick-panel");
    const _component_arrow_right = _vue.resolveComponent("arrow-right");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_d_arrow_left = _vue.resolveComponent("d-arrow-left");
    const _component_arrow_left = _vue.resolveComponent("arrow-left");
    const _component_d_arrow_right = _vue.resolveComponent("d-arrow-right");
    const _component_date_table = _vue.resolveComponent("date-table");
    const _component_el_button = _vue.resolveComponent("el-button");
    const _directive_clickoutside = _vue.resolveDirective("clickoutside");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            "el-picker-panel el-date-range-picker",
            [
                {
                    "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts,
                    "has-time": _ctx.showTime
                }
            ]
        ])
    }, [
        _vue.createElementVNode("div", _hoisted_1, [
            _vue.renderSlot(_ctx.$slots, "sidebar", {
                class: "el-picker-panel__sidebar"
            }),
            _ctx.hasShortcuts ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_2, [
                (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.shortcuts, (shortcut, key)=>{
                    return _vue.openBlock(), _vue.createElementBlock("button", {
                        key,
                        type: "button",
                        class: "el-picker-panel__shortcut",
                        onClick: ($event)=>_ctx.handleShortcutClick(shortcut)
                    }, _vue.toDisplayString(shortcut.text), 9, _hoisted_3);
                }), 128))
            ])) : _vue.createCommentVNode("v-if", true),
            _vue.createElementVNode("div", _hoisted_4, [
                _ctx.showTime ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_5, [
                    _vue.createElementVNode("span", _hoisted_6, [
                        _vue.createElementVNode("span", _hoisted_7, [
                            _vue.createVNode(_component_el_input, {
                                size: "small",
                                disabled: _ctx.rangeState.selecting,
                                placeholder: _ctx.t("el.datepicker.startDate"),
                                class: "el-date-range-picker__editor",
                                "model-value": _ctx.minVisibleDate,
                                onInput: _cache[0] || (_cache[0] = (val)=>_ctx.handleDateInput(val, "min")
                                ),
                                onChange: _cache[1] || (_cache[1] = (val)=>_ctx.handleDateChange(val, "min")
                                )
                            }, null, 8, [
                                "disabled",
                                "placeholder",
                                "model-value"
                            ])
                        ]),
                        _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("span", _hoisted_8, [
                            _vue.createVNode(_component_el_input, {
                                size: "small",
                                class: "el-date-range-picker__editor",
                                disabled: _ctx.rangeState.selecting,
                                placeholder: _ctx.t("el.datepicker.startTime"),
                                "model-value": _ctx.minVisibleTime,
                                onFocus: _cache[2] || (_cache[2] = ($event)=>_ctx.minTimePickerVisible = true
                                ),
                                onInput: _cache[3] || (_cache[3] = (val)=>_ctx.handleTimeInput(val, "min")
                                ),
                                onChange: _cache[4] || (_cache[4] = (val)=>_ctx.handleTimeChange(val, "min")
                                )
                            }, null, 8, [
                                "disabled",
                                "placeholder",
                                "model-value"
                            ]),
                            _vue.createVNode(_component_time_pick_panel, {
                                visible: _ctx.minTimePickerVisible,
                                format: _ctx.timeFormat,
                                "datetime-role": "start",
                                "time-arrow-control": _ctx.arrowControl,
                                "parsed-value": _ctx.leftDate,
                                onPick: _ctx.handleMinTimePick
                            }, null, 8, [
                                "visible",
                                "format",
                                "time-arrow-control",
                                "parsed-value",
                                "onPick"
                            ])
                        ])), [
                            [
                                _directive_clickoutside,
                                _ctx.handleMinTimeClose
                            ]
                        ])
                    ]),
                    _vue.createElementVNode("span", null, [
                        _vue.createVNode(_component_el_icon, null, {
                            default: _vue.withCtx(()=>[
                                    _vue.createVNode(_component_arrow_right)
                                ]
                            ),
                            _: 1
                        })
                    ]),
                    _vue.createElementVNode("span", _hoisted_9, [
                        _vue.createElementVNode("span", _hoisted_10, [
                            _vue.createVNode(_component_el_input, {
                                size: "small",
                                class: "el-date-range-picker__editor",
                                disabled: _ctx.rangeState.selecting,
                                placeholder: _ctx.t("el.datepicker.endDate"),
                                "model-value": _ctx.maxVisibleDate,
                                readonly: !_ctx.minDate,
                                onInput: _cache[5] || (_cache[5] = (val)=>_ctx.handleDateInput(val, "max")
                                ),
                                onChange: _cache[6] || (_cache[6] = (val)=>_ctx.handleDateChange(val, "max")
                                )
                            }, null, 8, [
                                "disabled",
                                "placeholder",
                                "model-value",
                                "readonly"
                            ])
                        ]),
                        _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("span", _hoisted_11, [
                            _vue.createVNode(_component_el_input, {
                                size: "small",
                                class: "el-date-range-picker__editor",
                                disabled: _ctx.rangeState.selecting,
                                placeholder: _ctx.t("el.datepicker.endTime"),
                                "model-value": _ctx.maxVisibleTime,
                                readonly: !_ctx.minDate,
                                onFocus: _cache[7] || (_cache[7] = ($event)=>_ctx.minDate && (_ctx.maxTimePickerVisible = true)
                                ),
                                onInput: _cache[8] || (_cache[8] = (val)=>_ctx.handleTimeInput(val, "max")
                                ),
                                onChange: _cache[9] || (_cache[9] = (val)=>_ctx.handleTimeChange(val, "max")
                                )
                            }, null, 8, [
                                "disabled",
                                "placeholder",
                                "model-value",
                                "readonly"
                            ]),
                            _vue.createVNode(_component_time_pick_panel, {
                                "datetime-role": "end",
                                visible: _ctx.maxTimePickerVisible,
                                format: _ctx.timeFormat,
                                "time-arrow-control": _ctx.arrowControl,
                                "parsed-value": _ctx.rightDate,
                                onPick: _ctx.handleMaxTimePick
                            }, null, 8, [
                                "visible",
                                "format",
                                "time-arrow-control",
                                "parsed-value",
                                "onPick"
                            ])
                        ])), [
                            [
                                _directive_clickoutside,
                                _ctx.handleMaxTimeClose
                            ]
                        ])
                    ])
                ])) : _vue.createCommentVNode("v-if", true),
                _vue.createElementVNode("div", _hoisted_12, [
                    _vue.createElementVNode("div", _hoisted_13, [
                        _vue.createElementVNode("button", {
                            type: "button",
                            class: "el-picker-panel__icon-btn d-arrow-left",
                            onClick: _cache[10] || (_cache[10] = (...args)=>_ctx.leftPrevYear && _ctx.leftPrevYear(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_d_arrow_left)
                                    ]
                                ),
                                _: 1
                            })
                        ]),
                        _vue.createElementVNode("button", {
                            type: "button",
                            class: "el-picker-panel__icon-btn arrow-left",
                            onClick: _cache[11] || (_cache[11] = (...args)=>_ctx.leftPrevMonth && _ctx.leftPrevMonth(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_arrow_left)
                                    ]
                                ),
                                _: 1
                            })
                        ]),
                        _ctx.unlinkPanels ? (_vue.openBlock(), _vue.createElementBlock("button", {
                            key: 0,
                            type: "button",
                            disabled: !_ctx.enableYearArrow,
                            class: _vue.normalizeClass([
                                {
                                    "is-disabled": !_ctx.enableYearArrow
                                },
                                "el-picker-panel__icon-btn d-arrow-right"
                            ]),
                            onClick: _cache[12] || (_cache[12] = (...args)=>_ctx.leftNextYear && _ctx.leftNextYear(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_d_arrow_right)
                                    ]
                                ),
                                _: 1
                            })
                        ], 10, _hoisted_14)) : _vue.createCommentVNode("v-if", true),
                        _ctx.unlinkPanels ? (_vue.openBlock(), _vue.createElementBlock("button", {
                            key: 1,
                            type: "button",
                            disabled: !_ctx.enableMonthArrow,
                            class: _vue.normalizeClass([
                                {
                                    "is-disabled": !_ctx.enableMonthArrow
                                },
                                "el-picker-panel__icon-btn arrow-right"
                            ]),
                            onClick: _cache[13] || (_cache[13] = (...args)=>_ctx.leftNextMonth && _ctx.leftNextMonth(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_arrow_right)
                                    ]
                                ),
                                _: 1
                            })
                        ], 10, _hoisted_15)) : _vue.createCommentVNode("v-if", true),
                        _vue.createElementVNode("div", null, _vue.toDisplayString(_ctx.leftLabel), 1)
                    ]),
                    _vue.createVNode(_component_date_table, {
                        "selection-mode": "range",
                        date: _ctx.leftDate,
                        "min-date": _ctx.minDate,
                        "max-date": _ctx.maxDate,
                        "range-state": _ctx.rangeState,
                        "disabled-date": _ctx.disabledDate,
                        "cell-class-name": _ctx.cellClassName,
                        onChangerange: _ctx.handleChangeRange,
                        onPick: _ctx.handleRangePick,
                        onSelect: _ctx.onSelect
                    }, null, 8, [
                        "date",
                        "min-date",
                        "max-date",
                        "range-state",
                        "disabled-date",
                        "cell-class-name",
                        "onChangerange",
                        "onPick",
                        "onSelect"
                    ])
                ]),
                _vue.createElementVNode("div", _hoisted_16, [
                    _vue.createElementVNode("div", _hoisted_17, [
                        _ctx.unlinkPanels ? (_vue.openBlock(), _vue.createElementBlock("button", {
                            key: 0,
                            type: "button",
                            disabled: !_ctx.enableYearArrow,
                            class: _vue.normalizeClass([
                                {
                                    "is-disabled": !_ctx.enableYearArrow
                                },
                                "el-picker-panel__icon-btn d-arrow-left"
                            ]),
                            onClick: _cache[14] || (_cache[14] = (...args)=>_ctx.rightPrevYear && _ctx.rightPrevYear(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_d_arrow_left)
                                    ]
                                ),
                                _: 1
                            })
                        ], 10, _hoisted_18)) : _vue.createCommentVNode("v-if", true),
                        _ctx.unlinkPanels ? (_vue.openBlock(), _vue.createElementBlock("button", {
                            key: 1,
                            type: "button",
                            disabled: !_ctx.enableMonthArrow,
                            class: _vue.normalizeClass([
                                {
                                    "is-disabled": !_ctx.enableMonthArrow
                                },
                                "el-picker-panel__icon-btn arrow-left"
                            ]),
                            onClick: _cache[15] || (_cache[15] = (...args)=>_ctx.rightPrevMonth && _ctx.rightPrevMonth(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_arrow_left)
                                    ]
                                ),
                                _: 1
                            })
                        ], 10, _hoisted_19)) : _vue.createCommentVNode("v-if", true),
                        _vue.createElementVNode("button", {
                            type: "button",
                            class: "el-picker-panel__icon-btn d-arrow-right",
                            onClick: _cache[16] || (_cache[16] = (...args)=>_ctx.rightNextYear && _ctx.rightNextYear(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_d_arrow_right)
                                    ]
                                ),
                                _: 1
                            })
                        ]),
                        _vue.createElementVNode("button", {
                            type: "button",
                            class: "el-picker-panel__icon-btn arrow-right",
                            onClick: _cache[17] || (_cache[17] = (...args)=>_ctx.rightNextMonth && _ctx.rightNextMonth(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_arrow_right)
                                    ]
                                ),
                                _: 1
                            })
                        ]),
                        _vue.createElementVNode("div", null, _vue.toDisplayString(_ctx.rightLabel), 1)
                    ]),
                    _vue.createVNode(_component_date_table, {
                        "selection-mode": "range",
                        date: _ctx.rightDate,
                        "min-date": _ctx.minDate,
                        "max-date": _ctx.maxDate,
                        "range-state": _ctx.rangeState,
                        "disabled-date": _ctx.disabledDate,
                        "cell-class-name": _ctx.cellClassName,
                        onChangerange: _ctx.handleChangeRange,
                        onPick: _ctx.handleRangePick,
                        onSelect: _ctx.onSelect
                    }, null, 8, [
                        "date",
                        "min-date",
                        "max-date",
                        "range-state",
                        "disabled-date",
                        "cell-class-name",
                        "onChangerange",
                        "onPick",
                        "onSelect"
                    ])
                ])
            ])
        ]),
        _ctx.showTime ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_20, [
            _ctx.clearable ? (_vue.openBlock(), _vue.createBlock(_component_el_button, {
                key: 0,
                size: "small",
                type: "text",
                class: "el-picker-panel__link-btn",
                onClick: _ctx.handleClear
            }, {
                default: _vue.withCtx(()=>[
                        _vue.createTextVNode(_vue.toDisplayString(_ctx.t("el.datepicker.clear")), 1)
                    ]
                ),
                _: 1
            }, 8, [
                "onClick"
            ])) : _vue.createCommentVNode("v-if", true),
            _vue.createVNode(_component_el_button, {
                plain: "",
                size: "small",
                class: "el-picker-panel__link-btn",
                disabled: _ctx.btnDisabled,
                onClick: _cache[18] || (_cache[18] = ($event)=>_ctx.handleConfirm(false)
                )
            }, {
                default: _vue.withCtx(()=>[
                        _vue.createTextVNode(_vue.toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
                    ]
                ),
                _: 1
            }, 8, [
                "disabled"
            ])
        ])) : _vue.createCommentVNode("v-if", true)
    ], 2);
}
var DateRangePickPanel = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","dayjs":"NJZFB","../../../button/index.mjs":"64Ym1","../../../../directives/index.mjs":"aRbJ2","../../../../hooks/index.mjs":"1Ansp","../../../input/index.mjs":"18eQI","../../../time-picker/index.mjs":"4TaeO","../../../icon/index.mjs":"hnNTG","../../../../utils/index.mjs":"dsdeP","@element-plus/icons-vue":"b18uu","./basic-date-table.mjs":"nCvua","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../directives/click-outside/index.mjs":"cdlLW","../../../time-picker/src/time-picker-com/panel-time-pick.mjs":"351Kw","../../../../utils/vue/validator.mjs":"4UnBa","../../../../hooks/use-locale/index.mjs":"c1HoA","../../../time-picker/src/common/date-utils.mjs":"3CJdm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fAsjC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>MonthRangePickPanel
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _indexMjs = require("../../../icon/index.mjs");
var _indexMjs1 = require("../../../../hooks/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _basicMonthTableMjs = require("./basic-month-table.mjs");
var _basicMonthTableMjsDefault = parcelHelpers.interopDefault(_basicMonthTableMjs);
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../../hooks/use-locale/index.mjs");
const _sfc_main = _vue.defineComponent({
    components: {
        MonthTable: _basicMonthTableMjsDefault.default,
        ElIcon: _indexMjs.ElIcon,
        DArrowLeft: _iconsVue.DArrowLeft,
        DArrowRight: _iconsVue.DArrowRight
    },
    props: {
        unlinkPanels: Boolean,
        parsedValue: {
            type: Array
        }
    },
    emits: [
        "pick",
        "set-picker-option"
    ],
    setup (props, ctx) {
        const { t , lang  } = _indexMjs2.useLocale();
        const leftDate = _vue.ref(_dayjsDefault.default().locale(lang.value));
        const rightDate = _vue.ref(_dayjsDefault.default().locale(lang.value).add(1, "year"));
        const hasShortcuts = _vue.computed(()=>!!shortcuts.length
        );
        const handleShortcutClick = (shortcut)=>{
            const shortcutValues = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
            if (shortcutValues) {
                ctx.emit("pick", [
                    _dayjsDefault.default(shortcutValues[0]).locale(lang.value),
                    _dayjsDefault.default(shortcutValues[1]).locale(lang.value)
                ]);
                return;
            }
            if (shortcut.onClick) shortcut.onClick(ctx);
        };
        const leftPrevYear = ()=>{
            leftDate.value = leftDate.value.subtract(1, "year");
            if (!props.unlinkPanels) rightDate.value = rightDate.value.subtract(1, "year");
        };
        const rightNextYear = ()=>{
            if (!props.unlinkPanels) leftDate.value = leftDate.value.add(1, "year");
            rightDate.value = rightDate.value.add(1, "year");
        };
        const leftNextYear = ()=>{
            leftDate.value = leftDate.value.add(1, "year");
        };
        const rightPrevYear = ()=>{
            rightDate.value = rightDate.value.subtract(1, "year");
        };
        const leftLabel = _vue.computed(()=>{
            return `${leftDate.value.year()} ${t("el.datepicker.year")}`;
        });
        const rightLabel = _vue.computed(()=>{
            return `${rightDate.value.year()} ${t("el.datepicker.year")}`;
        });
        const leftYear = _vue.computed(()=>{
            return leftDate.value.year();
        });
        const rightYear = _vue.computed(()=>{
            return rightDate.value.year() === leftDate.value.year() ? leftDate.value.year() + 1 : rightDate.value.year();
        });
        const enableYearArrow = _vue.computed(()=>{
            return props.unlinkPanels && rightYear.value > leftYear.value + 1;
        });
        const minDate = _vue.ref(null);
        const maxDate = _vue.ref(null);
        const rangeState = _vue.ref({
            endDate: null,
            selecting: false
        });
        const handleChangeRange = (val)=>{
            rangeState.value = val;
        };
        const handleRangePick = (val, close = true)=>{
            const minDate_ = val.minDate;
            const maxDate_ = val.maxDate;
            if (maxDate.value === maxDate_ && minDate.value === minDate_) return;
            maxDate.value = maxDate_;
            minDate.value = minDate_;
            if (!close) return;
            handleConfirm();
        };
        const isValidValue = (value)=>{
            return Array.isArray(value) && value && value[0] && value[1] && value[0].valueOf() <= value[1].valueOf();
        };
        const handleConfirm = (visible = false)=>{
            if (isValidValue([
                minDate.value,
                maxDate.value
            ])) ctx.emit("pick", [
                minDate.value,
                maxDate.value
            ], visible);
        };
        const onSelect = (selecting)=>{
            rangeState.value.selecting = selecting;
            if (!selecting) rangeState.value.endDate = null;
        };
        const formatToString = (value)=>{
            return value.map((_)=>_.format(format)
            );
        };
        const getDefaultValue = ()=>{
            let start;
            if (Array.isArray(defaultValue.value)) {
                const left = _dayjsDefault.default(defaultValue.value[0]);
                let right = _dayjsDefault.default(defaultValue.value[1]);
                if (!props.unlinkPanels) right = left.add(1, "year");
                return [
                    left,
                    right
                ];
            } else if (defaultValue.value) start = _dayjsDefault.default(defaultValue.value);
            else start = _dayjsDefault.default();
            start = start.locale(lang.value);
            return [
                start,
                start.add(1, "year")
            ];
        };
        ctx.emit("set-picker-option", [
            "formatToString",
            formatToString
        ]);
        const pickerBase = _vue.inject("EP_PICKER_BASE");
        const { shortcuts , disabledDate , format  } = pickerBase.props;
        const defaultValue = _vue.toRef(pickerBase.props, "defaultValue");
        _vue.watch(()=>defaultValue.value
        , (val)=>{
            if (val) {
                const defaultArr = getDefaultValue();
                leftDate.value = defaultArr[0];
                rightDate.value = defaultArr[1];
            }
        }, {
            immediate: true
        });
        _vue.watch(()=>props.parsedValue
        , (newVal)=>{
            if (newVal && newVal.length === 2) {
                minDate.value = newVal[0];
                maxDate.value = newVal[1];
                leftDate.value = minDate.value;
                if (props.unlinkPanels && maxDate.value) {
                    const minDateYear = minDate.value.year();
                    const maxDateYear = maxDate.value.year();
                    rightDate.value = minDateYear === maxDateYear ? maxDate.value.add(1, "year") : maxDate.value;
                } else rightDate.value = leftDate.value.add(1, "year");
            } else {
                const defaultArr = getDefaultValue();
                minDate.value = null;
                maxDate.value = null;
                leftDate.value = defaultArr[0];
                rightDate.value = defaultArr[1];
            }
        }, {
            immediate: true
        });
        return {
            shortcuts,
            disabledDate,
            onSelect,
            handleRangePick,
            rangeState,
            handleChangeRange,
            minDate,
            maxDate,
            enableYearArrow,
            leftLabel,
            rightLabel,
            leftNextYear,
            leftPrevYear,
            rightNextYear,
            rightPrevYear,
            t,
            leftDate,
            rightDate,
            hasShortcuts,
            handleShortcutClick
        };
    }
});
const _hoisted_1 = {
    class: "el-picker-panel__body-wrapper"
};
const _hoisted_2 = {
    key: 0,
    class: "el-picker-panel__sidebar"
};
const _hoisted_3 = [
    "onClick"
];
const _hoisted_4 = {
    class: "el-picker-panel__body"
};
const _hoisted_5 = {
    class: "el-picker-panel__content el-date-range-picker__content is-left"
};
const _hoisted_6 = {
    class: "el-date-range-picker__header"
};
const _hoisted_7 = [
    "disabled"
];
const _hoisted_8 = {
    class: "el-picker-panel__content el-date-range-picker__content is-right"
};
const _hoisted_9 = {
    class: "el-date-range-picker__header"
};
const _hoisted_10 = [
    "disabled"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_d_arrow_left = _vue.resolveComponent("d-arrow-left");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_d_arrow_right = _vue.resolveComponent("d-arrow-right");
    const _component_month_table = _vue.resolveComponent("month-table");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            "el-picker-panel el-date-range-picker",
            [
                {
                    "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts
                }
            ]
        ])
    }, [
        _vue.createElementVNode("div", _hoisted_1, [
            _vue.renderSlot(_ctx.$slots, "sidebar", {
                class: "el-picker-panel__sidebar"
            }),
            _ctx.hasShortcuts ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_2, [
                (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.shortcuts, (shortcut, key)=>{
                    return _vue.openBlock(), _vue.createElementBlock("button", {
                        key,
                        type: "button",
                        class: "el-picker-panel__shortcut",
                        onClick: ($event)=>_ctx.handleShortcutClick(shortcut)
                    }, _vue.toDisplayString(shortcut.text), 9, _hoisted_3);
                }), 128))
            ])) : _vue.createCommentVNode("v-if", true),
            _vue.createElementVNode("div", _hoisted_4, [
                _vue.createElementVNode("div", _hoisted_5, [
                    _vue.createElementVNode("div", _hoisted_6, [
                        _vue.createElementVNode("button", {
                            type: "button",
                            class: "el-picker-panel__icon-btn d-arrow-left",
                            onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.leftPrevYear && _ctx.leftPrevYear(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_d_arrow_left)
                                    ]
                                ),
                                _: 1
                            })
                        ]),
                        _ctx.unlinkPanels ? (_vue.openBlock(), _vue.createElementBlock("button", {
                            key: 0,
                            type: "button",
                            disabled: !_ctx.enableYearArrow,
                            class: _vue.normalizeClass([
                                {
                                    "is-disabled": !_ctx.enableYearArrow
                                },
                                "el-picker-panel__icon-btn d-arrow-right"
                            ]),
                            onClick: _cache[1] || (_cache[1] = (...args)=>_ctx.leftNextYear && _ctx.leftNextYear(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_d_arrow_right)
                                    ]
                                ),
                                _: 1
                            })
                        ], 10, _hoisted_7)) : _vue.createCommentVNode("v-if", true),
                        _vue.createElementVNode("div", null, _vue.toDisplayString(_ctx.leftLabel), 1)
                    ]),
                    _vue.createVNode(_component_month_table, {
                        "selection-mode": "range",
                        date: _ctx.leftDate,
                        "min-date": _ctx.minDate,
                        "max-date": _ctx.maxDate,
                        "range-state": _ctx.rangeState,
                        "disabled-date": _ctx.disabledDate,
                        onChangerange: _ctx.handleChangeRange,
                        onPick: _ctx.handleRangePick,
                        onSelect: _ctx.onSelect
                    }, null, 8, [
                        "date",
                        "min-date",
                        "max-date",
                        "range-state",
                        "disabled-date",
                        "onChangerange",
                        "onPick",
                        "onSelect"
                    ])
                ]),
                _vue.createElementVNode("div", _hoisted_8, [
                    _vue.createElementVNode("div", _hoisted_9, [
                        _ctx.unlinkPanels ? (_vue.openBlock(), _vue.createElementBlock("button", {
                            key: 0,
                            type: "button",
                            disabled: !_ctx.enableYearArrow,
                            class: _vue.normalizeClass([
                                {
                                    "is-disabled": !_ctx.enableYearArrow
                                },
                                "el-picker-panel__icon-btn d-arrow-left"
                            ]),
                            onClick: _cache[2] || (_cache[2] = (...args)=>_ctx.rightPrevYear && _ctx.rightPrevYear(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_d_arrow_left)
                                    ]
                                ),
                                _: 1
                            })
                        ], 10, _hoisted_10)) : _vue.createCommentVNode("v-if", true),
                        _vue.createElementVNode("button", {
                            type: "button",
                            class: "el-picker-panel__icon-btn d-arrow-right",
                            onClick: _cache[3] || (_cache[3] = (...args)=>_ctx.rightNextYear && _ctx.rightNextYear(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_d_arrow_right)
                                    ]
                                ),
                                _: 1
                            })
                        ]),
                        _vue.createElementVNode("div", null, _vue.toDisplayString(_ctx.rightLabel), 1)
                    ]),
                    _vue.createVNode(_component_month_table, {
                        "selection-mode": "range",
                        date: _ctx.rightDate,
                        "min-date": _ctx.minDate,
                        "max-date": _ctx.maxDate,
                        "range-state": _ctx.rangeState,
                        "disabled-date": _ctx.disabledDate,
                        onChangerange: _ctx.handleChangeRange,
                        onPick: _ctx.handleRangePick,
                        onSelect: _ctx.onSelect
                    }, null, 8, [
                        "date",
                        "min-date",
                        "max-date",
                        "range-state",
                        "disabled-date",
                        "onChangerange",
                        "onPick",
                        "onSelect"
                    ])
                ])
            ])
        ])
    ], 2);
}
var MonthRangePickPanel = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","dayjs":"NJZFB","../../../icon/index.mjs":"hnNTG","../../../../hooks/index.mjs":"1Ansp","@element-plus/icons-vue":"b18uu","./basic-month-table.mjs":"dp2xC","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../hooks/use-locale/index.mjs":"c1HoA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aXmMH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElDescriptions", ()=>ElDescriptions
);
parcelHelpers.export(exports, "ElDescriptionsItem", ()=>ElDescriptionsItem
);
parcelHelpers.export(exports, "default", ()=>ElDescriptions
);
var _indexMjs = require("../../utils/index.mjs");
var _indexMjs1 = require("./src/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _descriptionItemMjs = require("./src/description-item.mjs");
var _descriptionItemMjsDefault = parcelHelpers.interopDefault(_descriptionItemMjs);
var _installMjs = require("../../utils/vue/install.mjs");
const ElDescriptions = _installMjs.withInstall(_indexMjsDefault.default, {
    DescriptionsItem: _descriptionItemMjsDefault.default
});
const ElDescriptionsItem = _installMjs.withNoopInstall(_descriptionItemMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/index.mjs":"LHsYR","./src/description-item.mjs":"l49WW","../../utils/vue/install.mjs":"4TMmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"LHsYR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Descriptions
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _descriptionsRowMjs = require("./descriptions-row.mjs");
var _descriptionsRowMjsDefault = parcelHelpers.interopDefault(_descriptionsRowMjs);
var _tokenMjs = require("./token.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _validatorMjs = require("../../../utils/vue/validator.mjs");
var _indexMjs2 = require("../../../hooks/use-common-props/index.mjs");
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElDescriptions",
    components: {
        [_descriptionsRowMjsDefault.default.name]: _descriptionsRowMjsDefault.default
    },
    props: {
        border: {
            type: Boolean,
            default: false
        },
        column: {
            type: Number,
            default: 3
        },
        direction: {
            type: String,
            default: "horizontal"
        },
        size: {
            type: String,
            validator: _validatorMjs.isValidComponentSize
        },
        title: {
            type: String,
            default: ""
        },
        extra: {
            type: String,
            default: ""
        }
    },
    setup (props, { slots  }) {
        _vue.provide(_tokenMjs.elDescriptionsKey, props);
        const descriptionsSize = _indexMjs2.useSize();
        const ns = _indexMjs3.useNamespace("descriptions");
        const descriptionKls = _vue.computed(()=>[
                ns.b(),
                ns.is(ns.m(descriptionsSize.value), !!descriptionsSize.value)
            ]
        );
        const flattedChildren = (children)=>{
            const temp = Array.isArray(children) ? children : [
                children
            ];
            const res = [];
            temp.forEach((child)=>{
                if (Array.isArray(child.children)) res.push(...flattedChildren(child.children));
                else res.push(child);
            });
            return res;
        };
        const filledNode = (node, span, count, isLast = false)=>{
            if (!node.props) node.props = {
            };
            if (span > count) node.props.span = count;
            if (isLast) node.props.span = span;
            return node;
        };
        const getRows = ()=>{
            var _a;
            const children = flattedChildren((_a = slots.default) == null ? void 0 : _a.call(slots)).filter((node)=>{
                var _a2;
                return ((_a2 = node == null ? void 0 : node.type) == null ? void 0 : _a2.name) === "ElDescriptionsItem";
            });
            const rows = [];
            let temp = [];
            let count = props.column;
            let totalSpan = 0;
            children.forEach((node, index)=>{
                var _a2;
                const span = ((_a2 = node.props) == null ? void 0 : _a2.span) || 1;
                if (index < children.length - 1) totalSpan += span > count ? count : span;
                if (index === children.length - 1) {
                    const lastSpan = props.column - totalSpan % props.column;
                    temp.push(filledNode(node, lastSpan, count, true));
                    rows.push(temp);
                    return;
                }
                if (span < count) {
                    count -= span;
                    temp.push(node);
                } else {
                    temp.push(filledNode(node, span, count));
                    rows.push(temp);
                    count = props.column;
                    temp = [];
                }
            });
            return rows;
        };
        return {
            descriptionKls,
            getRows,
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_descriptions_row = _vue.resolveComponent("el-descriptions-row");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.descriptionKls)
    }, [
        _ctx.title || _ctx.extra || _ctx.$slots.title || _ctx.$slots.extra ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.e("header"))
        }, [
            _vue.createElementVNode("div", {
                class: _vue.normalizeClass(_ctx.ns.e("title"))
            }, [
                _vue.renderSlot(_ctx.$slots, "title", {
                }, ()=>[
                        _vue.createTextVNode(_vue.toDisplayString(_ctx.title), 1)
                    ]
                )
            ], 2),
            _vue.createElementVNode("div", {
                class: _vue.normalizeClass(_ctx.ns.e("extra"))
            }, [
                _vue.renderSlot(_ctx.$slots, "extra", {
                }, ()=>[
                        _vue.createTextVNode(_vue.toDisplayString(_ctx.extra), 1)
                    ]
                )
            ], 2)
        ], 2)) : _vue.createCommentVNode("v-if", true),
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("body"))
        }, [
            _vue.createElementVNode("table", {
                class: _vue.normalizeClass([
                    _ctx.ns.e("table"),
                    _ctx.ns.is("bordered", _ctx.border)
                ])
            }, [
                _vue.createElementVNode("tbody", null, [
                    (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.getRows(), (row, index)=>{
                        return _vue.openBlock(), _vue.createBlock(_component_el_descriptions_row, {
                            key: index,
                            row
                        }, null, 8, [
                            "row"
                        ]);
                    }), 128))
                ])
            ], 2)
        ], 2)
    ], 2);
}
var Descriptions = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./descriptions-row.mjs":"3IqY6","./token.mjs":"4W7cW","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/vue/validator.mjs":"4UnBa","../../../hooks/use-common-props/index.mjs":"05czU","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3IqY6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>DescriptionsRow
);
var _vue = require("vue");
var _descriptionsCellMjs = require("./descriptions-cell.mjs");
var _descriptionsCellMjsDefault = parcelHelpers.interopDefault(_descriptionsCellMjs);
var _tokenMjs = require("./token.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ElDescriptionsRow",
    components: {
        [_descriptionsCellMjsDefault.default.name]: _descriptionsCellMjsDefault.default
    },
    props: {
        row: {
            type: Array
        }
    },
    setup () {
        const descriptions = _vue.inject(_tokenMjs.elDescriptionsKey, {
        });
        return {
            descriptions
        };
    }
});
const _hoisted_1 = {
    key: 1
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_descriptions_cell = _vue.resolveComponent("el-descriptions-cell");
    return _ctx.descriptions.direction === "vertical" ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
        key: 0
    }, [
        _vue.createElementVNode("tr", null, [
            (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.row, (cell, index)=>{
                return _vue.openBlock(), _vue.createBlock(_component_el_descriptions_cell, {
                    key: `tr1-${index}`,
                    cell,
                    tag: "th",
                    type: "label"
                }, null, 8, [
                    "cell"
                ]);
            }), 128))
        ]),
        _vue.createElementVNode("tr", null, [
            (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.row, (cell, index)=>{
                return _vue.openBlock(), _vue.createBlock(_component_el_descriptions_cell, {
                    key: `tr2-${index}`,
                    cell,
                    tag: "td",
                    type: "content"
                }, null, 8, [
                    "cell"
                ]);
            }), 128))
        ])
    ], 64)) : (_vue.openBlock(), _vue.createElementBlock("tr", _hoisted_1, [
        (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.row, (cell, index)=>{
            return _vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                key: `tr3-${index}`
            }, [
                _ctx.descriptions.border ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                    key: 0
                }, [
                    _vue.createVNode(_component_el_descriptions_cell, {
                        cell,
                        tag: "td",
                        type: "label"
                    }, null, 8, [
                        "cell"
                    ]),
                    _vue.createVNode(_component_el_descriptions_cell, {
                        cell,
                        tag: "td",
                        type: "content"
                    }, null, 8, [
                        "cell"
                    ])
                ], 64)) : (_vue.openBlock(), _vue.createBlock(_component_el_descriptions_cell, {
                    key: 1,
                    cell,
                    tag: "td",
                    type: "both"
                }, null, 8, [
                    "cell"
                ]))
            ], 64);
        }), 128))
    ]));
}
var DescriptionsRow = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./descriptions-cell.mjs":"1TOhJ","./token.mjs":"4W7cW","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1TOhJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>DescriptionsCell
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _tokenMjs = require("./token.mjs");
var _vnodeMjs = require("../../../utils/vue/vnode.mjs");
var _styleMjs = require("../../../utils/vue/style.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
var DescriptionsCell = _vue.defineComponent({
    name: "ElDescriptionsCell",
    props: {
        cell: {
            type: Object
        },
        tag: {
            type: String
        },
        type: {
            type: String
        }
    },
    setup () {
        const descriptions = _vue.inject(_tokenMjs.elDescriptionsKey, {
        });
        return {
            descriptions
        };
    },
    render () {
        var _a, _b, _c, _d, _e, _f;
        const item = _vnodeMjs.getNormalizedProps(this.cell);
        const { border , direction  } = this.descriptions;
        const isVertical = direction === "vertical";
        const label = ((_c = (_b = (_a = this.cell) == null ? void 0 : _a.children) == null ? void 0 : _b.label) == null ? void 0 : _c.call(_b)) || item.label;
        const content = (_f = (_e = (_d = this.cell) == null ? void 0 : _d.children) == null ? void 0 : _e.default) == null ? void 0 : _f.call(_e);
        const span = item.span;
        const align = item.align ? `is-${item.align}` : "";
        const labelAlign = item.labelAlign ? `is-${item.labelAlign}` : align;
        const className = item.className;
        const labelClassName = item.labelClassName;
        const style = {
            width: _styleMjs.addUnit(item.width),
            minWidth: _styleMjs.addUnit(item.minWidth)
        };
        const ns = _indexMjs2.useNamespace("descriptions");
        switch(this.type){
            case "label":
                return _vue.h(this.tag, {
                    style,
                    class: [
                        ns.e("cell"),
                        ns.e("label"),
                        ns.is("bordered-label", border),
                        ns.is("vertical-label", isVertical),
                        labelAlign,
                        labelClassName
                    ],
                    colSpan: isVertical ? span : 1
                }, label);
            case "content":
                return _vue.h(this.tag, {
                    style,
                    class: [
                        ns.e("cell"),
                        ns.e("content"),
                        ns.is("bordered-content", border),
                        ns.is("vertical-content", isVertical),
                        align,
                        className
                    ],
                    colSpan: isVertical ? span : span * 2 - 1
                }, content);
            default:
                return _vue.h("td", {
                    style,
                    class: [
                        ns.e("cell"),
                        align
                    ],
                    colSpan: span
                }, [
                    _vue.h("span", {
                        class: [
                            ns.e("label"),
                            labelClassName
                        ]
                    }, label),
                    _vue.h("span", {
                        class: [
                            ns.e("content"),
                            className
                        ]
                    }, content)
                ]);
        }
    }
});

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./token.mjs":"4W7cW","../../../utils/vue/vnode.mjs":"ljPKw","../../../utils/vue/style.mjs":"pODHb","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4W7cW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "elDescriptionsKey", ()=>elDescriptionsKey
);
const elDescriptionsKey = "elDescriptions";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l49WW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>DescriptionsItem
);
var _vue = require("vue");
var DescriptionsItem = _vue.defineComponent({
    name: "ElDescriptionsItem",
    props: {
        label: {
            type: String,
            default: ""
        },
        span: {
            type: Number,
            default: 1
        },
        width: {
            type: [
                String,
                Number
            ],
            default: ""
        },
        minWidth: {
            type: [
                String,
                Number
            ],
            default: ""
        },
        align: {
            type: String,
            default: "left"
        },
        labelAlign: {
            type: String,
            default: ""
        },
        className: {
            type: String,
            default: ""
        },
        labelClassName: {
            type: String,
            default: ""
        }
    }
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iXu3z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useDialog", ()=>_useDialogMjs.useDialog
);
parcelHelpers.export(exports, "dialogEmits", ()=>_dialogMjs.dialogEmits
);
parcelHelpers.export(exports, "dialogProps", ()=>_dialogMjs.dialogProps
);
parcelHelpers.export(exports, "ElDialog", ()=>ElDialog
);
parcelHelpers.export(exports, "default", ()=>ElDialog
);
var _indexMjs = require("../../utils/index.mjs");
var _dialog2Mjs = require("./src/dialog2.mjs");
var _dialog2MjsDefault = parcelHelpers.interopDefault(_dialog2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _useDialogMjs = require("./src/use-dialog.mjs");
var _dialogMjs = require("./src/dialog.mjs");
const ElDialog = _installMjs.withInstall(_dialog2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/dialog2.mjs":"j6VLi","../../utils/vue/install.mjs":"4TMmv","./src/use-dialog.mjs":"kcxXl","./src/dialog.mjs":"imlUB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j6VLi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Dialog
);
var _vue = require("vue");
var _indexMjs = require("../../../directives/index.mjs");
var _indexMjs1 = require("../../overlay/index.mjs");
var _indexMjs2 = require("../../icon/index.mjs");
var _indexMjs3 = require("../../../utils/index.mjs");
var _indexMjs4 = require("../../../hooks/index.mjs");
var _dialogMjs = require("./dialog.mjs");
var _useDialogMjs = require("./use-dialog.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _indexMjs5 = require("../../../directives/trap-focus/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs5);
var _indexMjs6 = require("../../../hooks/use-namespace/index.mjs");
var _indexMjs7 = require("../../../hooks/use-same-target/index.mjs");
var _indexMjs8 = require("../../../hooks/use-draggable/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElDialog",
    components: {
        ElOverlay: _indexMjs1.ElOverlay,
        ElIcon: _indexMjs2.ElIcon,
        ..._iconMjs.CloseComponents
    },
    directives: {
        TrapFocus: _indexMjsDefault.default
    },
    props: _dialogMjs.dialogProps,
    emits: _dialogMjs.dialogEmits,
    setup (props, ctx) {
        const ns = _indexMjs6.useNamespace("dialog");
        const dialogRef = _vue.ref();
        const headerRef = _vue.ref();
        const dialog = _useDialogMjs.useDialog(props, ctx, dialogRef);
        const overlayEvent = _indexMjs7.useSameTarget(dialog.onModalClick);
        const draggable = _vue.computed(()=>props.draggable && !props.fullscreen
        );
        _indexMjs8.useDraggable(dialogRef, headerRef, draggable);
        return {
            ns,
            dialogRef,
            headerRef,
            overlayEvent,
            ...dialog
        };
    }
});
const _hoisted_1 = [
    "aria-label"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_overlay = _vue.resolveComponent("el-overlay");
    const _directive_trap_focus = _vue.resolveDirective("trap-focus");
    return _vue.openBlock(), _vue.createBlock(_vue.Teleport, {
        to: "body",
        disabled: !_ctx.appendToBody
    }, [
        _vue.createVNode(_vue.Transition, {
            name: "dialog-fade",
            onAfterEnter: _ctx.afterEnter,
            onAfterLeave: _ctx.afterLeave,
            onBeforeLeave: _ctx.beforeLeave
        }, {
            default: _vue.withCtx(()=>[
                    _vue.withDirectives(_vue.createVNode(_component_el_overlay, {
                        "custom-mask-event": "",
                        mask: _ctx.modal,
                        "overlay-class": _ctx.modalClass,
                        "z-index": _ctx.zIndex
                    }, {
                        default: _vue.withCtx(()=>[
                                _vue.createElementVNode("div", {
                                    class: _vue.normalizeClass(`${_ctx.ns.namespace.value}-overlay-dialog`),
                                    onClick: _cache[2] || (_cache[2] = (...args)=>_ctx.overlayEvent.onClick && _ctx.overlayEvent.onClick(...args)
                                    ),
                                    onMousedown: _cache[3] || (_cache[3] = (...args)=>_ctx.overlayEvent.onMousedown && _ctx.overlayEvent.onMousedown(...args)
                                    ),
                                    onMouseup: _cache[4] || (_cache[4] = (...args)=>_ctx.overlayEvent.onMouseup && _ctx.overlayEvent.onMouseup(...args)
                                    )
                                }, [
                                    _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
                                        ref: "dialogRef",
                                        class: _vue.normalizeClass([
                                            _ctx.ns.b(),
                                            _ctx.ns.is("fullscreen", _ctx.fullscreen),
                                            _ctx.ns.is("draggable", _ctx.draggable),
                                            {
                                                [_ctx.ns.m("center")]: _ctx.center
                                            },
                                            _ctx.customClass
                                        ]),
                                        "aria-modal": "true",
                                        role: "dialog",
                                        "aria-label": _ctx.title || "dialog",
                                        style: _vue.normalizeStyle(_ctx.style),
                                        onClick: _cache[1] || (_cache[1] = _vue.withModifiers(()=>{
                                        }, [
                                            "stop"
                                        ]))
                                    }, [
                                        _vue.createElementVNode("div", {
                                            ref: "headerRef",
                                            class: _vue.normalizeClass(_ctx.ns.e("header"))
                                        }, [
                                            _vue.renderSlot(_ctx.$slots, "title", {
                                            }, ()=>[
                                                    _vue.createElementVNode("span", {
                                                        class: _vue.normalizeClass(_ctx.ns.e("title"))
                                                    }, _vue.toDisplayString(_ctx.title), 3)
                                                ]
                                            ),
                                            _ctx.showClose ? (_vue.openBlock(), _vue.createElementBlock("button", {
                                                key: 0,
                                                "aria-label": "close",
                                                class: _vue.normalizeClass(_ctx.ns.e("headerbtn")),
                                                type: "button",
                                                onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleClose && _ctx.handleClose(...args)
                                                )
                                            }, [
                                                _vue.createVNode(_component_el_icon, {
                                                    class: _vue.normalizeClass(_ctx.ns.e("close"))
                                                }, {
                                                    default: _vue.withCtx(()=>[
                                                            (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.closeIcon || "close")))
                                                        ]
                                                    ),
                                                    _: 1
                                                }, 8, [
                                                    "class"
                                                ])
                                            ], 2)) : _vue.createCommentVNode("v-if", true)
                                        ], 2),
                                        _ctx.rendered ? (_vue.openBlock(), _vue.createElementBlock("div", {
                                            key: 0,
                                            class: _vue.normalizeClass(_ctx.ns.e("body"))
                                        }, [
                                            _vue.renderSlot(_ctx.$slots, "default")
                                        ], 2)) : _vue.createCommentVNode("v-if", true),
                                        _ctx.$slots.footer ? (_vue.openBlock(), _vue.createElementBlock("div", {
                                            key: 1,
                                            class: _vue.normalizeClass(_ctx.ns.e("footer"))
                                        }, [
                                            _vue.renderSlot(_ctx.$slots, "footer")
                                        ], 2)) : _vue.createCommentVNode("v-if", true)
                                    ], 14, _hoisted_1)), [
                                        [
                                            _directive_trap_focus
                                        ]
                                    ])
                                ], 34)
                            ]
                        ),
                        _: 3
                    }, 8, [
                        "mask",
                        "overlay-class",
                        "z-index"
                    ]), [
                        [
                            _vue.vShow,
                            _ctx.visible
                        ]
                    ])
                ]
            ),
            _: 3
        }, 8, [
            "onAfterEnter",
            "onAfterLeave",
            "onBeforeLeave"
        ])
    ], 8, [
        "disabled"
    ]);
}
var Dialog = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../directives/index.mjs":"aRbJ2","../../overlay/index.mjs":"2HJvE","../../icon/index.mjs":"hnNTG","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./dialog.mjs":"imlUB","./use-dialog.mjs":"kcxXl","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/vue/icon.mjs":"3YbE5","../../../directives/trap-focus/index.mjs":"lw3sX","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../hooks/use-same-target/index.mjs":"duu8u","../../../hooks/use-draggable/index.mjs":"3SWUw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2HJvE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "overlayEmits", ()=>_overlayMjs.overlayEmits
);
parcelHelpers.export(exports, "overlayProps", ()=>_overlayMjs.overlayProps
);
parcelHelpers.export(exports, "ElOverlay", ()=>ElOverlay
);
parcelHelpers.export(exports, "default", ()=>ElOverlay
);
var _overlayMjs = require("./src/overlay.mjs");
var _overlayMjsDefault = parcelHelpers.interopDefault(_overlayMjs);
const ElOverlay = _overlayMjsDefault.default;

},{"./src/overlay.mjs":"fWAgM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fWAgM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Overlay
);
parcelHelpers.export(exports, "overlayEmits", ()=>overlayEmits
);
parcelHelpers.export(exports, "overlayProps", ()=>overlayProps
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
var _indexMjs3 = require("../../../hooks/use-same-target/index.mjs");
var _vnodeMjs = require("../../../utils/vue/vnode.mjs");
const overlayProps = _propsMjs.buildProps({
    mask: {
        type: Boolean,
        default: true
    },
    customMaskEvent: {
        type: Boolean,
        default: false
    },
    overlayClass: {
        type: _propsMjs.definePropType([
            String,
            Array,
            Object
        ])
    },
    zIndex: {
        type: _propsMjs.definePropType([
            String,
            Number
        ])
    }
});
const overlayEmits = {
    click: (evt)=>evt instanceof MouseEvent
};
var Overlay = _vue.defineComponent({
    name: "ElOverlay",
    props: overlayProps,
    emits: overlayEmits,
    setup (props, { slots , emit  }) {
        const ns = _indexMjs2.useNamespace("overlay");
        const onMaskClick = (e)=>{
            emit("click", e);
        };
        const { onClick , onMousedown , onMouseup  } = _indexMjs3.useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
        return ()=>{
            return props.mask ? _vue.createVNode("div", {
                class: [
                    ns.b(),
                    props.overlayClass
                ],
                style: {
                    zIndex: props.zIndex
                },
                onClick,
                onMousedown,
                onMouseup
            }, [
                _vue.renderSlot(slots, "default")
            ], _vnodeMjs.PatchFlags.STYLE | _vnodeMjs.PatchFlags.CLASS | _vnodeMjs.PatchFlags.PROPS, [
                "onClick",
                "onMouseup",
                "onMousedown"
            ]) : _vue.h("div", {
                class: props.overlayClass,
                style: {
                    zIndex: props.zIndex,
                    position: "fixed",
                    top: "0px",
                    right: "0px",
                    bottom: "0px",
                    left: "0px"
                }
            }, [
                _vue.renderSlot(slots, "default")
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","../../../utils/vue/props.mjs":"cpwWK","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../hooks/use-same-target/index.mjs":"duu8u","../../../utils/vue/vnode.mjs":"ljPKw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"imlUB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dialogEmits", ()=>dialogEmits
);
parcelHelpers.export(exports, "dialogProps", ()=>dialogProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _eventMjs = require("../../../constants/event.mjs");
const dialogProps = _propsMjs.buildProps({
    appendToBody: {
        type: Boolean,
        default: false
    },
    beforeClose: {
        type: _propsMjs.definePropType(Function)
    },
    destroyOnClose: {
        type: Boolean,
        default: false
    },
    center: {
        type: Boolean,
        default: false
    },
    customClass: {
        type: String,
        default: ""
    },
    closeIcon: {
        type: _iconMjs.iconPropType,
        default: ""
    },
    closeOnClickModal: {
        type: Boolean,
        default: true
    },
    closeOnPressEscape: {
        type: Boolean,
        default: true
    },
    fullscreen: {
        type: Boolean,
        default: false
    },
    draggable: {
        type: Boolean,
        default: false
    },
    lockScroll: {
        type: Boolean,
        default: true
    },
    modal: {
        type: Boolean,
        default: true
    },
    showClose: {
        type: Boolean,
        default: true
    },
    title: {
        type: String,
        default: ""
    },
    openDelay: {
        type: Number,
        default: 0
    },
    closeDelay: {
        type: Number,
        default: 0
    },
    top: {
        type: String
    },
    modelValue: {
        type: Boolean,
        required: true
    },
    modalClass: String,
    width: {
        type: [
            String,
            Number
        ]
    },
    zIndex: {
        type: Number
    }
});
const dialogEmits = {
    open: ()=>true
    ,
    opened: ()=>true
    ,
    close: ()=>true
    ,
    closed: ()=>true
    ,
    [_eventMjs.UPDATE_MODEL_EVENT]: (value)=>typeof value === "boolean"
};

},{"../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../../utils/vue/props.mjs":"cpwWK","../../../utils/vue/icon.mjs":"3YbE5","../../../constants/event.mjs":"92xVn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kcxXl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useDialog", ()=>useDialog
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../../utils/index.mjs");
var _indexMjs3 = require("../../../hooks/use-z-index/index.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs4 = require("../../../hooks/use-lockscreen/index.mjs");
var _indexMjs5 = require("../../../hooks/use-modal/index.mjs");
var _indexMjs6 = require("../../../hooks/use-restore-active/index.mjs");
const useDialog = (props, { emit  }, targetRef)=>{
    let lastPosition = "";
    const visible = _vue.ref(false);
    const closed = _vue.ref(false);
    const rendered = _vue.ref(false);
    const { nextZIndex  } = _indexMjs3.useZIndex();
    const zIndex = _vue.ref(props.zIndex || nextZIndex());
    let openTimer = void 0;
    let closeTimer = void 0;
    const normalizeWidth = _vue.computed(()=>_core.isNumber(props.width) ? `${props.width}px` : props.width
    );
    const style = _vue.computed(()=>{
        const style2 = {
        };
        const varPrefix = `--el-dialog`;
        if (!props.fullscreen) {
            if (props.top) style2[`${varPrefix}-margin-top`] = props.top;
            if (props.width) style2[`${varPrefix}-width`] = normalizeWidth.value;
        }
        return style2;
    });
    function afterEnter() {
        emit("opened");
    }
    function afterLeave() {
        emit("closed");
        emit(_eventMjs.UPDATE_MODEL_EVENT, false);
        if (props.destroyOnClose) rendered.value = false;
    }
    function beforeLeave() {
        emit("close");
    }
    function open() {
        closeTimer == null || closeTimer();
        openTimer == null || openTimer();
        if (props.openDelay && props.openDelay > 0) ({ stop: openTimer  } = _core.useTimeoutFn(()=>doOpen()
        , props.openDelay));
        else doOpen();
    }
    function close() {
        openTimer == null || openTimer();
        closeTimer == null || closeTimer();
        if (props.closeDelay && props.closeDelay > 0) ({ stop: closeTimer  } = _core.useTimeoutFn(()=>doClose()
        , props.closeDelay));
        else doClose();
    }
    function hide(shouldCancel) {
        if (shouldCancel) return;
        closed.value = true;
        visible.value = false;
    }
    function handleClose() {
        if (props.beforeClose) props.beforeClose(hide);
        else close();
    }
    function onModalClick() {
        if (props.closeOnClickModal) handleClose();
    }
    function doOpen() {
        if (!_core.isClient) return;
        visible.value = true;
    }
    function doClose() {
        visible.value = false;
    }
    if (props.lockScroll) _indexMjs4.useLockscreen(visible);
    if (props.closeOnPressEscape) _indexMjs5.useModal({
        handleClose
    }, visible);
    _indexMjs6.useRestoreActive(visible);
    _vue.watch(()=>props.modelValue
    , (val)=>{
        if (val) {
            closed.value = false;
            open();
            rendered.value = true;
            emit("open");
            zIndex.value = props.zIndex ? zIndex.value++ : nextZIndex();
            _vue.nextTick(()=>{
                if (targetRef.value) targetRef.value.scrollTop = 0;
            });
        } else if (visible.value) close();
    });
    _vue.watch(()=>props.fullscreen
    , (val)=>{
        if (!targetRef.value) return;
        if (val) {
            lastPosition = targetRef.value.style.transform;
            targetRef.value.style.transform = "";
        } else targetRef.value.style.transform = lastPosition;
    });
    _vue.onMounted(()=>{
        if (props.modelValue) {
            visible.value = true;
            rendered.value = true;
            open();
        }
    });
    return {
        afterEnter,
        afterLeave,
        beforeLeave,
        handleClose,
        onModalClick,
        close,
        doClose,
        closed,
        style,
        rendered,
        visible,
        zIndex
    };
};

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../hooks/index.mjs":"1Ansp","../../../constants/index.mjs":"74Fbn","../../../utils/index.mjs":"dsdeP","../../../hooks/use-z-index/index.mjs":"7aKZA","../../../constants/event.mjs":"92xVn","../../../hooks/use-lockscreen/index.mjs":"f9Ur8","../../../hooks/use-modal/index.mjs":"klFTZ","../../../hooks/use-restore-active/index.mjs":"9OlL1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bcJq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dividerProps", ()=>_dividerMjs.dividerProps
);
parcelHelpers.export(exports, "ElDivider", ()=>ElDivider
);
parcelHelpers.export(exports, "default", ()=>ElDivider
);
var _indexMjs = require("../../utils/index.mjs");
var _divider2Mjs = require("./src/divider2.mjs");
var _divider2MjsDefault = parcelHelpers.interopDefault(_divider2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _dividerMjs = require("./src/divider.mjs");
const ElDivider = _installMjs.withInstall(_divider2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/divider2.mjs":"5DEtO","../../utils/vue/install.mjs":"4TMmv","./src/divider.mjs":"X6LID","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5DEtO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Divider
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _dividerMjs = require("./divider.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElDivider",
    props: _dividerMjs.dividerProps,
    setup (props) {
        const ns = _indexMjs1.useNamespace("divider");
        const dividerStyle = _vue.computed(()=>{
            return {
                "--el-border-style": props.borderStyle
            };
        });
        return {
            ns,
            dividerStyle
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.m(_ctx.direction)
        ]),
        style: _vue.normalizeStyle(_ctx.dividerStyle)
    }, [
        _ctx.$slots.default && _ctx.direction !== "vertical" ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 0,
            class: _vue.normalizeClass([
                _ctx.ns.e("text"),
                _ctx.ns.is(_ctx.contentPosition)
            ])
        }, [
            _vue.renderSlot(_ctx.$slots, "default")
        ], 2)) : _vue.createCommentVNode("v-if", true)
    ], 6);
}
var Divider = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./divider.mjs":"X6LID","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"X6LID":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dividerProps", ()=>dividerProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const dividerProps = _propsMjs.buildProps({
    direction: {
        type: String,
        values: [
            "horizontal",
            "vertical"
        ],
        default: "horizontal"
    },
    contentPosition: {
        type: String,
        values: [
            "left",
            "center",
            "right"
        ],
        default: "center"
    },
    borderStyle: {
        type: _propsMjs.definePropType(String),
        default: "solid"
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"DJoCd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawerEmits", ()=>_drawerMjs.drawerEmits
);
parcelHelpers.export(exports, "drawerProps", ()=>_drawerMjs.drawerProps
);
parcelHelpers.export(exports, "ElDrawer", ()=>ElDrawer
);
parcelHelpers.export(exports, "default", ()=>ElDrawer
);
var _indexMjs = require("../../utils/index.mjs");
var _drawer2Mjs = require("./src/drawer2.mjs");
var _drawer2MjsDefault = parcelHelpers.interopDefault(_drawer2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _drawerMjs = require("./src/drawer.mjs");
const ElDrawer = _installMjs.withInstall(_drawer2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/drawer2.mjs":"gFJeW","../../utils/vue/install.mjs":"4TMmv","./src/drawer.mjs":"6GsxM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gFJeW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Drawer
);
var _vue = require("vue");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs = require("../../overlay/index.mjs");
var _indexMjs1 = require("../../dialog/index.mjs");
var _indexMjs2 = require("../../icon/index.mjs");
var _indexMjs3 = require("../../../directives/index.mjs");
var _indexMjs4 = require("../../../hooks/index.mjs");
var _drawerMjs = require("./drawer.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs5 = require("../../../directives/trap-focus/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs5);
var _indexMjs6 = require("../../../hooks/use-namespace/index.mjs");
var _useDialogMjs = require("../../dialog/src/use-dialog.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElDrawer",
    components: {
        ElOverlay: _indexMjs.ElOverlay,
        ElIcon: _indexMjs2.ElIcon,
        Close: _iconsVue.Close
    },
    directives: {
        TrapFocus: _indexMjsDefault.default
    },
    props: _drawerMjs.drawerProps,
    emits: _drawerMjs.drawerEmits,
    setup (props, ctx) {
        const drawerRef = _vue.ref();
        const ns = _indexMjs6.useNamespace("drawer");
        const isHorizontal = _vue.computed(()=>props.direction === "rtl" || props.direction === "ltr"
        );
        const drawerSize = _vue.computed(()=>typeof props.size === "number" ? `${props.size}px` : props.size
        );
        return {
            ..._useDialogMjs.useDialog(props, ctx, drawerRef),
            drawerRef,
            isHorizontal,
            drawerSize,
            ns
        };
    }
});
const _hoisted_1 = [
    "aria-labelledby",
    "aria-label"
];
const _hoisted_2 = [
    "id"
];
const _hoisted_3 = [
    "title"
];
const _hoisted_4 = [
    "aria-label"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_close = _vue.resolveComponent("close");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_overlay = _vue.resolveComponent("el-overlay");
    const _directive_trap_focus = _vue.resolveDirective("trap-focus");
    return _vue.openBlock(), _vue.createBlock(_vue.Teleport, {
        to: "body",
        disabled: !_ctx.appendToBody
    }, [
        _vue.createVNode(_vue.Transition, {
            name: _ctx.ns.b("fade"),
            onAfterEnter: _ctx.afterEnter,
            onAfterLeave: _ctx.afterLeave,
            onBeforeLeave: _ctx.beforeLeave
        }, {
            default: _vue.withCtx(()=>[
                    _vue.withDirectives(_vue.createVNode(_component_el_overlay, {
                        mask: _ctx.modal,
                        "overlay-class": _ctx.modalClass,
                        "z-index": _ctx.zIndex,
                        onClick: _ctx.onModalClick
                    }, {
                        default: _vue.withCtx(()=>[
                                _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
                                    ref: "drawerRef",
                                    "aria-modal": "true",
                                    "aria-labelledby": _ctx.ns.e("title"),
                                    "aria-label": _ctx.title,
                                    class: _vue.normalizeClass([
                                        _ctx.ns.b(),
                                        _ctx.direction,
                                        _ctx.visible && "open",
                                        _ctx.customClass
                                    ]),
                                    style: _vue.normalizeStyle(_ctx.isHorizontal ? "width: " + _ctx.drawerSize : "height: " + _ctx.drawerSize),
                                    role: "dialog",
                                    onClick: _cache[1] || (_cache[1] = _vue.withModifiers(()=>{
                                    }, [
                                        "stop"
                                    ]))
                                }, [
                                    _ctx.withHeader ? (_vue.openBlock(), _vue.createElementBlock("header", {
                                        key: 0,
                                        id: _ctx.ns.e("title"),
                                        class: _vue.normalizeClass(_ctx.ns.e("header"))
                                    }, [
                                        _vue.renderSlot(_ctx.$slots, "title", {
                                        }, ()=>[
                                                _vue.createElementVNode("span", {
                                                    role: "heading",
                                                    title: _ctx.title
                                                }, _vue.toDisplayString(_ctx.title), 9, _hoisted_3)
                                            ]
                                        ),
                                        _ctx.showClose ? (_vue.openBlock(), _vue.createElementBlock("button", {
                                            key: 0,
                                            "aria-label": "close " + (_ctx.title || "drawer"),
                                            class: _vue.normalizeClass(_ctx.ns.e("close-btn")),
                                            type: "button",
                                            onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleClose && _ctx.handleClose(...args)
                                            )
                                        }, [
                                            _vue.createVNode(_component_el_icon, {
                                                class: _vue.normalizeClass(_ctx.ns.e("close"))
                                            }, {
                                                default: _vue.withCtx(()=>[
                                                        _vue.createVNode(_component_close)
                                                    ]
                                                ),
                                                _: 1
                                            }, 8, [
                                                "class"
                                            ])
                                        ], 10, _hoisted_4)) : _vue.createCommentVNode("v-if", true)
                                    ], 10, _hoisted_2)) : _vue.createCommentVNode("v-if", true),
                                    _ctx.rendered ? (_vue.openBlock(), _vue.createElementBlock("section", {
                                        key: 1,
                                        class: _vue.normalizeClass(_ctx.ns.e("body"))
                                    }, [
                                        _vue.renderSlot(_ctx.$slots, "default")
                                    ], 2)) : _vue.createCommentVNode("v-if", true),
                                    _ctx.$slots.footer ? (_vue.openBlock(), _vue.createElementBlock("div", {
                                        key: 2,
                                        class: _vue.normalizeClass(_ctx.ns.e("footer"))
                                    }, [
                                        _vue.renderSlot(_ctx.$slots, "footer")
                                    ], 2)) : _vue.createCommentVNode("v-if", true)
                                ], 14, _hoisted_1)), [
                                    [
                                        _directive_trap_focus
                                    ]
                                ])
                            ]
                        ),
                        _: 3
                    }, 8, [
                        "mask",
                        "overlay-class",
                        "z-index",
                        "onClick"
                    ]), [
                        [
                            _vue.vShow,
                            _ctx.visible
                        ]
                    ])
                ]
            ),
            _: 3
        }, 8, [
            "name",
            "onAfterEnter",
            "onAfterLeave",
            "onBeforeLeave"
        ])
    ], 8, [
        "disabled"
    ]);
}
var Drawer = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@element-plus/icons-vue":"b18uu","../../overlay/index.mjs":"2HJvE","../../dialog/index.mjs":"iXu3z","../../icon/index.mjs":"hnNTG","../../../directives/index.mjs":"aRbJ2","../../../hooks/index.mjs":"1Ansp","./drawer.mjs":"6GsxM","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../directives/trap-focus/index.mjs":"lw3sX","../../../hooks/use-namespace/index.mjs":"a1pcf","../../dialog/src/use-dialog.mjs":"kcxXl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6GsxM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawerEmits", ()=>drawerEmits
);
parcelHelpers.export(exports, "drawerProps", ()=>drawerProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../dialog/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _dialogMjs = require("../../dialog/src/dialog.mjs");
const drawerProps = _propsMjs.buildProps({
    ..._dialogMjs.dialogProps,
    direction: {
        type: String,
        default: "rtl",
        values: [
            "ltr",
            "rtl",
            "ttb",
            "btt"
        ]
    },
    size: {
        type: [
            String,
            Number
        ],
        default: "30%"
    },
    withHeader: {
        type: Boolean,
        default: true
    },
    modalFade: {
        type: Boolean,
        default: true
    }
});
const drawerEmits = _dialogMjs.dialogEmits;

},{"../../../utils/index.mjs":"dsdeP","../../dialog/index.mjs":"iXu3z","../../../utils/vue/props.mjs":"cpwWK","../../dialog/src/dialog.mjs":"imlUB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dk8yW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DROPDOWN_COLLECTION_INJECTION_KEY", ()=>_dropdownMjs.DROPDOWN_COLLECTION_INJECTION_KEY
);
parcelHelpers.export(exports, "DROPDOWN_COLLECTION_ITEM_INJECTION_KEY", ()=>_dropdownMjs.DROPDOWN_COLLECTION_ITEM_INJECTION_KEY
);
parcelHelpers.export(exports, "ElCollection", ()=>_dropdownMjs.ElCollection
);
parcelHelpers.export(exports, "ElCollectionItem", ()=>_dropdownMjs.ElCollectionItem
);
parcelHelpers.export(exports, "FIRST_KEYS", ()=>_dropdownMjs.FIRST_KEYS
);
parcelHelpers.export(exports, "FIRST_LAST_KEYS", ()=>_dropdownMjs.FIRST_LAST_KEYS
);
parcelHelpers.export(exports, "LAST_KEYS", ()=>_dropdownMjs.LAST_KEYS
);
parcelHelpers.export(exports, "dropdownItemProps", ()=>_dropdownMjs.dropdownItemProps
);
parcelHelpers.export(exports, "dropdownMenuProps", ()=>_dropdownMjs.dropdownMenuProps
);
parcelHelpers.export(exports, "dropdownProps", ()=>_dropdownMjs.dropdownProps
);
parcelHelpers.export(exports, "DROPDOWN_INJECTION_KEY", ()=>_tokensMjs.DROPDOWN_INJECTION_KEY
);
parcelHelpers.export(exports, "ElDropdown", ()=>ElDropdown
);
parcelHelpers.export(exports, "ElDropdownItem", ()=>ElDropdownItem
);
parcelHelpers.export(exports, "ElDropdownMenu", ()=>ElDropdownMenu
);
parcelHelpers.export(exports, "default", ()=>ElDropdown
);
var _indexMjs = require("../../utils/index.mjs");
var _dropdown2Mjs = require("./src/dropdown2.mjs");
var _dropdown2MjsDefault = parcelHelpers.interopDefault(_dropdown2Mjs);
var _dropdownItemMjs = require("./src/dropdown-item.mjs");
var _dropdownItemMjsDefault = parcelHelpers.interopDefault(_dropdownItemMjs);
var _dropdownMenuMjs = require("./src/dropdown-menu.mjs");
var _dropdownMenuMjsDefault = parcelHelpers.interopDefault(_dropdownMenuMjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _dropdownMjs = require("./src/dropdown.mjs");
var _tokensMjs = require("./src/tokens.mjs");
const ElDropdown = _installMjs.withInstall(_dropdown2MjsDefault.default, {
    DropdownItem: _dropdownItemMjsDefault.default,
    DropdownMenu: _dropdownMenuMjsDefault.default
});
const ElDropdownItem = _installMjs.withNoopInstall(_dropdownItemMjsDefault.default);
const ElDropdownMenu = _installMjs.withNoopInstall(_dropdownMenuMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/dropdown2.mjs":"h2H6N","./src/dropdown-item.mjs":"d7HNH","./src/dropdown-menu.mjs":"ab1hX","../../utils/vue/install.mjs":"4TMmv","./src/dropdown.mjs":"7C9Hj","./src/tokens.mjs":"ghjhG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h2H6N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Dropdown
);
var _vue = require("vue");
var _indexMjs = require("../../button/index.mjs");
var _indexMjs1 = require("../../tooltip/index.mjs");
var _indexMjs2 = require("../../scrollbar/index.mjs");
var _indexMjs3 = require("../../icon/index.mjs");
var _indexMjs4 = require("../../focus-trap/index.mjs");
var _indexMjs5 = require("../../roving-focus-group/index.mjs");
var _indexMjs6 = require("../../../utils/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs7 = require("../../../hooks/index.mjs");
var _dropdownMjs = require("./dropdown.mjs");
var _tokensMjs = require("./tokens.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _focusTrapMjs = require("../../focus-trap/src/focus-trap.mjs");
var _focusTrapMjsDefault = parcelHelpers.interopDefault(_focusTrapMjs);
var _rovingFocusGroup2Mjs = require("../../roving-focus-group/src/roving-focus-group2.mjs");
var _rovingFocusGroup2MjsDefault = parcelHelpers.interopDefault(_rovingFocusGroup2Mjs);
var _indexMjs8 = require("../../../hooks/use-namespace/index.mjs");
var _styleMjs = require("../../../utils/vue/style.mjs");
var _indexMjs9 = require("../../../hooks/use-common-props/index.mjs");
const { ButtonGroup: ElButtonGroup  } = _indexMjs.ElButton;
const _sfc_main = _vue.defineComponent({
    name: "ElDropdown",
    components: {
        ElButton: _indexMjs.ElButton,
        ElFocusTrap: _focusTrapMjsDefault.default,
        ElButtonGroup,
        ElScrollbar: _indexMjs2.ElScrollbar,
        ElDropdownCollection: _dropdownMjs.ElCollection,
        ElTooltip: _indexMjs1.ElTooltip,
        ElRovingFocusGroup: _rovingFocusGroup2MjsDefault.default,
        ElIcon: _indexMjs3.ElIcon,
        ArrowDown: _iconsVue.ArrowDown
    },
    props: _dropdownMjs.dropdownProps,
    emits: [
        "visible-change",
        "click",
        "command"
    ],
    setup (props, { emit  }) {
        const _instance = _vue.getCurrentInstance();
        const ns = _indexMjs8.useNamespace("dropdown");
        const triggeringElementRef = _vue.ref();
        const referenceElementRef = _vue.ref();
        const popperRef = _vue.ref(null);
        const contentRef = _vue.ref(null);
        const scrollbar = _vue.ref(null);
        const currentTabId = _vue.ref(null);
        const isUsingKeyboard = _vue.ref(false);
        const wrapStyle = _vue.computed(()=>({
                maxHeight: _styleMjs.addUnit(props.maxHeight)
            })
        );
        const dropdownTriggerKls = _vue.computed(()=>[
                ns.m(dropdownSize.value)
            ]
        );
        function handleClick() {
            handleClose();
        }
        function handleClose() {
            var _a;
            (_a = popperRef.value) == null || _a.onClose();
        }
        function handleOpen() {
            var _a;
            (_a = popperRef.value) == null || _a.onOpen();
        }
        const dropdownSize = _indexMjs9.useSize();
        function commandHandler(...args) {
            emit("command", ...args);
        }
        function onItemEnter() {
        }
        function onItemLeave() {
            const contentEl = _vue.unref(contentRef);
            contentEl == null || contentEl.focus();
            currentTabId.value = null;
        }
        function handleCurrentTabIdChange(id) {
            currentTabId.value = id;
        }
        function handleEntryFocus(e) {
            if (!isUsingKeyboard.value) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        }
        _vue.provide(_tokensMjs.DROPDOWN_INJECTION_KEY, {
            contentRef,
            isUsingKeyboard,
            onItemEnter,
            onItemLeave
        });
        _vue.provide("elDropdown", {
            instance: _instance,
            dropdownSize,
            handleClick,
            commandHandler,
            trigger: _vue.toRef(props, "trigger"),
            hideOnClick: _vue.toRef(props, "hideOnClick")
        });
        const onMountOnFocus = (e)=>{
            var _a, _b;
            e.preventDefault();
            (_b = (_a = contentRef.value) == null ? void 0 : _a.focus) == null || _b.call(_a, {
                preventScroll: true
            });
        };
        const handlerMainButtonClick = (event)=>{
            emit("click", event);
        };
        return {
            ns,
            scrollbar,
            wrapStyle,
            dropdownTriggerKls,
            dropdownSize,
            currentTabId,
            handleCurrentTabIdChange,
            handlerMainButtonClick,
            handleEntryFocus,
            handleClose,
            handleOpen,
            onMountOnFocus,
            popperRef,
            triggeringElementRef,
            referenceElementRef
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    var _a;
    const _component_el_dropdown_collection = _vue.resolveComponent("el-dropdown-collection");
    const _component_el_roving_focus_group = _vue.resolveComponent("el-roving-focus-group");
    const _component_el_focus_trap = _vue.resolveComponent("el-focus-trap");
    const _component_el_scrollbar = _vue.resolveComponent("el-scrollbar");
    const _component_el_tooltip = _vue.resolveComponent("el-tooltip");
    const _component_el_button = _vue.resolveComponent("el-button");
    const _component_arrow_down = _vue.resolveComponent("arrow-down");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_button_group = _vue.resolveComponent("el-button-group");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.ns.b())
    }, [
        _vue.createVNode(_component_el_tooltip, {
            ref: "popperRef",
            effect: _ctx.effect,
            "fallback-placements": [
                "bottom",
                "top"
            ],
            "popper-options": _ctx.popperOptions,
            "gpu-acceleration": false,
            "hide-after": _ctx.hideTimeout,
            "manual-mode": true,
            placement: _ctx.placement,
            "popper-class": [
                _ctx.ns.e("popper"),
                _ctx.popperClass
            ],
            "reference-element": (_a = _ctx.referenceElementRef) == null ? void 0 : _a.$el,
            trigger: _ctx.trigger,
            "show-after": _ctx.showTimeout,
            "stop-popper-mouse-event": false,
            "virtual-ref": _ctx.triggeringElementRef,
            "virtual-triggering": _ctx.splitButton,
            "append-to-body": "",
            pure: "",
            transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
            persistent: "",
            onShow: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("visible-change", true)
            ),
            onHide: _cache[1] || (_cache[1] = ($event)=>_ctx.$emit("visible-change", false)
            )
        }, _vue.createSlots({
            content: _vue.withCtx(()=>[
                    _vue.createVNode(_component_el_scrollbar, {
                        ref: "scrollbar",
                        "wrap-style": _ctx.wrapStyle,
                        tag: "ul",
                        "view-class": _ctx.ns.e("list")
                    }, {
                        default: _vue.withCtx(()=>[
                                _vue.createVNode(_component_el_focus_trap, {
                                    trapped: "",
                                    onMountOnFocus: _ctx.onMountOnFocus
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_el_roving_focus_group, {
                                                loop: _ctx.loop,
                                                "current-tab-id": _ctx.currentTabId,
                                                orientation: "horizontal",
                                                onCurrentTabIdChange: _ctx.handleCurrentTabIdChange,
                                                onEntryFocus: _ctx.handleEntryFocus
                                            }, {
                                                default: _vue.withCtx(()=>[
                                                        _vue.createVNode(_component_el_dropdown_collection, null, {
                                                            default: _vue.withCtx(()=>[
                                                                    _vue.renderSlot(_ctx.$slots, "dropdown")
                                                                ]
                                                            ),
                                                            _: 3
                                                        })
                                                    ]
                                                ),
                                                _: 3
                                            }, 8, [
                                                "loop",
                                                "current-tab-id",
                                                "onCurrentTabIdChange",
                                                "onEntryFocus"
                                            ])
                                        ]
                                    ),
                                    _: 3
                                }, 8, [
                                    "onMountOnFocus"
                                ])
                            ]
                        ),
                        _: 3
                    }, 8, [
                        "wrap-style",
                        "view-class"
                    ])
                ]
            ),
            _: 2
        }, [
            !_ctx.splitButton ? {
                name: "default",
                fn: _vue.withCtx(()=>[
                        _vue.createElementVNode("div", {
                            class: _vue.normalizeClass(_ctx.dropdownTriggerKls)
                        }, [
                            _vue.renderSlot(_ctx.$slots, "default")
                        ], 2)
                    ]
                )
            } : void 0
        ]), 1032, [
            "effect",
            "popper-options",
            "hide-after",
            "placement",
            "popper-class",
            "reference-element",
            "trigger",
            "show-after",
            "virtual-ref",
            "virtual-triggering",
            "transition"
        ]),
        _ctx.splitButton ? (_vue.openBlock(), _vue.createBlock(_component_el_button_group, {
            key: 0
        }, {
            default: _vue.withCtx(()=>[
                    _vue.createVNode(_component_el_button, {
                        ref: "referenceElementRef",
                        size: _ctx.dropdownSize,
                        type: _ctx.type,
                        onClick: _ctx.handlerMainButtonClick
                    }, {
                        default: _vue.withCtx(()=>[
                                _vue.renderSlot(_ctx.$slots, "default")
                            ]
                        ),
                        _: 3
                    }, 8, [
                        "size",
                        "type",
                        "onClick"
                    ]),
                    _vue.createVNode(_component_el_button, {
                        ref: "triggeringElementRef",
                        size: _ctx.dropdownSize,
                        type: _ctx.type,
                        class: _vue.normalizeClass(_ctx.ns.e("caret-button"))
                    }, {
                        default: _vue.withCtx(()=>[
                                _vue.createVNode(_component_el_icon, {
                                    class: _vue.normalizeClass(_ctx.ns.e("icon"))
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_arrow_down)
                                        ]
                                    ),
                                    _: 1
                                }, 8, [
                                    "class"
                                ])
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "size",
                        "type",
                        "class"
                    ])
                ]
            ),
            _: 3
        })) : _vue.createCommentVNode("v-if", true)
    ], 2);
}
var Dropdown = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../button/index.mjs":"64Ym1","../../tooltip/index.mjs":"kiwBC","../../scrollbar/index.mjs":"kXLHt","../../icon/index.mjs":"hnNTG","../../focus-trap/index.mjs":"dSOZm","../../roving-focus-group/index.mjs":"c0fzg","../../../utils/index.mjs":"dsdeP","@element-plus/icons-vue":"b18uu","../../../hooks/index.mjs":"1Ansp","./dropdown.mjs":"7C9Hj","./tokens.mjs":"ghjhG","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../focus-trap/src/focus-trap.mjs":"6mIbI","../../roving-focus-group/src/roving-focus-group2.mjs":"cEXXy","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/vue/style.mjs":"pODHb","../../../hooks/use-common-props/index.mjs":"05czU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dSOZm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElFocusTrap", ()=>_focusTrapMjsDefault.default
);
parcelHelpers.export(exports, "default", ()=>_focusTrapMjsDefault.default
);
parcelHelpers.export(exports, "FOCUS_ON_MOUNT", ()=>_tokensMjs.FOCUS_ON_MOUNT
);
parcelHelpers.export(exports, "FOCUS_ON_MOUNT_OPTS", ()=>_tokensMjs.FOCUS_ON_MOUNT_OPTS
);
parcelHelpers.export(exports, "FOCUS_ON_UNMOUNT", ()=>_tokensMjs.FOCUS_ON_UNMOUNT
);
parcelHelpers.export(exports, "FOCUS_TRAP_INJECTION_KEY", ()=>_tokensMjs.FOCUS_TRAP_INJECTION_KEY
);
parcelHelpers.export(exports, "ON_MOUNT_FOCUS_EVT", ()=>_tokensMjs.ON_MOUNT_FOCUS_EVT
);
parcelHelpers.export(exports, "ON_UNMOUNT_FOCUS_EVT", ()=>_tokensMjs.ON_UNMOUNT_FOCUS_EVT
);
parcelHelpers.export(exports, "focusFirstDescendant", ()=>_utilsMjs.focusFirstDescendant
);
parcelHelpers.export(exports, "focusableStack", ()=>_utilsMjs.focusableStack
);
parcelHelpers.export(exports, "getEdges", ()=>_utilsMjs.getEdges
);
parcelHelpers.export(exports, "getVisibleElement", ()=>_utilsMjs.getVisibleElement
);
parcelHelpers.export(exports, "isHidden", ()=>_utilsMjs.isHidden
);
parcelHelpers.export(exports, "obtainAllFocusableElements", ()=>_utilsMjs.obtainAllFocusableElements
);
parcelHelpers.export(exports, "tryFocus", ()=>_utilsMjs.tryFocus
);
var _focusTrapMjs = require("./src/focus-trap.mjs");
var _focusTrapMjsDefault = parcelHelpers.interopDefault(_focusTrapMjs);
var _tokensMjs = require("./src/tokens.mjs");
var _utilsMjs = require("./src/utils.mjs");

},{"./src/focus-trap.mjs":"6mIbI","./src/tokens.mjs":"9DFns","./src/utils.mjs":"CDHCS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6mIbI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElFocusTrap
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _utilsMjs = require("./utils.mjs");
var _tokensMjs = require("./tokens.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _ariaMjs = require("../../../constants/aria.mjs");
var _eventMjs = require("../../../utils/dom/event.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElFocusTrap",
    inheritAttrs: false,
    props: {
        loop: Boolean,
        trapped: Boolean
    },
    emits: [
        _tokensMjs.ON_MOUNT_FOCUS_EVT,
        _tokensMjs.ON_UNMOUNT_FOCUS_EVT
    ],
    setup (props, { emit  }) {
        const focusTrapRef = _vue.ref();
        const forwardRef = _vue.ref(null);
        let lastFocusBeforeMounted;
        let lastFocusAfterMounted;
        const focusLayer = {
            paused: false,
            pause () {
                this.paused = true;
            },
            resume () {
                this.paused = false;
            }
        };
        const onKeydown = (e)=>{
            if (!props.loop && !props.trapped) return;
            if (focusLayer.paused) return;
            const { key , altKey , ctrlKey , metaKey , currentTarget , shiftKey  } = e;
            const { loop  } = props;
            const isTabbing = key === _ariaMjs.EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
                const container = currentTarget;
                const [first, last] = _utilsMjs.getEdges(container);
                const isTabbable = first && last;
                if (!isTabbable) {
                    if (currentFocusingEl === container) e.preventDefault();
                } else {
                    if (!shiftKey && currentFocusingEl === last) {
                        e.preventDefault();
                        if (loop) _utilsMjs.tryFocus(first, true);
                    } else if (shiftKey && currentFocusingEl === first) {
                        e.preventDefault();
                        if (loop) _utilsMjs.tryFocus(last, true);
                    }
                }
            }
        };
        _vue.provide(_tokensMjs.FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
        });
        const focusOnMount = (e)=>{
            emit(_tokensMjs.ON_MOUNT_FOCUS_EVT, e);
        };
        const focusOnUnmount = (e)=>emit(_tokensMjs.ON_UNMOUNT_FOCUS_EVT, e)
        ;
        const onFocusIn = (e)=>{
            const trapContainer = _vue.unref(forwardRef);
            if (focusLayer.paused || !trapContainer) return;
            const target = e.target;
            if (target && trapContainer.contains(target)) lastFocusAfterMounted = target;
            else _utilsMjs.tryFocus(lastFocusAfterMounted, true);
        };
        const onFocusOut = (e)=>{
            const trapContainer = _vue.unref(forwardRef);
            if (focusLayer.paused || !trapContainer) return;
            if (!trapContainer.contains(e.relatedTarget)) _utilsMjs.tryFocus(lastFocusAfterMounted, true);
        };
        _vue.onMounted(()=>{
            const trapContainer = _vue.unref(forwardRef);
            if (trapContainer) {
                _utilsMjs.focusableStack.push(focusLayer);
                const prevFocusedElement = document.activeElement;
                lastFocusBeforeMounted = prevFocusedElement;
                const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
                if (!isPrevFocusContained) {
                    const mountEvent = new Event(_tokensMjs.FOCUS_ON_MOUNT, _tokensMjs.FOCUS_ON_MOUNT_OPTS);
                    _eventMjs.on(trapContainer, _tokensMjs.FOCUS_ON_MOUNT, focusOnMount);
                    trapContainer.dispatchEvent(mountEvent);
                    if (!mountEvent.defaultPrevented) {
                        _utilsMjs.focusFirstDescendant(_utilsMjs.obtainAllFocusableElements(trapContainer), true);
                        if (document.activeElement === prevFocusedElement) _utilsMjs.tryFocus(trapContainer);
                    }
                }
            }
            _vue.watch(()=>props.trapped
            , (trapped)=>{
                if (trapped) {
                    _eventMjs.on(document, "focusin", onFocusIn);
                    _eventMjs.on(document, "focusout", onFocusOut);
                } else {
                    _eventMjs.off(document, "focusin", onFocusIn);
                    _eventMjs.off(document, "focusout", onFocusOut);
                }
            }, {
                immediate: true
            });
        });
        _vue.onBeforeUnmount(()=>{
            const trapContainer = _vue.unref(forwardRef);
            if (trapContainer) {
                _eventMjs.off(trapContainer, _tokensMjs.FOCUS_ON_MOUNT, focusOnMount);
                const unmountEvent = new Event(_tokensMjs.FOCUS_ON_UNMOUNT, _tokensMjs.FOCUS_ON_MOUNT_OPTS);
                _eventMjs.on(trapContainer, _tokensMjs.FOCUS_ON_UNMOUNT, focusOnUnmount);
                trapContainer.dispatchEvent(unmountEvent);
                if (!unmountEvent.defaultPrevented) _utilsMjs.tryFocus(lastFocusBeforeMounted != null ? lastFocusBeforeMounted : document.body, true);
                _eventMjs.off(trapContainer, _tokensMjs.FOCUS_ON_UNMOUNT, focusOnUnmount);
                _utilsMjs.focusableStack.remove(focusLayer);
            }
        });
        return {
            focusTrapRef,
            forwardRef,
            onKeydown
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.renderSlot(_ctx.$slots, "default");
}
var ElFocusTrap = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","./utils.mjs":"CDHCS","./tokens.mjs":"9DFns","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../constants/aria.mjs":"jS6iK","../../../utils/dom/event.mjs":"fnXSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"CDHCS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "focusFirstDescendant", ()=>focusFirstDescendant
);
parcelHelpers.export(exports, "focusableStack", ()=>focusableStack
);
parcelHelpers.export(exports, "getEdges", ()=>getEdges
);
parcelHelpers.export(exports, "getVisibleElement", ()=>getVisibleElement
);
parcelHelpers.export(exports, "isHidden", ()=>isHidden
);
parcelHelpers.export(exports, "obtainAllFocusableElements", ()=>obtainAllFocusableElements
);
parcelHelpers.export(exports, "tryFocus", ()=>tryFocus
);
const obtainAllFocusableElements = (element)=>{
    const nodes = [];
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: (node)=>{
            const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
            if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
            return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
    });
    while(walker.nextNode())nodes.push(walker.currentNode);
    return nodes;
};
const getVisibleElement = (elements, container)=>{
    for (const element of elements){
        if (!isHidden(element, container)) return element;
    }
};
const isHidden = (element, container)=>{
    if (getComputedStyle(element).visibility === "hidden") return true;
    while(element){
        if (container && element === container) return false;
        if (getComputedStyle(element).display === "none") return true;
        element = element.parentElement;
    }
    return false;
};
const getEdges = (container)=>{
    const focusable = obtainAllFocusableElements(container);
    const first = getVisibleElement(focusable, container);
    const last = getVisibleElement(focusable.reverse(), container);
    return [
        first,
        last
    ];
};
const isSelectable = (element)=>{
    return element instanceof HTMLInputElement && "select" in element;
};
const tryFocus = (element, shouldSelect)=>{
    if (element && element.focus) {
        const prevFocusedElement = document.activeElement;
        element.focus({
            preventScroll: true
        });
        if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) element.select();
    }
};
function removeFromStack(list, item) {
    const copy = [
        ...list
    ];
    const idx = list.indexOf(item);
    if (idx !== -1) copy.splice(idx, 1);
    return copy;
}
const createFocusableStack = ()=>{
    let stack = [];
    const push = (layer)=>{
        const currentLayer = stack[0];
        if (currentLayer && layer !== currentLayer) currentLayer.pause();
        stack = removeFromStack(stack, layer);
        stack.unshift(layer);
    };
    const remove = (layer)=>{
        var _a, _b;
        stack = removeFromStack(stack, layer);
        (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null || _b.call(_a);
    };
    return {
        push,
        remove
    };
};
const focusFirstDescendant = (elements, shouldSelect = false)=>{
    const prevFocusedElement = document.activeElement;
    for (const element of elements){
        tryFocus(element, shouldSelect);
        if (document.activeElement !== prevFocusedElement) return;
    }
};
const focusableStack = createFocusableStack();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9DFns":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FOCUS_ON_MOUNT", ()=>FOCUS_ON_MOUNT
);
parcelHelpers.export(exports, "FOCUS_ON_MOUNT_OPTS", ()=>FOCUS_ON_MOUNT_OPTS
);
parcelHelpers.export(exports, "FOCUS_ON_UNMOUNT", ()=>FOCUS_ON_UNMOUNT
);
parcelHelpers.export(exports, "FOCUS_TRAP_INJECTION_KEY", ()=>FOCUS_TRAP_INJECTION_KEY
);
parcelHelpers.export(exports, "ON_MOUNT_FOCUS_EVT", ()=>ON_MOUNT_FOCUS_EVT
);
parcelHelpers.export(exports, "ON_UNMOUNT_FOCUS_EVT", ()=>ON_UNMOUNT_FOCUS_EVT
);
const FOCUS_ON_MOUNT = "focus-trap.focus-on-mount";
const FOCUS_ON_UNMOUNT = "focus-trap.focus-on-unmount";
const FOCUS_ON_MOUNT_OPTS = {
    cancelable: true,
    bubbles: false
};
const ON_MOUNT_FOCUS_EVT = "mountOnFocus";
const ON_UNMOUNT_FOCUS_EVT = "unmountOnFocus";
const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c0fzg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElRovingFocusGroup", ()=>_rovingFocusGroup2MjsDefault.default
);
parcelHelpers.export(exports, "default", ()=>_rovingFocusGroup2MjsDefault.default
);
parcelHelpers.export(exports, "ElRovingFocusItem", ()=>_rovingFocusItemMjsDefault.default
);
parcelHelpers.export(exports, "ROVING_FOCUS_GROUP_INJECTION_KEY", ()=>_tokensMjs.ROVING_FOCUS_GROUP_INJECTION_KEY
);
parcelHelpers.export(exports, "ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY", ()=>_tokensMjs.ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY
);
parcelHelpers.export(exports, "focusFirst", ()=>_utilsMjs.focusFirst
);
parcelHelpers.export(exports, "getFocusIntent", ()=>_utilsMjs.getFocusIntent
);
parcelHelpers.export(exports, "reorderArray", ()=>_utilsMjs.reorderArray
);
parcelHelpers.export(exports, "ROVING_FOCUS_COLLECTION_INJECTION_KEY", ()=>_rovingFocusGroupMjs.ROVING_FOCUS_COLLECTION_INJECTION_KEY
);
parcelHelpers.export(exports, "ROVING_FOCUS_ITEM_COLLECTION_INJECTION_KEY", ()=>_rovingFocusGroupMjs.ROVING_FOCUS_ITEM_COLLECTION_INJECTION_KEY
);
var _rovingFocusGroup2Mjs = require("./src/roving-focus-group2.mjs");
var _rovingFocusGroup2MjsDefault = parcelHelpers.interopDefault(_rovingFocusGroup2Mjs);
var _rovingFocusItemMjs = require("./src/roving-focus-item.mjs");
var _rovingFocusItemMjsDefault = parcelHelpers.interopDefault(_rovingFocusItemMjs);
var _tokensMjs = require("./src/tokens.mjs");
var _utilsMjs = require("./src/utils.mjs");
var _rovingFocusGroupMjs = require("./src/roving-focus-group.mjs");

},{"./src/roving-focus-group2.mjs":"cEXXy","./src/roving-focus-item.mjs":"hennk","./src/tokens.mjs":"2nYZU","./src/utils.mjs":"7ZQhG","./src/roving-focus-group.mjs":"hfjEe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cEXXy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElRovingFocusGroup
);
var _vue = require("vue");
var _rovingFocusGroupImplMjs = require("./roving-focus-group-impl.mjs");
var _rovingFocusGroupImplMjsDefault = parcelHelpers.interopDefault(_rovingFocusGroupImplMjs);
var _rovingFocusGroupMjs = require("./roving-focus-group.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ElRovingFocusGroup",
    components: {
        ElFocusGroupCollection: _rovingFocusGroupMjs.ElCollection,
        ElRovingFocusGroupImpl: _rovingFocusGroupImplMjsDefault.default
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_roving_focus_group_impl = _vue.resolveComponent("el-roving-focus-group-impl");
    const _component_el_focus_group_collection = _vue.resolveComponent("el-focus-group-collection");
    return _vue.openBlock(), _vue.createBlock(_component_el_focus_group_collection, null, {
        default: _vue.withCtx(()=>[
                _vue.createVNode(_component_el_roving_focus_group_impl, _vue.normalizeProps(_vue.guardReactiveProps(_ctx.$attrs)), {
                    default: _vue.withCtx(()=>[
                            _vue.renderSlot(_ctx.$slots, "default")
                        ]
                    ),
                    _: 3
                }, 16)
            ]
        ),
        _: 3
    });
}
var ElRovingFocusGroup = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","./roving-focus-group-impl.mjs":"c7YYs","./roving-focus-group.mjs":"hfjEe","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c7YYs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElRovingFocusGroupImpl
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _rovingFocusGroupMjs = require("./roving-focus-group.mjs");
var _tokensMjs = require("./tokens.mjs");
var _utilsMjs = require("./utils.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _eventMjs = require("../../../utils/dom/event.mjs");
const CURRENT_TAB_ID_CHANGE_EVT = "currentTabIdChange";
const ENTRY_FOCUS_EVT = "rovingFocusGroup.entryFocus";
const EVT_OPTS = {
    bubbles: false,
    cancelable: true
};
const _sfc_main = _vue.defineComponent({
    name: "ElRovingFocusGroupImpl",
    inheritAttrs: false,
    props: _rovingFocusGroupMjs.rovingFocusGroupProps,
    emits: [
        CURRENT_TAB_ID_CHANGE_EVT,
        "entryFocus"
    ],
    setup (props, { emit  }) {
        var _a;
        const currentTabbedId = _vue.ref((_a = props.currentTabId || props.defaultCurrentTabId) != null ? _a : null);
        const isBackingOut = _vue.ref(false);
        const isClickFocus = _vue.ref(false);
        const rovingFocusGroupRef = _vue.ref(null);
        const { getItems  } = _vue.inject(_rovingFocusGroupMjs.ROVING_FOCUS_COLLECTION_INJECTION_KEY, void 0);
        const rovingFocusGroupRootStyle = _vue.computed(()=>{
            return [
                {
                    outline: "none"
                },
                props.style
            ];
        });
        const onItemFocus = (tabbedId)=>{
            emit(CURRENT_TAB_ID_CHANGE_EVT, tabbedId);
        };
        const onItemShiftTab = ()=>{
            isBackingOut.value = true;
        };
        const onMousedown = _eventMjs.composeEventHandlers((e)=>{
            var _a2;
            (_a2 = props.onMousedown) == null || _a2.call(props, e);
        }, ()=>{
            isClickFocus.value = true;
        });
        const onFocus = _eventMjs.composeEventHandlers((e)=>{
            var _a2;
            (_a2 = props.onFocus) == null || _a2.call(props, e);
        }, (e)=>{
            const isKeyboardFocus = !_vue.unref(isClickFocus);
            const { target , currentTarget  } = e;
            if (target === currentTarget && isKeyboardFocus && !_vue.unref(isBackingOut)) {
                const entryFocusEvt = new Event(ENTRY_FOCUS_EVT, EVT_OPTS);
                currentTarget == null || currentTarget.dispatchEvent(entryFocusEvt);
                if (!entryFocusEvt.defaultPrevented) {
                    const items = getItems().filter((item)=>item.focusable
                    );
                    const activeItem = items.find((item)=>item.active
                    );
                    const currentItem = items.find((item)=>item.id === _vue.unref(currentTabbedId)
                    );
                    const candidates = [
                        activeItem,
                        currentItem,
                        ...items
                    ].filter(Boolean);
                    const candidateNodes = candidates.map((item)=>item.ref
                    );
                    _utilsMjs.focusFirst(candidateNodes);
                }
            }
            isClickFocus.value = false;
        });
        const onBlur = _eventMjs.composeEventHandlers((e)=>{
            var _a2;
            (_a2 = props.onBlur) == null || _a2.call(props, e);
        }, ()=>{
            isBackingOut.value = false;
        });
        const handleEntryFocus = (...args)=>{
            emit("entryFocus", ...args);
        };
        _vue.provide(_tokensMjs.ROVING_FOCUS_GROUP_INJECTION_KEY, {
            currentTabbedId: _vue.readonly(currentTabbedId),
            loop: _vue.toRef(props, "loop"),
            tabIndex: _vue.computed(()=>{
                return _vue.unref(isBackingOut) ? -1 : 0;
            }),
            rovingFocusGroupRef,
            rovingFocusGroupRootStyle,
            orientation: _vue.toRef(props, "orientation"),
            dir: _vue.toRef(props, "dir"),
            onItemFocus,
            onItemShiftTab,
            onBlur,
            onFocus,
            onMousedown
        });
        _vue.watch(()=>props.currentTabId
        , (val)=>{
            currentTabbedId.value = val != null ? val : null;
        });
        _vue.onMounted(()=>{
            const rovingFocusGroupEl = _vue.unref(rovingFocusGroupRef);
            _eventMjs.on(rovingFocusGroupEl, ENTRY_FOCUS_EVT, handleEntryFocus);
        });
        _vue.onBeforeUnmount(()=>{
            const rovingFocusGroupEl = _vue.unref(rovingFocusGroupRef);
            _eventMjs.off(rovingFocusGroupEl, ENTRY_FOCUS_EVT, handleEntryFocus);
        });
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.renderSlot(_ctx.$slots, "default");
}
var ElRovingFocusGroupImpl = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","./roving-focus-group.mjs":"hfjEe","./tokens.mjs":"2nYZU","./utils.mjs":"7ZQhG","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/dom/event.mjs":"fnXSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hfjEe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElCollection", ()=>ElCollection
);
parcelHelpers.export(exports, "ElCollectionItem", ()=>ElCollectionItem
);
parcelHelpers.export(exports, "ROVING_FOCUS_COLLECTION_INJECTION_KEY", ()=>COLLECTION_INJECTION_KEY
);
parcelHelpers.export(exports, "ROVING_FOCUS_ITEM_COLLECTION_INJECTION_KEY", ()=>COLLECTION_ITEM_INJECTION_KEY
);
parcelHelpers.export(exports, "rovingFocusGroupProps", ()=>rovingFocusGroupProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../collection/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _collectionMjs = require("../../collection/src/collection.mjs");
const rovingFocusGroupProps = _propsMjs.buildProps({
    style: {
        type: _propsMjs.definePropType([
            String,
            Array,
            Object
        ])
    },
    currentTabId: {
        type: _propsMjs.definePropType(String)
    },
    defaultCurrentTabId: String,
    loop: Boolean,
    dir: {
        type: String,
        values: [
            "ltr",
            "rtl"
        ],
        default: "ltr"
    },
    orientation: {
        type: _propsMjs.definePropType(String)
    },
    onBlur: Function,
    onFocus: Function,
    onMousedown: Function
});
const { ElCollection , ElCollectionItem , COLLECTION_INJECTION_KEY , COLLECTION_ITEM_INJECTION_KEY  } = _collectionMjs.createCollectionWithScope("RovingFocusGroup");

},{"../../../utils/index.mjs":"dsdeP","../../collection/index.mjs":"9OhGg","../../../utils/vue/props.mjs":"cpwWK","../../collection/src/collection.mjs":"82Qvm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9OhGg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "COLLECTION_ITEM_SIGN", ()=>_collectionMjs.COLLECTION_ITEM_SIGN
);
parcelHelpers.export(exports, "createCollectionWithScope", ()=>_collectionMjs.createCollectionWithScope
);
var _tokensMjs = require("./src/tokens.mjs");
var _collectionMjs = require("./src/collection.mjs");

},{"./src/tokens.mjs":"1mvN5","./src/collection.mjs":"82Qvm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1mvN5":[function(require,module,exports) {

},{}],"82Qvm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "COLLECTION_ITEM_SIGN", ()=>COLLECTION_ITEM_SIGN
);
parcelHelpers.export(exports, "createCollectionWithScope", ()=>createCollectionWithScope
);
var _vue = require("vue");
var _collection2Mjs = require("./collection2.mjs");
var _collection2MjsDefault = parcelHelpers.interopDefault(_collection2Mjs);
var _collectionItemMjs = require("./collection-item.mjs");
var _collectionItemMjsDefault = parcelHelpers.interopDefault(_collectionItemMjs);
const COLLECTION_ITEM_SIGN = `data-el-collection-item`;
const createCollectionWithScope = (name)=>{
    const COLLECTION_NAME = `El${name}Collection`;
    const COLLECTION_ITEM_NAME = `${COLLECTION_NAME}Item`;
    const COLLECTION_INJECTION_KEY = Symbol(COLLECTION_NAME);
    const COLLECTION_ITEM_INJECTION_KEY = Symbol(COLLECTION_ITEM_NAME);
    const ElCollection = {
        ..._collection2MjsDefault.default,
        name: COLLECTION_NAME,
        setup () {
            const collectionRef = _vue.ref(null);
            const itemMap = /* @__PURE__ */ new Map();
            const getItems = ()=>{
                const collectionEl = _vue.unref(collectionRef);
                if (!collectionEl) return [];
                const orderedNodes = Array.from(collectionEl.querySelectorAll(`[${COLLECTION_ITEM_SIGN}]`));
                const items = [
                    ...itemMap.values()
                ];
                const orderedItems = items.sort((a, b)=>orderedNodes.indexOf(a.ref) - orderedNodes.indexOf(b.ref)
                );
                return orderedItems;
            };
            _vue.provide(COLLECTION_INJECTION_KEY, {
                itemMap,
                getItems,
                collectionRef
            });
        }
    };
    const ElCollectionItem = {
        ..._collectionItemMjsDefault.default,
        name: COLLECTION_ITEM_NAME,
        setup (_, { attrs  }) {
            const collectionItemRef = _vue.ref(null);
            const collectionInjection = _vue.inject(COLLECTION_INJECTION_KEY, void 0);
            _vue.provide(COLLECTION_ITEM_INJECTION_KEY, {
                collectionItemRef
            });
            _vue.onMounted(()=>{
                const collectionItemEl = _vue.unref(collectionItemRef);
                if (collectionItemEl) collectionInjection.itemMap.set(collectionItemEl, {
                    ref: collectionItemEl,
                    ...attrs
                });
            });
            _vue.onBeforeUnmount(()=>{
                const collectionItemEl = _vue.unref(collectionItemRef);
                collectionInjection.itemMap.delete(collectionItemEl);
            });
        }
    };
    return {
        COLLECTION_INJECTION_KEY,
        COLLECTION_ITEM_INJECTION_KEY,
        ElCollection,
        ElCollectionItem
    };
};

},{"vue":"gzxs9","./collection2.mjs":"bneT0","./collection-item.mjs":"dOvjk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bneT0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Collection
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    inheritAttrs: false
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.renderSlot(_ctx.$slots, "default");
}
var Collection = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dOvjk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CollectionItem
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ElCollectionItem",
    inheritAttrs: false
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.renderSlot(_ctx.$slots, "default");
}
var CollectionItem = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2nYZU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ROVING_FOCUS_GROUP_INJECTION_KEY", ()=>ROVING_FOCUS_GROUP_INJECTION_KEY
);
parcelHelpers.export(exports, "ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY", ()=>ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY
);
const ROVING_FOCUS_GROUP_INJECTION_KEY = Symbol("elRovingFocusGroup");
const ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY = Symbol("elRovingFocusGroupItem");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7ZQhG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "focusFirst", ()=>focusFirst
);
parcelHelpers.export(exports, "getFocusIntent", ()=>getFocusIntent
);
parcelHelpers.export(exports, "reorderArray", ()=>reorderArray
);
var _indexMjs = require("../../../constants/index.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
const MAP_KEY_TO_FOCUS_INTENT = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
};
const getDirectionAwareKey = (key, dir)=>{
    if (dir !== "rtl") return key;
    switch(key){
        case _ariaMjs.EVENT_CODE.right:
            return _ariaMjs.EVENT_CODE.left;
        case _ariaMjs.EVENT_CODE.left:
            return _ariaMjs.EVENT_CODE.right;
        default:
            return key;
    }
};
const getFocusIntent = (event, orientation, dir)=>{
    const key = getDirectionAwareKey(event.key, dir);
    if (orientation === "vertical" && [
        _ariaMjs.EVENT_CODE.left,
        _ariaMjs.EVENT_CODE.right
    ].includes(key)) return void 0;
    if (orientation === "horizontal" && [
        _ariaMjs.EVENT_CODE.up,
        _ariaMjs.EVENT_CODE.down
    ].includes(key)) return void 0;
    return MAP_KEY_TO_FOCUS_INTENT[key];
};
const reorderArray = (array, atIdx)=>{
    return array.map((_, idx)=>array[(idx + atIdx) % array.length]
    );
};
const focusFirst = (elements)=>{
    const { activeElement: prevActive  } = document;
    for (const element of elements){
        if (element === prevActive) return;
        element.focus();
        if (prevActive !== document.activeElement) return;
    }
};

},{"../../../constants/index.mjs":"74Fbn","../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hennk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElRovingFocusItem
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../../constants/index.mjs");
var _rovingFocusGroupMjs = require("./roving-focus-group.mjs");
var _tokensMjs = require("./tokens.mjs");
var _utilsMjs = require("./utils.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../hooks/use-id/index.mjs");
var _eventMjs = require("../../../utils/dom/event.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
const _sfc_main = _vue.defineComponent({
    components: {
        ElRovingFocusCollectionItem: _rovingFocusGroupMjs.ElCollectionItem
    },
    props: {
        focusable: {
            type: Boolean,
            default: true
        },
        active: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "mousedown",
        "focus",
        "keydown"
    ],
    setup (props, { emit  }) {
        const { currentTabbedId , loop , onItemFocus , onItemShiftTab  } = _vue.inject(_tokensMjs.ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
        const { getItems  } = _vue.inject(_rovingFocusGroupMjs.ROVING_FOCUS_COLLECTION_INJECTION_KEY, void 0);
        const id = _indexMjs3.useId();
        const rovingFocusGroupItemRef = _vue.ref(null);
        const handleMousedown = _eventMjs.composeEventHandlers((e)=>{
            emit("mousedown", e);
        }, (e)=>{
            if (!props.focusable) e.preventDefault();
            else onItemFocus(_vue.unref(id));
        });
        const handleFocus = _eventMjs.composeEventHandlers((e)=>{
            emit("focus", e);
        }, ()=>{
            onItemFocus(_vue.unref(id));
        });
        const handleKeydown = _eventMjs.composeEventHandlers((e)=>{
            emit("keydown", e);
        }, (e)=>{
            const { key , shiftKey , target , currentTarget  } = e;
            if (key === _ariaMjs.EVENT_CODE.tab && shiftKey) {
                onItemShiftTab();
                return;
            }
            if (target !== currentTarget) return;
            const focusIntent = _utilsMjs.getFocusIntent(e);
            if (focusIntent) {
                e.preventDefault();
                const items = getItems().filter((item)=>item.focusable
                );
                let elements = items.map((item)=>item.ref
                );
                switch(focusIntent){
                    case "last":
                        elements.reverse();
                        break;
                    case "prev":
                    case "next":
                        {
                            if (focusIntent === "prev") elements.reverse();
                            const currentIdx = elements.indexOf(currentTarget);
                            elements = loop.value ? _utilsMjs.reorderArray(elements, currentIdx + 1) : elements.slice(currentIdx + 1);
                            break;
                        }
                    default:
                        break;
                }
                _vue.nextTick(()=>{
                    _utilsMjs.focusFirst(elements);
                });
            }
        });
        const isCurrentTab = _vue.computed(()=>currentTabbedId.value === _vue.unref(id)
        );
        _vue.provide(_tokensMjs.ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, {
            rovingFocusGroupItemRef,
            tabIndex: _vue.computed(()=>_vue.unref(isCurrentTab) ? 0 : -1
            ),
            handleMousedown,
            handleFocus,
            handleKeydown
        });
        return {
            id,
            handleKeydown,
            handleFocus,
            handleMousedown
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_roving_focus_collection_item = _vue.resolveComponent("el-roving-focus-collection-item");
    return _vue.openBlock(), _vue.createBlock(_component_el_roving_focus_collection_item, {
        id: _ctx.id,
        focusable: _ctx.focusable,
        active: _ctx.active
    }, {
        default: _vue.withCtx(()=>[
                _vue.renderSlot(_ctx.$slots, "default")
            ]
        ),
        _: 3
    }, 8, [
        "id",
        "focusable",
        "active"
    ]);
}
var ElRovingFocusItem = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","./roving-focus-group.mjs":"hfjEe","./tokens.mjs":"2nYZU","./utils.mjs":"7ZQhG","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-id/index.mjs":"jWUTV","../../../utils/dom/event.mjs":"fnXSh","../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7C9Hj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DROPDOWN_COLLECTION_INJECTION_KEY", ()=>COLLECTION_INJECTION_KEY
);
parcelHelpers.export(exports, "DROPDOWN_COLLECTION_ITEM_INJECTION_KEY", ()=>COLLECTION_ITEM_INJECTION_KEY
);
parcelHelpers.export(exports, "ElCollection", ()=>ElCollection
);
parcelHelpers.export(exports, "ElCollectionItem", ()=>ElCollectionItem
);
parcelHelpers.export(exports, "FIRST_KEYS", ()=>FIRST_KEYS
);
parcelHelpers.export(exports, "FIRST_LAST_KEYS", ()=>FIRST_LAST_KEYS
);
parcelHelpers.export(exports, "LAST_KEYS", ()=>LAST_KEYS
);
parcelHelpers.export(exports, "dropdownItemProps", ()=>dropdownItemProps
);
parcelHelpers.export(exports, "dropdownMenuProps", ()=>dropdownMenuProps
);
parcelHelpers.export(exports, "dropdownProps", ()=>dropdownProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../collection/index.mjs");
var _indexMjs3 = require("../../tooltip/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _tooltipMjs = require("../../tooltip/src/tooltip.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
var _collectionMjs = require("../../collection/src/collection.mjs");
const dropdownProps = _propsMjs.buildProps({
    trigger: _tooltipMjs.useTooltipTriggerProps.trigger,
    effect: {
        ..._tooltipMjs.useTooltipContentProps.effect,
        default: "light"
    },
    type: {
        type: _propsMjs.definePropType(String)
    },
    placement: {
        type: _propsMjs.definePropType(String),
        default: "bottom"
    },
    popperOptions: {
        type: _propsMjs.definePropType(Object),
        default: ()=>({
            })
    },
    size: {
        type: String,
        default: ""
    },
    splitButton: Boolean,
    hideOnClick: {
        type: Boolean,
        default: true
    },
    loop: {
        type: Boolean
    },
    showTimeout: {
        type: Number,
        default: 150
    },
    hideTimeout: {
        type: Number,
        default: 150
    },
    tabindex: {
        type: _propsMjs.definePropType([
            Number,
            String
        ]),
        default: 0
    },
    maxHeight: {
        type: _propsMjs.definePropType([
            Number,
            String
        ]),
        default: ""
    },
    popperClass: {
        type: String,
        default: ""
    }
});
const dropdownItemProps = _propsMjs.buildProps({
    command: {
        type: [
            Object,
            String,
            Number
        ],
        default: ()=>({
            })
    },
    disabled: Boolean,
    divided: Boolean,
    textValue: String,
    icon: {
        type: _iconMjs.iconPropType
    }
});
const dropdownMenuProps = _propsMjs.buildProps({
    onKeydown: {
        type: _propsMjs.definePropType(Function)
    }
});
const FIRST_KEYS = [
    _ariaMjs.EVENT_CODE.down,
    _ariaMjs.EVENT_CODE.pageDown,
    _ariaMjs.EVENT_CODE.home
];
const LAST_KEYS = [
    _ariaMjs.EVENT_CODE.up,
    _ariaMjs.EVENT_CODE.pageUp,
    _ariaMjs.EVENT_CODE.end
];
const FIRST_LAST_KEYS = [
    ...FIRST_KEYS,
    ...LAST_KEYS
];
const { ElCollection , ElCollectionItem , COLLECTION_INJECTION_KEY , COLLECTION_ITEM_INJECTION_KEY  } = _collectionMjs.createCollectionWithScope("Dropdown");

},{"../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../collection/index.mjs":"9OhGg","../../tooltip/index.mjs":"kiwBC","../../../utils/vue/props.mjs":"cpwWK","../../tooltip/src/tooltip.mjs":"7LVFi","../../../utils/vue/icon.mjs":"3YbE5","../../../constants/aria.mjs":"jS6iK","../../collection/src/collection.mjs":"82Qvm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ghjhG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DROPDOWN_INJECTION_KEY", ()=>DROPDOWN_INJECTION_KEY
);
const DROPDOWN_INJECTION_KEY = Symbol("elDropdown");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7HNH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>DropdownItem
);
var _vue = require("vue");
var _indexMjs = require("../../roving-focus-group/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _dropdownItemImplMjs = require("./dropdown-item-impl.mjs");
var _dropdownItemImplMjsDefault = parcelHelpers.interopDefault(_dropdownItemImplMjs);
var _useDropdownMjs = require("./useDropdown.mjs");
var _dropdownMjs = require("./dropdown.mjs");
var _tokensMjs = require("./tokens.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _rovingFocusItemMjs = require("../../roving-focus-group/src/roving-focus-item.mjs");
var _rovingFocusItemMjsDefault = parcelHelpers.interopDefault(_rovingFocusItemMjs);
var _eventMjs = require("../../../utils/dom/event.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElDropdownItem",
    components: {
        ElDropdownCollectionItem: _dropdownMjs.ElCollectionItem,
        ElRovingFocusItem: _rovingFocusItemMjsDefault.default,
        ElDropdownItemImpl: _dropdownItemImplMjsDefault.default
    },
    inheritAttrs: false,
    props: _dropdownMjs.dropdownItemProps,
    emits: [
        "pointermove",
        "pointerleave",
        "click"
    ],
    setup (props, { emit , attrs  }) {
        const { elDropdown  } = _useDropdownMjs.useDropdown();
        const _instance = _vue.getCurrentInstance();
        const itemRef = _vue.ref(null);
        const textContent = _vue.computed(()=>{
            var _a, _b;
            return (_b = (_a = _vue.unref(itemRef)) == null ? void 0 : _a.textContent) != null ? _b : "";
        });
        const { onItemEnter , onItemLeave  } = _vue.inject(_tokensMjs.DROPDOWN_INJECTION_KEY, void 0);
        const handlePointerMove = _eventMjs.composeEventHandlers((e)=>{
            emit("pointermove", e);
            return e.defaultPrevented;
        }, _eventMjs.whenMouse((e)=>{
            var _a;
            if (props.disabled) onItemLeave(e);
            else {
                onItemEnter(e);
                if (!e.defaultPrevented) (_a = e.currentTarget) == null || _a.focus();
            }
        }));
        const handlePointerLeave = _eventMjs.composeEventHandlers((e)=>{
            emit("pointerleave", e);
            return e.defaultPrevented;
        }, _eventMjs.whenMouse((e)=>{
            onItemLeave(e);
        }));
        const handleClick = _eventMjs.composeEventHandlers((e)=>{
            emit("click", e);
            return e.defaultPrevented;
        }, (e)=>{
            var _a, _b, _c;
            if (props.disabled) {
                e.stopImmediatePropagation();
                return;
            }
            if ((_a = elDropdown == null ? void 0 : elDropdown.hideOnClick) == null ? void 0 : _a.value) (_b = elDropdown.handleClick) == null || _b.call(elDropdown);
            (_c = elDropdown.commandHandler) == null || _c.call(elDropdown, props.command, _instance, e);
        });
        const propsAndAttrs = _vue.computed(()=>{
            return {
                ...props,
                ...attrs
            };
        });
        return {
            handleClick,
            handlePointerMove,
            handlePointerLeave,
            textContent,
            propsAndAttrs
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    var _a;
    const _component_el_dropdown_item_impl = _vue.resolveComponent("el-dropdown-item-impl");
    const _component_el_roving_focus_item = _vue.resolveComponent("el-roving-focus-item");
    const _component_el_dropdown_collection_item = _vue.resolveComponent("el-dropdown-collection-item");
    return _vue.openBlock(), _vue.createBlock(_component_el_dropdown_collection_item, {
        disabled: _ctx.disabled,
        "text-value": (_a = _ctx.textValue) != null ? _a : _ctx.textContent
    }, {
        default: _vue.withCtx(()=>[
                _vue.createVNode(_component_el_roving_focus_item, {
                    focusable: !_ctx.disabled
                }, {
                    default: _vue.withCtx(()=>[
                            _vue.createVNode(_component_el_dropdown_item_impl, _vue.mergeProps(_ctx.propsAndAttrs, {
                                onPointerleave: _ctx.handlePointerLeave,
                                onPointermove: _ctx.handlePointerMove,
                                onClick: _ctx.handleClick
                            }), {
                                default: _vue.withCtx(()=>[
                                        _vue.renderSlot(_ctx.$slots, "default")
                                    ]
                                ),
                                _: 3
                            }, 16, [
                                "onPointerleave",
                                "onPointermove",
                                "onClick"
                            ])
                        ]
                    ),
                    _: 3
                }, 8, [
                    "focusable"
                ])
            ]
        ),
        _: 3
    }, 8, [
        "disabled",
        "text-value"
    ]);
}
var DropdownItem = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../roving-focus-group/index.mjs":"c0fzg","../../../utils/index.mjs":"dsdeP","./dropdown-item-impl.mjs":"229Sr","./useDropdown.mjs":"forNq","./dropdown.mjs":"7C9Hj","./tokens.mjs":"ghjhG","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../roving-focus-group/src/roving-focus-item.mjs":"hennk","../../../utils/dom/event.mjs":"fnXSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"229Sr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElDropdownItemImpl
);
var _vue = require("vue");
var _indexMjs = require("../../roving-focus-group/index.mjs");
var _indexMjs1 = require("../../collection/index.mjs");
var _indexMjs2 = require("../../icon/index.mjs");
var _indexMjs3 = require("../../../hooks/index.mjs");
var _indexMjs4 = require("../../../utils/index.mjs");
var _indexMjs5 = require("../../../constants/index.mjs");
var _dropdownMjs = require("./dropdown.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs6 = require("../../../hooks/use-namespace/index.mjs");
var _rovingFocusGroupMjs = require("../../roving-focus-group/src/roving-focus-group.mjs");
var _tokensMjs = require("../../roving-focus-group/src/tokens.mjs");
var _refsMjs = require("../../../utils/vue/refs.mjs");
var _eventMjs = require("../../../utils/dom/event.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
var _collectionMjs = require("../../collection/src/collection.mjs");
const _sfc_main = _vue.defineComponent({
    name: "DropdownItemImpl",
    components: {
        ElIcon: _indexMjs2.ElIcon
    },
    props: _dropdownMjs.dropdownItemProps,
    emits: [
        "pointermove",
        "pointerleave",
        "click"
    ],
    setup (_, { emit  }) {
        const ns = _indexMjs6.useNamespace("dropdown");
        const { collectionItemRef: dropdownCollectionItemRef  } = _vue.inject(_dropdownMjs.DROPDOWN_COLLECTION_ITEM_INJECTION_KEY, void 0);
        const { collectionItemRef: rovingFocusCollectionItemRef  } = _vue.inject(_rovingFocusGroupMjs.ROVING_FOCUS_ITEM_COLLECTION_INJECTION_KEY, void 0);
        const { rovingFocusGroupItemRef , tabIndex , handleFocus , handleKeydown: handleItemKeydown , handleMousedown  } = _vue.inject(_tokensMjs.ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, void 0);
        const itemRef = _refsMjs.composeRefs(dropdownCollectionItemRef, rovingFocusCollectionItemRef, rovingFocusGroupItemRef);
        const handleKeydown = _eventMjs.composeEventHandlers((e)=>{
            const { code  } = e;
            if (code === _ariaMjs.EVENT_CODE.enter || code === _ariaMjs.EVENT_CODE.space) {
                e.preventDefault();
                e.stopImmediatePropagation();
                emit("click", e);
                return true;
            }
        }, handleItemKeydown);
        return {
            ns,
            itemRef,
            dataset: {
                [_collectionMjs.COLLECTION_ITEM_SIGN]: ""
            },
            tabIndex,
            handleFocus,
            handleKeydown,
            handleMousedown
        };
    }
});
const _hoisted_1 = [
    "aria-disabled",
    "tabindex"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    return _vue.openBlock(), _vue.createElementBlock(_vue.Fragment, null, [
        _ctx.divided ? (_vue.openBlock(), _vue.createElementBlock("div", _vue.mergeProps({
            key: 0,
            class: _ctx.ns.bem("menu", "item", "divided")
        }, _ctx.$attrs), null, 16)) : _vue.createCommentVNode("v-if", true),
        _vue.createElementVNode("div", _vue.mergeProps({
            ref: _ctx.itemRef
        }, {
            ..._ctx.dataset,
            ..._ctx.$attrs
        }, {
            "aria-disabled": _ctx.disabled,
            class: [
                _ctx.ns.be("menu", "item"),
                _ctx.ns.is("disabled", _ctx.disabled)
            ],
            tabindex: _ctx.tabIndex,
            role: "menuitem",
            onClick: _cache[0] || (_cache[0] = (e)=>_ctx.$emit("click", e)
            ),
            onFocus: _cache[1] || (_cache[1] = (...args)=>_ctx.handleFocus && _ctx.handleFocus(...args)
            ),
            onKeydown: _cache[2] || (_cache[2] = (...args)=>_ctx.handleKeydown && _ctx.handleKeydown(...args)
            ),
            onMousedown: _cache[3] || (_cache[3] = (...args)=>_ctx.handleMousedown && _ctx.handleMousedown(...args)
            ),
            onPointermove: _cache[4] || (_cache[4] = (e)=>_ctx.$emit("pointermove", e)
            ),
            onPointerleave: _cache[5] || (_cache[5] = (e)=>_ctx.$emit("pointerleave", e)
            )
        }), [
            _ctx.icon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                key: 0
            }, {
                default: _vue.withCtx(()=>[
                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.icon)))
                    ]
                ),
                _: 1
            })) : _vue.createCommentVNode("v-if", true),
            _vue.renderSlot(_ctx.$slots, "default")
        ], 16, _hoisted_1)
    ], 64);
}
var ElDropdownItemImpl = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../roving-focus-group/index.mjs":"c0fzg","../../collection/index.mjs":"9OhGg","../../icon/index.mjs":"hnNTG","../../../hooks/index.mjs":"1Ansp","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","./dropdown.mjs":"7C9Hj","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../roving-focus-group/src/roving-focus-group.mjs":"hfjEe","../../roving-focus-group/src/tokens.mjs":"2nYZU","../../../utils/vue/refs.mjs":"iuyFi","../../../utils/dom/event.mjs":"fnXSh","../../../constants/aria.mjs":"jS6iK","../../collection/src/collection.mjs":"82Qvm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"forNq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initDropdownDomEvent", ()=>initDropdownDomEvent
);
parcelHelpers.export(exports, "useDropdown", ()=>useDropdown
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
var _randMjs = require("../../../utils/rand.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
var _styleMjs = require("../../../utils/dom/style.mjs");
var _eventMjs = require("../../../utils/dom/event.mjs");
const useDropdown = ()=>{
    const elDropdown = _vue.inject("elDropdown", {
    });
    const _elDropdownSize = _vue.computed(()=>elDropdown == null ? void 0 : elDropdown.dropdownSize
    );
    return {
        elDropdown,
        _elDropdownSize
    };
};
const initDropdownDomEvent = (dropdownChildren, triggerElm, _instance)=>{
    const ns = _indexMjs3.useNamespace("dropdown");
    const menuItems = _vue.ref(null);
    const menuItemsArray = _vue.ref(null);
    const dropdownElm = _vue.ref(null);
    const listId = _vue.ref(`dropdown-menu-${_randMjs.generateId()}`);
    dropdownElm.value = dropdownChildren == null ? void 0 : dropdownChildren.subTree.el;
    function removeTabindex() {
        var _a;
        triggerElm.setAttribute("tabindex", "-1");
        (_a = menuItemsArray.value) == null || _a.forEach((item)=>{
            item.setAttribute("tabindex", "-1");
        });
    }
    function resetTabindex(ele) {
        removeTabindex();
        ele == null || ele.setAttribute("tabindex", "0");
    }
    function handleTriggerKeyDown(ev) {
        const code = ev.code;
        if ([
            _ariaMjs.EVENT_CODE.up,
            _ariaMjs.EVENT_CODE.down
        ].includes(code)) {
            removeTabindex();
            resetTabindex(menuItems.value[0]);
            menuItems.value[0].focus();
            ev.preventDefault();
            ev.stopPropagation();
        } else if (code === _ariaMjs.EVENT_CODE.enter) _instance.handleClick();
        else if ([
            _ariaMjs.EVENT_CODE.tab,
            _ariaMjs.EVENT_CODE.esc
        ].includes(code)) _instance.hide();
    }
    function handleItemKeyDown(ev) {
        const code = ev.code;
        const target = ev.target;
        const currentIndex = menuItemsArray.value.indexOf(target);
        const max = menuItemsArray.value.length - 1;
        let nextIndex;
        if ([
            _ariaMjs.EVENT_CODE.up,
            _ariaMjs.EVENT_CODE.down
        ].includes(code)) {
            if (code === _ariaMjs.EVENT_CODE.up) nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
            else nextIndex = currentIndex < max ? currentIndex + 1 : max;
            removeTabindex();
            resetTabindex(menuItems.value[nextIndex]);
            menuItems.value[nextIndex].focus();
            ev.preventDefault();
            ev.stopPropagation();
        } else if (code === _ariaMjs.EVENT_CODE.enter) {
            triggerElmFocus();
            target.click();
            if (_instance.props.hideOnClick) _instance.hide();
        } else if ([
            _ariaMjs.EVENT_CODE.tab,
            _ariaMjs.EVENT_CODE.esc
        ].includes(code)) {
            _instance.hide();
            triggerElmFocus();
        }
    }
    function initAria() {
        dropdownElm.value.setAttribute("id", listId.value);
        triggerElm.setAttribute("aria-haspopup", "list");
        triggerElm.setAttribute("aria-controls", listId.value);
        if (!_instance.props.splitButton) {
            triggerElm.setAttribute("role", "button");
            triggerElm.setAttribute("tabindex", _instance.props.tabindex);
            _styleMjs.addClass(triggerElm, ns.b("selfdefine"));
        }
    }
    function initEvent() {
        _eventMjs.on(triggerElm, "keydown", handleTriggerKeyDown);
        _eventMjs.on(dropdownElm.value, "keydown", handleItemKeyDown, true);
    }
    function initDomOperation() {
        menuItems.value = dropdownElm.value.querySelectorAll("[tabindex='-1']");
        menuItemsArray.value = [].slice.call(menuItems.value);
        initEvent();
        initAria();
    }
    function triggerElmFocus() {
        triggerElm.focus();
    }
    initDomOperation();
};

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../../hooks/index.mjs":"1Ansp","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/rand.mjs":"6d823","../../../constants/aria.mjs":"jS6iK","../../../utils/dom/style.mjs":"cA8Mp","../../../utils/dom/event.mjs":"fnXSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ab1hX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>DropdownMenu
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../focus-trap/index.mjs");
var _indexMjs3 = require("../../roving-focus-group/index.mjs");
var _indexMjs4 = require("../../../hooks/index.mjs");
var _tokensMjs = require("./tokens.mjs");
var _dropdownMjs = require("./dropdown.mjs");
var _useDropdownMjs = require("./useDropdown.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs5 = require("../../../hooks/use-namespace/index.mjs");
var _tokensMjs1 = require("../../focus-trap/src/tokens.mjs");
var _tokensMjs2 = require("../../roving-focus-group/src/tokens.mjs");
var _rovingFocusGroupMjs = require("../../roving-focus-group/src/roving-focus-group.mjs");
var _refsMjs = require("../../../utils/vue/refs.mjs");
var _eventMjs = require("../../../utils/dom/event.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
var _utilsMjs = require("../../roving-focus-group/src/utils.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElDropdownMenu",
    props: _dropdownMjs.dropdownMenuProps,
    setup (props) {
        const ns = _indexMjs5.useNamespace("dropdown");
        const { _elDropdownSize  } = _useDropdownMjs.useDropdown();
        const size = _elDropdownSize.value;
        const { focusTrapRef , onKeydown  } = _vue.inject(_tokensMjs1.FOCUS_TRAP_INJECTION_KEY, void 0);
        const { contentRef  } = _vue.inject(_tokensMjs.DROPDOWN_INJECTION_KEY, void 0);
        const { collectionRef: dropdownCollectionRef , getItems  } = _vue.inject(_dropdownMjs.DROPDOWN_COLLECTION_INJECTION_KEY, void 0);
        const { rovingFocusGroupRef , rovingFocusGroupRootStyle , tabIndex , onBlur , onFocus , onMousedown  } = _vue.inject(_tokensMjs2.ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
        const { collectionRef: rovingFocusGroupCollectionRef  } = _vue.inject(_rovingFocusGroupMjs.ROVING_FOCUS_COLLECTION_INJECTION_KEY, void 0);
        const dropdownKls = _vue.computed(()=>{
            return [
                ns.b("menu"),
                ns.bm("menu", size == null ? void 0 : size.value)
            ];
        });
        const dropdownListWrapperRef = _refsMjs.composeRefs(contentRef, dropdownCollectionRef, focusTrapRef, rovingFocusGroupRef, rovingFocusGroupCollectionRef);
        const composedKeydown = _eventMjs.composeEventHandlers((e)=>{
            var _a;
            (_a = props.onKeydown) == null || _a.call(props, e);
        }, (e)=>{
            const { currentTarget , code , target  } = e;
            const isKeydownContained = currentTarget.contains(target);
            if (_ariaMjs.EVENT_CODE.tab === code) e.stopImmediatePropagation();
            e.preventDefault();
            if (target !== _vue.unref(contentRef)) return;
            if (!_dropdownMjs.FIRST_LAST_KEYS.includes(code)) return;
            const items = getItems().filter((item)=>!item.disabled
            );
            const targets = items.map((item)=>item.ref
            );
            if (_dropdownMjs.LAST_KEYS.includes(code)) targets.reverse();
            _utilsMjs.focusFirst(targets);
        });
        const handleKeydown = (e)=>{
            composedKeydown(e);
            onKeydown(e);
        };
        return {
            size,
            rovingFocusGroupRootStyle,
            tabIndex,
            dropdownKls,
            dropdownListWrapperRef,
            handleKeydown,
            onBlur,
            onFocus,
            onMousedown
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("ul", {
        ref: _ctx.dropdownListWrapperRef,
        class: _vue.normalizeClass(_ctx.dropdownKls),
        style: _vue.normalizeStyle(_ctx.rovingFocusGroupRootStyle),
        tabindex: -1,
        role: "menu",
        onBlur: _cache[0] || (_cache[0] = (...args)=>_ctx.onBlur && _ctx.onBlur(...args)
        ),
        onFocus: _cache[1] || (_cache[1] = (...args)=>_ctx.onFocus && _ctx.onFocus(...args)
        ),
        onKeydown: _cache[2] || (_cache[2] = (...args)=>_ctx.handleKeydown && _ctx.handleKeydown(...args)
        ),
        onMousedown: _cache[3] || (_cache[3] = (...args)=>_ctx.onMousedown && _ctx.onMousedown(...args)
        )
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 38);
}
var DropdownMenu = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../focus-trap/index.mjs":"dSOZm","../../roving-focus-group/index.mjs":"c0fzg","../../../hooks/index.mjs":"1Ansp","./tokens.mjs":"ghjhG","./dropdown.mjs":"7C9Hj","./useDropdown.mjs":"forNq","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../focus-trap/src/tokens.mjs":"9DFns","../../roving-focus-group/src/tokens.mjs":"2nYZU","../../roving-focus-group/src/roving-focus-group.mjs":"hfjEe","../../../utils/vue/refs.mjs":"iuyFi","../../../utils/dom/event.mjs":"fnXSh","../../../constants/aria.mjs":"jS6iK","../../roving-focus-group/src/utils.mjs":"7ZQhG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5bPkj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "emptyProps", ()=>_emptyMjs.emptyProps
);
parcelHelpers.export(exports, "ElEmpty", ()=>ElEmpty
);
parcelHelpers.export(exports, "default", ()=>ElEmpty
);
var _indexMjs = require("../../utils/index.mjs");
var _empty2Mjs = require("./src/empty2.mjs");
var _empty2MjsDefault = parcelHelpers.interopDefault(_empty2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _emptyMjs = require("./src/empty.mjs");
const ElEmpty = _installMjs.withInstall(_empty2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/empty2.mjs":"iP9my","../../utils/vue/install.mjs":"4TMmv","./src/empty.mjs":"6dOm6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iP9my":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Empty
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _imgEmptyMjs = require("./img-empty.mjs");
var _imgEmptyMjsDefault = parcelHelpers.interopDefault(_imgEmptyMjs);
var _emptyMjs = require("./empty.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElEmpty",
    components: {
        ImgEmpty: _imgEmptyMjsDefault.default
    },
    props: _emptyMjs.emptyProps,
    setup (props) {
        const { t  } = _indexMjs1.useLocale();
        const ns = _indexMjs2.useNamespace("empty");
        const emptyDescription = _vue.computed(()=>props.description || t("el.table.emptyText")
        );
        const imageStyle = _vue.computed(()=>({
                width: props.imageSize ? `${props.imageSize}px` : ""
            })
        );
        return {
            ns,
            emptyDescription,
            imageStyle
        };
    }
});
const _hoisted_1 = [
    "src"
];
const _hoisted_2 = {
    key: 1
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_img_empty = _vue.resolveComponent("img-empty");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.ns.b())
    }, [
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("image")),
            style: _vue.normalizeStyle(_ctx.imageStyle)
        }, [
            _ctx.image ? (_vue.openBlock(), _vue.createElementBlock("img", {
                key: 0,
                src: _ctx.image,
                ondragstart: "return false"
            }, null, 8, _hoisted_1)) : _vue.renderSlot(_ctx.$slots, "image", {
                key: 1
            }, ()=>[
                    _vue.createVNode(_component_img_empty)
                ]
            )
        ], 6),
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("description"))
        }, [
            _ctx.$slots.description ? _vue.renderSlot(_ctx.$slots, "description", {
                key: 0
            }) : (_vue.openBlock(), _vue.createElementBlock("p", _hoisted_2, _vue.toDisplayString(_ctx.emptyDescription), 1))
        ], 2),
        _ctx.$slots.default ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.e("bottom"))
        }, [
            _vue.renderSlot(_ctx.$slots, "default")
        ], 2)) : _vue.createCommentVNode("v-if", true)
    ], 2);
}
var Empty = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./img-empty.mjs":"btSsW","./empty.mjs":"6dOm6","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"btSsW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ImgEmpty
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
let id = 0;
const _sfc_main = _vue.defineComponent({
    name: "ImgEmpty",
    setup () {
        return {
            id: ++id
        };
    }
});
const _hoisted_1 = {
    viewBox: "0 0 79 86",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
const _hoisted_2 = [
    "id"
];
const _hoisted_3 = /* @__PURE__ */ _vue.createElementVNode("stop", {
    "stop-color": "var(--el-empty-fill-color-1)",
    offset: "0%"
}, null, -1);
const _hoisted_4 = /* @__PURE__ */ _vue.createElementVNode("stop", {
    "stop-color": "var(--el-empty-fill-color-4)",
    offset: "100%"
}, null, -1);
const _hoisted_5 = [
    _hoisted_3,
    _hoisted_4
];
const _hoisted_6 = [
    "id"
];
const _hoisted_7 = /* @__PURE__ */ _vue.createElementVNode("stop", {
    "stop-color": "var(--el-empty-fill-color-1)",
    offset: "0%"
}, null, -1);
const _hoisted_8 = /* @__PURE__ */ _vue.createElementVNode("stop", {
    "stop-color": "var(--el-empty-fill-color-6)",
    offset: "100%"
}, null, -1);
const _hoisted_9 = [
    _hoisted_7,
    _hoisted_8
];
const _hoisted_10 = [
    "id"
];
const _hoisted_11 = {
    id: "Illustrations",
    stroke: "none",
    "stroke-width": "1",
    fill: "none",
    "fill-rule": "evenodd"
};
const _hoisted_12 = {
    id: "B-type",
    transform: "translate(-1268.000000, -535.000000)"
};
const _hoisted_13 = {
    id: "Group-2",
    transform: "translate(1268.000000, 535.000000)"
};
const _hoisted_14 = /* @__PURE__ */ _vue.createElementVNode("path", {
    id: "Oval-Copy-2",
    d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
    fill: "var(--el-empty-fill-color-3)"
}, null, -1);
const _hoisted_15 = /* @__PURE__ */ _vue.createElementVNode("polygon", {
    id: "Rectangle-Copy-14",
    fill: "var(--el-empty-fill-color-7)",
    transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
    points: "13 58 53 58 42 45 2 45"
}, null, -1);
const _hoisted_16 = {
    id: "Group-Copy",
    transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
};
const _hoisted_17 = /* @__PURE__ */ _vue.createElementVNode("polygon", {
    id: "Rectangle-Copy-10",
    fill: "var(--el-empty-fill-color-7)",
    transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
    points: "2.84078316e-14 3 18 3 23 7 5 7"
}, null, -1);
const _hoisted_18 = /* @__PURE__ */ _vue.createElementVNode("polygon", {
    id: "Rectangle-Copy-11",
    fill: "var(--el-empty-fill-color-5)",
    points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
}, null, -1);
const _hoisted_19 = [
    "fill"
];
const _hoisted_20 = /* @__PURE__ */ _vue.createElementVNode("polygon", {
    id: "Rectangle-Copy-13",
    fill: "var(--el-empty-fill-color-2)",
    transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
    points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
}, null, -1);
const _hoisted_21 = [
    "fill"
];
const _hoisted_22 = {
    id: "Rectangle-Copy-17",
    transform: "translate(53.000000, 45.000000)"
};
const _hoisted_23 = [
    "id"
];
const _hoisted_24 = [
    "xlink:href"
];
const _hoisted_25 = [
    "xlink:href"
];
const _hoisted_26 = [
    "mask"
];
const _hoisted_27 = /* @__PURE__ */ _vue.createElementVNode("polygon", {
    id: "Rectangle-Copy-18",
    fill: "var(--el-empty-fill-color-2)",
    transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
    points: "62 45 79 45 70 58 53 58"
}, null, -1);
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, [
        _vue.createElementVNode("defs", null, [
            _vue.createElementVNode("linearGradient", {
                id: `linearGradient-1-${_ctx.id}`,
                x1: "38.8503086%",
                y1: "0%",
                x2: "61.1496914%",
                y2: "100%"
            }, _hoisted_5, 8, _hoisted_2),
            _vue.createElementVNode("linearGradient", {
                id: `linearGradient-2-${_ctx.id}`,
                x1: "0%",
                y1: "9.5%",
                x2: "100%",
                y2: "90.5%"
            }, _hoisted_9, 8, _hoisted_6),
            _vue.createElementVNode("rect", {
                id: `path-3-${_ctx.id}`,
                x: "0",
                y: "0",
                width: "17",
                height: "36"
            }, null, 8, _hoisted_10)
        ]),
        _vue.createElementVNode("g", _hoisted_11, [
            _vue.createElementVNode("g", _hoisted_12, [
                _vue.createElementVNode("g", _hoisted_13, [
                    _hoisted_14,
                    _hoisted_15,
                    _vue.createElementVNode("g", _hoisted_16, [
                        _hoisted_17,
                        _hoisted_18,
                        _vue.createElementVNode("rect", {
                            id: "Rectangle-Copy-12",
                            fill: `url(#linearGradient-1-${_ctx.id})`,
                            transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
                            x: "38",
                            y: "7",
                            width: "17",
                            height: "36"
                        }, null, 8, _hoisted_19),
                        _hoisted_20
                    ]),
                    _vue.createElementVNode("rect", {
                        id: "Rectangle-Copy-15",
                        fill: `url(#linearGradient-2-${_ctx.id})`,
                        x: "13",
                        y: "45",
                        width: "40",
                        height: "36"
                    }, null, 8, _hoisted_21),
                    _vue.createElementVNode("g", _hoisted_22, [
                        _vue.createElementVNode("mask", {
                            id: `mask-4-${_ctx.id}`,
                            fill: "var(--el-empty-fill-color-0)"
                        }, [
                            _vue.createElementVNode("use", {
                                "xlink:href": `#path-3-${_ctx.id}`
                            }, null, 8, _hoisted_24)
                        ], 8, _hoisted_23),
                        _vue.createElementVNode("use", {
                            id: "Mask",
                            fill: "var(--el-empty-fill-color-8)",
                            transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
                            "xlink:href": `#path-3-${_ctx.id}`
                        }, null, 8, _hoisted_25),
                        _vue.createElementVNode("polygon", {
                            id: "Rectangle-Copy",
                            fill: "var(--el-empty-fill-color-9)",
                            mask: `url(#mask-4-${_ctx.id})`,
                            transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
                            points: "7 0 24 0 20 18 -1.70530257e-13 16"
                        }, null, 8, _hoisted_26)
                    ]),
                    _hoisted_27
                ])
            ])
        ])
    ]);
}
var ImgEmpty = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6dOm6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "emptyProps", ()=>emptyProps
);
const emptyProps = {
    image: {
        type: String,
        default: ""
    },
    imageSize: Number,
    description: {
        type: String,
        default: ""
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hQT2m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElForm", ()=>ElForm
);
parcelHelpers.export(exports, "ElFormItem", ()=>ElFormItem
);
parcelHelpers.export(exports, "default", ()=>ElForm
);
var _indexMjs = require("../../utils/index.mjs");
var _formMjs = require("./src/form.mjs");
var _formMjsDefault = parcelHelpers.interopDefault(_formMjs);
var _formItemMjs = require("./src/form-item.mjs");
var _formItemMjsDefault = parcelHelpers.interopDefault(_formItemMjs);
var _installMjs = require("../../utils/vue/install.mjs");
const ElForm = _installMjs.withInstall(_formMjsDefault.default, {
    FormItem: _formItemMjsDefault.default
});
const ElFormItem = _installMjs.withNoopInstall(_formItemMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/form.mjs":"9xId0","./src/form-item.mjs":"bplj9","../../utils/vue/install.mjs":"4TMmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9xId0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Form
);
var _vue = require("vue");
var _indexMjs = require("../../../tokens/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _errorMjs = require("../../../utils/error.mjs");
var _indexMjs3 = require("../../../hooks/use-common-props/index.mjs");
var _formMjs = require("../../../tokens/form.mjs");
function useFormLabelWidth() {
    const potentialLabelWidthArr = _vue.ref([]);
    const autoLabelWidth = _vue.computed(()=>{
        if (!potentialLabelWidthArr.value.length) return "0";
        const max = Math.max(...potentialLabelWidthArr.value);
        return max ? `${max}px` : "";
    });
    function getLabelWidthIndex(width) {
        const index = potentialLabelWidthArr.value.indexOf(width);
        if (index === -1) _errorMjs.debugWarn("Form", `unexpected width ${width}`);
        return index;
    }
    function registerLabelWidth(val, oldVal) {
        if (val && oldVal) {
            const index = getLabelWidthIndex(oldVal);
            potentialLabelWidthArr.value.splice(index, 1, val);
        } else if (val) potentialLabelWidthArr.value.push(val);
    }
    function deregisterLabelWidth(val) {
        const index = getLabelWidthIndex(val);
        index > -1 && potentialLabelWidthArr.value.splice(index, 1);
    }
    return {
        autoLabelWidth,
        registerLabelWidth,
        deregisterLabelWidth
    };
}
const _sfc_main = _vue.defineComponent({
    name: "ElForm",
    props: {
        model: Object,
        rules: Object,
        labelPosition: String,
        labelWidth: {
            type: [
                String,
                Number
            ],
            default: ""
        },
        labelSuffix: {
            type: String,
            default: ""
        },
        inline: Boolean,
        inlineMessage: Boolean,
        statusIcon: Boolean,
        showMessage: {
            type: Boolean,
            default: true
        },
        size: String,
        disabled: Boolean,
        validateOnRuleChange: {
            type: Boolean,
            default: true
        },
        hideRequiredAsterisk: {
            type: Boolean,
            default: false
        },
        scrollToError: Boolean
    },
    emits: [
        "validate"
    ],
    setup (props, { emit  }) {
        const fields = [];
        _vue.watch(()=>props.rules
        , ()=>{
            fields.forEach((field)=>{
                field.evaluateValidationEnabled();
            });
            if (props.validateOnRuleChange) validate(()=>({
                })
            );
        });
        const formSize = _indexMjs3.useSize();
        const prefix = "el-form";
        const formKls = _vue.computed(()=>{
            const { labelPosition , inline  } = props;
            return [
                prefix,
                `${prefix}--${formSize.value}`,
                labelPosition ? `${prefix}--label-${labelPosition}` : "",
                inline ? `${prefix}--inline` : ""
            ];
        });
        const addField = (field)=>{
            if (field) fields.push(field);
        };
        const removeField = (field)=>{
            if (field.prop) fields.splice(fields.indexOf(field), 1);
        };
        const resetFields = ()=>{
            if (!props.model) {
                _errorMjs.debugWarn("Form", "model is required for resetFields to work.");
                return;
            }
            fields.forEach((field)=>{
                field.resetField();
            });
        };
        const clearValidate = (props2 = [])=>{
            const fds = props2.length ? typeof props2 === "string" ? fields.filter((field)=>props2 === field.prop
            ) : fields.filter((field)=>props2.indexOf(field.prop) > -1
            ) : fields;
            fds.forEach((field)=>{
                field.clearValidate();
            });
        };
        const validate = (callback)=>{
            if (!props.model) {
                _errorMjs.debugWarn("Form", "model is required for validate to work!");
                return;
            }
            let promise;
            if (typeof callback !== "function") promise = new Promise((resolve, reject)=>{
                callback = function(valid2, invalidFields2) {
                    if (valid2) resolve(true);
                    else reject(invalidFields2);
                };
            });
            if (fields.length === 0) callback(true);
            let valid = true;
            let count = 0;
            let invalidFields = {
            };
            let firstInvalidFields;
            for (const field of fields)field.validate("", (message, field2)=>{
                if (message) {
                    valid = false;
                    firstInvalidFields || (firstInvalidFields = field2);
                }
                invalidFields = {
                    ...invalidFields,
                    ...field2
                };
                if (++count === fields.length) callback(valid, invalidFields);
            });
            if (!valid && props.scrollToError) scrollToField(Object.keys(firstInvalidFields)[0]);
            return promise;
        };
        const validateField = (props2, cb)=>{
            props2 = [].concat(props2);
            const fds = fields.filter((field)=>props2.indexOf(field.prop) !== -1
            );
            if (!fields.length) {
                _errorMjs.debugWarn("Form", "please pass correct props!");
                return;
            }
            fds.forEach((field)=>{
                field.validate("", cb);
            });
        };
        const scrollToField = (prop)=>{
            fields.forEach((item)=>{
                var _a, _b;
                if (item.prop === prop) (_b = (_a = item.$el).scrollIntoView) == null || _b.call(_a);
            });
        };
        const elForm = _vue.reactive({
            ..._vue.toRefs(props),
            resetFields,
            clearValidate,
            validateField,
            emit,
            addField,
            removeField,
            ...useFormLabelWidth()
        });
        _vue.provide(_formMjs.elFormKey, elForm);
        return {
            formKls,
            validate,
            resetFields,
            clearValidate,
            validateField,
            scrollToField
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("form", {
        class: _vue.normalizeClass(_ctx.formKls)
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 2);
}
var Form = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../tokens/index.mjs":"wVNQi","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/error.mjs":"2zPBN","../../../hooks/use-common-props/index.mjs":"05czU","../../../tokens/form.mjs":"2r4O0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bplj9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>FormItem
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _asyncValidator = require("async-validator");
var _asyncValidatorDefault = parcelHelpers.interopDefault(_asyncValidator);
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../tokens/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _labelWrapMjs = require("./label-wrap.mjs");
var _labelWrapMjsDefault = parcelHelpers.interopDefault(_labelWrapMjs);
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _validatorMjs = require("../../../utils/vue/validator.mjs");
var _formMjs = require("../../../tokens/form.mjs");
var _styleMjs = require("../../../utils/vue/style.mjs");
var _objectsMjs = require("../../../utils/objects.mjs");
var _indexMjs3 = require("../../../hooks/use-common-props/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElFormItem",
    componentName: "ElFormItem",
    components: {
        LabelWrap: _labelWrapMjsDefault.default
    },
    props: {
        label: String,
        labelWidth: {
            type: [
                String,
                Number
            ],
            default: ""
        },
        prop: String,
        required: {
            type: Boolean,
            default: void 0
        },
        rules: [
            Object,
            Array
        ],
        error: String,
        validateStatus: String,
        for: String,
        inlineMessage: {
            type: [
                String,
                Boolean
            ],
            default: ""
        },
        showMessage: {
            type: Boolean,
            default: true
        },
        size: {
            type: String,
            validator: _validatorMjs.isValidComponentSize
        }
    },
    setup (props, { slots  }) {
        const elForm = _vue.inject(_formMjs.elFormKey, {
        });
        const validateState = _vue.ref("");
        const validateMessage = _vue.ref("");
        const isValidationEnabled = _vue.ref(false);
        const computedLabelWidth = _vue.ref("");
        const formItemRef = _vue.ref();
        const vm = _vue.getCurrentInstance();
        const isNested = _vue.computed(()=>{
            let parent = vm.parent;
            while(parent && parent.type.name !== "ElForm"){
                if (parent.type.name === "ElFormItem") return true;
                parent = parent.parent;
            }
            return false;
        });
        let initialValue = void 0;
        _vue.watch(()=>props.error
        , (val)=>{
            validateMessage.value = val;
            validateState.value = val ? "error" : "";
        }, {
            immediate: true
        });
        _vue.watch(()=>props.validateStatus
        , (val)=>{
            validateState.value = val;
        });
        const labelFor = _vue.computed(()=>props.for || props.prop
        );
        const labelStyle = _vue.computed(()=>{
            const ret = {
            };
            if (elForm.labelPosition === "top") return ret;
            const labelWidth = _styleMjs.addUnit(props.labelWidth || elForm.labelWidth);
            if (labelWidth) ret.width = labelWidth;
            return ret;
        });
        const contentStyle = _vue.computed(()=>{
            const ret = {
            };
            if (elForm.labelPosition === "top" || elForm.inline) return ret;
            if (!props.label && !props.labelWidth && isNested.value) return ret;
            const labelWidth = _styleMjs.addUnit(props.labelWidth || elForm.labelWidth);
            if (!props.label && !slots.label) ret.marginLeft = labelWidth;
            return ret;
        });
        const fieldValue = _vue.computed(()=>{
            const model = elForm.model;
            if (!model || !props.prop) return;
            let path = props.prop;
            if (path.indexOf(":") !== -1) path = path.replace(/:/, ".");
            return _objectsMjs.getPropByPath(model, path, true).v;
        });
        const isRequired = _vue.computed(()=>{
            const rules = getRules();
            let required = false;
            if (rules && rules.length) rules.every((rule)=>{
                if (rule.required) {
                    required = true;
                    return false;
                }
                return true;
            });
            return required;
        });
        const sizeClass = _indexMjs3.useSize(void 0, {
            formItem: false
        });
        const validate = (trigger, callback = _shared.NOOP)=>{
            if (!isValidationEnabled.value) {
                callback();
                return;
            }
            const rules = getFilteredRule(trigger);
            if ((!rules || rules.length === 0) && props.required === void 0) {
                callback();
                return;
            }
            validateState.value = "validating";
            const descriptor = {
            };
            if (rules && rules.length > 0) rules.forEach((rule)=>{
                delete rule.trigger;
            });
            descriptor[props.prop] = rules;
            const validator = new _asyncValidatorDefault.default(descriptor);
            const model = {
            };
            model[props.prop] = fieldValue.value;
            validator.validate(model, {
                firstFields: true
            }, (errors, fields)=>{
                var _a;
                validateState.value = !errors ? "success" : "error";
                validateMessage.value = errors ? errors[0].message || `${props.prop} is required` : "";
                callback(validateMessage.value, errors ? fields : {
                });
                (_a = elForm.emit) == null || _a.call(elForm, "validate", props.prop, !errors, validateMessage.value || null);
            });
        };
        const clearValidate = ()=>{
            validateState.value = "";
            validateMessage.value = "";
        };
        const resetField = ()=>{
            const model = elForm.model;
            const value = fieldValue.value;
            let path = props.prop;
            if (path.indexOf(":") !== -1) path = path.replace(/:/, ".");
            const prop = _objectsMjs.getPropByPath(model, path, true);
            if (Array.isArray(value)) prop.o[prop.k] = [].concat(initialValue);
            else prop.o[prop.k] = initialValue;
            _vue.nextTick(()=>{
                clearValidate();
            });
        };
        const getRules = ()=>{
            const formRules = elForm.rules;
            const selfRules = props.rules;
            const requiredRule = props.required !== void 0 ? {
                required: !!props.required
            } : [];
            const prop = _objectsMjs.getPropByPath(formRules, props.prop || "", false);
            const normalizedRule = formRules ? prop.o[props.prop || ""] || prop.v : [];
            return [].concat(selfRules || normalizedRule || []).concat(requiredRule);
        };
        const getFilteredRule = (trigger)=>{
            const rules = getRules();
            return rules.filter((rule)=>{
                if (!rule.trigger || trigger === "") return true;
                if (Array.isArray(rule.trigger)) return rule.trigger.indexOf(trigger) > -1;
                else return rule.trigger === trigger;
            }).map((rule)=>({
                    ...rule
                })
            );
        };
        const evaluateValidationEnabled = ()=>{
            var _a;
            isValidationEnabled.value = !!((_a = getRules()) == null ? void 0 : _a.length);
        };
        const updateComputedLabelWidth = (width)=>{
            computedLabelWidth.value = width ? `${width}px` : "";
        };
        const elFormItem = _vue.reactive({
            ..._vue.toRefs(props),
            size: sizeClass,
            validateState,
            $el: formItemRef,
            evaluateValidationEnabled,
            resetField,
            clearValidate,
            validate,
            updateComputedLabelWidth
        });
        _vue.onMounted(()=>{
            if (props.prop) {
                elForm == null || elForm.addField(elFormItem);
                const value = fieldValue.value;
                initialValue = Array.isArray(value) ? [
                    ...value
                ] : value;
                evaluateValidationEnabled();
            }
        });
        _vue.onBeforeUnmount(()=>{
            elForm == null || elForm.removeField(elFormItem);
        });
        _vue.provide(_formMjs.elFormItemKey, elFormItem);
        const formItemClass = _vue.computed(()=>[
                {
                    "el-form-item--feedback": elForm.statusIcon,
                    "is-error": validateState.value === "error",
                    "is-validating": validateState.value === "validating",
                    "is-success": validateState.value === "success",
                    "is-required": isRequired.value || props.required,
                    "is-no-asterisk": elForm.hideRequiredAsterisk
                },
                sizeClass.value ? `el-form-item--${sizeClass.value}` : ""
            ]
        );
        const shouldShowError = _vue.computed(()=>{
            return validateState.value === "error" && props.showMessage && elForm.showMessage;
        });
        const currentLabel = _vue.computed(()=>(props.label || "") + (elForm.labelSuffix || "")
        );
        return {
            formItemRef,
            formItemClass,
            shouldShowError,
            elForm,
            labelStyle,
            contentStyle,
            validateMessage,
            labelFor,
            resetField,
            clearValidate,
            currentLabel
        };
    }
});
const _hoisted_1 = [
    "for"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_LabelWrap = _vue.resolveComponent("LabelWrap");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "formItemRef",
        class: _vue.normalizeClass([
            "el-form-item",
            _ctx.formItemClass
        ])
    }, [
        _vue.createVNode(_component_LabelWrap, {
            "is-auto-width": _ctx.labelStyle.width === "auto",
            "update-all": _ctx.elForm.labelWidth === "auto"
        }, {
            default: _vue.withCtx(()=>[
                    _ctx.label || _ctx.$slots.label ? (_vue.openBlock(), _vue.createElementBlock("label", {
                        key: 0,
                        for: _ctx.labelFor,
                        class: "el-form-item__label",
                        style: _vue.normalizeStyle(_ctx.labelStyle)
                    }, [
                        _vue.renderSlot(_ctx.$slots, "label", {
                            label: _ctx.currentLabel
                        }, ()=>[
                                _vue.createTextVNode(_vue.toDisplayString(_ctx.currentLabel), 1)
                            ]
                        )
                    ], 12, _hoisted_1)) : _vue.createCommentVNode("v-if", true)
                ]
            ),
            _: 3
        }, 8, [
            "is-auto-width",
            "update-all"
        ]),
        _vue.createElementVNode("div", {
            class: "el-form-item__content",
            style: _vue.normalizeStyle(_ctx.contentStyle)
        }, [
            _vue.renderSlot(_ctx.$slots, "default"),
            _vue.createVNode(_vue.Transition, {
                name: "el-zoom-in-top"
            }, {
                default: _vue.withCtx(()=>[
                        _ctx.shouldShowError ? _vue.renderSlot(_ctx.$slots, "error", {
                            key: 0,
                            error: _ctx.validateMessage
                        }, ()=>[
                                _vue.createElementVNode("div", {
                                    class: _vue.normalizeClass([
                                        "el-form-item__error",
                                        {
                                            "el-form-item__error--inline": typeof _ctx.inlineMessage === "boolean" ? _ctx.inlineMessage : _ctx.elForm.inlineMessage || false
                                        }
                                    ])
                                }, _vue.toDisplayString(_ctx.validateMessage), 3)
                            ]
                        ) : _vue.createCommentVNode("v-if", true)
                    ]
                ),
                _: 3
            })
        ], 4)
    ], 2);
}
var FormItem = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vue/shared":"3SM3y","async-validator":"2KHae","../../../utils/index.mjs":"dsdeP","../../../tokens/index.mjs":"wVNQi","../../../hooks/index.mjs":"1Ansp","./label-wrap.mjs":"jDa7A","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/vue/validator.mjs":"4UnBa","../../../tokens/form.mjs":"2r4O0","../../../utils/vue/style.mjs":"pODHb","../../../utils/objects.mjs":"1tXXV","../../../hooks/use-common-props/index.mjs":"05czU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2KHae":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Schema
);
var process = require("process");
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o1) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o1);
}
function _setPrototypeOf(o2, p1) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o2, p1);
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
    } catch (e) {
        return false;
    }
}
function _construct(Parent1, args1, Class1) {
    if (_isNativeReflectConstruct()) _construct = Reflect.construct;
    else _construct = function _construct(Parent, args, Class) {
        var a = [
            null
        ];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
    };
    return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class2) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class2);
}
/* eslint no-console:0 */ var formatRegExp = /%[sdj%]/g;
var warning = function warning() {
}; // don't print warning message when in production env or node runtime
if (typeof process !== 'undefined' && process.env && true && typeof window !== 'undefined' && typeof document !== 'undefined') warning = function warning(type1, errors) {
    if (typeof console !== 'undefined' && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === 'undefined') {
        if (errors.every(function(e) {
            return typeof e === 'string';
        })) console.warn(type1, errors);
    }
};
function convertFieldsError(errors) {
    if (!errors || !errors.length) return null;
    var fields = {
    };
    errors.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
    });
    return fields;
}
function format(template) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
    var i = 0;
    var len = args.length;
    if (typeof template === 'function') return template.apply(null, args);
    if (typeof template === 'string') {
        var str = template.replace(formatRegExp, function(x) {
            if (x === '%%') return '%';
            if (i >= len) return x;
            switch(x){
                case '%s':
                    return String(args[i++]);
                case '%d':
                    return Number(args[i++]);
                case '%j':
                    try {
                        return JSON.stringify(args[i++]);
                    } catch (_) {
                        return '[Circular]';
                    }
                    break;
                default:
                    return x;
            }
        });
        return str;
    }
    return template;
}
function isNativeStringType(type2) {
    return type2 === 'string' || type2 === 'url' || type2 === 'hex' || type2 === 'email' || type2 === 'date' || type2 === 'pattern';
}
function isEmptyValue(value, type3) {
    if (value === undefined || value === null) return true;
    if (type3 === 'array' && Array.isArray(value) && !value.length) return true;
    if (isNativeStringType(type3) && typeof value === 'string' && !value) return true;
    return false;
}
function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;
    function count(errors) {
        results.push.apply(results, errors || []);
        total++;
        if (total === arrLength) callback(results);
    }
    arr.forEach(function(a) {
        func(a, count);
    });
}
function asyncSerialArray(arr, func, callback) {
    var index = 0;
    var arrLength = arr.length;
    function next(errors) {
        if (errors && errors.length) {
            callback(errors);
            return;
        }
        var original = index;
        index = index + 1;
        if (original < arrLength) func(arr[original], next);
        else callback([]);
    }
    next([]);
}
function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function(k) {
        ret.push.apply(ret, objArr[k] || []);
    });
    return ret;
}
var AsyncValidationError = /*#__PURE__*/ function(_Error) {
    _inheritsLoose(AsyncValidationError1, _Error);
    function AsyncValidationError1(errors, fields) {
        var _this;
        _this = _Error.call(this, 'Async Validation Error') || this;
        _this.errors = errors;
        _this.fields = fields;
        return _this;
    }
    return AsyncValidationError1;
}(/*#__PURE__*/ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
    if (option.first) {
        var _pending = new Promise(function(resolve, reject) {
            var next = function next(errors) {
                callback(errors);
                return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func, next);
        });
        _pending["catch"](function(e) {
            return e;
        });
        return _pending;
    }
    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function(resolve, reject) {
        var next = function next(errors) {
            results.push.apply(results, errors);
            total++;
            if (total === objArrLength) {
                callback(results);
                return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
            }
        };
        if (!objArrKeys.length) {
            callback(results);
            resolve(source);
        }
        objArrKeys.forEach(function(key) {
            var arr = objArr[key];
            if (firstFields.indexOf(key) !== -1) asyncSerialArray(arr, func, next);
            else asyncParallelArray(arr, func, next);
        });
    });
    pending["catch"](function(e) {
        return e;
    });
    return pending;
}
function isErrorObj(obj) {
    return !!(obj && obj.message !== undefined);
}
function getValue(value, path) {
    var v = value;
    for(var i = 0; i < path.length; i++){
        if (v == undefined) return v;
        v = v[path[i]];
    }
    return v;
}
function complementError(rule, source) {
    return function(oe) {
        var fieldValue;
        if (rule.fullFields) fieldValue = getValue(source, rule.fullFields);
        else fieldValue = source[oe.field || rule.fullField];
        if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
        }
        return {
            message: typeof oe === 'function' ? oe() : oe,
            fieldValue: fieldValue,
            field: oe.field || rule.fullField
        };
    };
}
function deepMerge(target, source) {
    if (source) {
        for(var s in source)if (source.hasOwnProperty(s)) {
            var value = source[s];
            if (typeof value === 'object' && typeof target[s] === 'object') target[s] = _extends({
            }, target[s], value);
            else target[s] = value;
        }
    }
    return target;
}
var required$1 = function required(rule, value, source, errors, options, type4) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) errors.push(format(options.messages.required, rule.fullField));
};
/**
 *  Rule for validating whitespace.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */ var whitespace = function whitespace(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === '') errors.push(format(options.messages.whitespace, rule.fullField));
};
/* eslint max-len:0 */ var pattern$2 = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", 'i'),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
    integer: function integer(value) {
        return types.number(value) && parseInt(value, 10) === value;
    },
    "float": function float(value) {
        return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
        return Array.isArray(value);
    },
    regexp: function regexp(value) {
        if (value instanceof RegExp) return true;
        try {
            return new RegExp(value), true;
        } catch (e) {
            return false;
        }
    },
    date: function date(value) {
        return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function' && !isNaN(value.getTime());
    },
    number: function number(value) {
        if (isNaN(value)) return false;
        return typeof value === 'number';
    },
    object: function object(value) {
        return typeof value === 'object' && !types.array(value);
    },
    method: function method(value) {
        return typeof value === 'function';
    },
    email: function email(value) {
        return typeof value === 'string' && value.length <= 320 && !!value.match(pattern$2.email);
    },
    url: function url(value) {
        return typeof value === 'string' && value.length <= 2048 && !!value.match(pattern$2.url);
    },
    hex: function hex(value) {
        return typeof value === 'string' && !!value.match(pattern$2.hex);
    }
};
var type$1 = function type(rule, value, source, errors, options) {
    if (rule.required && value === undefined) {
        required$1(rule, value, source, errors, options);
        return;
    }
    var custom = [
        'integer',
        'float',
        'array',
        'regexp',
        'object',
        'method',
        'email',
        'number',
        'date',
        'url',
        'hex'
    ];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
         // straight typeof check
    } else if (ruleType && typeof value !== rule.type) errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
};
var range = function range(rule, value, source, errors, options) {
    var len = typeof rule.len === 'number';
    var min = typeof rule.min === 'number';
    var max = typeof rule.max === 'number'; // æ­£åˆ™åŒ¹é…ç ç‚¹èŒƒå›´ä»ŽU+010000ä¸€ç›´åˆ°U+10FFFFçš„æ–‡å­—ï¼ˆè¡¥å……å¹³é¢Supplementary Planeï¼‰
    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key = null;
    var num = typeof value === 'number';
    var str = typeof value === 'string';
    var arr = Array.isArray(value);
    if (num) key = 'number';
    else if (str) key = 'string';
    else if (arr) key = 'array';
     // if the value is not of a supported type for range validation
    // the validation rule rule should use the
    // type property to also test for a particular type
    if (!key) return false;
    if (arr) val = value.length;
    if (str) // å¤„ç†ç ç‚¹å¤§äºŽU+010000çš„æ–‡å­—lengthå±žæ€§ä¸å‡†ç¡®çš„bugï¼Œå¦‚"ð ®·ð ®·ð ®·".lenght !== 3
    val = value.replace(spRegexp, '_').length;
    if (len) {
        if (val !== rule.len) errors.push(format(options.messages[key].len, rule.fullField, rule.len));
    } else if (min && !max && val < rule.min) errors.push(format(options.messages[key].min, rule.fullField, rule.min));
    else if (max && !min && val > rule.max) errors.push(format(options.messages[key].max, rule.fullField, rule.max));
    else if (min && max && (val < rule.min || val > rule.max)) errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
};
var ENUM$1 = 'enum';
var enumerable$1 = function enumerable(rule, value, source, errors, options) {
    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
    if (rule[ENUM$1].indexOf(value) === -1) errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(', ')));
};
var pattern$1 = function pattern(rule, value, source, errors, options) {
    if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
            // if a RegExp instance is passed, reset `lastIndex` in case its `global`
            // flag is accidentally set to `true`, which in a validation scenario
            // is not necessary and the result might be misleading
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        } else if (typeof rule.pattern === 'string') {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
    }
};
var rules = {
    required: required$1,
    whitespace: whitespace,
    type: type$1,
    range: range,
    "enum": enumerable$1,
    pattern: pattern$1
};
var string = function string(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if (isEmptyValue(value, 'string') && !rule.required) return callback();
        rules.required(rule, value, source, errors, options, 'string');
        if (!isEmptyValue(value, 'string')) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
            rules.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) rules.whitespace(rule, value, source, errors, options);
        }
    }
    callback(errors);
};
var method = function method(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if (isEmptyValue(value) && !rule.required) return callback();
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) rules.type(rule, value, source, errors, options);
    }
    callback(errors);
};
var number = function number(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if (value === '') value = undefined;
        if (isEmptyValue(value) && !rule.required) return callback();
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
        }
    }
    callback(errors);
};
var _boolean = function _boolean(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if (isEmptyValue(value) && !rule.required) return callback();
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) rules.type(rule, value, source, errors, options);
    }
    callback(errors);
};
var regexp = function regexp(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if (isEmptyValue(value) && !rule.required) return callback();
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value)) rules.type(rule, value, source, errors, options);
    }
    callback(errors);
};
var integer = function integer(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if (isEmptyValue(value) && !rule.required) return callback();
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
        }
    }
    callback(errors);
};
var floatFn = function floatFn(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if (isEmptyValue(value) && !rule.required) return callback();
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
        }
    }
    callback(errors);
};
var array = function array(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if ((value === undefined || value === null) && !rule.required) return callback();
        rules.required(rule, value, source, errors, options, 'array');
        if (value !== undefined && value !== null) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
        }
    }
    callback(errors);
};
var object = function object(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if (isEmptyValue(value) && !rule.required) return callback();
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) rules.type(rule, value, source, errors, options);
    }
    callback(errors);
};
var ENUM = 'enum';
var enumerable = function enumerable(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if (isEmptyValue(value) && !rule.required) return callback();
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) rules[ENUM](rule, value, source, errors, options);
    }
    callback(errors);
};
var pattern = function pattern(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if (isEmptyValue(value, 'string') && !rule.required) return callback();
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, 'string')) rules.pattern(rule, value, source, errors, options);
    }
    callback(errors);
};
var date = function date(rule, value, callback, source, options) {
    // console.log('integer rule called %j', rule);
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);
    if (validate) {
        if (isEmptyValue(value, 'date') && !rule.required) return callback();
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, 'date')) {
            var dateObject;
            if (value instanceof Date) dateObject = value;
            else dateObject = new Date(value);
            rules.type(rule, dateObject, source, errors, options);
            if (dateObject) rules.range(rule, dateObject.getTime(), source, errors, options);
        }
    }
    callback(errors);
};
var required = function required(rule, value, callback, source, options) {
    var errors = [];
    var type5 = Array.isArray(value) ? 'array' : typeof value;
    rules.required(rule, value, source, errors, options, type5);
    callback(errors);
};
var type = function type(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) return callback();
        rules.required(rule, value, source, errors, options, ruleType);
        if (!isEmptyValue(value, ruleType)) rules.type(rule, value, source, errors, options);
    }
    callback(errors);
};
var any = function any(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
        if (isEmptyValue(value) && !rule.required) return callback();
        rules.required(rule, value, source, errors, options);
    }
    callback(errors);
};
var validators = {
    string: string,
    method: method,
    number: number,
    "boolean": _boolean,
    regexp: regexp,
    integer: integer,
    "float": floatFn,
    array: array,
    object: object,
    "enum": enumerable,
    pattern: pattern,
    date: date,
    url: type,
    hex: type,
    email: type,
    required: required,
    any: any
};
function newMessages() {
    return {
        "default": 'Validation error on field %s',
        required: '%s is required',
        "enum": '%s must be one of %s',
        whitespace: '%s cannot be empty',
        date: {
            format: '%s date %s is invalid for format %s',
            parse: '%s date could not be parsed, %s is invalid ',
            invalid: '%s date %s is invalid'
        },
        types: {
            string: '%s is not a %s',
            method: '%s is not a %s (function)',
            array: '%s is not an %s',
            object: '%s is not an %s',
            number: '%s is not a %s',
            date: '%s is not a %s',
            "boolean": '%s is not a %s',
            integer: '%s is not an %s',
            "float": '%s is not a %s',
            regexp: '%s is not a valid %s',
            email: '%s is not a valid %s',
            url: '%s is not a valid %s',
            hex: '%s is not a valid %s'
        },
        string: {
            len: '%s must be exactly %s characters',
            min: '%s must be at least %s characters',
            max: '%s cannot be longer than %s characters',
            range: '%s must be between %s and %s characters'
        },
        number: {
            len: '%s must equal %s',
            min: '%s cannot be less than %s',
            max: '%s cannot be greater than %s',
            range: '%s must be between %s and %s'
        },
        array: {
            len: '%s must be exactly %s in length',
            min: '%s cannot be less than %s in length',
            max: '%s cannot be greater than %s in length',
            range: '%s must be between %s and %s in length'
        },
        pattern: {
            mismatch: '%s value %s does not match pattern %s'
        },
        clone: function clone() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
        }
    };
}
var messages = newMessages();
/**
 *  Encapsulates a validation schema.
 *
 *  @param descriptor An object declaring validation rules
 *  for this schema.
 */ var Schema = /*#__PURE__*/ function() {
    // ========================= Static =========================
    // ======================== Instance ========================
    function Schema1(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
    }
    var _proto = Schema1.prototype;
    _proto.define = function define(rules1) {
        var _this = this;
        if (!rules1) throw new Error('Cannot configure a schema with no rules');
        if (typeof rules1 !== 'object' || Array.isArray(rules1)) throw new Error('Rules must be an object');
        this.rules = {
        };
        Object.keys(rules1).forEach(function(name) {
            var item = rules1[name];
            _this.rules[name] = Array.isArray(item) ? item : [
                item
            ];
        });
    };
    _proto.messages = function messages(_messages) {
        if (_messages) this._messages = deepMerge(newMessages(), _messages);
        return this._messages;
    };
    _proto.validate = function validate(source_, o, oc) {
        var _this2 = this;
        if (o === void 0) o = {
        };
        if (oc === void 0) oc = function oc() {
        };
        var source = source_;
        var options = o;
        var callback = oc;
        if (typeof options === 'function') {
            callback = options;
            options = {
            };
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) callback(null, source);
            return Promise.resolve(source);
        }
        function complete(results) {
            var errors = [];
            var fields = {
            };
            function add(e) {
                if (Array.isArray(e)) {
                    var _errors;
                    errors = (_errors = errors).concat.apply(_errors, e);
                } else errors.push(e);
            }
            for(var i = 0; i < results.length; i++)add(results[i]);
            if (!errors.length) callback(null, source);
            else {
                fields = convertFieldsError(errors);
                callback(errors, fields);
            }
        }
        if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) messages$1 = newMessages();
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
        } else options.messages = this.messages();
        var series = {
        };
        var keys = options.keys || Object.keys(this.rules);
        keys.forEach(function(z) {
            var arr = _this2.rules[z];
            var value = source[z];
            arr.forEach(function(r) {
                var rule = r;
                if (typeof rule.transform === 'function') {
                    if (source === source_) source = _extends({
                    }, source);
                    value = source[z] = rule.transform(value);
                }
                if (typeof rule === 'function') rule = {
                    validator: rule
                };
                else rule = _extends({
                }, rule);
                 // Fill validator. Skip if nothing need to validate
                rule.validator = _this2.getValidationMethod(rule);
                if (!rule.validator) return;
                rule.field = z;
                rule.fullField = rule.fullField || z;
                rule.type = _this2.getType(rule);
                series[z] = series[z] || [];
                series[z].push({
                    rule: rule,
                    value: value,
                    source: source,
                    field: z
                });
            });
        });
        var errorFields = {
        };
        return asyncMap(series, options, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField === 'object');
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
                return _extends({
                }, schema, {
                    fullField: rule.fullField + "." + key,
                    fullFields: rule.fullFields ? [].concat(rule.fullFields, [
                        key
                    ]) : [
                        key
                    ]
                });
            }
            function cb(e) {
                if (e === void 0) e = [];
                var errorList = Array.isArray(e) ? e : [
                    e
                ];
                if (!options.suppressWarning && errorList.length) Schema1.warning('async-validator:', errorList);
                if (errorList.length && rule.message !== undefined) errorList = [].concat(rule.message);
                 // Fill error info
                var filledErrors = errorList.map(complementError(rule, source));
                if (options.first && filledErrors.length) {
                    errorFields[rule.field] = 1;
                    return doIt(filledErrors);
                }
                if (!deep) doIt(filledErrors);
                else {
                    // if rule is required but the target object
                    // does not exist fail at the rule level and don't
                    // go deeper
                    if (rule.required && !data.value) {
                        if (rule.message !== undefined) filledErrors = [].concat(rule.message).map(complementError(rule, source));
                        else if (options.error) filledErrors = [
                            options.error(rule, format(options.messages.required, rule.field))
                        ];
                        return doIt(filledErrors);
                    }
                    var fieldsSchema = {
                    };
                    if (rule.defaultField) Object.keys(data.value).map(function(key) {
                        fieldsSchema[key] = rule.defaultField;
                    });
                    fieldsSchema = _extends({
                    }, fieldsSchema, data.rule.fields);
                    var paredFieldsSchema = {
                    };
                    Object.keys(fieldsSchema).forEach(function(field) {
                        var fieldSchema = fieldsSchema[field];
                        var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [
                            fieldSchema
                        ];
                        paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                    });
                    var schema = new Schema1(paredFieldsSchema);
                    schema.messages(options.messages);
                    if (data.rule.options) {
                        data.rule.options.messages = options.messages;
                        data.rule.options.error = options.error;
                    }
                    schema.validate(data.value, data.rule.options || options, function(errs) {
                        var finalErrors = [];
                        if (filledErrors && filledErrors.length) finalErrors.push.apply(finalErrors, filledErrors);
                        if (errs && errs.length) finalErrors.push.apply(finalErrors, errs);
                        doIt(finalErrors.length ? finalErrors : null);
                    });
                }
            }
            var res;
            if (rule.asyncValidator) res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            else if (rule.validator) {
                res = rule.validator(rule, data.value, cb, data.source, options);
                if (res === true) cb();
                else if (res === false) cb(typeof rule.message === 'function' ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
                else if (res instanceof Array) cb(res);
                else if (res instanceof Error) cb(res.message);
            }
            if (res && res.then) res.then(function() {
                return cb();
            }, function(e) {
                return cb(e);
            });
        }, function(results) {
            complete(results);
        }, source);
    };
    _proto.getType = function getType(rule) {
        if (rule.type === undefined && rule.pattern instanceof RegExp) rule.type = 'pattern';
        if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) throw new Error(format('Unknown rule type %s', rule.type));
        return rule.type || 'string';
    };
    _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === 'function') return rule.validator;
        var keys = Object.keys(rule);
        var messageIndex = keys.indexOf('message');
        if (messageIndex !== -1) keys.splice(messageIndex, 1);
        if (keys.length === 1 && keys[0] === 'required') return validators.required;
        return validators[this.getType(rule)] || undefined;
    };
    return Schema1;
}();
Schema.register = function register(type, validator) {
    if (typeof validator !== 'function') throw new Error('Cannot register a validator by type, validator is not a function');
    validators[type] = validator;
};
Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators;

},{"process":"d5jf4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {
};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e1) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {
};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {
};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"jDa7A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>LabelWrap
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../tokens/index.mjs");
var _formMjs = require("../../../tokens/form.mjs");
var _resizeEventMjs = require("../../../utils/dom/resize-event.mjs");
var LabelWrap = _vue.defineComponent({
    name: "ElLabelWrap",
    props: {
        isAutoWidth: Boolean,
        updateAll: Boolean
    },
    setup (props, { slots  }) {
        const el = _vue.ref(null);
        const elForm = _vue.inject(_formMjs.elFormKey);
        const elFormItem = _vue.inject(_formMjs.elFormItemKey);
        const computedWidth = _vue.ref(0);
        _vue.watch(computedWidth, (val, oldVal)=>{
            if (props.updateAll) {
                elForm.registerLabelWidth(val, oldVal);
                elFormItem.updateComputedLabelWidth(val);
            }
        });
        const getLabelWidth = ()=>{
            var _a;
            if ((_a = el.value) == null ? void 0 : _a.firstElementChild) {
                const width = window.getComputedStyle(el.value.firstElementChild).width;
                return Math.ceil(parseFloat(width));
            } else return 0;
        };
        const updateLabelWidth = (action = "update")=>{
            _vue.nextTick(()=>{
                if (slots.default && props.isAutoWidth) {
                    if (action === "update") computedWidth.value = getLabelWidth();
                    else if (action === "remove") elForm.deregisterLabelWidth(computedWidth.value);
                }
            });
        };
        const updateLabelWidthFn = ()=>updateLabelWidth("update")
        ;
        _vue.onMounted(()=>{
            _resizeEventMjs.addResizeListener(el.value.firstElementChild, updateLabelWidthFn);
            updateLabelWidthFn();
        });
        _vue.onUpdated(updateLabelWidthFn);
        _vue.onBeforeUnmount(()=>{
            var _a;
            updateLabelWidth("remove");
            _resizeEventMjs.removeResizeListener((_a = el.value) == null ? void 0 : _a.firstElementChild, updateLabelWidthFn);
        });
        function render() {
            var _a, _b;
            if (!slots) return null;
            if (props.isAutoWidth) {
                const autoLabelWidth = elForm.autoLabelWidth;
                const style = {
                };
                if (autoLabelWidth && autoLabelWidth !== "auto") {
                    const marginWidth = Math.max(0, parseInt(autoLabelWidth, 10) - computedWidth.value);
                    const marginPosition = elForm.labelPosition === "left" ? "marginRight" : "marginLeft";
                    if (marginWidth) style[marginPosition] = `${marginWidth}px`;
                }
                return _vue.h("div", {
                    ref: el,
                    class: [
                        "el-form-item__label-wrap"
                    ],
                    style
                }, (_a = slots.default) == null ? void 0 : _a.call(slots));
            } else return _vue.h(_vue.Fragment, {
                ref: el
            }, (_b = slots.default) == null ? void 0 : _b.call(slots));
        }
        return render;
    }
});

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../tokens/index.mjs":"wVNQi","../../../tokens/form.mjs":"2r4O0","../../../utils/dom/resize-event.mjs":"TzEEU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hFVHx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "imageEmits", ()=>_imageMjs.imageEmits
);
parcelHelpers.export(exports, "imageProps", ()=>_imageMjs.imageProps
);
parcelHelpers.export(exports, "ElImage", ()=>ElImage
);
parcelHelpers.export(exports, "default", ()=>ElImage
);
var _indexMjs = require("../../utils/index.mjs");
var _image2Mjs = require("./src/image2.mjs");
var _image2MjsDefault = parcelHelpers.interopDefault(_image2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _imageMjs = require("./src/image.mjs");
const ElImage = _installMjs.withInstall(_image2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/image2.mjs":"bQfMA","../../utils/vue/install.mjs":"4TMmv","./src/image.mjs":"hhtmC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bQfMA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Image$1
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../image-viewer/index.mjs");
var _indexMjs2 = require("../../../utils/index.mjs");
var _imageMjs = require("./image.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../hooks/use-deprecated/index.mjs");
var _indexMjs4 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs5 = require("../../../hooks/use-namespace/index.mjs");
var _indexMjs6 = require("../../../hooks/use-attrs/index.mjs");
var _positionMjs = require("../../../utils/dom/position.mjs");
var _scrollMjs = require("../../../utils/dom/scroll.mjs");
const isHtmlElement = (e)=>e && e.nodeType === Node.ELEMENT_NODE
;
let prevOverflow = "";
const _sfc_main = _vue.defineComponent({
    name: "ElImage",
    components: {
        ImageViewer: _indexMjs1.ElImageViewer
    },
    inheritAttrs: false,
    props: _imageMjs.imageProps,
    emits: _imageMjs.imageEmits,
    setup (props, { emit , attrs: rawAttrs  }) {
        _indexMjs3.useDeprecated({
            scope: "el-image",
            from: "append-to-body",
            replacement: "preview-teleported",
            version: "2.2.0",
            ref: "https://element-plus.org/en-US/component/image.html#image-attributess"
        }, _vue.computed(()=>_core.isBoolean(props.appendToBody)
        ));
        const { t  } = _indexMjs4.useLocale();
        const ns = _indexMjs5.useNamespace("image");
        const attrs = _indexMjs6.useAttrs();
        const hasLoadError = _vue.ref(false);
        const loading = _vue.ref(true);
        const imgWidth = _vue.ref(0);
        const imgHeight = _vue.ref(0);
        const showViewer = _vue.ref(false);
        const container = _vue.ref();
        const _scrollContainer = _vue.ref();
        let stopScrollListener;
        let stopWheelListener;
        const containerStyle = _vue.computed(()=>rawAttrs.style
        );
        const imageStyle = _vue.computed(()=>{
            const { fit  } = props;
            if (_core.isClient && fit) return {
                objectFit: fit
            };
            return {
            };
        });
        const preview = _vue.computed(()=>{
            const { previewSrcList  } = props;
            return Array.isArray(previewSrcList) && previewSrcList.length > 0;
        });
        const teleported = _vue.computed(()=>{
            return props.appendToBody || props.previewTeleported;
        });
        const imageIndex = _vue.computed(()=>{
            const { previewSrcList , initialIndex  } = props;
            let previewIndex = initialIndex;
            if (initialIndex > previewSrcList.length - 1) previewIndex = 0;
            return previewIndex;
        });
        const loadImage = ()=>{
            if (!_core.isClient) return;
            loading.value = true;
            hasLoadError.value = false;
            const img = new Image();
            const currentImageSrc = props.src;
            img.addEventListener("load", (e)=>{
                if (currentImageSrc !== props.src) return;
                handleLoad(e, img);
            });
            img.addEventListener("error", (e)=>{
                if (currentImageSrc !== props.src) return;
                handleError(e);
            });
            Object.entries(attrs.value).forEach(([key, value])=>{
                if (key.toLowerCase() === "onload") return;
                img.setAttribute(key, value);
            });
            img.src = currentImageSrc;
        };
        function handleLoad(e, img) {
            imgWidth.value = img.width;
            imgHeight.value = img.height;
            loading.value = false;
            hasLoadError.value = false;
        }
        function handleError(event) {
            loading.value = false;
            hasLoadError.value = true;
            emit("error", event);
        }
        function handleLazyLoad() {
            if (_positionMjs.isInContainer(container.value, _scrollContainer.value)) {
                loadImage();
                removeLazyLoadListener();
            }
        }
        const lazyLoadHandler = _core.useThrottleFn(handleLazyLoad, 200);
        async function addLazyLoadListener() {
            var _a;
            if (!_core.isClient) return;
            await _vue.nextTick();
            const { scrollContainer  } = props;
            if (isHtmlElement(scrollContainer)) _scrollContainer.value = scrollContainer;
            else if (_shared.isString(scrollContainer) && scrollContainer !== "") _scrollContainer.value = (_a = document.querySelector(scrollContainer)) != null ? _a : void 0;
            else if (container.value) _scrollContainer.value = _scrollMjs.getScrollContainer(container.value);
            if (_scrollContainer.value) {
                stopScrollListener = _core.useEventListener(_scrollContainer, "scroll", lazyLoadHandler);
                setTimeout(()=>handleLazyLoad()
                , 100);
            }
        }
        function removeLazyLoadListener() {
            if (!_core.isClient || !_scrollContainer.value || !lazyLoadHandler) return;
            stopScrollListener();
            _scrollContainer.value = void 0;
        }
        function wheelHandler(e) {
            if (!e.ctrlKey) return;
            if (e.deltaY < 0) {
                e.preventDefault();
                return false;
            } else if (e.deltaY > 0) {
                e.preventDefault();
                return false;
            }
        }
        function clickHandler() {
            if (!preview.value) return;
            stopWheelListener = _core.useEventListener("wheel", wheelHandler, {
                passive: false
            });
            prevOverflow = document.body.style.overflow;
            document.body.style.overflow = "hidden";
            showViewer.value = true;
        }
        function closeViewer() {
            stopWheelListener == null || stopWheelListener();
            document.body.style.overflow = prevOverflow;
            showViewer.value = false;
            emit("close");
        }
        function switchViewer(val) {
            emit("switch", val);
        }
        _vue.watch(()=>props.src
        , ()=>{
            if (props.lazy) {
                loading.value = true;
                hasLoadError.value = false;
                removeLazyLoadListener();
                addLazyLoadListener();
            } else loadImage();
        });
        _vue.onMounted(()=>{
            if (props.lazy) addLazyLoadListener();
            else loadImage();
        });
        return {
            attrs,
            loading,
            hasLoadError,
            showViewer,
            containerStyle,
            imageStyle,
            preview,
            imageIndex,
            container,
            ns,
            teleported,
            clickHandler,
            closeViewer,
            switchViewer,
            t
        };
    }
});
const _hoisted_1 = [
    "src"
];
const _hoisted_2 = {
    key: 0
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_image_viewer = _vue.resolveComponent("image-viewer");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "container",
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.$attrs.class
        ]),
        style: _vue.normalizeStyle(_ctx.containerStyle)
    }, [
        _ctx.loading ? _vue.renderSlot(_ctx.$slots, "placeholder", {
            key: 0
        }, ()=>[
                _vue.createElementVNode("div", {
                    class: _vue.normalizeClass(_ctx.ns.e("placeholder"))
                }, null, 2)
            ]
        ) : _ctx.hasLoadError ? _vue.renderSlot(_ctx.$slots, "error", {
            key: 1
        }, ()=>[
                _vue.createElementVNode("div", {
                    class: _vue.normalizeClass(_ctx.ns.e("error"))
                }, _vue.toDisplayString(_ctx.t("el.image.error")), 3)
            ]
        ) : (_vue.openBlock(), _vue.createElementBlock("img", _vue.mergeProps({
            key: 2
        }, _ctx.attrs, {
            src: _ctx.src,
            style: _ctx.imageStyle,
            class: [
                _ctx.ns.e("inner"),
                _ctx.preview ? _ctx.ns.e("preview") : ""
            ],
            onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.clickHandler && _ctx.clickHandler(...args)
            )
        }), null, 16, _hoisted_1)),
        _ctx.preview ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
            key: 3
        }, [
            _ctx.showViewer ? (_vue.openBlock(), _vue.createBlock(_component_image_viewer, {
                key: 0,
                "z-index": _ctx.zIndex,
                "initial-index": _ctx.imageIndex,
                "url-list": _ctx.previewSrcList,
                "hide-on-click-modal": _ctx.hideOnClickModal,
                teleported: _ctx.teleported,
                onClose: _ctx.closeViewer,
                onSwitch: _ctx.switchViewer
            }, {
                default: _vue.withCtx(()=>[
                        _ctx.$slots.viewer ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_2, [
                            _vue.renderSlot(_ctx.$slots, "viewer")
                        ])) : _vue.createCommentVNode("v-if", true)
                    ]
                ),
                _: 3
            }, 8, [
                "z-index",
                "initial-index",
                "url-list",
                "hide-on-click-modal",
                "teleported",
                "onClose",
                "onSwitch"
            ])) : _vue.createCommentVNode("v-if", true)
        ], 2112)) : _vue.createCommentVNode("v-if", true)
    ], 6);
}
var Image$1 = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vue/shared":"3SM3y","@vueuse/core":"eEHP9","../../../hooks/index.mjs":"1Ansp","../../image-viewer/index.mjs":"39t5l","../../../utils/index.mjs":"dsdeP","./image.mjs":"hhtmC","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-deprecated/index.mjs":"4fitg","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../hooks/use-attrs/index.mjs":"3W2Zt","../../../utils/dom/position.mjs":"cYzxx","../../../utils/dom/scroll.mjs":"hpitc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"39t5l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "imageViewerEmits", ()=>_imageViewerMjs.imageViewerEmits
);
parcelHelpers.export(exports, "imageViewerProps", ()=>_imageViewerMjs.imageViewerProps
);
parcelHelpers.export(exports, "ElImageViewer", ()=>ElImageViewer
);
parcelHelpers.export(exports, "default", ()=>ElImageViewer
);
var _indexMjs = require("../../utils/index.mjs");
var _imageViewer2Mjs = require("./src/image-viewer2.mjs");
var _imageViewer2MjsDefault = parcelHelpers.interopDefault(_imageViewer2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _imageViewerMjs = require("./src/image-viewer.mjs");
const ElImageViewer = _installMjs.withInstall(_imageViewer2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/image-viewer2.mjs":"ipCTP","../../utils/vue/install.mjs":"4TMmv","./src/image-viewer.mjs":"kIWgu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ipCTP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ImageViewer
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../icon/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _indexMjs2 = require("../../../constants/index.mjs");
var _indexMjs3 = require("../../../utils/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _imageViewerMjs = require("./image-viewer.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _browserMjs = require("../../../utils/browser.mjs");
var _indexMjs4 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs5 = require("../../../hooks/use-namespace/index.mjs");
var _indexMjs6 = require("../../../hooks/use-z-index/index.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
const Mode = {
    CONTAIN: {
        name: "contain",
        icon: _vue.markRaw(_iconsVue.FullScreen)
    },
    ORIGINAL: {
        name: "original",
        icon: _vue.markRaw(_iconsVue.ScaleToOriginal)
    }
};
const mousewheelEventName = _browserMjs.isFirefox() ? "DOMMouseScroll" : "mousewheel";
const _sfc_main = _vue.defineComponent({
    name: "ElImageViewer",
    components: {
        ElIcon: _indexMjs.ElIcon,
        Close: _iconsVue.Close,
        ArrowLeft: _iconsVue.ArrowLeft,
        ArrowRight: _iconsVue.ArrowRight,
        ZoomOut: _iconsVue.ZoomOut,
        ZoomIn: _iconsVue.ZoomIn,
        RefreshLeft: _iconsVue.RefreshLeft,
        RefreshRight: _iconsVue.RefreshRight
    },
    props: _imageViewerMjs.imageViewerProps,
    emits: _imageViewerMjs.imageViewerEmits,
    setup (props, { emit  }) {
        const { t  } = _indexMjs4.useLocale();
        const ns = _indexMjs5.useNamespace("image-viewer");
        const { nextZIndex  } = _indexMjs6.useZIndex();
        const wrapper = _vue.ref();
        const imgRefs = _vue.ref([]);
        const scopeEventListener = _vue.effectScope();
        const loading = _vue.ref(true);
        const index = _vue.ref(props.initialIndex);
        const mode = _vue.ref(Mode.CONTAIN);
        const transform = _vue.ref({
            scale: 1,
            deg: 0,
            offsetX: 0,
            offsetY: 0,
            enableTransition: false
        });
        const isSingle = _vue.computed(()=>{
            const { urlList  } = props;
            return urlList.length <= 1;
        });
        const isFirst = _vue.computed(()=>{
            return index.value === 0;
        });
        const isLast = _vue.computed(()=>{
            return index.value === props.urlList.length - 1;
        });
        const currentImg = _vue.computed(()=>{
            return props.urlList[index.value];
        });
        const imgStyle = _vue.computed(()=>{
            const { scale , deg , offsetX , offsetY , enableTransition  } = transform.value;
            let translateX = offsetX / scale;
            let translateY = offsetY / scale;
            switch(deg % 360){
                case 90:
                case -270:
                    [translateX, translateY] = [
                        translateY,
                        -translateX
                    ];
                    break;
                case 180:
                case -180:
                    [translateX, translateY] = [
                        -translateX,
                        -translateY
                    ];
                    break;
                case 270:
                case -90:
                    [translateX, translateY] = [
                        -translateY,
                        translateX
                    ];
                    break;
            }
            const style = {
                transform: `scale(${scale}) rotate(${deg}deg) translate(${translateX}px, ${translateY}px)`,
                transition: enableTransition ? "transform .3s" : ""
            };
            if (mode.value.name === Mode.CONTAIN.name) style.maxWidth = style.maxHeight = "100%";
            return style;
        });
        const computedZIndex = _vue.computed(()=>{
            return _core.isNumber(props.zIndex) ? props.zIndex : nextZIndex();
        });
        function hide() {
            unregisterEventListener();
            emit("close");
        }
        function registerEventListener() {
            const keydownHandler = _lodashUnified.throttle((e)=>{
                switch(e.code){
                    case _ariaMjs.EVENT_CODE.esc:
                        hide();
                        break;
                    case _ariaMjs.EVENT_CODE.space:
                        toggleMode();
                        break;
                    case _ariaMjs.EVENT_CODE.left:
                        prev();
                        break;
                    case _ariaMjs.EVENT_CODE.up:
                        handleActions("zoomIn");
                        break;
                    case _ariaMjs.EVENT_CODE.right:
                        next();
                        break;
                    case _ariaMjs.EVENT_CODE.down:
                        handleActions("zoomOut");
                        break;
                }
            });
            const mousewheelHandler = _lodashUnified.throttle((e)=>{
                const delta = e.wheelDelta ? e.wheelDelta : -e.detail;
                if (delta > 0) handleActions("zoomIn", {
                    zoomRate: 1.2,
                    enableTransition: false
                });
                else handleActions("zoomOut", {
                    zoomRate: 1.2,
                    enableTransition: false
                });
            });
            scopeEventListener.run(()=>{
                _core.useEventListener(document, "keydown", keydownHandler);
                _core.useEventListener(document, mousewheelEventName, mousewheelHandler);
            });
        }
        function unregisterEventListener() {
            scopeEventListener.stop();
        }
        function handleImgLoad() {
            loading.value = false;
        }
        function handleImgError(e) {
            loading.value = false;
            e.target.alt = t("el.image.error");
        }
        function handleMouseDown(e) {
            if (loading.value || e.button !== 0 || !wrapper.value) return;
            transform.value.enableTransition = false;
            const { offsetX , offsetY  } = transform.value;
            const startX = e.pageX;
            const startY = e.pageY;
            const dragHandler = _lodashUnified.throttle((ev)=>{
                transform.value = {
                    ...transform.value,
                    offsetX: offsetX + ev.pageX - startX,
                    offsetY: offsetY + ev.pageY - startY
                };
            });
            const removeMousemove = _core.useEventListener(document, "mousemove", dragHandler);
            _core.useEventListener(document, "mouseup", ()=>{
                removeMousemove();
            });
            e.preventDefault();
        }
        function reset() {
            transform.value = {
                scale: 1,
                deg: 0,
                offsetX: 0,
                offsetY: 0,
                enableTransition: false
            };
        }
        function toggleMode() {
            if (loading.value) return;
            const modeNames = Object.keys(Mode);
            const modeValues = Object.values(Mode);
            const currentMode = mode.value.name;
            const index2 = modeValues.findIndex((i)=>i.name === currentMode
            );
            const nextIndex = (index2 + 1) % modeNames.length;
            mode.value = Mode[modeNames[nextIndex]];
            reset();
        }
        function prev() {
            if (isFirst.value && !props.infinite) return;
            const len = props.urlList.length;
            index.value = (index.value - 1 + len) % len;
        }
        function next() {
            if (isLast.value && !props.infinite) return;
            const len = props.urlList.length;
            index.value = (index.value + 1) % len;
        }
        function handleActions(action, options = {
        }) {
            if (loading.value) return;
            const { zoomRate , rotateDeg , enableTransition  } = {
                zoomRate: 1.4,
                rotateDeg: 90,
                enableTransition: true,
                ...options
            };
            switch(action){
                case "zoomOut":
                    if (transform.value.scale > 0.2) transform.value.scale = parseFloat((transform.value.scale / zoomRate).toFixed(3));
                    break;
                case "zoomIn":
                    if (transform.value.scale < 7) transform.value.scale = parseFloat((transform.value.scale * zoomRate).toFixed(3));
                    break;
                case "clockwise":
                    transform.value.deg += rotateDeg;
                    break;
                case "anticlockwise":
                    transform.value.deg -= rotateDeg;
                    break;
            }
            transform.value.enableTransition = enableTransition;
        }
        _vue.watch(currentImg, ()=>{
            _vue.nextTick(()=>{
                const $img = imgRefs.value[0];
                if (!($img == null ? void 0 : $img.complete)) loading.value = true;
            });
        });
        _vue.watch(index, (val)=>{
            reset();
            emit("switch", val);
        });
        _vue.onMounted(()=>{
            var _a, _b;
            registerEventListener();
            (_b = (_a = wrapper.value) == null ? void 0 : _a.focus) == null || _b.call(_a);
        });
        return {
            index,
            wrapper,
            imgRefs,
            isSingle,
            isFirst,
            isLast,
            currentImg,
            imgStyle,
            mode,
            computedZIndex,
            handleActions,
            prev,
            next,
            hide,
            toggleMode,
            handleImgLoad,
            handleImgError,
            handleMouseDown,
            ns
        };
    }
});
const _hoisted_1 = [
    "src"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_close = _vue.resolveComponent("close");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_arrow_left = _vue.resolveComponent("arrow-left");
    const _component_arrow_right = _vue.resolveComponent("arrow-right");
    const _component_zoom_out = _vue.resolveComponent("zoom-out");
    const _component_zoom_in = _vue.resolveComponent("zoom-in");
    const _component_refresh_left = _vue.resolveComponent("refresh-left");
    const _component_refresh_right = _vue.resolveComponent("refresh-right");
    return _vue.openBlock(), _vue.createBlock(_vue.Teleport, {
        to: "body",
        disabled: !_ctx.teleported
    }, [
        _vue.createVNode(_vue.Transition, {
            name: "viewer-fade",
            appear: ""
        }, {
            default: _vue.withCtx(()=>[
                    _vue.createElementVNode("div", {
                        ref: "wrapper",
                        tabindex: -1,
                        class: _vue.normalizeClass(_ctx.ns.e("wrapper")),
                        style: _vue.normalizeStyle({
                            zIndex: _ctx.computedZIndex
                        })
                    }, [
                        _vue.createElementVNode("div", {
                            class: _vue.normalizeClass(_ctx.ns.e("mask")),
                            onClick: _cache[0] || (_cache[0] = _vue.withModifiers(($event)=>_ctx.hideOnClickModal && _ctx.hide()
                            , [
                                "self"
                            ]))
                        }, null, 2),
                        _vue.createCommentVNode(" CLOSE "),
                        _vue.createElementVNode("span", {
                            class: _vue.normalizeClass([
                                _ctx.ns.e("btn"),
                                _ctx.ns.e("close")
                            ]),
                            onClick: _cache[1] || (_cache[1] = (...args)=>_ctx.hide && _ctx.hide(...args)
                            )
                        }, [
                            _vue.createVNode(_component_el_icon, null, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_close)
                                    ]
                                ),
                                _: 1
                            })
                        ], 2),
                        _vue.createCommentVNode(" ARROW "),
                        !_ctx.isSingle ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                            key: 0
                        }, [
                            _vue.createElementVNode("span", {
                                class: _vue.normalizeClass([
                                    _ctx.ns.e("btn"),
                                    _ctx.ns.e("prev"),
                                    _ctx.ns.is("disabled", !_ctx.infinite && _ctx.isFirst)
                                ]),
                                onClick: _cache[2] || (_cache[2] = (...args)=>_ctx.prev && _ctx.prev(...args)
                                )
                            }, [
                                _vue.createVNode(_component_el_icon, null, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_arrow_left)
                                        ]
                                    ),
                                    _: 1
                                })
                            ], 2),
                            _vue.createElementVNode("span", {
                                class: _vue.normalizeClass([
                                    _ctx.ns.e("btn"),
                                    _ctx.ns.e("next"),
                                    _ctx.ns.is("disabled", !_ctx.infinite && _ctx.isLast)
                                ]),
                                onClick: _cache[3] || (_cache[3] = (...args)=>_ctx.next && _ctx.next(...args)
                                )
                            }, [
                                _vue.createVNode(_component_el_icon, null, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_arrow_right)
                                        ]
                                    ),
                                    _: 1
                                })
                            ], 2)
                        ], 64)) : _vue.createCommentVNode("v-if", true),
                        _vue.createCommentVNode(" ACTIONS "),
                        _vue.createElementVNode("div", {
                            class: _vue.normalizeClass([
                                _ctx.ns.e("btn"),
                                _ctx.ns.e("actions")
                            ])
                        }, [
                            _vue.createElementVNode("div", {
                                class: _vue.normalizeClass(_ctx.ns.e("actions__inner"))
                            }, [
                                _vue.createVNode(_component_el_icon, {
                                    onClick: _cache[4] || (_cache[4] = ($event)=>_ctx.handleActions("zoomOut")
                                    )
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_zoom_out)
                                        ]
                                    ),
                                    _: 1
                                }),
                                _vue.createVNode(_component_el_icon, {
                                    onClick: _cache[5] || (_cache[5] = ($event)=>_ctx.handleActions("zoomIn")
                                    )
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_zoom_in)
                                        ]
                                    ),
                                    _: 1
                                }),
                                _vue.createElementVNode("i", {
                                    class: _vue.normalizeClass(_ctx.ns.e("actions__divider"))
                                }, null, 2),
                                _vue.createVNode(_component_el_icon, {
                                    onClick: _ctx.toggleMode
                                }, {
                                    default: _vue.withCtx(()=>[
                                            (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.mode.icon)))
                                        ]
                                    ),
                                    _: 1
                                }, 8, [
                                    "onClick"
                                ]),
                                _vue.createElementVNode("i", {
                                    class: _vue.normalizeClass(_ctx.ns.e("actions__divider"))
                                }, null, 2),
                                _vue.createVNode(_component_el_icon, {
                                    onClick: _cache[6] || (_cache[6] = ($event)=>_ctx.handleActions("anticlockwise")
                                    )
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_refresh_left)
                                        ]
                                    ),
                                    _: 1
                                }),
                                _vue.createVNode(_component_el_icon, {
                                    onClick: _cache[7] || (_cache[7] = ($event)=>_ctx.handleActions("clockwise")
                                    )
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_refresh_right)
                                        ]
                                    ),
                                    _: 1
                                })
                            ], 2)
                        ], 2),
                        _vue.createCommentVNode(" CANVAS "),
                        _vue.createElementVNode("div", {
                            class: _vue.normalizeClass(_ctx.ns.e("canvas"))
                        }, [
                            (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.urlList, (url, i)=>{
                                return _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("img", {
                                    ref_for: true,
                                    ref: (el)=>_ctx.imgRefs[i] = el
                                    ,
                                    key: url,
                                    src: url,
                                    style: _vue.normalizeStyle(_ctx.imgStyle),
                                    class: _vue.normalizeClass(_ctx.ns.e("img")),
                                    onLoad: _cache[8] || (_cache[8] = (...args)=>_ctx.handleImgLoad && _ctx.handleImgLoad(...args)
                                    ),
                                    onError: _cache[9] || (_cache[9] = (...args)=>_ctx.handleImgError && _ctx.handleImgError(...args)
                                    ),
                                    onMousedown: _cache[10] || (_cache[10] = (...args)=>_ctx.handleMouseDown && _ctx.handleMouseDown(...args)
                                    )
                                }, null, 46, _hoisted_1)), [
                                    [
                                        _vue.vShow,
                                        i === _ctx.index
                                    ]
                                ]);
                            }), 128))
                        ], 2),
                        _vue.renderSlot(_ctx.$slots, "default")
                    ], 6)
                ]
            ),
            _: 3
        })
    ], 8, [
        "disabled"
    ]);
}
var ImageViewer = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vueuse/core":"eEHP9","lodash-unified":"4Oj4p","../../icon/index.mjs":"hnNTG","../../../hooks/index.mjs":"1Ansp","../../../constants/index.mjs":"74Fbn","../../../utils/index.mjs":"dsdeP","@element-plus/icons-vue":"b18uu","./image-viewer.mjs":"kIWgu","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/browser.mjs":"9TDf1","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../hooks/use-z-index/index.mjs":"7aKZA","../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kIWgu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "imageViewerEmits", ()=>imageViewerEmits
);
parcelHelpers.export(exports, "imageViewerProps", ()=>imageViewerProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _typescriptMjs = require("../../../utils/typescript.mjs");
const imageViewerProps = _propsMjs.buildProps({
    urlList: {
        type: _propsMjs.definePropType(Array),
        default: ()=>_typescriptMjs.mutable([])
    },
    zIndex: {
        type: Number
    },
    initialIndex: {
        type: Number,
        default: 0
    },
    infinite: {
        type: Boolean,
        default: true
    },
    hideOnClickModal: {
        type: Boolean,
        default: false
    },
    teleported: {
        type: Boolean,
        default: false
    }
});
const imageViewerEmits = {
    close: ()=>true
    ,
    switch: (index)=>typeof index === "number"
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","../../../utils/typescript.mjs":"bRl53","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hhtmC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "imageEmits", ()=>imageEmits
);
parcelHelpers.export(exports, "imageProps", ()=>imageProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _typescriptMjs = require("../../../utils/typescript.mjs");
var _core = require("@vueuse/core");
const imageProps = _propsMjs.buildProps({
    appendToBody: {
        type: Boolean,
        default: void 0
    },
    hideOnClickModal: {
        type: Boolean,
        default: false
    },
    src: {
        type: String,
        default: ""
    },
    fit: {
        type: String,
        values: [
            "",
            "contain",
            "cover",
            "fill",
            "none",
            "scale-down"
        ],
        default: ""
    },
    lazy: {
        type: Boolean,
        default: false
    },
    scrollContainer: {
        type: _propsMjs.definePropType([
            String,
            Object
        ])
    },
    previewSrcList: {
        type: _propsMjs.definePropType(Array),
        default: ()=>_typescriptMjs.mutable([])
    },
    previewTeleported: {
        type: Boolean,
        default: false
    },
    zIndex: {
        type: Number
    },
    initialIndex: {
        type: Number,
        default: 0
    }
});
const imageEmits = {
    error: (evt)=>evt instanceof Event
    ,
    switch: (val)=>_core.isNumber(val)
    ,
    close: ()=>true
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","../../../utils/typescript.mjs":"bRl53","@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1U2Gu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "inputNumberEmits", ()=>_inputNumberMjs.inputNumberEmits
);
parcelHelpers.export(exports, "inputNumberProps", ()=>_inputNumberMjs.inputNumberProps
);
parcelHelpers.export(exports, "ElInputNumber", ()=>ElInputNumber
);
parcelHelpers.export(exports, "default", ()=>ElInputNumber
);
var _indexMjs = require("../../utils/index.mjs");
var _inputNumber2Mjs = require("./src/input-number2.mjs");
var _inputNumber2MjsDefault = parcelHelpers.interopDefault(_inputNumber2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _inputNumberMjs = require("./src/input-number.mjs");
const ElInputNumber = _installMjs.withInstall(_inputNumber2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/input-number2.mjs":"hVzx4","../../utils/vue/install.mjs":"4TMmv","./src/input-number.mjs":"hcBfX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hVzx4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>InputNumber
);
var _vue = require("vue");
var _indexMjs = require("../../icon/index.mjs");
var _indexMjs1 = require("../../../directives/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _indexMjs3 = require("../../input/index.mjs");
var _indexMjs4 = require("../../../utils/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _inputNumberMjs = require("./input-number.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs5 = require("../../../directives/repeat-click/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs5);
var _indexMjs6 = require("../../../hooks/use-form-item/index.mjs");
var _indexMjs7 = require("../../../hooks/use-namespace/index.mjs");
var _errorMjs = require("../../../utils/error.mjs");
var _indexMjs8 = require("../../../hooks/use-common-props/index.mjs");
var _core = require("@vueuse/core");
const _sfc_main = _vue.defineComponent({
    name: "ElInputNumber",
    components: {
        ElInput: _indexMjs3.ElInput,
        ElIcon: _indexMjs.ElIcon,
        ArrowUp: _iconsVue.ArrowUp,
        ArrowDown: _iconsVue.ArrowDown,
        Plus: _iconsVue.Plus,
        Minus: _iconsVue.Minus
    },
    directives: {
        RepeatClick: _indexMjsDefault.default
    },
    props: _inputNumberMjs.inputNumberProps,
    emits: _inputNumberMjs.inputNumberEmits,
    setup (props, { emit  }) {
        const input = _vue.ref();
        const data = _vue.reactive({
            currentValue: props.modelValue,
            userInput: null
        });
        const { formItem  } = _indexMjs6.useFormItem();
        const ns = _indexMjs7.useNamespace("input-number");
        const minDisabled = _vue.computed(()=>_decrease(props.modelValue) < props.min
        );
        const maxDisabled = _vue.computed(()=>_increase(props.modelValue) > props.max
        );
        const numPrecision = _vue.computed(()=>{
            const stepPrecision = getPrecision(props.step);
            if (props.precision !== void 0) {
                if (stepPrecision > props.precision) _errorMjs.debugWarn("InputNumber", "precision should not be less than the decimal places of step");
                return props.precision;
            } else return Math.max(getPrecision(props.modelValue), stepPrecision);
        });
        const controlsAtRight = _vue.computed(()=>{
            return props.controls && props.controlsPosition === "right";
        });
        const inputNumberSize = _indexMjs8.useSize();
        const inputNumberDisabled = _indexMjs8.useDisabled();
        const displayValue = _vue.computed(()=>{
            if (data.userInput !== null) return data.userInput;
            let currentValue = data.currentValue;
            if (_core.isNumber(currentValue)) {
                if (Number.isNaN(currentValue)) return "";
                if (props.precision !== void 0) currentValue = currentValue.toFixed(props.precision);
            }
            return currentValue;
        });
        const toPrecision = (num, pre)=>{
            if (pre === void 0) pre = numPrecision.value;
            return parseFloat(`${Math.round(num * Math.pow(10, pre)) / Math.pow(10, pre)}`);
        };
        const getPrecision = (value)=>{
            if (value === void 0) return 0;
            const valueString = value.toString();
            const dotPosition = valueString.indexOf(".");
            let precision = 0;
            if (dotPosition !== -1) precision = valueString.length - dotPosition - 1;
            return precision;
        };
        const _increase = (val)=>{
            if (!_core.isNumber(val)) return data.currentValue;
            const precisionFactor = Math.pow(10, numPrecision.value);
            val = _core.isNumber(val) ? val : NaN;
            return toPrecision((precisionFactor * val + precisionFactor * props.step) / precisionFactor);
        };
        const _decrease = (val)=>{
            if (!_core.isNumber(val)) return data.currentValue;
            const precisionFactor = Math.pow(10, numPrecision.value);
            val = _core.isNumber(val) ? val : NaN;
            return toPrecision((precisionFactor * val - precisionFactor * props.step) / precisionFactor);
        };
        const increase = ()=>{
            if (inputNumberDisabled.value || maxDisabled.value) return;
            const value = props.modelValue || 0;
            const newVal = _increase(value);
            setCurrentValue(newVal);
        };
        const decrease = ()=>{
            if (inputNumberDisabled.value || minDisabled.value) return;
            const value = props.modelValue || 0;
            const newVal = _decrease(value);
            setCurrentValue(newVal);
        };
        const setCurrentValue = (newVal)=>{
            var _a;
            const oldVal = data.currentValue;
            if (typeof newVal === "number" && props.precision !== void 0) newVal = toPrecision(newVal, props.precision);
            if (newVal !== void 0 && newVal >= props.max) newVal = props.max;
            if (newVal !== void 0 && newVal <= props.min) newVal = props.min;
            if (oldVal === newVal) return;
            if (!_core.isNumber(newVal)) newVal = void 0;
            data.userInput = null;
            emit("update:modelValue", newVal);
            emit("input", newVal);
            emit("change", newVal, oldVal);
            (_a = formItem == null ? void 0 : formItem.validate) == null || _a.call(formItem, "change");
            data.currentValue = newVal;
        };
        const handleInput = (value)=>{
            return data.userInput = value;
        };
        const handleInputChange = (value)=>{
            const newVal = value !== "" ? Number(value) : "";
            if (_core.isNumber(newVal) && !Number.isNaN(newVal) || value === "") setCurrentValue(newVal);
            data.userInput = null;
        };
        const focus = ()=>{
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.focus) == null || _b.call(_a);
        };
        const blur = ()=>{
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.blur) == null || _b.call(_a);
        };
        const handleFocus = (event)=>{
            emit("focus", event);
        };
        const handleBlur = (event)=>{
            var _a;
            emit("blur", event);
            (_a = formItem == null ? void 0 : formItem.validate) == null || _a.call(formItem, "blur");
        };
        _vue.watch(()=>props.modelValue
        , (value)=>{
            let newVal = Number(value);
            if (value === null) newVal = Number.NaN;
            if (!isNaN(newVal)) {
                if (props.stepStrictly) {
                    const stepPrecision = getPrecision(props.step);
                    const precisionFactor = Math.pow(10, stepPrecision);
                    newVal = Math.round(newVal / props.step) * precisionFactor * props.step / precisionFactor;
                }
                if (props.precision !== void 0) newVal = toPrecision(newVal, props.precision);
                if (newVal > props.max) {
                    newVal = props.max;
                    emit("update:modelValue", newVal);
                }
                if (newVal < props.min) {
                    newVal = props.min;
                    emit("update:modelValue", newVal);
                }
            }
            data.currentValue = newVal;
            data.userInput = null;
        }, {
            immediate: true
        });
        _vue.onMounted(()=>{
            var _a;
            const innerInput = (_a = input.value) == null ? void 0 : _a.input;
            innerInput.setAttribute("role", "spinbutton");
            innerInput.setAttribute("aria-valuemax", String(props.max));
            innerInput.setAttribute("aria-valuemin", String(props.min));
            innerInput.setAttribute("aria-valuenow", String(data.currentValue));
            innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
            if (!_core.isNumber(props.modelValue)) {
                let val = Number(props.modelValue);
                if (isNaN(val)) val = void 0;
                emit("update:modelValue", val);
            }
        });
        _vue.onUpdated(()=>{
            var _a;
            const innerInput = (_a = input.value) == null ? void 0 : _a.input;
            innerInput == null || innerInput.setAttribute("aria-valuenow", data.currentValue);
        });
        return {
            input,
            displayValue,
            handleInput,
            handleInputChange,
            controlsAtRight,
            decrease,
            increase,
            inputNumberSize,
            inputNumberDisabled,
            maxDisabled,
            minDisabled,
            focus,
            blur,
            handleFocus,
            handleBlur,
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_arrow_down = _vue.resolveComponent("arrow-down");
    const _component_minus = _vue.resolveComponent("minus");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_arrow_up = _vue.resolveComponent("arrow-up");
    const _component_plus = _vue.resolveComponent("plus");
    const _component_el_input = _vue.resolveComponent("el-input");
    const _directive_repeat_click = _vue.resolveDirective("repeat-click");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.m(_ctx.inputNumberSize),
            _ctx.ns.is("disabled", _ctx.inputNumberDisabled),
            _ctx.ns.is("without-controls", !_ctx.controls),
            _ctx.ns.is("controls-right", _ctx.controlsAtRight)
        ]),
        onDragstart: _cache[2] || (_cache[2] = _vue.withModifiers(()=>{
        }, [
            "prevent"
        ]))
    }, [
        _ctx.controls ? _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("span", {
            key: 0,
            role: "button",
            class: _vue.normalizeClass([
                _ctx.ns.e("decrease"),
                _ctx.ns.is("disabled", _ctx.minDisabled)
            ]),
            onKeydown: _cache[0] || (_cache[0] = _vue.withKeys((...args)=>_ctx.decrease && _ctx.decrease(...args)
            , [
                "enter"
            ]))
        }, [
            _vue.createVNode(_component_el_icon, null, {
                default: _vue.withCtx(()=>[
                        _ctx.controlsAtRight ? (_vue.openBlock(), _vue.createBlock(_component_arrow_down, {
                            key: 0
                        })) : (_vue.openBlock(), _vue.createBlock(_component_minus, {
                            key: 1
                        }))
                    ]
                ),
                _: 1
            })
        ], 34)), [
            [
                _directive_repeat_click,
                _ctx.decrease
            ]
        ]) : _vue.createCommentVNode("v-if", true),
        _ctx.controls ? _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("span", {
            key: 1,
            role: "button",
            class: _vue.normalizeClass([
                _ctx.ns.e("increase"),
                _ctx.ns.is("disabled", _ctx.maxDisabled)
            ]),
            onKeydown: _cache[1] || (_cache[1] = _vue.withKeys((...args)=>_ctx.increase && _ctx.increase(...args)
            , [
                "enter"
            ]))
        }, [
            _vue.createVNode(_component_el_icon, null, {
                default: _vue.withCtx(()=>[
                        _ctx.controlsAtRight ? (_vue.openBlock(), _vue.createBlock(_component_arrow_up, {
                            key: 0
                        })) : (_vue.openBlock(), _vue.createBlock(_component_plus, {
                            key: 1
                        }))
                    ]
                ),
                _: 1
            })
        ], 34)), [
            [
                _directive_repeat_click,
                _ctx.increase
            ]
        ]) : _vue.createCommentVNode("v-if", true),
        _vue.createVNode(_component_el_input, {
            ref: "input",
            type: "number",
            step: _ctx.step,
            "model-value": _ctx.displayValue,
            placeholder: _ctx.placeholder,
            disabled: _ctx.inputNumberDisabled,
            size: _ctx.inputNumberSize,
            max: _ctx.max,
            min: _ctx.min,
            name: _ctx.name,
            label: _ctx.label,
            "validate-event": false,
            onKeydown: [
                _vue.withKeys(_vue.withModifiers(_ctx.increase, [
                    "prevent"
                ]), [
                    "up"
                ]),
                _vue.withKeys(_vue.withModifiers(_ctx.decrease, [
                    "prevent"
                ]), [
                    "down"
                ])
            ],
            onBlur: _ctx.handleBlur,
            onFocus: _ctx.handleFocus,
            onInput: _ctx.handleInput,
            onChange: _ctx.handleInputChange
        }, null, 8, [
            "step",
            "model-value",
            "placeholder",
            "disabled",
            "size",
            "max",
            "min",
            "name",
            "label",
            "onKeydown",
            "onBlur",
            "onFocus",
            "onInput",
            "onChange"
        ])
    ], 34);
}
var InputNumber = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../icon/index.mjs":"hnNTG","../../../directives/index.mjs":"aRbJ2","../../../hooks/index.mjs":"1Ansp","../../input/index.mjs":"18eQI","../../../utils/index.mjs":"dsdeP","@element-plus/icons-vue":"b18uu","./input-number.mjs":"hcBfX","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../directives/repeat-click/index.mjs":"3krgJ","../../../hooks/use-form-item/index.mjs":"jSs21","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/error.mjs":"2zPBN","../../../hooks/use-common-props/index.mjs":"05czU","@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hcBfX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "inputNumberEmits", ()=>inputNumberEmits
);
parcelHelpers.export(exports, "inputNumberProps", ()=>inputNumberProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _sizeMjs = require("../../../constants/size.mjs");
var _core = require("@vueuse/core");
const inputNumberProps = _propsMjs.buildProps({
    step: {
        type: Number,
        default: 1
    },
    stepStrictly: {
        type: Boolean,
        default: false
    },
    max: {
        type: Number,
        default: Infinity
    },
    min: {
        type: Number,
        default: -Infinity
    },
    modelValue: {
        type: Number
    },
    disabled: {
        type: Boolean,
        default: false
    },
    size: {
        type: String,
        values: _sizeMjs.componentSizes
    },
    controls: {
        type: Boolean,
        default: true
    },
    controlsPosition: {
        type: String,
        default: "",
        values: [
            "",
            "right"
        ]
    },
    name: String,
    label: String,
    placeholder: String,
    precision: {
        type: Number,
        validator: (val)=>val >= 0 && val === parseInt(`${val}`, 10)
    }
});
const inputNumberEmits = {
    change: (prev, cur)=>prev !== cur
    ,
    blur: (e)=>e instanceof FocusEvent
    ,
    focus: (e)=>e instanceof FocusEvent
    ,
    input: (val)=>_core.isNumber(val)
    ,
    "update:modelValue": (val)=>_core.isNumber(val) || val === void 0
};

},{"../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../../utils/vue/props.mjs":"cpwWK","../../../constants/size.mjs":"jelXi","@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"18DrN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "linkEmits", ()=>_linkMjs.linkEmits
);
parcelHelpers.export(exports, "linkProps", ()=>_linkMjs.linkProps
);
parcelHelpers.export(exports, "ElLink", ()=>ElLink
);
parcelHelpers.export(exports, "default", ()=>ElLink
);
var _indexMjs = require("../../utils/index.mjs");
var _link2Mjs = require("./src/link2.mjs");
var _link2MjsDefault = parcelHelpers.interopDefault(_link2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _linkMjs = require("./src/link.mjs");
const ElLink = _installMjs.withInstall(_link2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/link2.mjs":"61aP3","../../utils/vue/install.mjs":"4TMmv","./src/link.mjs":"cyxqy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"61aP3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Link
);
var _vue = require("vue");
var _indexMjs = require("../../icon/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _linkMjs = require("./link.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElLink",
    components: {
        ElIcon: _indexMjs.ElIcon
    },
    props: _linkMjs.linkProps,
    emits: _linkMjs.linkEmits,
    setup (props, { emit  }) {
        const ns = _indexMjs2.useNamespace("link");
        function handleClick(event) {
            if (!props.disabled) emit("click", event);
        }
        return {
            ns,
            handleClick
        };
    }
});
const _hoisted_1 = [
    "href"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    return _vue.openBlock(), _vue.createElementBlock("a", {
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.type ? _ctx.ns.m(_ctx.type) : "",
            _ctx.ns.is("disabled", _ctx.disabled),
            _ctx.ns.is("underline", _ctx.underline && !_ctx.disabled)
        ]),
        href: _ctx.disabled || !_ctx.href ? void 0 : _ctx.href,
        onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleClick && _ctx.handleClick(...args)
        )
    }, [
        _ctx.icon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
            key: 0
        }, {
            default: _vue.withCtx(()=>[
                    (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.icon)))
                ]
            ),
            _: 1
        })) : _vue.createCommentVNode("v-if", true),
        _ctx.$slots.default ? (_vue.openBlock(), _vue.createElementBlock("span", {
            key: 1,
            class: _vue.normalizeClass(_ctx.ns.m("inner"))
        }, [
            _vue.renderSlot(_ctx.$slots, "default")
        ], 2)) : _vue.createCommentVNode("v-if", true),
        _ctx.$slots.icon ? _vue.renderSlot(_ctx.$slots, "icon", {
            key: 2
        }) : _vue.createCommentVNode("v-if", true)
    ], 10, _hoisted_1);
}
var Link = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../icon/index.mjs":"hnNTG","../../../hooks/index.mjs":"1Ansp","./link.mjs":"cyxqy","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cyxqy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "linkEmits", ()=>linkEmits
);
parcelHelpers.export(exports, "linkProps", ()=>linkProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
const linkProps = _propsMjs.buildProps({
    type: {
        type: String,
        values: [
            "primary",
            "success",
            "warning",
            "info",
            "danger",
            "default"
        ],
        default: "default"
    },
    underline: {
        type: Boolean,
        default: true
    },
    disabled: {
        type: Boolean,
        default: false
    },
    href: {
        type: String,
        default: ""
    },
    icon: {
        type: _iconMjs.iconPropType,
        default: ""
    }
});
const linkEmits = {
    click: (evt)=>evt instanceof MouseEvent
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","../../../utils/vue/icon.mjs":"3YbE5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5wfdz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "menuEmits", ()=>_menuMjs.menuEmits
);
parcelHelpers.export(exports, "menuProps", ()=>_menuMjs.menuProps
);
parcelHelpers.export(exports, "subMenuProps", ()=>_subMenuMjs.subMenuProps
);
parcelHelpers.export(exports, "menuItemEmits", ()=>_menuItemMjs.menuItemEmits
);
parcelHelpers.export(exports, "menuItemProps", ()=>_menuItemMjs.menuItemProps
);
parcelHelpers.export(exports, "menuItemGroupProps", ()=>_menuItemGroupMjs.menuItemGroupProps
);
parcelHelpers.export(exports, "ElMenu", ()=>ElMenu
);
parcelHelpers.export(exports, "ElMenuItem", ()=>ElMenuItem
);
parcelHelpers.export(exports, "ElMenuItemGroup", ()=>ElMenuItemGroup
);
parcelHelpers.export(exports, "ElSubMenu", ()=>ElSubMenu
);
parcelHelpers.export(exports, "default", ()=>ElMenu
);
var _indexMjs = require("../../utils/index.mjs");
var _menuMjs = require("./src/menu.mjs");
var _menuMjsDefault = parcelHelpers.interopDefault(_menuMjs);
var _menuItem2Mjs = require("./src/menu-item2.mjs");
var _menuItem2MjsDefault = parcelHelpers.interopDefault(_menuItem2Mjs);
var _menuItemGroup2Mjs = require("./src/menu-item-group2.mjs");
var _menuItemGroup2MjsDefault = parcelHelpers.interopDefault(_menuItemGroup2Mjs);
var _subMenuMjs = require("./src/sub-menu.mjs");
var _subMenuMjsDefault = parcelHelpers.interopDefault(_subMenuMjs);
var _typesMjs = require("./src/types.mjs");
var _installMjs = require("../../utils/vue/install.mjs");
var _menuItemMjs = require("./src/menu-item.mjs");
var _menuItemGroupMjs = require("./src/menu-item-group.mjs");
const ElMenu = _installMjs.withInstall(_menuMjsDefault.default, {
    MenuItem: _menuItem2MjsDefault.default,
    MenuItemGroup: _menuItemGroup2MjsDefault.default,
    SubMenu: _subMenuMjsDefault.default
});
const ElMenuItem = _installMjs.withNoopInstall(_menuItem2MjsDefault.default);
const ElMenuItemGroup = _installMjs.withNoopInstall(_menuItemGroup2MjsDefault.default);
const ElSubMenu = _installMjs.withNoopInstall(_subMenuMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/menu.mjs":"5fjO6","./src/menu-item2.mjs":"d4RO0","./src/menu-item-group2.mjs":"dIIqq","./src/sub-menu.mjs":"d2lRI","./src/types.mjs":"cgc0G","../../utils/vue/install.mjs":"4TMmv","./src/menu-item.mjs":"5FnwZ","./src/menu-item-group.mjs":"foLPD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5fjO6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Menu
);
parcelHelpers.export(exports, "menuEmits", ()=>menuEmits
);
parcelHelpers.export(exports, "menuProps", ()=>menuProps
);
var _vue = require("vue");
var _indexMjs = require("../../../directives/index.mjs");
var _indexMjs1 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs2 = require("../../../utils/index.mjs");
var _menuBarMjs = require("./utils/menu-bar.mjs");
var _menuBarMjsDefault = parcelHelpers.interopDefault(_menuBarMjs);
var _menuCollapseTransitionMjs = require("./menu-collapse-transition.mjs");
var _menuCollapseTransitionMjsDefault = parcelHelpers.interopDefault(_menuCollapseTransitionMjs);
var _subMenuMjs = require("./sub-menu.mjs");
var _subMenuMjsDefault = parcelHelpers.interopDefault(_subMenuMjs);
var _useMenuCssVarMjs = require("./use-menu-css-var.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _typescriptMjs = require("../../../utils/typescript.mjs");
var _shared = require("@vue/shared");
var _indexMjs3 = require("../../../directives/resize/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs3);
const menuProps = _propsMjs.buildProps({
    mode: {
        type: String,
        values: [
            "horizontal",
            "vertical"
        ],
        default: "vertical"
    },
    defaultActive: {
        type: String,
        default: ""
    },
    defaultOpeneds: {
        type: _propsMjs.definePropType(Array),
        default: ()=>_typescriptMjs.mutable([])
    },
    uniqueOpened: Boolean,
    router: Boolean,
    menuTrigger: {
        type: String,
        values: [
            "hover",
            "click"
        ],
        default: "hover"
    },
    collapse: Boolean,
    backgroundColor: String,
    textColor: String,
    activeTextColor: String,
    collapseTransition: {
        type: Boolean,
        default: true
    },
    ellipsis: {
        type: Boolean,
        default: true
    }
});
const checkIndexPath = (indexPath)=>Array.isArray(indexPath) && indexPath.every((path)=>_shared.isString(path)
    )
;
const menuEmits = {
    close: (index, indexPath)=>_shared.isString(index) && checkIndexPath(indexPath)
    ,
    open: (index, indexPath)=>_shared.isString(index) && checkIndexPath(indexPath)
    ,
    select: (index, indexPath, item, routerResult)=>_shared.isString(index) && checkIndexPath(indexPath) && _shared.isObject(item) && (routerResult === void 0 || routerResult instanceof Promise)
};
var Menu = _vue.defineComponent({
    name: "ElMenu",
    props: menuProps,
    emits: menuEmits,
    setup (props, { emit , slots , expose  }) {
        const instance = _vue.getCurrentInstance();
        const router = instance.appContext.config.globalProperties.$router;
        const menu = _vue.ref();
        const openedMenus = _vue.ref(props.defaultOpeneds && !props.collapse ? props.defaultOpeneds.slice(0) : []);
        const activeIndex = _vue.ref(props.defaultActive);
        const items = _vue.ref({
        });
        const subMenus = _vue.ref({
        });
        const isMenuPopup = _vue.computed(()=>{
            return props.mode === "horizontal" || props.mode === "vertical" && props.collapse;
        });
        const initMenu = ()=>{
            const activeItem = activeIndex.value && items.value[activeIndex.value];
            if (!activeItem || props.mode === "horizontal" || props.collapse) return;
            const indexPath = activeItem.indexPath;
            indexPath.forEach((index)=>{
                const subMenu = subMenus.value[index];
                subMenu && openMenu(index, subMenu.indexPath);
            });
        };
        const openMenu = (index, indexPath)=>{
            if (openedMenus.value.includes(index)) return;
            if (props.uniqueOpened) openedMenus.value = openedMenus.value.filter((index2)=>indexPath.includes(index2)
            );
            openedMenus.value.push(index);
            emit("open", index, indexPath);
        };
        const closeMenu = (index, indexPath)=>{
            const i = openedMenus.value.indexOf(index);
            if (i !== -1) openedMenus.value.splice(i, 1);
            emit("close", index, indexPath);
        };
        const handleSubMenuClick = ({ index , indexPath  })=>{
            const isOpened = openedMenus.value.includes(index);
            if (isOpened) closeMenu(index, indexPath);
            else openMenu(index, indexPath);
        };
        const handleMenuItemClick = (menuItem)=>{
            if (props.mode === "horizontal" || props.collapse) openedMenus.value = [];
            const { index , indexPath  } = menuItem;
            if (index === void 0 || indexPath === void 0) return;
            if (props.router && router) {
                const route = menuItem.route || index;
                const routerResult = router.push(route).then((res)=>{
                    if (!res) activeIndex.value = index;
                    return res;
                });
                emit("select", index, indexPath, {
                    index,
                    indexPath,
                    route
                }, routerResult);
            } else {
                activeIndex.value = index;
                emit("select", index, indexPath, {
                    index,
                    indexPath
                });
            }
        };
        const updateActiveIndex = (val)=>{
            const itemsInData = items.value;
            const item = itemsInData[val] || activeIndex.value && itemsInData[activeIndex.value] || itemsInData[props.defaultActive];
            if (item) {
                activeIndex.value = item.index;
                initMenu();
            } else activeIndex.value = val;
        };
        const handleResize = ()=>{
            _vue.nextTick(()=>instance.proxy.$forceUpdate()
            );
        };
        _vue.watch(()=>props.defaultActive
        , (currentActive)=>{
            if (!items.value[currentActive]) activeIndex.value = "";
            updateActiveIndex(currentActive);
        });
        _vue.watch(items.value, ()=>initMenu()
        );
        _vue.watch(()=>props.collapse
        , (value)=>{
            if (value) openedMenus.value = [];
        });
        {
            const addSubMenu = (item)=>{
                subMenus.value[item.index] = item;
            };
            const removeSubMenu = (item)=>{
                delete subMenus.value[item.index];
            };
            const addMenuItem = (item)=>{
                items.value[item.index] = item;
            };
            const removeMenuItem = (item)=>{
                delete items.value[item.index];
            };
            _vue.provide("rootMenu", _vue.reactive({
                props,
                openedMenus,
                items,
                subMenus,
                activeIndex,
                isMenuPopup,
                addMenuItem,
                removeMenuItem,
                addSubMenu,
                removeSubMenu,
                openMenu,
                closeMenu,
                handleMenuItemClick,
                handleSubMenuClick
            }));
            _vue.provide(`subMenu:${instance.uid}`, {
                addSubMenu,
                removeSubMenu,
                mouseInChild: _vue.ref(false)
            });
        }
        _vue.onMounted(()=>{
            initMenu();
            if (props.mode === "horizontal") new _menuBarMjsDefault.default(instance.vnode.el);
        });
        {
            const open = (index)=>{
                const { indexPath  } = subMenus.value[index];
                indexPath.forEach((i)=>openMenu(i, indexPath)
                );
            };
            expose({
                open,
                close: closeMenu,
                handleResize
            });
        }
        const flattedChildren = (children)=>{
            const vnodes = Array.isArray(children) ? children : [
                children
            ];
            const result = [];
            vnodes.forEach((child)=>{
                if (Array.isArray(child.children)) result.push(...flattedChildren(child.children));
                else result.push(child);
            });
            return result;
        };
        const useVNodeResize = (vnode)=>props.mode === "horizontal" ? _vue.withDirectives(vnode, [
                [
                    _indexMjsDefault.default,
                    handleResize
                ]
            ]) : vnode
        ;
        return ()=>{
            var _a, _b, _c, _d;
            let slot = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [];
            const vShowMore = [];
            if (props.mode === "horizontal" && menu.value) {
                const items2 = Array.from((_d = (_c = menu.value) == null ? void 0 : _c.childNodes) != null ? _d : []).filter((item)=>item.nodeName !== "#text" || item.nodeValue
                );
                const originalSlot = flattedChildren(slot);
                const moreItemWidth = 64;
                const paddingLeft = parseInt(getComputedStyle(menu.value).paddingLeft, 10);
                const paddingRight = parseInt(getComputedStyle(menu.value).paddingRight, 10);
                const menuWidth = menu.value.clientWidth - paddingLeft - paddingRight;
                let calcWidth = 0;
                let sliceIndex = 0;
                items2.forEach((item, index)=>{
                    calcWidth += item.offsetWidth || 0;
                    if (calcWidth <= menuWidth - moreItemWidth) sliceIndex = index + 1;
                });
                const slotDefault = originalSlot.slice(0, sliceIndex);
                const slotMore = originalSlot.slice(sliceIndex);
                if ((slotMore == null ? void 0 : slotMore.length) && props.ellipsis) {
                    slot = slotDefault;
                    vShowMore.push(_vue.h(_subMenuMjsDefault.default, {
                        index: "sub-menu-more",
                        class: "el-sub-menu__hide-arrow"
                    }, {
                        title: ()=>_vue.h(_indexMjs1.ElIcon, {
                                class: [
                                    "el-sub-menu__icon-more"
                                ]
                            }, {
                                default: ()=>_vue.h(_iconsVue.More)
                            })
                        ,
                        default: ()=>slotMore
                    }));
                }
            }
            const ulStyle = _useMenuCssVarMjs.useMenuCssVar(props);
            const resizeMenu = (vNode)=>props.ellipsis ? useVNodeResize(vNode) : vNode
            ;
            const vMenu = resizeMenu(_vue.h("ul", {
                key: String(props.collapse),
                role: "menubar",
                ref: menu,
                style: ulStyle.value,
                class: {
                    "el-menu": true,
                    "el-menu--horizontal": props.mode === "horizontal",
                    "el-menu--collapse": props.collapse
                }
            }, [
                ...slot.map((vnode)=>resizeMenu(vnode)
                ),
                ...vShowMore
            ]));
            if (props.collapseTransition && props.mode === "vertical") return _vue.h(_menuCollapseTransitionMjsDefault.default, ()=>vMenu
            );
            return vMenu;
        };
    }
});

},{"vue":"gzxs9","../../../directives/index.mjs":"aRbJ2","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../utils/index.mjs":"dsdeP","./utils/menu-bar.mjs":"bYpNo","./menu-collapse-transition.mjs":"cxbYs","./sub-menu.mjs":"d2lRI","./use-menu-css-var.mjs":"lrS7d","../../../utils/vue/props.mjs":"cpwWK","../../../utils/typescript.mjs":"bRl53","@vue/shared":"3SM3y","../../../directives/resize/index.mjs":"dLlY9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bYpNo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Menu
);
var _menuItemMjs = require("./menu-item.mjs");
var _menuItemMjsDefault = parcelHelpers.interopDefault(_menuItemMjs);
class Menu {
    constructor(domNode){
        this.domNode = domNode;
        this.init();
    }
    init() {
        const menuChildren = this.domNode.childNodes;
        Array.from(menuChildren, (child)=>{
            if (child.nodeType === 1) new _menuItemMjsDefault.default(child);
        });
    }
}

},{"./menu-item.mjs":"jHVfa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jHVfa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>MenuItem
);
var _indexMjs = require("../../../../utils/index.mjs");
var _indexMjs1 = require("../../../../constants/index.mjs");
var _submenuMjs = require("./submenu.mjs");
var _submenuMjsDefault = parcelHelpers.interopDefault(_submenuMjs);
var _ariaMjs = require("../../../../constants/aria.mjs");
var _ariaMjs1 = require("../../../../utils/dom/aria.mjs");
class MenuItem {
    constructor(domNode){
        this.domNode = domNode;
        this.submenu = null;
        this.submenu = null;
        this.init();
    }
    init() {
        this.domNode.setAttribute("tabindex", "0");
        const menuChild = this.domNode.querySelector(".el-menu");
        if (menuChild) this.submenu = new _submenuMjsDefault.default(this, menuChild);
        this.addListeners();
    }
    addListeners() {
        this.domNode.addEventListener("keydown", (event)=>{
            let prevDef = false;
            switch(event.code){
                case _ariaMjs.EVENT_CODE.down:
                    _ariaMjs1.triggerEvent(event.currentTarget, "mouseenter");
                    this.submenu && this.submenu.gotoSubIndex(0);
                    prevDef = true;
                    break;
                case _ariaMjs.EVENT_CODE.up:
                    _ariaMjs1.triggerEvent(event.currentTarget, "mouseenter");
                    this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
                    prevDef = true;
                    break;
                case _ariaMjs.EVENT_CODE.tab:
                    _ariaMjs1.triggerEvent(event.currentTarget, "mouseleave");
                    break;
                case _ariaMjs.EVENT_CODE.enter:
                case _ariaMjs.EVENT_CODE.space:
                    prevDef = true;
                    event.currentTarget.click();
                    break;
            }
            if (prevDef) event.preventDefault();
        });
    }
}

},{"../../../../utils/index.mjs":"dsdeP","../../../../constants/index.mjs":"74Fbn","./submenu.mjs":"6cTXb","../../../../constants/aria.mjs":"jS6iK","../../../../utils/dom/aria.mjs":"6roYP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6cTXb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>SubMenu
);
var _indexMjs = require("../../../../utils/index.mjs");
var _indexMjs1 = require("../../../../constants/index.mjs");
var _ariaMjs = require("../../../../constants/aria.mjs");
var _ariaMjs1 = require("../../../../utils/dom/aria.mjs");
class SubMenu {
    constructor(parent, domNode){
        this.parent = parent;
        this.domNode = domNode;
        this.subIndex = 0;
        this.subIndex = 0;
        this.init();
    }
    init() {
        this.subMenuItems = this.domNode.querySelectorAll("li");
        this.addListeners();
    }
    gotoSubIndex(idx) {
        if (idx === this.subMenuItems.length) idx = 0;
        else if (idx < 0) idx = this.subMenuItems.length - 1;
        this.subMenuItems[idx].focus();
        this.subIndex = idx;
    }
    addListeners() {
        const parentNode = this.parent.domNode;
        Array.prototype.forEach.call(this.subMenuItems, (el)=>{
            el.addEventListener("keydown", (event)=>{
                let prevDef = false;
                switch(event.code){
                    case _ariaMjs.EVENT_CODE.down:
                        this.gotoSubIndex(this.subIndex + 1);
                        prevDef = true;
                        break;
                    case _ariaMjs.EVENT_CODE.up:
                        this.gotoSubIndex(this.subIndex - 1);
                        prevDef = true;
                        break;
                    case _ariaMjs.EVENT_CODE.tab:
                        _ariaMjs1.triggerEvent(parentNode, "mouseleave");
                        break;
                    case _ariaMjs.EVENT_CODE.enter:
                    case _ariaMjs.EVENT_CODE.space:
                        prevDef = true;
                        event.currentTarget.click();
                        break;
                }
                if (prevDef) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                return false;
            });
        });
    }
}

},{"../../../../utils/index.mjs":"dsdeP","../../../../constants/index.mjs":"74Fbn","../../../../constants/aria.mjs":"jS6iK","../../../../utils/dom/aria.mjs":"6roYP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cxbYs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElMenuCollapseTransition
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _styleMjs = require("../../../utils/dom/style.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElMenuCollapseTransition",
    setup () {
        const listeners = {
            onBeforeEnter: (el)=>el.style.opacity = "0.2"
            ,
            onEnter (el, done) {
                _styleMjs.addClass(el, "el-opacity-transition");
                el.style.opacity = "1";
                done();
            },
            onAfterEnter (el) {
                _styleMjs.removeClass(el, "el-opacity-transition");
                el.style.opacity = "";
            },
            onBeforeLeave (el) {
                if (!el.dataset) el.dataset = {
                };
                if (_styleMjs.hasClass(el, "el-menu--collapse")) {
                    _styleMjs.removeClass(el, "el-menu--collapse");
                    el.dataset.oldOverflow = el.style.overflow;
                    el.dataset.scrollWidth = el.clientWidth.toString();
                    _styleMjs.addClass(el, "el-menu--collapse");
                } else {
                    _styleMjs.addClass(el, "el-menu--collapse");
                    el.dataset.oldOverflow = el.style.overflow;
                    el.dataset.scrollWidth = el.clientWidth.toString();
                    _styleMjs.removeClass(el, "el-menu--collapse");
                }
                el.style.width = `${el.scrollWidth}px`;
                el.style.overflow = "hidden";
            },
            onLeave (el) {
                _styleMjs.addClass(el, "horizontal-collapse-transition");
                el.style.width = `${el.dataset.scrollWidth}px`;
            }
        };
        return {
            listeners
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createBlock(_vue.Transition, _vue.mergeProps({
        mode: "out-in"
    }, _ctx.listeners), {
        default: _vue.withCtx(()=>[
                _vue.renderSlot(_ctx.$slots, "default")
            ]
        ),
        _: 3
    }, 16);
}
var ElMenuCollapseTransition = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/dom/style.mjs":"cA8Mp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d2lRI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>SubMenu
);
parcelHelpers.export(exports, "subMenuProps", ()=>subMenuProps
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../collapse-transition/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _indexMjs1 = require("../../tooltip/index.mjs");
var _indexMjs2 = require("../../../utils/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs3 = require("../../icon/index.mjs");
var _useMenuMjs = require("./use-menu.mjs");
var _useMenuMjsDefault = parcelHelpers.interopDefault(_useMenuMjs);
var _useMenuCssVarMjs = require("./use-menu-css-var.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const subMenuProps = _propsMjs.buildProps({
    index: {
        type: String,
        required: true
    },
    showTimeout: {
        type: Number,
        default: 300
    },
    hideTimeout: {
        type: Number,
        default: 300
    },
    popperClass: String,
    disabled: Boolean,
    popperAppendToBody: {
        type: Boolean,
        default: void 0
    }
});
const COMPONENT_NAME = "ElSubMenu";
var SubMenu = _vue.defineComponent({
    name: COMPONENT_NAME,
    props: subMenuProps,
    setup (props, { slots , expose  }) {
        const instance = _vue.getCurrentInstance();
        const { paddingStyle , indexPath , parentMenu  } = _useMenuMjsDefault.default(instance, _vue.computed(()=>props.index
        ));
        const rootMenu = _vue.inject("rootMenu");
        if (!rootMenu) _errorMjs.throwError(COMPONENT_NAME, "can not inject root menu");
        const subMenu = _vue.inject(`subMenu:${parentMenu.value.uid}`);
        if (!subMenu) _errorMjs.throwError(COMPONENT_NAME, "can not inject sub menu");
        const items = _vue.ref({
        });
        const subMenus = _vue.ref({
        });
        let timeout;
        const mouseInChild = _vue.ref(false);
        const verticalTitleRef = _vue.ref();
        const vPopper = _vue.ref(null);
        const currentPlacement = _vue.computed(()=>mode.value === "horizontal" && isFirstLevel.value ? "bottom-start" : "right-start"
        );
        const subMenuTitleIcon = _vue.computed(()=>{
            return mode.value === "horizontal" && isFirstLevel.value || mode.value === "vertical" && !rootMenu.props.collapse ? _iconsVue.ArrowDown : _iconsVue.ArrowRight;
        });
        const isFirstLevel = _vue.computed(()=>{
            let isFirstLevel2 = true;
            let parent = instance.parent;
            while(parent && parent.type.name !== "ElMenu")if ([
                "ElSubMenu",
                "ElMenuItemGroup"
            ].includes(parent.type.name)) {
                isFirstLevel2 = false;
                break;
            } else parent = parent.parent;
            return isFirstLevel2;
        });
        const appendToBody = _vue.computed(()=>{
            return props.popperAppendToBody === void 0 ? isFirstLevel.value : Boolean(props.popperAppendToBody);
        });
        const menuTransitionName = _vue.computed(()=>rootMenu.props.collapse ? "el-zoom-in-left" : "el-zoom-in-top"
        );
        const fallbackPlacements = _vue.computed(()=>mode.value === "horizontal" && isFirstLevel.value ? [
                "bottom-start",
                "bottom-end",
                "top-start",
                "top-end",
                "right-start",
                "left-start"
            ] : [
                "right-start",
                "left-start",
                "bottom-start",
                "bottom-end",
                "top-start",
                "top-end"
            ]
        );
        const opened = _vue.computed(()=>rootMenu.openedMenus.includes(props.index)
        );
        const active = _vue.computed(()=>{
            let isActive = false;
            Object.values(items.value).forEach((item2)=>{
                if (item2.active) isActive = true;
            });
            Object.values(subMenus.value).forEach((subItem)=>{
                if (subItem.active) isActive = true;
            });
            return isActive;
        });
        const backgroundColor = _vue.computed(()=>rootMenu.props.backgroundColor || ""
        );
        const activeTextColor = _vue.computed(()=>rootMenu.props.activeTextColor || ""
        );
        const textColor = _vue.computed(()=>rootMenu.props.textColor || ""
        );
        const mode = _vue.computed(()=>rootMenu.props.mode
        );
        const item = _vue.reactive({
            index: props.index,
            indexPath,
            active
        });
        const titleStyle = _vue.computed(()=>{
            if (mode.value !== "horizontal") return {
                color: textColor.value
            };
            return {
                borderBottomColor: active.value ? rootMenu.props.activeTextColor ? activeTextColor.value : "" : "transparent",
                color: active.value ? activeTextColor.value : textColor.value
            };
        });
        const doDestroy = ()=>{
            var _a, _b, _c;
            return (_c = (_b = (_a = vPopper.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.popperInstanceRef) == null ? void 0 : _c.destroy();
        };
        const handleCollapseToggle = (value)=>{
            if (!value) doDestroy();
        };
        const handleClick = ()=>{
            if (rootMenu.props.menuTrigger === "hover" && rootMenu.props.mode === "horizontal" || rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled) return;
            rootMenu.handleSubMenuClick({
                index: props.index,
                indexPath: indexPath.value,
                active: active.value
            });
        };
        const handleMouseenter = (event, showTimeout = props.showTimeout)=>{
            var _a;
            if (event.type === "focus" && !event.relatedTarget) return;
            if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled) return;
            subMenu.mouseInChild.value = true;
            timeout == null || timeout();
            ({ stop: timeout  } = _core.useTimeoutFn(()=>{
                rootMenu.openMenu(props.index, indexPath.value);
            }, showTimeout));
            if (appendToBody.value) (_a = parentMenu.value.vnode.el) == null || _a.dispatchEvent(new MouseEvent("mouseenter"));
        };
        const handleMouseleave = (deepDispatch = false)=>{
            var _a, _b;
            if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical") return;
            timeout == null || timeout();
            subMenu.mouseInChild.value = false;
            ({ stop: timeout  } = _core.useTimeoutFn(()=>!mouseInChild.value && rootMenu.closeMenu(props.index, indexPath.value)
            , props.hideTimeout));
            if (appendToBody.value && deepDispatch) {
                if (((_a = instance.parent) == null ? void 0 : _a.type.name) === "ElSubMenu") (_b = subMenu.handleMouseleave) == null || _b.call(subMenu, true);
            }
        };
        _vue.watch(()=>rootMenu.props.collapse
        , (value)=>handleCollapseToggle(Boolean(value))
        );
        {
            const addSubMenu = (item2)=>{
                subMenus.value[item2.index] = item2;
            };
            const removeSubMenu = (item2)=>{
                delete subMenus.value[item2.index];
            };
            _vue.provide(`subMenu:${instance.uid}`, {
                addSubMenu,
                removeSubMenu,
                handleMouseleave,
                mouseInChild
            });
        }
        expose({
            opened
        });
        _vue.onMounted(()=>{
            rootMenu.addSubMenu(item);
            subMenu.addSubMenu(item);
        });
        _vue.onBeforeUnmount(()=>{
            subMenu.removeSubMenu(item);
            rootMenu.removeSubMenu(item);
        });
        return ()=>{
            var _a;
            const titleTag = [
                (_a = slots.title) == null ? void 0 : _a.call(slots),
                _vue.h(_indexMjs3.ElIcon, {
                    class: [
                        "el-sub-menu__icon-arrow"
                    ]
                }, {
                    default: ()=>_vue.h(subMenuTitleIcon.value)
                })
            ];
            const ulStyle = _useMenuCssVarMjs.useMenuCssVar(rootMenu.props);
            const child = rootMenu.isMenuPopup ? _vue.h(_indexMjs1.ElTooltip, {
                ref: vPopper,
                visible: opened.value,
                effect: "light",
                pure: true,
                offset: 6,
                showArrow: false,
                persistent: true,
                popperClass: props.popperClass,
                placement: currentPlacement.value,
                teleported: appendToBody.value,
                fallbackPlacements: fallbackPlacements.value,
                transition: menuTransitionName.value,
                gpuAcceleration: false
            }, {
                content: ()=>{
                    var _a2;
                    return _vue.h("div", {
                        class: [
                            `el-menu--${mode.value}`,
                            props.popperClass
                        ],
                        onMouseenter: (evt)=>handleMouseenter(evt, 100)
                        ,
                        onMouseleave: ()=>handleMouseleave(true)
                        ,
                        onFocus: (evt)=>handleMouseenter(evt, 100)
                    }, [
                        _vue.h("ul", {
                            class: [
                                "el-menu el-menu--popup",
                                `el-menu--popup-${currentPlacement.value}`
                            ],
                            style: ulStyle.value
                        }, [
                            (_a2 = slots.default) == null ? void 0 : _a2.call(slots)
                        ])
                    ]);
                },
                default: ()=>_vue.h("div", {
                        class: "el-sub-menu__title",
                        style: [
                            paddingStyle.value,
                            titleStyle.value,
                            {
                                backgroundColor: backgroundColor.value
                            }
                        ],
                        onClick: handleClick
                    }, titleTag)
            }) : _vue.h(_vue.Fragment, {
            }, [
                _vue.h("div", {
                    class: "el-sub-menu__title",
                    style: [
                        paddingStyle.value,
                        titleStyle.value,
                        {
                            backgroundColor: backgroundColor.value
                        }
                    ],
                    ref: verticalTitleRef,
                    onClick: handleClick
                }, titleTag),
                _vue.h(_indexMjsDefault.default, {
                }, {
                    default: ()=>{
                        var _a2;
                        return _vue.withDirectives(_vue.h("ul", {
                            role: "menu",
                            class: "el-menu el-menu--inline",
                            style: ulStyle.value
                        }, [
                            (_a2 = slots.default) == null ? void 0 : _a2.call(slots)
                        ]), [
                            [
                                _vue.vShow,
                                opened.value
                            ]
                        ]);
                    }
                })
            ]);
            return _vue.h("li", {
                class: [
                    "el-sub-menu",
                    {
                        "is-active": active.value,
                        "is-opened": opened.value,
                        "is-disabled": props.disabled
                    }
                ],
                role: "menuitem",
                ariaHaspopup: true,
                ariaExpanded: opened.value,
                onMouseenter: handleMouseenter,
                onMouseleave: ()=>handleMouseleave(true)
                ,
                onFocus: handleMouseenter
            }, [
                child
            ]);
        };
    }
});

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../collapse-transition/index.mjs":"kOsra","../../tooltip/index.mjs":"kiwBC","../../../utils/index.mjs":"dsdeP","@element-plus/icons-vue":"b18uu","../../icon/index.mjs":"hnNTG","./use-menu.mjs":"ffifR","./use-menu-css-var.mjs":"lrS7d","../../../utils/vue/props.mjs":"cpwWK","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ffifR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useMenu
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _errorMjs = require("../../../utils/error.mjs");
function useMenu(instance, currentIndex) {
    const rootMenu = _vue.inject("rootMenu");
    if (!rootMenu) _errorMjs.throwError("useMenu", "can not inject root menu");
    const indexPath = _vue.computed(()=>{
        let parent = instance.parent;
        const path = [
            currentIndex.value
        ];
        while(parent.type.name !== "ElMenu"){
            if (parent.props.index) path.unshift(parent.props.index);
            parent = parent.parent;
        }
        return path;
    });
    const parentMenu = _vue.computed(()=>{
        let parent = instance.parent;
        while(parent && ![
            "ElMenu",
            "ElSubMenu"
        ].includes(parent.type.name))parent = parent.parent;
        return parent;
    });
    const paddingStyle = _vue.computed(()=>{
        let parent = instance.parent;
        if (rootMenu.props.mode !== "vertical") return {
        };
        let padding = 20;
        if (rootMenu.props.collapse) padding = 20;
        else while(parent && parent.type.name !== "ElMenu"){
            if (parent.type.name === "ElSubMenu") padding += 20;
            parent = parent.parent;
        }
        return {
            paddingLeft: `${padding}px`
        };
    });
    return {
        parentMenu,
        paddingStyle,
        indexPath
    };
}

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lrS7d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useMenuCssVar", ()=>useMenuCssVar
);
var _vue = require("vue");
var _useMenuColorMjs = require("./use-menu-color.mjs");
var _useMenuColorMjsDefault = parcelHelpers.interopDefault(_useMenuColorMjs);
const useMenuCssVar = (props)=>{
    return _vue.computed(()=>{
        return {
            "--el-menu-text-color": props.textColor || "",
            "--el-menu-hover-text-color": props.textColor || "",
            "--el-menu-bg-color": props.backgroundColor || "",
            "--el-menu-hover-bg-color": _useMenuColorMjsDefault.default(props).value || "",
            "--el-menu-active-color": props.activeTextColor || ""
        };
    });
};

},{"vue":"gzxs9","./use-menu-color.mjs":"dLVPB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dLVPB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useMenuColor
);
var _vue = require("vue");
var _tinycolor = require("@ctrl/tinycolor");
function useMenuColor(props) {
    const menuBarColor = _vue.computed(()=>{
        const color = props.backgroundColor;
        if (!color) return "";
        else return new _tinycolor.TinyColor(color).shade(20).toString();
    });
    return menuBarColor;
}

},{"vue":"gzxs9","@ctrl/tinycolor":"e1DHG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d4RO0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>MenuItem
);
var _vue = require("vue");
var _indexMjs = require("../../tooltip/index.mjs");
var _indexMjs1 = require("../../popper/index.mjs");
var _indexMjs2 = require("../../../utils/index.mjs");
var _useMenuMjs = require("./use-menu.mjs");
var _useMenuMjsDefault = parcelHelpers.interopDefault(_useMenuMjs);
var _menuItemMjs = require("./menu-item.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _errorMjs = require("../../../utils/error.mjs");
var _popperMjs = require("../../popper/src/popper.mjs");
const COMPONENT_NAME = "ElMenuItem";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    components: {
        ElTooltip: _indexMjs.ElTooltip
    },
    props: _menuItemMjs.menuItemProps,
    emits: _menuItemMjs.menuItemEmits,
    setup (props, { emit  }) {
        const instance = _vue.getCurrentInstance();
        const rootMenu = _vue.inject("rootMenu");
        if (!rootMenu) _errorMjs.throwError(COMPONENT_NAME, "can not inject root menu");
        const { parentMenu , paddingStyle , indexPath  } = _useMenuMjsDefault.default(instance, _vue.toRef(props, "index"));
        const subMenu = _vue.inject(`subMenu:${parentMenu.value.uid}`);
        if (!subMenu) _errorMjs.throwError(COMPONENT_NAME, "can not inject sub menu");
        const active = _vue.computed(()=>props.index === rootMenu.activeIndex
        );
        const item = _vue.reactive({
            index: props.index,
            indexPath,
            active
        });
        const handleClick = ()=>{
            if (!props.disabled) {
                rootMenu.handleMenuItemClick({
                    index: props.index,
                    indexPath: indexPath.value,
                    route: props.route
                });
                emit("click", item);
            }
        };
        _vue.onMounted(()=>{
            subMenu.addSubMenu(item);
            rootMenu.addMenuItem(item);
        });
        _vue.onBeforeUnmount(()=>{
            subMenu.removeSubMenu(item);
            rootMenu.removeMenuItem(item);
        });
        return {
            Effect: _popperMjs.Effect,
            parentMenu,
            rootMenu,
            paddingStyle,
            active,
            handleClick
        };
    }
});
const _hoisted_1 = {
    style: {
        position: "absolute",
        left: 0,
        top: 0,
        height: "100%",
        width: "100%",
        display: "inline-block",
        boxSizing: "border-box",
        padding: "0 20px"
    }
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_tooltip = _vue.resolveComponent("el-tooltip");
    return _vue.openBlock(), _vue.createElementBlock("li", {
        class: _vue.normalizeClass([
            "el-menu-item",
            {
                "is-active": _ctx.active,
                "is-disabled": _ctx.disabled
            }
        ]),
        role: "menuitem",
        tabindex: "-1",
        style: _vue.normalizeStyle(_ctx.paddingStyle),
        onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleClick && _ctx.handleClick(...args)
        )
    }, [
        _ctx.parentMenu.type.name === "ElMenu" && _ctx.rootMenu.props.collapse && _ctx.$slots.title ? (_vue.openBlock(), _vue.createBlock(_component_el_tooltip, {
            key: 0,
            effect: _ctx.Effect.DARK,
            placement: "right",
            persistent: ""
        }, {
            content: _vue.withCtx(()=>[
                    _vue.renderSlot(_ctx.$slots, "title")
                ]
            ),
            default: _vue.withCtx(()=>[
                    _vue.createElementVNode("div", _hoisted_1, [
                        _vue.renderSlot(_ctx.$slots, "default")
                    ])
                ]
            ),
            _: 3
        }, 8, [
            "effect"
        ])) : (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
            key: 1
        }, [
            _vue.renderSlot(_ctx.$slots, "default"),
            _vue.renderSlot(_ctx.$slots, "title")
        ], 64))
    ], 6);
}
var MenuItem = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../tooltip/index.mjs":"kiwBC","../../popper/index.mjs":"kIV7g","../../../utils/index.mjs":"dsdeP","./use-menu.mjs":"ffifR","./menu-item.mjs":"5FnwZ","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/error.mjs":"2zPBN","../../popper/src/popper.mjs":"lCFux","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5FnwZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "menuItemEmits", ()=>menuItemEmits
);
parcelHelpers.export(exports, "menuItemProps", ()=>menuItemProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _shared = require("@vue/shared");
const menuItemProps = _propsMjs.buildProps({
    index: {
        type: _propsMjs.definePropType([
            String,
            null
        ]),
        default: null
    },
    route: {
        type: _propsMjs.definePropType([
            String,
            Object
        ])
    },
    disabled: Boolean
});
const menuItemEmits = {
    click: (item)=>_shared.isString(item.index) && Array.isArray(item.indexPath)
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dIIqq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>MenuItemGroup
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _menuItemGroupMjs = require("./menu-item-group.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _errorMjs = require("../../../utils/error.mjs");
const COMPONENT_NAME = "ElMenuItemGroup";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    props: _menuItemGroupMjs.menuItemGroupProps,
    setup () {
        const instance = _vue.getCurrentInstance();
        const menu = _vue.inject("rootMenu");
        if (!menu) _errorMjs.throwError(COMPONENT_NAME, "can not inject root menu");
        const levelPadding = _vue.computed(()=>{
            if (menu.props.collapse) return 20;
            let padding = 20;
            let parent = instance.parent;
            while(parent && parent.type.name !== "ElMenu"){
                if (parent.type.name === "ElSubMenu") padding += 20;
                parent = parent.parent;
            }
            return padding;
        });
        return {
            levelPadding
        };
    }
});
const _hoisted_1 = {
    class: "el-menu-item-group"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("li", _hoisted_1, [
        _vue.createElementVNode("div", {
            class: "el-menu-item-group__title",
            style: _vue.normalizeStyle({
                paddingLeft: `${_ctx.levelPadding}px`
            })
        }, [
            !_ctx.$slots.title ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                key: 0
            }, [
                _vue.createTextVNode(_vue.toDisplayString(_ctx.title), 1)
            ], 2112)) : _vue.renderSlot(_ctx.$slots, "title", {
                key: 1
            })
        ], 4),
        _vue.createElementVNode("ul", null, [
            _vue.renderSlot(_ctx.$slots, "default")
        ])
    ]);
}
var MenuItemGroup = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","./menu-item-group.mjs":"foLPD","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"foLPD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "menuItemGroupProps", ()=>menuItemGroupProps
);
const menuItemGroupProps = {
    title: String
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cgc0G":[function(require,module,exports) {

},{}],"cmyvF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pageHeaderEmits", ()=>_pageHeaderMjs.pageHeaderEmits
);
parcelHelpers.export(exports, "pageHeaderProps", ()=>_pageHeaderMjs.pageHeaderProps
);
parcelHelpers.export(exports, "ElPageHeader", ()=>ElPageHeader
);
parcelHelpers.export(exports, "default", ()=>ElPageHeader
);
var _indexMjs = require("../../utils/index.mjs");
var _pageHeader2Mjs = require("./src/page-header2.mjs");
var _pageHeader2MjsDefault = parcelHelpers.interopDefault(_pageHeader2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _pageHeaderMjs = require("./src/page-header.mjs");
const ElPageHeader = _installMjs.withInstall(_pageHeader2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/page-header2.mjs":"2zrVN","../../utils/vue/install.mjs":"4TMmv","./src/page-header.mjs":"wnNZL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2zrVN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>PageHeader
);
var _vue = require("vue");
var _indexMjs = require("../../icon/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _pageHeaderMjs = require("./page-header.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElPageHeader",
    components: {
        ElIcon: _indexMjs.ElIcon
    },
    props: _pageHeaderMjs.pageHeaderProps,
    emits: _pageHeaderMjs.pageHeaderEmits,
    setup (_, { emit  }) {
        const { t  } = _indexMjs2.useLocale();
        const ns = _indexMjs3.useNamespace("page-header");
        function handleClick() {
            emit("back");
        }
        return {
            handleClick,
            t,
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.ns.b())
    }, [
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("left")),
            onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.handleClick && _ctx.handleClick(...args)
            )
        }, [
            _ctx.icon || _ctx.$slots.icon ? (_vue.openBlock(), _vue.createElementBlock("div", {
                key: 0,
                class: _vue.normalizeClass(_ctx.ns.e("icon"))
            }, [
                _vue.renderSlot(_ctx.$slots, "icon", {
                }, ()=>[
                        _ctx.icon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                            key: 0
                        }, {
                            default: _vue.withCtx(()=>[
                                    (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.icon)))
                                ]
                            ),
                            _: 1
                        })) : _vue.createCommentVNode("v-if", true)
                    ]
                )
            ], 2)) : _vue.createCommentVNode("v-if", true),
            _vue.createElementVNode("div", {
                class: _vue.normalizeClass(_ctx.ns.e("title"))
            }, [
                _vue.renderSlot(_ctx.$slots, "title", {
                }, ()=>[
                        _vue.createTextVNode(_vue.toDisplayString(_ctx.title || _ctx.t("el.pageHeader.title")), 1)
                    ]
                )
            ], 2)
        ], 2),
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("content"))
        }, [
            _vue.renderSlot(_ctx.$slots, "content", {
            }, ()=>[
                    _vue.createTextVNode(_vue.toDisplayString(_ctx.content), 1)
                ]
            )
        ], 2)
    ], 2);
}
var PageHeader = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../icon/index.mjs":"hnNTG","../../../hooks/index.mjs":"1Ansp","./page-header.mjs":"wnNZL","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"wnNZL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pageHeaderEmits", ()=>pageHeaderEmits
);
parcelHelpers.export(exports, "pageHeaderProps", ()=>pageHeaderProps
);
var _iconsVue = require("@element-plus/icons-vue");
const pageHeaderProps = {
    icon: {
        type: [
            String,
            Object
        ],
        default: _iconsVue.Back
    },
    title: String,
    content: {
        type: String,
        default: ""
    }
};
const pageHeaderEmits = {
    back: ()=>true
};

},{"@element-plus/icons-vue":"b18uu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ep8iT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "paginationEmits", ()=>_paginationMjs.paginationEmits
);
parcelHelpers.export(exports, "paginationProps", ()=>_paginationMjs.paginationProps
);
parcelHelpers.export(exports, "ElPagination", ()=>ElPagination
);
parcelHelpers.export(exports, "default", ()=>ElPagination
);
var _indexMjs = require("../../utils/index.mjs");
var _paginationMjs = require("./src/pagination.mjs");
var _paginationMjsDefault = parcelHelpers.interopDefault(_paginationMjs);
var _installMjs = require("../../utils/vue/install.mjs");
const ElPagination = _installMjs.withInstall(_paginationMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/pagination.mjs":"3DWdA","../../utils/vue/install.mjs":"4TMmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3DWdA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Pagination
);
parcelHelpers.export(exports, "paginationEmits", ()=>paginationEmits
);
parcelHelpers.export(exports, "paginationProps", ()=>paginationProps
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _indexMjs2 = require("../../../tokens/index.mjs");
var _prevMjs = require("./components/prev.mjs");
var _prevMjsDefault = parcelHelpers.interopDefault(_prevMjs);
var _nextMjs = require("./components/next.mjs");
var _nextMjsDefault = parcelHelpers.interopDefault(_nextMjs);
var _sizesMjs = require("./components/sizes.mjs");
var _sizesMjsDefault = parcelHelpers.interopDefault(_sizesMjs);
var _jumperMjs = require("./components/jumper.mjs");
var _jumperMjsDefault = parcelHelpers.interopDefault(_jumperMjs);
var _totalMjs = require("./components/total.mjs");
var _totalMjsDefault = parcelHelpers.interopDefault(_totalMjs);
var _pagerMjs = require("./components/pager.mjs");
var _pagerMjsDefault = parcelHelpers.interopDefault(_pagerMjs);
var _propsMjs = require("../../../utils/vue/props.mjs");
var _typescriptMjs = require("../../../utils/typescript.mjs");
var _indexMjs3 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs4 = require("../../../hooks/use-namespace/index.mjs");
var _paginationMjs = require("../../../tokens/pagination.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const isAbsent = (v)=>typeof v !== "number"
;
const paginationProps = _propsMjs.buildProps({
    total: Number,
    pageSize: Number,
    defaultPageSize: Number,
    currentPage: Number,
    defaultCurrentPage: Number,
    pageCount: Number,
    pagerCount: {
        type: Number,
        validator: (value)=>{
            return typeof value === "number" && (value | 0) === value && value > 4 && value < 22 && value % 2 === 1;
        },
        default: 7
    },
    layout: {
        type: String,
        default: [
            "prev",
            "pager",
            "next",
            "jumper",
            "->",
            "total"
        ].join(", ")
    },
    pageSizes: {
        type: _propsMjs.definePropType(Array),
        default: ()=>_typescriptMjs.mutable([
                10,
                20,
                30,
                40,
                50,
                100
            ])
    },
    popperClass: {
        type: String,
        default: ""
    },
    prevText: {
        type: String,
        default: ""
    },
    nextText: {
        type: String,
        default: ""
    },
    small: Boolean,
    background: Boolean,
    disabled: Boolean,
    hideOnSinglePage: Boolean
});
const paginationEmits = {
    "update:current-page": (val)=>typeof val === "number"
    ,
    "update:page-size": (val)=>typeof val === "number"
    ,
    "size-change": (val)=>typeof val === "number"
    ,
    "current-change": (val)=>typeof val === "number"
    ,
    "prev-click": (val)=>typeof val === "number"
    ,
    "next-click": (val)=>typeof val === "number"
};
const componentName = "ElPagination";
var Pagination = _vue.defineComponent({
    name: componentName,
    props: paginationProps,
    emits: paginationEmits,
    setup (props, { emit , slots  }) {
        const { t  } = _indexMjs3.useLocale();
        const ns = _indexMjs4.useNamespace("pagination");
        const vnodeProps = _vue.getCurrentInstance().vnode.props || {
        };
        const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
        const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
        const assertValidUsage = _vue.computed(()=>{
            if (isAbsent(props.total) && isAbsent(props.pageCount)) return false;
            if (!isAbsent(props.currentPage) && !hasCurrentPageListener) return false;
            if (props.layout.includes("sizes")) {
                if (!isAbsent(props.pageCount)) {
                    if (!hasPageSizeListener) return false;
                } else if (!isAbsent(props.total)) {
                    if (!isAbsent(props.pageSize)) {
                        if (!hasPageSizeListener) return false;
                    }
                }
            }
            return true;
        });
        const innerPageSize = _vue.ref(isAbsent(props.defaultPageSize) ? 10 : props.defaultPageSize);
        const innerCurrentPage = _vue.ref(isAbsent(props.defaultCurrentPage) ? 1 : props.defaultCurrentPage);
        const pageSizeBridge = _vue.computed({
            get () {
                return isAbsent(props.pageSize) ? innerPageSize.value : props.pageSize;
            },
            set (v) {
                if (isAbsent(props.pageSize)) innerPageSize.value = v;
                if (hasPageSizeListener) {
                    emit("update:page-size", v);
                    emit("size-change", v);
                }
            }
        });
        const pageCountBridge = _vue.computed(()=>{
            let pageCount = 0;
            if (!isAbsent(props.pageCount)) pageCount = props.pageCount;
            else if (!isAbsent(props.total)) pageCount = Math.max(1, Math.ceil(props.total / pageSizeBridge.value));
            return pageCount;
        });
        const currentPageBridge = _vue.computed({
            get () {
                return isAbsent(props.currentPage) ? innerCurrentPage.value : props.currentPage;
            },
            set (v) {
                let newCurrentPage = v;
                if (v < 1) newCurrentPage = 1;
                else if (v > pageCountBridge.value) newCurrentPage = pageCountBridge.value;
                if (isAbsent(props.currentPage)) innerCurrentPage.value = newCurrentPage;
                if (hasCurrentPageListener) {
                    emit("update:current-page", newCurrentPage);
                    emit("current-change", newCurrentPage);
                }
            }
        });
        _vue.watch(pageCountBridge, (val)=>{
            if (currentPageBridge.value > val) currentPageBridge.value = val;
        });
        function handleCurrentChange(val) {
            currentPageBridge.value = val;
        }
        function handleSizeChange(val) {
            pageSizeBridge.value = val;
            const newPageCount = pageCountBridge.value;
            if (currentPageBridge.value > newPageCount) currentPageBridge.value = newPageCount;
        }
        function prev() {
            if (props.disabled) return;
            currentPageBridge.value -= 1;
            emit("prev-click", currentPageBridge.value);
        }
        function next() {
            if (props.disabled) return;
            currentPageBridge.value += 1;
            emit("next-click", currentPageBridge.value);
        }
        function addClass(element, cls) {
            if (element) {
                if (!element.props) element.props = {
                };
                element.props.class = [
                    element.props.class,
                    cls
                ].join(" ");
            }
        }
        _vue.provide(_paginationMjs.elPaginationKey, {
            pageCount: pageCountBridge,
            disabled: _vue.computed(()=>props.disabled
            ),
            currentPage: currentPageBridge,
            changeEvent: handleCurrentChange,
            handleSizeChange
        });
        return ()=>{
            var _a, _b;
            if (!assertValidUsage.value) {
                _errorMjs.debugWarn(componentName, t("el.pagination.deprecationWarning"));
                return null;
            }
            if (!props.layout) return null;
            if (props.hideOnSinglePage && pageCountBridge.value <= 1) return null;
            const rootChildren = [];
            const rightWrapperChildren = [];
            const rightWrapperRoot = _vue.h("div", {
                class: ns.e("rightwrapper")
            }, rightWrapperChildren);
            const TEMPLATE_MAP = {
                prev: _vue.h(_prevMjsDefault.default, {
                    disabled: props.disabled,
                    currentPage: currentPageBridge.value,
                    prevText: props.prevText,
                    onClick: prev
                }),
                jumper: _vue.h(_jumperMjsDefault.default),
                pager: _vue.h(_pagerMjsDefault.default, {
                    currentPage: currentPageBridge.value,
                    pageCount: pageCountBridge.value,
                    pagerCount: props.pagerCount,
                    onChange: handleCurrentChange,
                    disabled: props.disabled
                }),
                next: _vue.h(_nextMjsDefault.default, {
                    disabled: props.disabled,
                    currentPage: currentPageBridge.value,
                    pageCount: pageCountBridge.value,
                    nextText: props.nextText,
                    onClick: next
                }),
                sizes: _vue.h(_sizesMjsDefault.default, {
                    pageSize: pageSizeBridge.value,
                    pageSizes: props.pageSizes,
                    popperClass: props.popperClass,
                    disabled: props.disabled,
                    size: props.small ? "small" : "default"
                }),
                slot: (_b = (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : null,
                total: _vue.h(_totalMjsDefault.default, {
                    total: isAbsent(props.total) ? 0 : props.total
                })
            };
            const components = props.layout.split(",").map((item)=>item.trim()
            );
            let haveRightWrapper = false;
            components.forEach((c)=>{
                if (c === "->") {
                    haveRightWrapper = true;
                    return;
                }
                if (!haveRightWrapper) rootChildren.push(TEMPLATE_MAP[c]);
                else rightWrapperChildren.push(TEMPLATE_MAP[c]);
            });
            addClass(rootChildren[0], ns.is("first"));
            addClass(rootChildren[rootChildren.length - 1], ns.is("last"));
            if (haveRightWrapper && rightWrapperChildren.length > 0) {
                addClass(rightWrapperChildren[0], ns.is("first"));
                addClass(rightWrapperChildren[rightWrapperChildren.length - 1], ns.is("last"));
                rootChildren.push(rightWrapperRoot);
            }
            return _vue.h("div", {
                role: "pagination",
                "aria-label": "pagination",
                class: [
                    ns.b(),
                    ns.is("background", props.background),
                    {
                        [ns.m("small")]: props.small
                    }
                ]
            }, rootChildren);
        };
    }
});

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","../../../tokens/index.mjs":"wVNQi","./components/prev.mjs":"63TQx","./components/next.mjs":"1j9pg","./components/sizes.mjs":"iVulY","./components/jumper.mjs":"dGl7n","./components/total.mjs":"8fzkt","./components/pager.mjs":"g4RaC","../../../utils/vue/props.mjs":"cpwWK","../../../utils/typescript.mjs":"bRl53","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../tokens/pagination.mjs":"9NXrn","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"63TQx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Prev
);
var _vue = require("vue");
var _indexMjs = require("../../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const paginationPrevProps = {
    disabled: Boolean,
    currentPage: {
        type: Number,
        default: 1
    },
    prevText: {
        type: String,
        default: ""
    }
};
const _sfc_main = _vue.defineComponent({
    name: "ElPaginationPrev",
    components: {
        ElIcon: _indexMjs.ElIcon,
        ArrowLeft: _iconsVue.ArrowLeft
    },
    props: paginationPrevProps,
    emits: [
        "click"
    ],
    setup (props) {
        const internalDisabled = _vue.computed(()=>props.disabled || props.currentPage <= 1
        );
        return {
            internalDisabled
        };
    }
});
const _hoisted_1 = [
    "disabled",
    "aria-disabled"
];
const _hoisted_2 = {
    key: 0
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_arrow_left = _vue.resolveComponent("arrow-left");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    return _vue.openBlock(), _vue.createElementBlock("button", {
        type: "button",
        class: "btn-prev",
        disabled: _ctx.internalDisabled,
        "aria-disabled": _ctx.internalDisabled,
        onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("click", $event)
        )
    }, [
        _ctx.prevText ? (_vue.openBlock(), _vue.createElementBlock("span", _hoisted_2, _vue.toDisplayString(_ctx.prevText), 1)) : (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
            key: 1
        }, {
            default: _vue.withCtx(()=>[
                    _vue.createVNode(_component_arrow_left)
                ]
            ),
            _: 1
        }))
    ], 8, _hoisted_1);
}
var Prev = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1j9pg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Next
);
var _vue = require("vue");
var _indexMjs = require("../../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const paginationNextProps = {
    disabled: Boolean,
    currentPage: {
        type: Number,
        default: 1
    },
    pageCount: {
        type: Number,
        default: 50
    },
    nextText: {
        type: String,
        default: ""
    }
};
const _sfc_main = _vue.defineComponent({
    name: "ElPaginationNext",
    components: {
        ElIcon: _indexMjs.ElIcon,
        ArrowRight: _iconsVue.ArrowRight
    },
    props: paginationNextProps,
    emits: [
        "click"
    ],
    setup (props) {
        const internalDisabled = _vue.computed(()=>props.disabled || props.currentPage === props.pageCount || props.pageCount === 0
        );
        return {
            internalDisabled
        };
    }
});
const _hoisted_1 = [
    "disabled",
    "aria-disabled"
];
const _hoisted_2 = {
    key: 0
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_arrow_right = _vue.resolveComponent("arrow-right");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    return _vue.openBlock(), _vue.createElementBlock("button", {
        type: "button",
        class: "btn-next",
        disabled: _ctx.internalDisabled,
        "aria-disabled": _ctx.internalDisabled,
        onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("click", $event)
        )
    }, [
        _ctx.nextText ? (_vue.openBlock(), _vue.createElementBlock("span", _hoisted_2, _vue.toDisplayString(_ctx.nextText), 1)) : (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
            key: 1
        }, {
            default: _vue.withCtx(()=>[
                    _vue.createVNode(_component_arrow_right)
                ]
            ),
            _: 1
        }))
    ], 8, _hoisted_1);
}
var Next = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iVulY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Sizes
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../select/index.mjs");
var _indexMjs1 = require("../../../../hooks/index.mjs");
var _indexMjs2 = require("../../../../utils/index.mjs");
var _usePaginationMjs = require("../usePagination.mjs");
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _propsMjs = require("../../../../utils/vue/props.mjs");
var _typescriptMjs = require("../../../../utils/typescript.mjs");
var _indexMjs3 = require("../../../../hooks/use-locale/index.mjs");
var _indexMjs4 = require("../../../../hooks/use-namespace/index.mjs");
const paginationSizesProps = _propsMjs.buildProps({
    pageSize: {
        type: Number,
        required: true
    },
    pageSizes: {
        type: _propsMjs.definePropType(Array),
        default: ()=>_typescriptMjs.mutable([
                10,
                20,
                30,
                40,
                50,
                100
            ])
    },
    popperClass: {
        type: String,
        default: ""
    },
    disabled: Boolean,
    size: {
        type: String,
        default: "default"
    }
});
const _sfc_main = _vue.defineComponent({
    name: "ElPaginationSizes",
    components: {
        ElSelect: _indexMjs.ElSelect,
        ElOption: _indexMjs.ElOption
    },
    props: paginationSizesProps,
    emits: [
        "page-size-change"
    ],
    setup (props, { emit  }) {
        const { t  } = _indexMjs3.useLocale();
        const ns = _indexMjs4.useNamespace("pagination");
        const pagination = _usePaginationMjs.usePagination();
        const innerPageSize = _vue.ref(props.pageSize);
        _vue.watch(()=>props.pageSizes
        , (newVal, oldVal)=>{
            if (_lodashUnified.isEqual(newVal, oldVal)) return;
            if (Array.isArray(newVal)) {
                const pageSize = newVal.indexOf(props.pageSize) > -1 ? props.pageSize : props.pageSizes[0];
                emit("page-size-change", pageSize);
            }
        });
        _vue.watch(()=>props.pageSize
        , (newVal)=>{
            innerPageSize.value = newVal;
        });
        const innerPagesizes = _vue.computed(()=>props.pageSizes
        );
        function handleChange(val) {
            var _a;
            if (val !== innerPageSize.value) {
                innerPageSize.value = val;
                (_a = pagination.handleSizeChange) == null || _a.call(pagination, Number(val));
            }
        }
        return {
            ns,
            innerPagesizes,
            innerPageSize,
            t,
            handleChange
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_option = _vue.resolveComponent("el-option");
    const _component_el_select = _vue.resolveComponent("el-select");
    return _vue.openBlock(), _vue.createElementBlock("span", {
        class: _vue.normalizeClass(_ctx.ns.e("sizes"))
    }, [
        _vue.createVNode(_component_el_select, {
            "model-value": _ctx.innerPageSize,
            disabled: _ctx.disabled,
            "popper-class": _ctx.popperClass,
            size: _ctx.size,
            onChange: _ctx.handleChange
        }, {
            default: _vue.withCtx(()=>[
                    (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.innerPagesizes, (item)=>{
                        return _vue.openBlock(), _vue.createBlock(_component_el_option, {
                            key: item,
                            value: item,
                            label: item + _ctx.t("el.pagination.pagesize")
                        }, null, 8, [
                            "value",
                            "label"
                        ]);
                    }), 128))
                ]
            ),
            _: 1
        }, 8, [
            "model-value",
            "disabled",
            "popper-class",
            "size",
            "onChange"
        ])
    ], 2);
}
var Sizes = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","lodash-unified":"4Oj4p","../../../select/index.mjs":"llDRW","../../../../hooks/index.mjs":"1Ansp","../../../../utils/index.mjs":"dsdeP","../usePagination.mjs":"b5Iy0","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../utils/vue/props.mjs":"cpwWK","../../../../utils/typescript.mjs":"bRl53","../../../../hooks/use-locale/index.mjs":"c1HoA","../../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"llDRW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "selectGroupKey", ()=>_tokenMjs.selectGroupKey
);
parcelHelpers.export(exports, "selectKey", ()=>_tokenMjs.selectKey
);
parcelHelpers.export(exports, "ElOption", ()=>ElOption
);
parcelHelpers.export(exports, "ElOptionGroup", ()=>ElOptionGroup
);
parcelHelpers.export(exports, "ElSelect", ()=>ElSelect
);
parcelHelpers.export(exports, "default", ()=>ElSelect
);
var _indexMjs = require("../../utils/index.mjs");
var _selectMjs = require("./src/select.mjs");
var _selectMjsDefault = parcelHelpers.interopDefault(_selectMjs);
var _optionMjs = require("./src/option.mjs");
var _optionMjsDefault = parcelHelpers.interopDefault(_optionMjs);
var _optionGroupMjs = require("./src/option-group.mjs");
var _optionGroupMjsDefault = parcelHelpers.interopDefault(_optionGroupMjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _tokenMjs = require("./src/token.mjs");
const ElSelect = _installMjs.withInstall(_selectMjsDefault.default, {
    Option: _optionMjsDefault.default,
    OptionGroup: _optionGroupMjsDefault.default
});
const ElOption = _installMjs.withNoopInstall(_optionMjsDefault.default);
const ElOptionGroup = _installMjs.withNoopInstall(_optionGroupMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/select.mjs":"1mWz4","./src/option.mjs":"iVTLO","./src/option-group.mjs":"dEleR","../../utils/vue/install.mjs":"4TMmv","./src/token.mjs":"cOSZy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1mWz4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Select
);
var _vue = require("vue");
var _indexMjs = require("../../../directives/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _indexMjs2 = require("../../input/index.mjs");
var _indexMjs3 = require("../../tooltip/index.mjs");
var _indexMjs4 = require("../../scrollbar/index.mjs");
var _indexMjs5 = require("../../tag/index.mjs");
var _indexMjs6 = require("../../icon/index.mjs");
var _indexMjs7 = require("../../popper/index.mjs");
var _indexMjs8 = require("../../../constants/index.mjs");
var _indexMjs9 = require("../../../utils/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _optionMjs = require("./option.mjs");
var _optionMjsDefault = parcelHelpers.interopDefault(_optionMjs);
var _selectDropdownMjs = require("./select-dropdown.mjs");
var _selectDropdownMjsDefault = parcelHelpers.interopDefault(_selectDropdownMjs);
var _useSelectMjs = require("./useSelect.mjs");
var _tokenMjs = require("./token.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs10 = require("../../../directives/click-outside/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs10);
var _validatorMjs = require("../../../utils/vue/validator.mjs");
var _tooltipMjs = require("../../tooltip/src/tooltip.mjs");
var _tagMjs = require("../../tag/src/tag.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs11 = require("../../../hooks/use-namespace/index.mjs");
var _indexMjs12 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs13 = require("../../../hooks/use-focus/index.mjs");
var _resizeEventMjs = require("../../../utils/dom/resize-event.mjs");
var _deprecationMjs = require("../../popper/src/deprecation.mjs");
const COMPONENT_NAME = "ElSelect";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    componentName: COMPONENT_NAME,
    components: {
        ElInput: _indexMjs2.ElInput,
        ElSelectMenu: _selectDropdownMjsDefault.default,
        ElOption: _optionMjsDefault.default,
        ElTag: _indexMjs5.ElTag,
        ElScrollbar: _indexMjs4.ElScrollbar,
        ElTooltip: _indexMjs3.ElTooltip,
        ElIcon: _indexMjs6.ElIcon
    },
    directives: {
        ClickOutside: _indexMjsDefault.default
    },
    props: {
        name: String,
        id: String,
        modelValue: {
            type: [
                Array,
                String,
                Number,
                Boolean,
                Object
            ],
            default: void 0
        },
        autocomplete: {
            type: String,
            default: "off"
        },
        automaticDropdown: Boolean,
        size: {
            type: String,
            validator: _validatorMjs.isValidComponentSize
        },
        effect: {
            type: String,
            default: "light"
        },
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        allowCreate: Boolean,
        loading: Boolean,
        popperClass: {
            type: String,
            default: ""
        },
        remote: Boolean,
        loadingText: String,
        noMatchText: String,
        noDataText: String,
        remoteMethod: Function,
        filterMethod: Function,
        multiple: Boolean,
        multipleLimit: {
            type: Number,
            default: 0
        },
        placeholder: {
            type: String
        },
        defaultFirstOption: Boolean,
        reserveKeyword: {
            type: Boolean,
            default: true
        },
        valueKey: {
            type: String,
            default: "value"
        },
        collapseTags: Boolean,
        popperAppendToBody: {
            type: Boolean,
            default: void 0
        },
        teleported: _tooltipMjs.useTooltipContentProps.teleported,
        clearIcon: {
            type: [
                String,
                Object
            ],
            default: _iconsVue.CircleClose
        },
        fitInputWidth: {
            type: Boolean,
            default: false
        },
        suffixIcon: {
            type: [
                String,
                Object
            ],
            default: _iconsVue.ArrowUp
        },
        tagType: {
            ..._tagMjs.tagProps.type,
            default: "info"
        }
    },
    emits: [
        _eventMjs.UPDATE_MODEL_EVENT,
        _eventMjs.CHANGE_EVENT,
        "remove-tag",
        "clear",
        "visible-change",
        "focus",
        "blur"
    ],
    setup (props, ctx) {
        const nsSelect = _indexMjs11.useNamespace("select");
        const nsInput = _indexMjs11.useNamespace("input");
        const { t  } = _indexMjs12.useLocale();
        const states = _useSelectMjs.useSelectStates(props);
        const { optionsArray , selectSize , readonly , handleResize , collapseTagSize , debouncedOnInputChange , debouncedQueryChange , deletePrevTag , deleteTag , deleteSelected , handleOptionSelect , scrollToOption , setSelected , resetInputHeight , managePlaceholder , showClose , selectDisabled , iconComponent , iconReverse , showNewOption , emptyText , toggleLastOptionHitState , resetInputState , handleComposition , onOptionCreate , onOptionDestroy , handleMenuEnter , handleFocus , blur , handleBlur , handleClearClick , handleClose , toggleMenu , selectOption , getValueKey , navigateOptions , dropMenuVisible , reference , input , tooltipRef , tags , selectWrapper , scrollbar , queryChange , groupQueryChange  } = _useSelectMjs.useSelect(props, states, ctx);
        const { focus  } = _indexMjs13.useFocus(reference);
        const { inputWidth , selected , inputLength , filteredOptionsCount , visible , softFocus , selectedLabel , hoverIndex , query , inputHovering , currentPlaceholder , menuVisibleOnFocus , isOnComposition , isSilentBlur , options , cachedOptions , optionsCount , prefixWidth , tagInMultiLine  } = _vue.toRefs(states);
        const wrapperKls = _vue.computed(()=>{
            const classList = [
                nsSelect.b()
            ];
            const _selectSize = _vue.unref(selectSize);
            if (_selectSize) classList.push(nsSelect.m(_selectSize));
            if (props.disabled) classList.push(nsSelect.m("disabled"));
            return classList;
        });
        const selectTagsStyle = _vue.computed(()=>({
                maxWidth: `${_vue.unref(inputWidth) - 32}px`,
                width: "100%"
            })
        );
        _vue.provide(_tokenMjs.selectKey, _vue.reactive({
            props,
            options,
            optionsArray,
            cachedOptions,
            optionsCount,
            filteredOptionsCount,
            hoverIndex,
            handleOptionSelect,
            onOptionCreate,
            onOptionDestroy,
            selectWrapper,
            selected,
            setSelected,
            queryChange,
            groupQueryChange
        }));
        _vue.onMounted(()=>{
            states.cachedPlaceHolder = currentPlaceholder.value = props.placeholder || t("el.select.placeholder");
            if (props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0) currentPlaceholder.value = "";
            _resizeEventMjs.addResizeListener(selectWrapper.value, handleResize);
            if (reference.value && reference.value.$el) {
                const sizeMap = {
                    large: 36,
                    default: 32,
                    small: 28
                };
                const input2 = reference.value.input;
                states.initialInputHeight = input2.getBoundingClientRect().height || sizeMap[selectSize.value];
            }
            if (props.remote && props.multiple) resetInputHeight();
            _vue.nextTick(()=>{
                if (!reference.value) return;
                if (reference.value.$el) inputWidth.value = reference.value.$el.getBoundingClientRect().width;
                if (ctx.slots.prefix) {
                    const inputChildNodes = reference.value.$el.childNodes;
                    const input2 = Array.from(inputChildNodes).filter((item)=>item.tagName === "INPUT"
                    )[0];
                    const prefix = reference.value.$el.querySelector(`.${nsInput.e("prefix")}`);
                    prefixWidth.value = Math.max(prefix.getBoundingClientRect().width + 5, 30);
                    if (states.prefixWidth) input2.style.paddingLeft = `${Math.max(states.prefixWidth, 30)}px`;
                }
            });
            setSelected();
        });
        _vue.onBeforeUnmount(()=>{
            _resizeEventMjs.removeResizeListener(selectWrapper.value, handleResize);
        });
        if (props.multiple && !Array.isArray(props.modelValue)) ctx.emit(_eventMjs.UPDATE_MODEL_EVENT, []);
        if (!props.multiple && Array.isArray(props.modelValue)) ctx.emit(_eventMjs.UPDATE_MODEL_EVENT, "");
        const popperPaneRef = _vue.computed(()=>{
            var _a, _b;
            return (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
        });
        const { compatTeleported  } = _deprecationMjs.useDeprecateAppendToBody(COMPONENT_NAME, "popperAppendToBody");
        return {
            tagInMultiLine,
            prefixWidth,
            selectSize,
            readonly,
            handleResize,
            collapseTagSize,
            debouncedOnInputChange,
            debouncedQueryChange,
            deletePrevTag,
            deleteTag,
            deleteSelected,
            handleOptionSelect,
            scrollToOption,
            inputWidth,
            selected,
            inputLength,
            filteredOptionsCount,
            visible,
            softFocus,
            selectedLabel,
            hoverIndex,
            query,
            inputHovering,
            currentPlaceholder,
            menuVisibleOnFocus,
            isOnComposition,
            isSilentBlur,
            options,
            resetInputHeight,
            managePlaceholder,
            showClose,
            selectDisabled,
            iconComponent,
            iconReverse,
            showNewOption,
            emptyText,
            toggleLastOptionHitState,
            resetInputState,
            handleComposition,
            handleMenuEnter,
            handleFocus,
            blur,
            handleBlur,
            handleClearClick,
            handleClose,
            toggleMenu,
            selectOption,
            getValueKey,
            navigateOptions,
            dropMenuVisible,
            focus,
            reference,
            input,
            tooltipRef,
            popperPaneRef,
            tags,
            selectWrapper,
            scrollbar,
            wrapperKls,
            selectTagsStyle,
            compatTeleported,
            nsSelect
        };
    }
});
const _hoisted_1 = {
    class: "select-trigger"
};
const _hoisted_2 = {
    key: 0
};
const _hoisted_3 = [
    "disabled",
    "autocomplete"
];
const _hoisted_4 = {
    style: {
        "height": "100%",
        "display": "flex",
        "justify-content": "center",
        "align-items": "center"
    }
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_tag = _vue.resolveComponent("el-tag");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_input = _vue.resolveComponent("el-input");
    const _component_el_option = _vue.resolveComponent("el-option");
    const _component_el_scrollbar = _vue.resolveComponent("el-scrollbar");
    const _component_el_select_menu = _vue.resolveComponent("el-select-menu");
    const _component_el_tooltip = _vue.resolveComponent("el-tooltip");
    const _directive_click_outside = _vue.resolveDirective("click-outside");
    return _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
        ref: "selectWrapper",
        class: _vue.normalizeClass(_ctx.wrapperKls),
        onClick: _cache[24] || (_cache[24] = _vue.withModifiers((...args)=>_ctx.toggleMenu && _ctx.toggleMenu(...args)
        , [
            "stop"
        ]))
    }, [
        _vue.createVNode(_component_el_tooltip, {
            ref: "tooltipRef",
            visible: _ctx.dropMenuVisible,
            "onUpdate:visible": _cache[23] || (_cache[23] = ($event)=>_ctx.dropMenuVisible = $event
            ),
            placement: "bottom-start",
            teleported: _ctx.compatTeleported,
            "popper-class": [
                _ctx.nsSelect.e("popper"),
                _ctx.popperClass
            ],
            "fallback-placements": [
                "bottom-start",
                "top-start",
                "right",
                "left"
            ],
            effect: _ctx.effect,
            pure: "",
            trigger: "click",
            transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
            "stop-popper-mouse-event": false,
            "gpu-acceleration": false,
            persistent: "",
            onShow: _ctx.handleMenuEnter
        }, {
            default: _vue.withCtx(()=>[
                    _vue.createElementVNode("div", _hoisted_1, [
                        _ctx.multiple ? (_vue.openBlock(), _vue.createElementBlock("div", {
                            key: 0,
                            ref: "tags",
                            class: _vue.normalizeClass(_ctx.nsSelect.e("tags")),
                            style: _vue.normalizeStyle(_ctx.selectTagsStyle)
                        }, [
                            _ctx.collapseTags && _ctx.selected.length ? (_vue.openBlock(), _vue.createElementBlock("span", _hoisted_2, [
                                _vue.createVNode(_component_el_tag, {
                                    closable: !_ctx.selectDisabled && !_ctx.selected[0].isDisabled,
                                    size: _ctx.collapseTagSize,
                                    hit: _ctx.selected[0].hitState,
                                    type: _ctx.tagType,
                                    "disable-transitions": "",
                                    onClose: _cache[0] || (_cache[0] = ($event)=>_ctx.deleteTag($event, _ctx.selected[0])
                                    )
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createElementVNode("span", {
                                                class: _vue.normalizeClass(_ctx.nsSelect.e("tags-text")),
                                                style: _vue.normalizeStyle({
                                                    maxWidth: _ctx.inputWidth - 123 + "px"
                                                })
                                            }, _vue.toDisplayString(_ctx.selected[0].currentLabel), 7)
                                        ]
                                    ),
                                    _: 1
                                }, 8, [
                                    "closable",
                                    "size",
                                    "hit",
                                    "type"
                                ]),
                                _ctx.selected.length > 1 ? (_vue.openBlock(), _vue.createBlock(_component_el_tag, {
                                    key: 0,
                                    closable: false,
                                    size: _ctx.collapseTagSize,
                                    type: _ctx.tagType,
                                    "disable-transitions": ""
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createElementVNode("span", {
                                                class: _vue.normalizeClass(_ctx.nsSelect.e("tags-text"))
                                            }, "+ " + _vue.toDisplayString(_ctx.selected.length - 1), 3)
                                        ]
                                    ),
                                    _: 1
                                }, 8, [
                                    "size",
                                    "type"
                                ])) : _vue.createCommentVNode("v-if", true)
                            ])) : _vue.createCommentVNode("v-if", true),
                            _vue.createCommentVNode(" <div> "),
                            !_ctx.collapseTags ? (_vue.openBlock(), _vue.createBlock(_vue.Transition, {
                                key: 1,
                                onAfterLeave: _ctx.resetInputHeight
                            }, {
                                default: _vue.withCtx(()=>[
                                        _vue.createElementVNode("span", {
                                            style: _vue.normalizeStyle({
                                                marginLeft: _ctx.prefixWidth && _ctx.selected.length ? `${_ctx.prefixWidth}px` : ""
                                            })
                                        }, [
                                            (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.selected, (item)=>{
                                                return _vue.openBlock(), _vue.createBlock(_component_el_tag, {
                                                    key: _ctx.getValueKey(item),
                                                    closable: !_ctx.selectDisabled && !item.isDisabled,
                                                    size: _ctx.collapseTagSize,
                                                    hit: item.hitState,
                                                    type: _ctx.tagType,
                                                    "disable-transitions": "",
                                                    onClose: ($event)=>_ctx.deleteTag($event, item)
                                                }, {
                                                    default: _vue.withCtx(()=>[
                                                            _vue.createElementVNode("span", {
                                                                class: _vue.normalizeClass(_ctx.nsSelect.e("tags-text")),
                                                                style: _vue.normalizeStyle({
                                                                    maxWidth: _ctx.inputWidth - 75 + "px"
                                                                })
                                                            }, _vue.toDisplayString(item.currentLabel), 7)
                                                        ]
                                                    ),
                                                    _: 2
                                                }, 1032, [
                                                    "closable",
                                                    "size",
                                                    "hit",
                                                    "type",
                                                    "onClose"
                                                ]);
                                            }), 128))
                                        ], 4)
                                    ]
                                ),
                                _: 1
                            }, 8, [
                                "onAfterLeave"
                            ])) : _vue.createCommentVNode("v-if", true),
                            _vue.createCommentVNode(" </div> "),
                            _ctx.filterable ? _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("input", {
                                key: 2,
                                ref: "input",
                                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>_ctx.query = $event
                                ),
                                type: "text",
                                class: _vue.normalizeClass([
                                    _ctx.nsSelect.e("input"),
                                    _ctx.nsSelect.is(_ctx.selectSize)
                                ]),
                                disabled: _ctx.selectDisabled,
                                autocomplete: _ctx.autocomplete,
                                style: _vue.normalizeStyle({
                                    marginLeft: _ctx.prefixWidth && !_ctx.selected.length || _ctx.tagInMultiLine ? `${_ctx.prefixWidth}px` : "",
                                    flexGrow: 1,
                                    width: `${_ctx.inputLength / (_ctx.inputWidth - 32)}%`,
                                    maxWidth: `${_ctx.inputWidth - 42}px`
                                }),
                                onFocus: _cache[2] || (_cache[2] = (...args)=>_ctx.handleFocus && _ctx.handleFocus(...args)
                                ),
                                onBlur: _cache[3] || (_cache[3] = (...args)=>_ctx.handleBlur && _ctx.handleBlur(...args)
                                ),
                                onKeyup: _cache[4] || (_cache[4] = (...args)=>_ctx.managePlaceholder && _ctx.managePlaceholder(...args)
                                ),
                                onKeydown: [
                                    _cache[5] || (_cache[5] = (...args)=>_ctx.resetInputState && _ctx.resetInputState(...args)
                                    ),
                                    _cache[6] || (_cache[6] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.navigateOptions("next")
                                    , [
                                        "prevent"
                                    ]), [
                                        "down"
                                    ])),
                                    _cache[7] || (_cache[7] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.navigateOptions("prev")
                                    , [
                                        "prevent"
                                    ]), [
                                        "up"
                                    ])),
                                    _cache[8] || (_cache[8] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.visible = false
                                    , [
                                        "stop",
                                        "prevent"
                                    ]), [
                                        "esc"
                                    ])),
                                    _cache[9] || (_cache[9] = _vue.withKeys(_vue.withModifiers((...args)=>_ctx.selectOption && _ctx.selectOption(...args)
                                    , [
                                        "stop",
                                        "prevent"
                                    ]), [
                                        "enter"
                                    ])),
                                    _cache[10] || (_cache[10] = _vue.withKeys((...args)=>_ctx.deletePrevTag && _ctx.deletePrevTag(...args)
                                    , [
                                        "delete"
                                    ])),
                                    _cache[11] || (_cache[11] = _vue.withKeys(($event)=>_ctx.visible = false
                                    , [
                                        "tab"
                                    ]))
                                ],
                                onCompositionstart: _cache[12] || (_cache[12] = (...args)=>_ctx.handleComposition && _ctx.handleComposition(...args)
                                ),
                                onCompositionupdate: _cache[13] || (_cache[13] = (...args)=>_ctx.handleComposition && _ctx.handleComposition(...args)
                                ),
                                onCompositionend: _cache[14] || (_cache[14] = (...args)=>_ctx.handleComposition && _ctx.handleComposition(...args)
                                ),
                                onInput: _cache[15] || (_cache[15] = (...args)=>_ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args)
                                )
                            }, null, 46, _hoisted_3)), [
                                [
                                    _vue.vModelText,
                                    _ctx.query
                                ]
                            ]) : _vue.createCommentVNode("v-if", true)
                        ], 6)) : _vue.createCommentVNode("v-if", true),
                        _vue.createVNode(_component_el_input, {
                            id: _ctx.id,
                            ref: "reference",
                            modelValue: _ctx.selectedLabel,
                            "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event)=>_ctx.selectedLabel = $event
                            ),
                            type: "text",
                            placeholder: _ctx.currentPlaceholder,
                            name: _ctx.name,
                            autocomplete: _ctx.autocomplete,
                            size: _ctx.selectSize,
                            disabled: _ctx.selectDisabled,
                            readonly: _ctx.readonly,
                            "validate-event": false,
                            class: _vue.normalizeClass([
                                _ctx.nsSelect.is("focus", _ctx.visible)
                            ]),
                            tabindex: _ctx.multiple && _ctx.filterable ? -1 : void 0,
                            onFocus: _ctx.handleFocus,
                            onBlur: _ctx.handleBlur,
                            onInput: _ctx.debouncedOnInputChange,
                            onPaste: _ctx.debouncedOnInputChange,
                            onCompositionstart: _ctx.handleComposition,
                            onCompositionupdate: _ctx.handleComposition,
                            onCompositionend: _ctx.handleComposition,
                            onKeydown: [
                                _cache[17] || (_cache[17] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.navigateOptions("next")
                                , [
                                    "stop",
                                    "prevent"
                                ]), [
                                    "down"
                                ])),
                                _cache[18] || (_cache[18] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.navigateOptions("prev")
                                , [
                                    "stop",
                                    "prevent"
                                ]), [
                                    "up"
                                ])),
                                _vue.withKeys(_vue.withModifiers(_ctx.selectOption, [
                                    "stop",
                                    "prevent"
                                ]), [
                                    "enter"
                                ]),
                                _cache[19] || (_cache[19] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.visible = false
                                , [
                                    "stop",
                                    "prevent"
                                ]), [
                                    "esc"
                                ])),
                                _cache[20] || (_cache[20] = _vue.withKeys(($event)=>_ctx.visible = false
                                , [
                                    "tab"
                                ]))
                            ],
                            onMouseenter: _cache[21] || (_cache[21] = ($event)=>_ctx.inputHovering = true
                            ),
                            onMouseleave: _cache[22] || (_cache[22] = ($event)=>_ctx.inputHovering = false
                            )
                        }, _vue.createSlots({
                            suffix: _vue.withCtx(()=>[
                                    _ctx.iconComponent ? _vue.withDirectives((_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                        key: 0,
                                        class: _vue.normalizeClass([
                                            _ctx.nsSelect.e("caret"),
                                            _ctx.nsSelect.e("icon"),
                                            _ctx.iconReverse
                                        ])
                                    }, {
                                        default: _vue.withCtx(()=>[
                                                (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.iconComponent)))
                                            ]
                                        ),
                                        _: 1
                                    }, 8, [
                                        "class"
                                    ])), [
                                        [
                                            _vue.vShow,
                                            !_ctx.showClose
                                        ]
                                    ]) : _vue.createCommentVNode("v-if", true),
                                    _ctx.showClose && _ctx.clearIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                        key: 1,
                                        class: _vue.normalizeClass([
                                            _ctx.nsSelect.e("caret"),
                                            _ctx.nsSelect.e("icon")
                                        ]),
                                        onClick: _ctx.handleClearClick
                                    }, {
                                        default: _vue.withCtx(()=>[
                                                (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.clearIcon)))
                                            ]
                                        ),
                                        _: 1
                                    }, 8, [
                                        "class",
                                        "onClick"
                                    ])) : _vue.createCommentVNode("v-if", true)
                                ]
                            ),
                            _: 2
                        }, [
                            _ctx.$slots.prefix ? {
                                name: "prefix",
                                fn: _vue.withCtx(()=>[
                                        _vue.createElementVNode("div", _hoisted_4, [
                                            _vue.renderSlot(_ctx.$slots, "prefix")
                                        ])
                                    ]
                                )
                            } : void 0
                        ]), 1032, [
                            "id",
                            "modelValue",
                            "placeholder",
                            "name",
                            "autocomplete",
                            "size",
                            "disabled",
                            "readonly",
                            "class",
                            "tabindex",
                            "onFocus",
                            "onBlur",
                            "onInput",
                            "onPaste",
                            "onCompositionstart",
                            "onCompositionupdate",
                            "onCompositionend",
                            "onKeydown"
                        ])
                    ])
                ]
            ),
            content: _vue.withCtx(()=>[
                    _vue.createVNode(_component_el_select_menu, null, {
                        default: _vue.withCtx(()=>[
                                _vue.withDirectives(_vue.createVNode(_component_el_scrollbar, {
                                    ref: "scrollbar",
                                    tag: "ul",
                                    "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                                    "view-class": _ctx.nsSelect.be("dropdown", "list"),
                                    class: _vue.normalizeClass([
                                        _ctx.nsSelect.is("empty", !_ctx.allowCreate && _ctx.query && _ctx.filteredOptionsCount === 0)
                                    ])
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _ctx.showNewOption ? (_vue.openBlock(), _vue.createBlock(_component_el_option, {
                                                key: 0,
                                                value: _ctx.query,
                                                created: true
                                            }, null, 8, [
                                                "value"
                                            ])) : _vue.createCommentVNode("v-if", true),
                                            _vue.renderSlot(_ctx.$slots, "default")
                                        ]
                                    ),
                                    _: 3
                                }, 8, [
                                    "wrap-class",
                                    "view-class",
                                    "class"
                                ]), [
                                    [
                                        _vue.vShow,
                                        _ctx.options.size > 0 && !_ctx.loading
                                    ]
                                ]),
                                _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                                    key: 0
                                }, [
                                    _ctx.$slots.empty ? _vue.renderSlot(_ctx.$slots, "empty", {
                                        key: 0
                                    }) : (_vue.openBlock(), _vue.createElementBlock("p", {
                                        key: 1,
                                        class: _vue.normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                                    }, _vue.toDisplayString(_ctx.emptyText), 3))
                                ], 2112)) : _vue.createCommentVNode("v-if", true)
                            ]
                        ),
                        _: 3
                    })
                ]
            ),
            _: 3
        }, 8, [
            "visible",
            "teleported",
            "popper-class",
            "effect",
            "transition",
            "onShow"
        ])
    ], 2)), [
        [
            _directive_click_outside,
            _ctx.handleClose,
            _ctx.popperPaneRef
        ]
    ]);
}
var Select = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../directives/index.mjs":"aRbJ2","../../../hooks/index.mjs":"1Ansp","../../input/index.mjs":"18eQI","../../tooltip/index.mjs":"kiwBC","../../scrollbar/index.mjs":"kXLHt","../../tag/index.mjs":"96fQG","../../icon/index.mjs":"hnNTG","../../popper/index.mjs":"kIV7g","../../../constants/index.mjs":"74Fbn","../../../utils/index.mjs":"dsdeP","@element-plus/icons-vue":"b18uu","./option.mjs":"iVTLO","./select-dropdown.mjs":"ggEVP","./useSelect.mjs":"7MycF","./token.mjs":"cOSZy","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../directives/click-outside/index.mjs":"cdlLW","../../../utils/vue/validator.mjs":"4UnBa","../../tooltip/src/tooltip.mjs":"7LVFi","../../tag/src/tag.mjs":"i4Ov7","../../../constants/event.mjs":"92xVn","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-focus/index.mjs":"8V0bg","../../../utils/dom/resize-event.mjs":"TzEEU","../../popper/src/deprecation.mjs":"jm0Kb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iVTLO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Option
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _useOptionMjs = require("./useOption.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElOption",
    componentName: "ElOption",
    props: {
        value: {
            required: true,
            type: [
                String,
                Number,
                Boolean,
                Object
            ]
        },
        label: [
            String,
            Number
        ],
        created: Boolean,
        disabled: {
            type: Boolean,
            default: false
        }
    },
    setup (props) {
        const ns = _indexMjs1.useNamespace("select");
        const states = _vue.reactive({
            index: -1,
            groupDisabled: false,
            visible: true,
            hitState: false,
            hover: false
        });
        const { currentLabel , itemSelected , isDisabled , select , hoverItem  } = _useOptionMjs.useOption(props, states);
        const { visible , hover  } = _vue.toRefs(states);
        const vm = _vue.getCurrentInstance().proxy;
        const key = vm.value;
        select.onOptionCreate(vm);
        _vue.onBeforeUnmount(()=>{
            const { selected  } = select;
            const selectedOptions = select.props.multiple ? selected : [
                selected
            ];
            const doesExist = select.cachedOptions.has(key);
            const doesSelected = selectedOptions.some((item)=>{
                return item.value === vm.value;
            });
            if (doesExist && !doesSelected) select.cachedOptions.delete(key);
            select.onOptionDestroy(key);
        });
        function selectOptionClick() {
            if (props.disabled !== true && states.groupDisabled !== true) select.handleOptionSelect(vm, true);
        }
        return {
            ns,
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            visible,
            hover,
            selectOptionClick,
            states
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("li", {
        class: _vue.normalizeClass([
            _ctx.ns.be("dropdown", "item"),
            _ctx.ns.is("disabled", _ctx.isDisabled),
            {
                selected: _ctx.itemSelected,
                hover: _ctx.hover
            }
        ]),
        onMouseenter: _cache[0] || (_cache[0] = (...args)=>_ctx.hoverItem && _ctx.hoverItem(...args)
        ),
        onClick: _cache[1] || (_cache[1] = _vue.withModifiers((...args)=>_ctx.selectOptionClick && _ctx.selectOptionClick(...args)
        , [
            "stop"
        ]))
    }, [
        _vue.renderSlot(_ctx.$slots, "default", {
        }, ()=>[
                _vue.createElementVNode("span", null, _vue.toDisplayString(_ctx.currentLabel), 1)
            ]
        )
    ], 34)), [
        [
            _vue.vShow,
            _ctx.visible
        ]
    ]);
}
var Option = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./useOption.mjs":"jN65R","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jN65R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useOption", ()=>useOption
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../utils/index.mjs");
var _tokenMjs = require("./token.mjs");
var _stringsMjs = require("../../../utils/strings.mjs");
function useOption(props, states) {
    const select = _vue.inject(_tokenMjs.selectKey);
    const selectGroup = _vue.inject(_tokenMjs.selectGroupKey, {
        disabled: false
    });
    const isObject = _vue.computed(()=>{
        return Object.prototype.toString.call(props.value).toLowerCase() === "[object object]";
    });
    const itemSelected = _vue.computed(()=>{
        if (!select.props.multiple) return isEqual(props.value, select.props.modelValue);
        else return contains(select.props.modelValue, props.value);
    });
    const limitReached = _vue.computed(()=>{
        if (select.props.multiple) {
            const modelValue = select.props.modelValue || [];
            return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
        } else return false;
    });
    const currentLabel = _vue.computed(()=>{
        return props.label || (isObject.value ? "" : props.value);
    });
    const currentValue = _vue.computed(()=>{
        return props.value || props.label || "";
    });
    const isDisabled = _vue.computed(()=>{
        return props.disabled || states.groupDisabled || limitReached.value;
    });
    const instance = _vue.getCurrentInstance();
    const contains = (arr = [], target)=>{
        if (!isObject.value) return arr && arr.indexOf(target) > -1;
        else {
            const valueKey = select.props.valueKey;
            return arr && arr.some((item)=>{
                return _lodashUnified.get(item, valueKey) === _lodashUnified.get(target, valueKey);
            });
        }
    };
    const isEqual = (a, b)=>{
        if (!isObject.value) return a === b;
        else {
            const { valueKey  } = select.props;
            return _lodashUnified.get(a, valueKey) === _lodashUnified.get(b, valueKey);
        }
    };
    const hoverItem = ()=>{
        if (!props.disabled && !selectGroup.disabled) select.hoverIndex = select.optionsArray.indexOf(instance.proxy);
    };
    _vue.watch(()=>currentLabel.value
    , ()=>{
        if (!props.created && !select.props.remote) select.setSelected();
    });
    _vue.watch(()=>props.value
    , (val, oldVal)=>{
        const { remote , valueKey  } = select.props;
        if (!props.created && !remote) {
            if (valueKey && typeof val === "object" && typeof oldVal === "object" && val[valueKey] === oldVal[valueKey]) return;
            select.setSelected();
        }
    });
    _vue.watch(()=>selectGroup.disabled
    , ()=>{
        states.groupDisabled = selectGroup.disabled;
    }, {
        immediate: true
    });
    const { queryChange  } = _vue.toRaw(select);
    _vue.watch(queryChange, (changes)=>{
        const { query  } = _vue.unref(changes);
        const regexp = new RegExp(_stringsMjs.escapeStringRegexp(query), "i");
        states.visible = regexp.test(currentLabel.value) || props.created;
        if (!states.visible) select.filteredOptionsCount--;
    });
    return {
        select,
        currentLabel,
        currentValue,
        itemSelected,
        isDisabled,
        hoverItem
    };
}

},{"vue":"gzxs9","lodash-unified":"4Oj4p","../../../utils/index.mjs":"dsdeP","./token.mjs":"cOSZy","../../../utils/strings.mjs":"hK6FY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cOSZy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "selectGroupKey", ()=>selectGroupKey
);
parcelHelpers.export(exports, "selectKey", ()=>selectKey
);
const selectGroupKey = "ElSelectGroup";
const selectKey = "ElSelect";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ggEVP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElSelectMenu
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _tokenMjs = require("./token.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
var _resizeEventMjs = require("../../../utils/dom/resize-event.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElSelectDropdown",
    componentName: "ElSelectDropdown",
    setup () {
        const select = _vue.inject(_tokenMjs.selectKey);
        const ns = _indexMjs2.useNamespace("select");
        const popperClass = _vue.computed(()=>select.props.popperClass
        );
        const isMultiple = _vue.computed(()=>select.props.multiple
        );
        const isFitInputWidth = _vue.computed(()=>select.props.fitInputWidth
        );
        const minWidth = _vue.ref("");
        function updateMinWidth() {
            var _a;
            minWidth.value = `${(_a = select.selectWrapper) == null ? void 0 : _a.getBoundingClientRect().width}px`;
        }
        _vue.onMounted(()=>{
            updateMinWidth();
            _resizeEventMjs.addResizeListener(select.selectWrapper, updateMinWidth);
        });
        _vue.onBeforeUnmount(()=>{
            _resizeEventMjs.removeResizeListener(select.selectWrapper, updateMinWidth);
        });
        return {
            ns,
            minWidth,
            popperClass,
            isMultiple,
            isFitInputWidth
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.ns.b("dropdown"),
            _ctx.ns.is("multiple", _ctx.isMultiple),
            _ctx.popperClass
        ]),
        style: _vue.normalizeStyle({
            [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth
        })
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 6);
}
var ElSelectMenu = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../utils/index.mjs":"dsdeP","./token.mjs":"cOSZy","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/dom/resize-event.mjs":"TzEEU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7MycF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useSelect", ()=>useSelect
);
parcelHelpers.export(exports, "useSelectStates", ()=>useSelectStates
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _lodashUnified = require("lodash-unified");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../constants/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _indexMjs3 = require("../../../tokens/index.mjs");
var _indexMjs4 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs5 = require("../../../hooks/use-namespace/index.mjs");
var _formMjs = require("../../../tokens/form.mjs");
var _indexMjs6 = require("../../../hooks/use-common-props/index.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _scrollMjs = require("../../../utils/dom/scroll.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
var _i18NMjs = require("../../../utils/i18n.mjs");
function useSelectStates(props) {
    const { t  } = _indexMjs4.useLocale();
    return _vue.reactive({
        options: /* @__PURE__ */ new Map(),
        cachedOptions: /* @__PURE__ */ new Map(),
        createdLabel: null,
        createdSelected: false,
        selected: props.multiple ? [] : {
        },
        inputLength: 20,
        inputWidth: 0,
        initialInputHeight: 0,
        optionsCount: 0,
        filteredOptionsCount: 0,
        visible: false,
        softFocus: false,
        selectedLabel: "",
        hoverIndex: -1,
        query: "",
        previousQuery: null,
        inputHovering: false,
        cachedPlaceHolder: "",
        currentPlaceholder: t("el.select.placeholder"),
        menuVisibleOnFocus: false,
        isOnComposition: false,
        isSilentBlur: false,
        prefixWidth: 11,
        tagInMultiLine: false
    });
}
const useSelect = (props, states, ctx)=>{
    const { t  } = _indexMjs4.useLocale();
    const ns = _indexMjs5.useNamespace("select");
    const reference = _vue.ref(null);
    const input = _vue.ref(null);
    const tooltipRef = _vue.ref(null);
    const tags = _vue.ref(null);
    const selectWrapper = _vue.ref(null);
    const scrollbar = _vue.ref(null);
    const hoverOption = _vue.ref(-1);
    const queryChange = _vue.shallowRef({
        query: ""
    });
    const groupQueryChange = _vue.shallowRef("");
    const elForm = _vue.inject(_formMjs.elFormKey, {
    });
    const elFormItem = _vue.inject(_formMjs.elFormItemKey, {
    });
    const readonly = _vue.computed(()=>!props.filterable || props.multiple || !states.visible
    );
    const selectDisabled = _vue.computed(()=>props.disabled || elForm.disabled
    );
    const showClose = _vue.computed(()=>{
        const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
        const criteria = props.clearable && !selectDisabled.value && states.inputHovering && hasValue;
        return criteria;
    });
    const iconComponent = _vue.computed(()=>props.remote && props.filterable ? "" : props.suffixIcon
    );
    const iconReverse = _vue.computed(()=>ns.is("reverse", iconComponent.value && states.visible)
    );
    const debounce$1 = _vue.computed(()=>props.remote ? 300 : 0
    );
    const emptyText = _vue.computed(()=>{
        if (props.loading) return props.loadingText || t("el.select.loading");
        else {
            if (props.remote && states.query === "" && states.options.size === 0) return false;
            if (props.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) return props.noMatchText || t("el.select.noMatch");
            if (states.options.size === 0) return props.noDataText || t("el.select.noData");
        }
        return null;
    });
    const optionsArray = _vue.computed(()=>Array.from(states.options.values())
    );
    const cachedOptionsArray = _vue.computed(()=>Array.from(states.cachedOptions.values())
    );
    const showNewOption = _vue.computed(()=>{
        const hasExistingOption = optionsArray.value.filter((option)=>{
            return !option.created;
        }).some((option)=>{
            return option.currentLabel === states.query;
        });
        return props.filterable && props.allowCreate && states.query !== "" && !hasExistingOption;
    });
    const selectSize = _indexMjs6.useSize();
    const collapseTagSize = _vue.computed(()=>[
            "small"
        ].indexOf(selectSize.value) > -1 ? "small" : "default"
    );
    const dropMenuVisible = _vue.computed({
        get () {
            return states.visible && emptyText.value !== false;
        },
        set (val) {
            states.visible = val;
        }
    });
    _vue.watch(()=>selectDisabled.value
    , ()=>{
        _vue.nextTick(()=>{
            resetInputHeight();
        });
    });
    _vue.watch(()=>props.placeholder
    , (val)=>{
        states.cachedPlaceHolder = states.currentPlaceholder = val;
    });
    _vue.watch(()=>props.modelValue
    , (val, oldVal)=>{
        var _a;
        if (props.multiple) {
            resetInputHeight();
            if (val && val.length > 0 || input.value && states.query !== "") states.currentPlaceholder = "";
            else states.currentPlaceholder = states.cachedPlaceHolder;
            if (props.filterable && !props.reserveKeyword) {
                states.query = "";
                handleQueryChange(states.query);
            }
        }
        setSelected();
        if (props.filterable && !props.multiple) states.inputLength = 20;
        if (!_lodashUnified.isEqual(val, oldVal)) (_a = elFormItem.validate) == null || _a.call(elFormItem, "change");
    }, {
        flush: "post",
        deep: true
    });
    _vue.watch(()=>states.visible
    , (val)=>{
        var _a, _b, _c;
        if (!val) {
            input.value && input.value.blur();
            states.query = "";
            states.previousQuery = null;
            states.selectedLabel = "";
            states.inputLength = 20;
            states.menuVisibleOnFocus = false;
            resetHoverIndex();
            _vue.nextTick(()=>{
                if (input.value && input.value.value === "" && states.selected.length === 0) states.currentPlaceholder = states.cachedPlaceHolder;
            });
            if (!props.multiple) {
                if (states.selected) {
                    if (props.filterable && props.allowCreate && states.createdSelected && states.createdLabel) states.selectedLabel = states.createdLabel;
                    else states.selectedLabel = states.selected.currentLabel;
                    if (props.filterable) states.query = states.selectedLabel;
                }
                if (props.filterable) states.currentPlaceholder = states.cachedPlaceHolder;
            }
        } else {
            (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
            if (props.filterable) {
                states.filteredOptionsCount = states.optionsCount;
                states.query = props.remote ? "" : states.selectedLabel;
                if (props.multiple) (_c = input.value) == null || _c.focus();
                else if (states.selectedLabel) {
                    states.currentPlaceholder = states.selectedLabel;
                    states.selectedLabel = "";
                }
                handleQueryChange(states.query);
                if (!props.multiple && !props.remote) {
                    queryChange.value.query = "";
                    _vue.triggerRef(queryChange);
                    _vue.triggerRef(groupQueryChange);
                }
            }
        }
        ctx.emit("visible-change", val);
    });
    _vue.watch(()=>states.options.entries()
    , ()=>{
        var _a, _b, _c;
        if (!_core.isClient) return;
        (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
        if (props.multiple) resetInputHeight();
        const inputs = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll("input")) || [];
        if (Array.from(inputs).indexOf(document.activeElement) === -1) setSelected();
        if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) checkDefaultFirstOption();
    }, {
        flush: "post"
    });
    _vue.watch(()=>states.hoverIndex
    , (val)=>{
        if (typeof val === "number" && val > -1) hoverOption.value = optionsArray.value[val] || {
        };
        optionsArray.value.forEach((option)=>{
            option.hover = hoverOption.value === option;
        });
    });
    const resetInputHeight = ()=>{
        if (props.collapseTags && !props.filterable) return;
        _vue.nextTick(()=>{
            var _a, _b;
            if (!reference.value) return;
            const inputChildNodes = reference.value.$el.childNodes;
            const input2 = Array.from(inputChildNodes).filter((item)=>item.tagName === "INPUT"
            )[0];
            const _tags = tags.value;
            const sizeInMap = states.initialInputHeight || 40;
            input2.style.height = states.selected.length === 0 ? `${sizeInMap}px` : `${Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)}px`;
            states.tagInMultiLine = parseFloat(input2.style.height) >= sizeInMap;
            if (states.visible && emptyText.value !== false) (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
        });
    };
    const handleQueryChange = (val)=>{
        if (states.previousQuery === val || states.isOnComposition) return;
        if (states.previousQuery === null && (typeof props.filterMethod === "function" || typeof props.remoteMethod === "function")) {
            states.previousQuery = val;
            return;
        }
        states.previousQuery = val;
        _vue.nextTick(()=>{
            var _a, _b;
            if (states.visible) (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
        });
        states.hoverIndex = -1;
        if (props.multiple && props.filterable) _vue.nextTick(()=>{
            const length = input.value.value.length * 15 + 20;
            states.inputLength = props.collapseTags ? Math.min(50, length) : length;
            managePlaceholder();
            resetInputHeight();
        });
        if (props.remote && typeof props.remoteMethod === "function") {
            states.hoverIndex = -1;
            props.remoteMethod(val);
        } else if (typeof props.filterMethod === "function") {
            props.filterMethod(val);
            _vue.triggerRef(groupQueryChange);
        } else {
            states.filteredOptionsCount = states.optionsCount;
            queryChange.value.query = val;
            _vue.triggerRef(queryChange);
            _vue.triggerRef(groupQueryChange);
        }
        if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) checkDefaultFirstOption();
    };
    const managePlaceholder = ()=>{
        if (states.currentPlaceholder !== "") states.currentPlaceholder = input.value.value ? "" : states.cachedPlaceHolder;
    };
    const checkDefaultFirstOption = ()=>{
        const optionsInDropdown = optionsArray.value.filter((n)=>n.visible && !n.disabled && !n.states.groupDisabled
        );
        const userCreatedOption = optionsInDropdown.filter((n)=>n.created
        )[0];
        const firstOriginOption = optionsInDropdown[0];
        states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
    };
    const setSelected = ()=>{
        var _a;
        if (!props.multiple) {
            const option = getOption(props.modelValue);
            if ((_a = option.props) == null ? void 0 : _a.created) {
                states.createdLabel = option.props.value;
                states.createdSelected = true;
            } else states.createdSelected = false;
            states.selectedLabel = option.currentLabel;
            states.selected = option;
            if (props.filterable) states.query = states.selectedLabel;
            return;
        }
        const result = [];
        if (Array.isArray(props.modelValue)) props.modelValue.forEach((value)=>{
            result.push(getOption(value));
        });
        states.selected = result;
        _vue.nextTick(()=>{
            resetInputHeight();
        });
    };
    const getOption = (value)=>{
        let option;
        const isObjectValue = _shared.toRawType(value).toLowerCase() === "object";
        const isNull = _shared.toRawType(value).toLowerCase() === "null";
        const isUndefined = _shared.toRawType(value).toLowerCase() === "undefined";
        for(let i = states.cachedOptions.size - 1; i >= 0; i--){
            const cachedOption = cachedOptionsArray.value[i];
            const isEqualValue = isObjectValue ? _lodashUnified.get(cachedOption.value, props.valueKey) === _lodashUnified.get(value, props.valueKey) : cachedOption.value === value;
            if (isEqualValue) {
                option = {
                    value,
                    currentLabel: cachedOption.currentLabel,
                    isDisabled: cachedOption.isDisabled
                };
                break;
            }
        }
        if (option) return option;
        const label = isObjectValue ? value.label : !isNull && !isUndefined ? value : "";
        const newOption = {
            value,
            currentLabel: label
        };
        if (props.multiple) newOption.hitState = false;
        return newOption;
    };
    const resetHoverIndex = ()=>{
        setTimeout(()=>{
            const valueKey = props.valueKey;
            if (!props.multiple) states.hoverIndex = optionsArray.value.findIndex((item)=>{
                return getValueKey(item) === getValueKey(states.selected);
            });
            else if (states.selected.length > 0) states.hoverIndex = Math.min.apply(null, states.selected.map((selected)=>{
                return optionsArray.value.findIndex((item)=>{
                    return _lodashUnified.get(item, valueKey) === _lodashUnified.get(selected, valueKey);
                });
            }));
            else states.hoverIndex = -1;
        }, 300);
    };
    const handleResize = ()=>{
        var _a, _b;
        resetInputWidth();
        (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
        if (props.multiple && !props.filterable) resetInputHeight();
    };
    const resetInputWidth = ()=>{
        var _a;
        states.inputWidth = (_a = reference.value) == null ? void 0 : _a.$el.getBoundingClientRect().width;
    };
    const onInputChange = ()=>{
        if (props.filterable && states.query !== states.selectedLabel) {
            states.query = states.selectedLabel;
            handleQueryChange(states.query);
        }
    };
    const debouncedOnInputChange = _lodashUnified.debounce(()=>{
        onInputChange();
    }, debounce$1.value);
    const debouncedQueryChange = _lodashUnified.debounce((e)=>{
        handleQueryChange(e.target.value);
    }, debounce$1.value);
    const emitChange = (val)=>{
        if (!_lodashUnified.isEqual(props.modelValue, val)) ctx.emit(_eventMjs.CHANGE_EVENT, val);
    };
    const deletePrevTag = (e)=>{
        if (e.target.value.length <= 0 && !toggleLastOptionHitState()) {
            const value = props.modelValue.slice();
            value.pop();
            ctx.emit(_eventMjs.UPDATE_MODEL_EVENT, value);
            emitChange(value);
        }
        if (e.target.value.length === 1 && props.modelValue.length === 0) states.currentPlaceholder = states.cachedPlaceHolder;
    };
    const deleteTag = (event, tag)=>{
        const index = states.selected.indexOf(tag);
        if (index > -1 && !selectDisabled.value) {
            const value = props.modelValue.slice();
            value.splice(index, 1);
            ctx.emit(_eventMjs.UPDATE_MODEL_EVENT, value);
            emitChange(value);
            ctx.emit("remove-tag", tag.value);
        }
        event.stopPropagation();
    };
    const deleteSelected = (event)=>{
        event.stopPropagation();
        const value = props.multiple ? [] : "";
        if (typeof value !== "string") {
            for (const item of states.selected)if (item.isDisabled) value.push(item.value);
        }
        ctx.emit(_eventMjs.UPDATE_MODEL_EVENT, value);
        emitChange(value);
        states.visible = false;
        ctx.emit("clear");
    };
    const handleOptionSelect = (option, byClick)=>{
        var _a;
        if (props.multiple) {
            const value = (props.modelValue || []).slice();
            const optionIndex = getValueIndex(value, option.value);
            if (optionIndex > -1) value.splice(optionIndex, 1);
            else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) value.push(option.value);
            ctx.emit(_eventMjs.UPDATE_MODEL_EVENT, value);
            emitChange(value);
            if (option.created) {
                states.query = "";
                handleQueryChange("");
                states.inputLength = 20;
            }
            if (props.filterable) (_a = input.value) == null || _a.focus();
        } else {
            ctx.emit(_eventMjs.UPDATE_MODEL_EVENT, option.value);
            emitChange(option.value);
            states.visible = false;
        }
        states.isSilentBlur = byClick;
        setSoftFocus();
        if (states.visible) return;
        _vue.nextTick(()=>{
            scrollToOption(option);
        });
    };
    const getValueIndex = (arr = [], value)=>{
        if (!_shared.isObject(value)) return arr.indexOf(value);
        const valueKey = props.valueKey;
        let index = -1;
        arr.some((item, i)=>{
            if (_lodashUnified.get(item, valueKey) === _lodashUnified.get(value, valueKey)) {
                index = i;
                return true;
            }
            return false;
        });
        return index;
    };
    const setSoftFocus = ()=>{
        states.softFocus = true;
        const _input = input.value || reference.value;
        if (_input) _input == null || _input.focus();
    };
    const scrollToOption = (option)=>{
        var _a, _b, _c, _d, _e;
        const targetOption = Array.isArray(option) ? option[0] : option;
        let target = null;
        if (targetOption == null ? void 0 : targetOption.value) {
            const options = optionsArray.value.filter((item)=>item.value === targetOption.value
            );
            if (options.length > 0) target = options[0].$el;
        }
        if (tooltipRef.value && target) {
            const menu = (_d = (_c = (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, ".el-select-dropdown__wrap");
            if (menu) _scrollMjs.scrollIntoView(menu, target);
        }
        (_e = scrollbar.value) == null || _e.handleScroll();
    };
    const onOptionCreate = (vm)=>{
        states.optionsCount++;
        states.filteredOptionsCount++;
        states.options.set(vm.value, vm);
        states.cachedOptions.set(vm.value, vm);
    };
    const onOptionDestroy = (key)=>{
        states.optionsCount--;
        states.filteredOptionsCount--;
        states.options.delete(key);
    };
    const resetInputState = (e)=>{
        if (e.code !== _ariaMjs.EVENT_CODE.backspace) toggleLastOptionHitState(false);
        states.inputLength = input.value.value.length * 15 + 20;
        resetInputHeight();
    };
    const toggleLastOptionHitState = (hit)=>{
        if (!Array.isArray(states.selected)) return;
        const option = states.selected[states.selected.length - 1];
        if (!option) return;
        if (hit === true || hit === false) {
            option.hitState = hit;
            return hit;
        }
        option.hitState = !option.hitState;
        return option.hitState;
    };
    const handleComposition = (event)=>{
        const text = event.target.value;
        if (event.type === "compositionend") {
            states.isOnComposition = false;
            _vue.nextTick(()=>handleQueryChange(text)
            );
        } else {
            const lastCharacter = text[text.length - 1] || "";
            states.isOnComposition = !_i18NMjs.isKorean(lastCharacter);
        }
    };
    const handleMenuEnter = ()=>{
        _vue.nextTick(()=>scrollToOption(states.selected)
        );
    };
    const handleFocus = (event)=>{
        if (!states.softFocus) {
            if (props.automaticDropdown || props.filterable) {
                states.visible = true;
                if (props.filterable) states.menuVisibleOnFocus = true;
            }
            ctx.emit("focus", event);
        } else states.softFocus = false;
    };
    const blur = ()=>{
        var _a;
        states.visible = false;
        (_a = reference.value) == null || _a.blur();
    };
    const handleBlur = (event)=>{
        _vue.nextTick(()=>{
            if (states.isSilentBlur) states.isSilentBlur = false;
            else ctx.emit("blur", event);
        });
        states.softFocus = false;
    };
    const handleClearClick = (event)=>{
        deleteSelected(event);
    };
    const handleClose = ()=>{
        states.visible = false;
    };
    const toggleMenu = ()=>{
        var _a;
        if (props.automaticDropdown) return;
        if (!selectDisabled.value) {
            if (states.menuVisibleOnFocus) states.menuVisibleOnFocus = false;
            else states.visible = !states.visible;
            if (states.visible) (_a = input.value || reference.value) == null || _a.focus();
        }
    };
    const selectOption = ()=>{
        if (!states.visible) toggleMenu();
        else if (optionsArray.value[states.hoverIndex]) handleOptionSelect(optionsArray.value[states.hoverIndex], void 0);
    };
    const getValueKey = (item)=>{
        return _shared.isObject(item.value) ? _lodashUnified.get(item.value, props.valueKey) : item.value;
    };
    const optionsAllDisabled = _vue.computed(()=>optionsArray.value.filter((option)=>option.visible
        ).every((option)=>option.disabled
        )
    );
    const navigateOptions = (direction)=>{
        if (!states.visible) {
            states.visible = true;
            return;
        }
        if (states.options.size === 0 || states.filteredOptionsCount === 0) return;
        if (states.isOnComposition) return;
        if (!optionsAllDisabled.value) {
            if (direction === "next") {
                states.hoverIndex++;
                if (states.hoverIndex === states.options.size) states.hoverIndex = 0;
            } else if (direction === "prev") {
                states.hoverIndex--;
                if (states.hoverIndex < 0) states.hoverIndex = states.options.size - 1;
            }
            const option = optionsArray.value[states.hoverIndex];
            if (option.disabled === true || option.states.groupDisabled === true || !option.visible) navigateOptions(direction);
            _vue.nextTick(()=>scrollToOption(hoverOption.value)
            );
        }
    };
    return {
        optionsArray,
        selectSize,
        handleResize,
        debouncedOnInputChange,
        debouncedQueryChange,
        deletePrevTag,
        deleteTag,
        deleteSelected,
        handleOptionSelect,
        scrollToOption,
        readonly,
        resetInputHeight,
        showClose,
        iconComponent,
        iconReverse,
        showNewOption,
        collapseTagSize,
        setSelected,
        managePlaceholder,
        selectDisabled,
        emptyText,
        toggleLastOptionHitState,
        resetInputState,
        handleComposition,
        onOptionCreate,
        onOptionDestroy,
        handleMenuEnter,
        handleFocus,
        blur,
        handleBlur,
        handleClearClick,
        handleClose,
        toggleMenu,
        selectOption,
        getValueKey,
        navigateOptions,
        dropMenuVisible,
        queryChange,
        groupQueryChange,
        reference,
        input,
        tooltipRef,
        tags,
        selectWrapper,
        scrollbar
    };
};

},{"vue":"gzxs9","@vue/shared":"3SM3y","lodash-unified":"4Oj4p","@vueuse/core":"eEHP9","../../../constants/index.mjs":"74Fbn","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","../../../tokens/index.mjs":"wVNQi","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../tokens/form.mjs":"2r4O0","../../../hooks/use-common-props/index.mjs":"05czU","../../../constants/event.mjs":"92xVn","../../../utils/dom/scroll.mjs":"hpitc","../../../constants/aria.mjs":"jS6iK","../../../utils/i18n.mjs":"5xQne","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dEleR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>OptionGroup
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _tokenMjs = require("./token.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElOptionGroup",
    componentName: "ElOptionGroup",
    props: {
        label: String,
        disabled: {
            type: Boolean,
            default: false
        }
    },
    setup (props) {
        const ns = _indexMjs1.useNamespace("select");
        const visible = _vue.ref(true);
        const instance = _vue.getCurrentInstance();
        const children = _vue.ref([]);
        _vue.provide(_tokenMjs.selectGroupKey, _vue.reactive({
            ..._vue.toRefs(props)
        }));
        const select = _vue.inject(_tokenMjs.selectKey);
        _vue.onMounted(()=>{
            children.value = flattedChildren(instance.subTree);
        });
        const flattedChildren = (node)=>{
            const children2 = [];
            if (Array.isArray(node.children)) node.children.forEach((child)=>{
                var _a;
                if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) children2.push(child.component.proxy);
                else if ((_a = child.children) == null ? void 0 : _a.length) children2.push(...flattedChildren(child));
            });
            return children2;
        };
        const { groupQueryChange  } = _vue.toRaw(select);
        _vue.watch(groupQueryChange, ()=>{
            visible.value = children.value.some((option)=>option.visible === true
            );
        });
        return {
            visible,
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("ul", {
        class: _vue.normalizeClass(_ctx.ns.be("group", "wrap"))
    }, [
        _vue.createElementVNode("li", {
            class: _vue.normalizeClass(_ctx.ns.be("group", "title"))
        }, _vue.toDisplayString(_ctx.label), 3),
        _vue.createElementVNode("li", null, [
            _vue.createElementVNode("ul", {
                class: _vue.normalizeClass(_ctx.ns.b("group"))
            }, [
                _vue.renderSlot(_ctx.$slots, "default")
            ], 2)
        ])
    ], 2)), [
        [
            _vue.vShow,
            _ctx.visible
        ]
    ]);
}
var OptionGroup = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./token.mjs":"cOSZy","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b5Iy0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "usePagination", ()=>usePagination
);
var _vue = require("vue");
var _indexMjs = require("../../../tokens/index.mjs");
var _paginationMjs = require("../../../tokens/pagination.mjs");
const usePagination = ()=>_vue.inject(_paginationMjs.elPaginationKey, {
    })
;

},{"vue":"gzxs9","../../../tokens/index.mjs":"wVNQi","../../../tokens/pagination.mjs":"9NXrn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dGl7n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Jumper
);
var _vue = require("vue");
var _indexMjs = require("../../../../hooks/index.mjs");
var _indexMjs1 = require("../../../input/index.mjs");
var _usePaginationMjs = require("../usePagination.mjs");
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../../hooks/use-locale/index.mjs");
var _indexMjs3 = require("../../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElPaginationJumper",
    components: {
        ElInput: _indexMjs1.ElInput
    },
    setup () {
        const { t  } = _indexMjs2.useLocale();
        const ns = _indexMjs3.useNamespace("pagination");
        const { pageCount , disabled , currentPage , changeEvent  } = _usePaginationMjs.usePagination();
        const userInput = _vue.ref();
        const innerValue = _vue.computed(()=>{
            var _a;
            return (_a = userInput.value) != null ? _a : currentPage == null ? void 0 : currentPage.value;
        });
        function handleInput(val) {
            userInput.value = +val;
        }
        function handleChange(val) {
            val = Math.trunc(+val);
            changeEvent == null || changeEvent(+val);
            userInput.value = void 0;
        }
        return {
            ns,
            pageCount,
            disabled,
            innerValue,
            t,
            handleInput,
            handleChange
        };
    }
});
const _hoisted_1 = [
    "disabled"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_input = _vue.resolveComponent("el-input");
    return _vue.openBlock(), _vue.createElementBlock("span", {
        class: _vue.normalizeClass(_ctx.ns.e("jump")),
        disabled: _ctx.disabled
    }, [
        _vue.createTextVNode(_vue.toDisplayString(_ctx.t("el.pagination.goto")) + " ", 1),
        _vue.createVNode(_component_el_input, {
            size: "small",
            class: _vue.normalizeClass([
                _ctx.ns.e("editor"),
                _ctx.ns.is("in-pagination")
            ]),
            min: 1,
            max: _ctx.pageCount,
            disabled: _ctx.disabled,
            "model-value": _ctx.innerValue,
            type: "number",
            "onUpdate:modelValue": _ctx.handleInput,
            onChange: _ctx.handleChange
        }, null, 8, [
            "class",
            "max",
            "disabled",
            "model-value",
            "onUpdate:modelValue",
            "onChange"
        ]),
        _vue.createTextVNode(" " + _vue.toDisplayString(_ctx.t("el.pagination.pageClassifier")), 1)
    ], 10, _hoisted_1);
}
var Jumper = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../../hooks/index.mjs":"1Ansp","../../../input/index.mjs":"18eQI","../usePagination.mjs":"b5Iy0","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../hooks/use-locale/index.mjs":"c1HoA","../../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8fzkt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Total
);
var _vue = require("vue");
var _indexMjs = require("../../../../hooks/index.mjs");
var _usePaginationMjs = require("../usePagination.mjs");
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../../hooks/use-locale/index.mjs");
var _indexMjs2 = require("../../../../hooks/use-namespace/index.mjs");
const paginationTotalProps = {
    total: {
        type: Number,
        default: 1000
    }
};
const _sfc_main = _vue.defineComponent({
    name: "ElPaginationTotal",
    props: paginationTotalProps,
    setup () {
        const { t  } = _indexMjs1.useLocale();
        const ns = _indexMjs2.useNamespace("pagination");
        const { disabled  } = _usePaginationMjs.usePagination();
        return {
            t,
            ns,
            disabled
        };
    }
});
const _hoisted_1 = [
    "disabled"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("span", {
        class: _vue.normalizeClass(_ctx.ns.e("total")),
        disabled: _ctx.disabled
    }, _vue.toDisplayString(_ctx.t("el.pagination.total", {
        total: _ctx.total
    })), 11, _hoisted_1);
}
var Total = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../../hooks/index.mjs":"1Ansp","../usePagination.mjs":"b5Iy0","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../hooks/use-locale/index.mjs":"c1HoA","../../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g4RaC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Pager
);
var _vue = require("vue");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs = require("../../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../../hooks/use-namespace/index.mjs");
const paginationPagerProps = {
    currentPage: {
        type: Number,
        default: 1
    },
    pageCount: {
        type: Number,
        required: true
    },
    pagerCount: {
        type: Number,
        default: 7
    },
    disabled: Boolean
};
const _sfc_main = _vue.defineComponent({
    name: "ElPaginationPager",
    components: {
        DArrowLeft: _iconsVue.DArrowLeft,
        DArrowRight: _iconsVue.DArrowRight,
        MoreFilled: _iconsVue.MoreFilled
    },
    props: paginationPagerProps,
    emits: [
        "change"
    ],
    setup (props, { emit  }) {
        const nsPager = _indexMjs1.useNamespace("pager");
        const nsIcon = _indexMjs1.useNamespace("icon");
        const showPrevMore = _vue.ref(false);
        const showNextMore = _vue.ref(false);
        const quickPrevHover = _vue.ref(false);
        const quickNextHover = _vue.ref(false);
        const pagers = _vue.computed(()=>{
            const pagerCount = props.pagerCount;
            const halfPagerCount = (pagerCount - 1) / 2;
            const currentPage = Number(props.currentPage);
            const pageCount = Number(props.pageCount);
            let showPrevMore2 = false;
            let showNextMore2 = false;
            if (pageCount > pagerCount) {
                if (currentPage > pagerCount - halfPagerCount) showPrevMore2 = true;
                if (currentPage < pageCount - halfPagerCount) showNextMore2 = true;
            }
            const array = [];
            if (showPrevMore2 && !showNextMore2) {
                const startPage = pageCount - (pagerCount - 2);
                for(let i = startPage; i < pageCount; i++)array.push(i);
            } else if (!showPrevMore2 && showNextMore2) for(let i = 2; i < pagerCount; i++)array.push(i);
            else if (showPrevMore2 && showNextMore2) {
                const offset = Math.floor(pagerCount / 2) - 1;
                for(let i = currentPage - offset; i <= currentPage + offset; i++)array.push(i);
            } else for(let i1 = 2; i1 < pageCount; i1++)array.push(i1);
            return array;
        });
        _vue.watchEffect(()=>{
            const halfPagerCount = (props.pagerCount - 1) / 2;
            showPrevMore.value = false;
            showNextMore.value = false;
            if (props.pageCount > props.pagerCount) {
                if (props.currentPage > props.pagerCount - halfPagerCount) showPrevMore.value = true;
                if (props.currentPage < props.pageCount - halfPagerCount) showNextMore.value = true;
            }
        });
        function onMouseenter(direction) {
            if (props.disabled) return;
            if (direction === "left") quickPrevHover.value = true;
            else quickNextHover.value = true;
        }
        function onEnter(e) {
            const target = e.target;
            if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("number")) {
                const newPage = Number(target.textContent);
                if (newPage !== props.currentPage) emit("change", newPage);
            }
        }
        function onPagerClick(event) {
            const target = event.target;
            if (target.tagName.toLowerCase() === "ul" || props.disabled) return;
            let newPage = Number(target.textContent);
            const pageCount = props.pageCount;
            const currentPage = props.currentPage;
            const pagerCountOffset = props.pagerCount - 2;
            if (target.className.includes("more")) {
                if (target.className.includes("quickprev")) newPage = currentPage - pagerCountOffset;
                else if (target.className.includes("quicknext")) newPage = currentPage + pagerCountOffset;
            }
            if (!isNaN(newPage)) {
                if (newPage < 1) newPage = 1;
                if (newPage > pageCount) newPage = pageCount;
            }
            if (newPage !== currentPage) emit("change", newPage);
        }
        return {
            showPrevMore,
            showNextMore,
            quickPrevHover,
            quickNextHover,
            pagers,
            nsPager,
            nsIcon,
            onMouseenter,
            onPagerClick,
            onEnter
        };
    }
});
const _hoisted_1 = [
    "aria-current"
];
const _hoisted_2 = [
    "aria-current"
];
const _hoisted_3 = [
    "aria-current"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_d_arrow_left = _vue.resolveComponent("d-arrow-left");
    const _component_more_filled = _vue.resolveComponent("more-filled");
    const _component_d_arrow_right = _vue.resolveComponent("d-arrow-right");
    return _vue.openBlock(), _vue.createElementBlock("ul", {
        class: _vue.normalizeClass(_ctx.nsPager.b()),
        onClick: _cache[4] || (_cache[4] = (...args)=>_ctx.onPagerClick && _ctx.onPagerClick(...args)
        ),
        onKeyup: _cache[5] || (_cache[5] = _vue.withKeys((...args)=>_ctx.onEnter && _ctx.onEnter(...args)
        , [
            "enter"
        ]))
    }, [
        _ctx.pageCount > 0 ? (_vue.openBlock(), _vue.createElementBlock("li", {
            key: 0,
            class: _vue.normalizeClass([
                {
                    active: _ctx.currentPage === 1,
                    disabled: _ctx.disabled
                },
                "number"
            ]),
            "aria-current": _ctx.currentPage === 1,
            tabindex: "0"
        }, " 1 ", 10, _hoisted_1)) : _vue.createCommentVNode("v-if", true),
        _ctx.showPrevMore ? (_vue.openBlock(), _vue.createElementBlock("li", {
            key: 1,
            class: _vue.normalizeClass([
                "more",
                "btn-quickprev",
                _ctx.nsIcon.b(),
                {
                    disabled: _ctx.disabled
                }
            ]),
            onMouseenter: _cache[0] || (_cache[0] = ($event)=>_ctx.onMouseenter("left")
            ),
            onMouseleave: _cache[1] || (_cache[1] = ($event)=>_ctx.quickPrevHover = false
            )
        }, [
            _ctx.quickPrevHover ? (_vue.openBlock(), _vue.createBlock(_component_d_arrow_left, {
                key: 0
            })) : (_vue.openBlock(), _vue.createBlock(_component_more_filled, {
                key: 1
            }))
        ], 34)) : _vue.createCommentVNode("v-if", true),
        (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.pagers, (pager)=>{
            return _vue.openBlock(), _vue.createElementBlock("li", {
                key: pager,
                class: _vue.normalizeClass([
                    {
                        active: _ctx.currentPage === pager,
                        disabled: _ctx.disabled
                    },
                    "number"
                ]),
                "aria-current": _ctx.currentPage === pager,
                tabindex: "0"
            }, _vue.toDisplayString(pager), 11, _hoisted_2);
        }), 128)),
        _ctx.showNextMore ? (_vue.openBlock(), _vue.createElementBlock("li", {
            key: 2,
            class: _vue.normalizeClass([
                "more",
                "btn-quicknext",
                _ctx.nsIcon.b(),
                {
                    disabled: _ctx.disabled
                }
            ]),
            onMouseenter: _cache[2] || (_cache[2] = ($event)=>_ctx.onMouseenter("right")
            ),
            onMouseleave: _cache[3] || (_cache[3] = ($event)=>_ctx.quickNextHover = false
            )
        }, [
            _ctx.quickNextHover ? (_vue.openBlock(), _vue.createBlock(_component_d_arrow_right, {
                key: 0
            })) : (_vue.openBlock(), _vue.createBlock(_component_more_filled, {
                key: 1
            }))
        ], 34)) : _vue.createCommentVNode("v-if", true),
        _ctx.pageCount > 1 ? (_vue.openBlock(), _vue.createElementBlock("li", {
            key: 3,
            class: _vue.normalizeClass([
                {
                    active: _ctx.currentPage === _ctx.pageCount,
                    disabled: _ctx.disabled
                },
                "number"
            ]),
            "aria-current": _ctx.currentPage === _ctx.pageCount,
            tabindex: "0"
        }, _vue.toDisplayString(_ctx.pageCount), 11, _hoisted_3)) : _vue.createCommentVNode("v-if", true)
    ], 34);
}
var Pager = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@element-plus/icons-vue":"b18uu","../../../../hooks/index.mjs":"1Ansp","../../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ds8jY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popconfirmProps", ()=>_popconfirmMjs.popconfirmProps
);
parcelHelpers.export(exports, "ElPopconfirm", ()=>ElPopconfirm
);
parcelHelpers.export(exports, "default", ()=>ElPopconfirm
);
var _indexMjs = require("../../utils/index.mjs");
var _popconfirm2Mjs = require("./src/popconfirm2.mjs");
var _popconfirm2MjsDefault = parcelHelpers.interopDefault(_popconfirm2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _popconfirmMjs = require("./src/popconfirm.mjs");
const ElPopconfirm = _installMjs.withInstall(_popconfirm2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/popconfirm2.mjs":"l9YGH","../../utils/vue/install.mjs":"4TMmv","./src/popconfirm.mjs":"PeZMy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l9YGH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Popconfirm
);
var _vue = require("vue");
var _indexMjs = require("../../button/index.mjs");
var _indexMjs1 = require("../../icon/index.mjs");
var _indexMjs2 = require("../../tooltip/index.mjs");
var _indexMjs3 = require("../../popper/index.mjs");
var _indexMjs4 = require("../../../hooks/index.mjs");
var _popconfirmMjs = require("./popconfirm.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _deprecationMjs = require("../../popper/src/deprecation.mjs");
var _indexMjs5 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs6 = require("../../../hooks/use-namespace/index.mjs");
const COMPONENT_NAME = "ElPopconfirm";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    components: {
        ElButton: _indexMjs.ElButton,
        ElTooltip: _indexMjs2.ElTooltip,
        ElIcon: _indexMjs1.ElIcon
    },
    props: _popconfirmMjs.popconfirmProps,
    setup (props) {
        const { compatTeleported  } = _deprecationMjs.useDeprecateAppendToBody(COMPONENT_NAME, "appendToBody");
        const { t  } = _indexMjs5.useLocale();
        const ns = _indexMjs6.useNamespace("popconfirm");
        const tooltipRef = _vue.ref();
        const hidePopper = ()=>{
            var _a, _b;
            (_b = (_a = _vue.unref(tooltipRef)) == null ? void 0 : _a.onClose) == null || _b.call(_a);
        };
        const handleCallback = ()=>{
            hidePopper();
        };
        const confirm = (e)=>{
            var _a;
            (_a = props.onConfirm) == null || _a.call(props, e);
            handleCallback();
        };
        const cancel = (e)=>{
            var _a;
            (_a = props.onCancel) == null || _a.call(props, e);
            handleCallback();
        };
        const finalConfirmButtonText = _vue.computed(()=>props.confirmButtonText || t("el.popconfirm.confirmButtonText")
        );
        const finalCancelButtonText = _vue.computed(()=>props.cancelButtonText || t("el.popconfirm.cancelButtonText")
        );
        return {
            finalConfirmButtonText,
            finalCancelButtonText,
            tooltipRef,
            ns,
            compatTeleported,
            confirm,
            cancel
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_button = _vue.resolveComponent("el-button");
    const _component_el_tooltip = _vue.resolveComponent("el-tooltip");
    return _vue.openBlock(), _vue.createBlock(_component_el_tooltip, _vue.mergeProps({
        ref: "tooltipRef"
    }, _ctx.$attrs, {
        trigger: "click",
        effect: "light",
        "popper-class": `${_ctx.ns.namespace.value}-popover`,
        teleported: _ctx.compatTeleported,
        "fallback-placements": [
            "bottom",
            "top",
            "right",
            "left"
        ],
        "hide-after": _ctx.hideAfter,
        persistent: ""
    }), {
        content: _vue.withCtx(()=>[
                _vue.createElementVNode("div", {
                    class: _vue.normalizeClass(_ctx.ns.b())
                }, [
                    _vue.createElementVNode("div", {
                        class: _vue.normalizeClass(_ctx.ns.e("main"))
                    }, [
                        !_ctx.hideIcon && _ctx.icon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                            key: 0,
                            class: _vue.normalizeClass(_ctx.ns.e("icon")),
                            style: _vue.normalizeStyle({
                                color: _ctx.iconColor
                            })
                        }, {
                            default: _vue.withCtx(()=>[
                                    (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.icon)))
                                ]
                            ),
                            _: 1
                        }, 8, [
                            "class",
                            "style"
                        ])) : _vue.createCommentVNode("v-if", true),
                        _vue.createTextVNode(" " + _vue.toDisplayString(_ctx.title), 1)
                    ], 2),
                    _vue.createElementVNode("div", {
                        class: _vue.normalizeClass(_ctx.ns.e("action"))
                    }, [
                        _vue.createVNode(_component_el_button, {
                            size: "small",
                            type: _ctx.cancelButtonType,
                            onClick: _ctx.cancel
                        }, {
                            default: _vue.withCtx(()=>[
                                    _vue.createTextVNode(_vue.toDisplayString(_ctx.finalCancelButtonText), 1)
                                ]
                            ),
                            _: 1
                        }, 8, [
                            "type",
                            "onClick"
                        ]),
                        _vue.createVNode(_component_el_button, {
                            size: "small",
                            type: _ctx.confirmButtonType,
                            onClick: _ctx.confirm
                        }, {
                            default: _vue.withCtx(()=>[
                                    _vue.createTextVNode(_vue.toDisplayString(_ctx.finalConfirmButtonText), 1)
                                ]
                            ),
                            _: 1
                        }, 8, [
                            "type",
                            "onClick"
                        ])
                    ], 2)
                ], 2)
            ]
        ),
        default: _vue.withCtx(()=>[
                _ctx.$slots.reference ? _vue.renderSlot(_ctx.$slots, "reference", {
                    key: 0
                }) : _vue.createCommentVNode("v-if", true)
            ]
        ),
        _: 3
    }, 16, [
        "popper-class",
        "teleported",
        "hide-after"
    ]);
}
var Popconfirm = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../button/index.mjs":"64Ym1","../../icon/index.mjs":"hnNTG","../../tooltip/index.mjs":"kiwBC","../../popper/index.mjs":"kIV7g","../../../hooks/index.mjs":"1Ansp","./popconfirm.mjs":"PeZMy","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../popper/src/deprecation.mjs":"jm0Kb","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"PeZMy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popconfirmProps", ()=>popconfirmProps
);
var _indexMjs = require("../../button/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../tooltip/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _buttonMjs = require("../../button/src/button.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _tooltipMjs = require("../../tooltip/src/tooltip.mjs");
const popconfirmProps = _propsMjs.buildProps({
    title: {
        type: String
    },
    confirmButtonText: {
        type: String
    },
    cancelButtonText: {
        type: String
    },
    confirmButtonType: {
        type: String,
        values: _buttonMjs.buttonTypes,
        default: "primary"
    },
    cancelButtonType: {
        type: String,
        values: _buttonMjs.buttonTypes,
        default: "text"
    },
    icon: {
        type: _iconMjs.iconPropType,
        default: _iconsVue.QuestionFilled
    },
    iconColor: {
        type: String,
        default: "#f90"
    },
    hideIcon: {
        type: Boolean,
        default: false
    },
    hideAfter: {
        type: Number,
        default: 200
    },
    onConfirm: {
        type: _propsMjs.definePropType(Function)
    },
    onCancel: {
        type: _propsMjs.definePropType(Function)
    },
    teleported: _tooltipMjs.useTooltipContentProps.teleported
});

},{"../../button/index.mjs":"64Ym1","@element-plus/icons-vue":"b18uu","../../../utils/index.mjs":"dsdeP","../../tooltip/index.mjs":"kiwBC","../../../utils/vue/props.mjs":"cpwWK","../../button/src/button.mjs":"8GILO","../../../utils/vue/icon.mjs":"3YbE5","../../tooltip/src/tooltip.mjs":"7LVFi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cnet0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElPopover", ()=>ElPopover
);
parcelHelpers.export(exports, "ElPopoverDirective", ()=>ElPopoverDirective
);
parcelHelpers.export(exports, "default", ()=>_Popover
);
var _indexMjs = require("./src/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _directiveMjs = require("./src/directive.mjs");
var _directiveMjsDefault = parcelHelpers.interopDefault(_directiveMjs);
_indexMjsDefault.default.install = (app)=>{
    app.component(_indexMjsDefault.default.name, _indexMjsDefault.default);
};
_directiveMjsDefault.default.install = (app)=>{
    app.directive(_directiveMjs.VPopover, _directiveMjsDefault.default);
};
const _PopoverDirective = _directiveMjsDefault.default;
_indexMjsDefault.default.directive = _PopoverDirective;
const _Popover = _indexMjsDefault.default;
const ElPopover = _Popover;
const ElPopoverDirective = _PopoverDirective;

},{"./src/index.mjs":"2tewi","./src/directive.mjs":"fkp7Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2tewi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Popover
);
var _vue = require("vue");
var _indexMjs = require("../../tooltip/index.mjs");
var _indexMjs1 = require("../../popper/index.mjs");
var _indexMjs2 = require("../../../utils/index.mjs");
var _indexMjs3 = require("../../../hooks/index.mjs");
var _popoverMjs = require("./popover.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs4 = require("../../../hooks/use-namespace/index.mjs");
var _shared = require("@vue/shared");
var _deprecationMjs = require("../../popper/src/deprecation.mjs");
const emits = [
    "update:visible",
    "after-enter",
    "after-leave"
];
const COMPONENT_NAME = "ElPopover";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    components: {
        ElTooltip: _indexMjs.ElTooltip
    },
    props: _popoverMjs.usePopoverProps,
    emits,
    setup (props, { emit  }) {
        const ns = _indexMjs4.useNamespace("popover");
        const tooltipRef = _vue.ref(null);
        const popperRef = _vue.computed(()=>{
            var _a;
            return (_a = _vue.unref(tooltipRef)) == null ? void 0 : _a.popperRef;
        });
        const width = _vue.computed(()=>{
            if (_shared.isString(props.width)) return props.width;
            return `${props.width}px`;
        });
        const style = _vue.computed(()=>{
            return [
                {
                    width: width.value
                },
                props.popperStyle
            ];
        });
        const kls = _vue.computed(()=>{
            return [
                ns.b(),
                props.popperClass,
                {
                    [ns.m("plain")]: !!props.content
                }
            ];
        });
        const { compatTeleported  } = _deprecationMjs.useDeprecateAppendToBody(COMPONENT_NAME, "appendToBody");
        const hide = ()=>{
            var _a;
            (_a = tooltipRef.value) == null || _a.hide();
        };
        const afterEnter = ()=>{
            emit("after-enter");
        };
        const afterLeave = ()=>{
            emit("after-leave");
        };
        return {
            compatTeleported,
            ns,
            kls,
            style,
            tooltipRef,
            popperRef,
            hide,
            afterEnter,
            afterLeave
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_tooltip = _vue.resolveComponent("el-tooltip");
    return _vue.openBlock(), _vue.createBlock(_component_el_tooltip, _vue.mergeProps({
        ref: "tooltipRef"
    }, _ctx.$attrs, {
        trigger: _ctx.trigger,
        placement: _ctx.placement,
        disabled: _ctx.disabled,
        visible: _ctx.visible,
        transition: _ctx.transition,
        "popper-options": _ctx.popperOptions,
        tabindex: _ctx.tabindex,
        "append-to-body": _ctx.appendToBody,
        content: _ctx.content,
        offset: _ctx.offset,
        "show-after": _ctx.showAfter,
        "hide-after": _ctx.hideAfter,
        "auto-close": _ctx.autoClose,
        "show-arrow": _ctx.showArrow,
        "aria-label": _ctx.title,
        effect: _ctx.effect,
        enterable: _ctx.enterable,
        "popper-class": _ctx.kls,
        "popper-style": _ctx.style,
        teleported: _ctx.compatTeleported,
        persistent: "",
        onShow: _ctx.afterEnter,
        onHide: _ctx.afterLeave
    }), {
        content: _vue.withCtx(()=>[
                _ctx.title ? (_vue.openBlock(), _vue.createElementBlock("div", {
                    key: 0,
                    class: _vue.normalizeClass(_ctx.ns.e("title")),
                    role: "title"
                }, _vue.toDisplayString(_ctx.title), 3)) : _vue.createCommentVNode("v-if", true),
                _vue.renderSlot(_ctx.$slots, "default", {
                }, ()=>[
                        _vue.createTextVNode(_vue.toDisplayString(_ctx.content), 1)
                    ]
                )
            ]
        ),
        default: _vue.withCtx(()=>[
                _ctx.$slots.reference ? _vue.renderSlot(_ctx.$slots, "reference", {
                    key: 0
                }) : _vue.createCommentVNode("v-if", true)
            ]
        ),
        _: 3
    }, 16, [
        "trigger",
        "placement",
        "disabled",
        "visible",
        "transition",
        "popper-options",
        "tabindex",
        "append-to-body",
        "content",
        "offset",
        "show-after",
        "hide-after",
        "auto-close",
        "show-arrow",
        "aria-label",
        "effect",
        "enterable",
        "popper-class",
        "popper-style",
        "teleported",
        "onShow",
        "onHide"
    ]);
}
var Popover = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../tooltip/index.mjs":"kiwBC","../../popper/index.mjs":"kIV7g","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./popover.mjs":"gjIhQ","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@vue/shared":"3SM3y","../../popper/src/deprecation.mjs":"jm0Kb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gjIhQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "usePopoverProps", ()=>usePopoverProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../tooltip/index.mjs");
var _indexMjs2 = require("../../dropdown/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _tooltipMjs = require("../../tooltip/src/tooltip.mjs");
var _dropdownMjs = require("../../dropdown/src/dropdown.mjs");
const usePopoverProps = _propsMjs.buildProps({
    trigger: _tooltipMjs.useTooltipTriggerProps.trigger,
    placement: _dropdownMjs.dropdownProps.placement,
    disabled: _tooltipMjs.useTooltipTriggerProps.disabled,
    visible: _tooltipMjs.useTooltipContentProps.visible,
    transition: _tooltipMjs.useTooltipContentProps.transition,
    popperOptions: _dropdownMjs.dropdownProps.popperOptions,
    tabindex: _dropdownMjs.dropdownProps.tabindex,
    appendToBody: {
        type: Boolean,
        default: void 0
    },
    content: _tooltipMjs.useTooltipContentProps.content,
    popperStyle: _tooltipMjs.useTooltipContentProps.popperStyle,
    popperClass: _tooltipMjs.useTooltipContentProps.popperClass,
    enterable: {
        ..._tooltipMjs.useTooltipContentProps.enterable,
        default: true
    },
    effect: {
        ..._tooltipMjs.useTooltipContentProps.effect,
        default: "light"
    },
    teleported: _tooltipMjs.useTooltipContentProps.teleported,
    title: String,
    width: {
        type: [
            String,
            Number
        ],
        default: 150
    },
    offset: {
        type: Number,
        default: void 0
    },
    showAfter: {
        type: Number,
        default: 0
    },
    hideAfter: {
        type: Number,
        default: 200
    },
    autoClose: {
        type: Number,
        default: 0
    },
    showArrow: {
        type: Boolean,
        default: true
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../tooltip/index.mjs":"kiwBC","../../dropdown/index.mjs":"dk8yW","../../../utils/vue/props.mjs":"cpwWK","../../tooltip/src/tooltip.mjs":"7LVFi","../../dropdown/src/dropdown.mjs":"7C9Hj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fkp7Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VPopover", ()=>VPopover
);
parcelHelpers.export(exports, "default", ()=>PopoverDirective
);
const attachEvents = (el, binding)=>{
    const popperComponent = binding.arg || binding.value;
    const popover = popperComponent == null ? void 0 : popperComponent.popperRef;
    if (popover) popover.triggerRef = el;
};
var PopoverDirective = {
    mounted (el, binding) {
        attachEvents(el, binding);
    },
    updated (el, binding) {
        attachEvents(el, binding);
    }
};
const VPopover = "popover";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9ijV7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "progressProps", ()=>_progressMjs.progressProps
);
parcelHelpers.export(exports, "ElProgress", ()=>ElProgress
);
parcelHelpers.export(exports, "default", ()=>ElProgress
);
var _indexMjs = require("../../utils/index.mjs");
var _progress2Mjs = require("./src/progress2.mjs");
var _progress2MjsDefault = parcelHelpers.interopDefault(_progress2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _progressMjs = require("./src/progress.mjs");
const ElProgress = _installMjs.withInstall(_progress2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/progress2.mjs":"8M1Oa","../../utils/vue/install.mjs":"4TMmv","./src/progress.mjs":"iea9L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8M1Oa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Progress
);
var _vue = require("vue");
var _indexMjs = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _progressMjs = require("./progress.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElProgress",
    components: {
        ElIcon: _indexMjs.ElIcon,
        CircleCheck: _iconsVue.CircleCheck,
        CircleClose: _iconsVue.CircleClose,
        Check: _iconsVue.Check,
        Close: _iconsVue.Close,
        WarningFilled: _iconsVue.WarningFilled
    },
    props: _progressMjs.progressProps,
    setup (props) {
        const ns = _indexMjs2.useNamespace("progress");
        const barStyle = _vue.computed(()=>({
                width: `${props.percentage}%`,
                animationDuration: `${props.duration}s`,
                backgroundColor: getCurrentColor(props.percentage)
            })
        );
        const relativeStrokeWidth = _vue.computed(()=>(props.strokeWidth / props.width * 100).toFixed(1)
        );
        const radius = _vue.computed(()=>{
            if (props.type === "circle" || props.type === "dashboard") return parseInt(`${50 - parseFloat(relativeStrokeWidth.value) / 2}`, 10);
            else return 0;
        });
        const trackPath = _vue.computed(()=>{
            const r = radius.value;
            const isDashboard = props.type === "dashboard";
            return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
        });
        const perimeter = _vue.computed(()=>2 * Math.PI * radius.value
        );
        const rate = _vue.computed(()=>props.type === "dashboard" ? 0.75 : 1
        );
        const strokeDashoffset = _vue.computed(()=>{
            const offset = -1 * perimeter.value * (1 - rate.value) / 2;
            return `${offset}px`;
        });
        const trailPathStyle = _vue.computed(()=>({
                strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
                strokeDashoffset: strokeDashoffset.value
            })
        );
        const circlePathStyle = _vue.computed(()=>({
                strokeDasharray: `${perimeter.value * rate.value * (props.percentage / 100)}px, ${perimeter.value}px`,
                strokeDashoffset: strokeDashoffset.value,
                transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease"
            })
        );
        const stroke = _vue.computed(()=>{
            let ret;
            if (props.color) ret = getCurrentColor(props.percentage);
            else switch(props.status){
                case "success":
                    ret = "#13ce66";
                    break;
                case "exception":
                    ret = "#ff4949";
                    break;
                case "warning":
                    ret = "#e6a23c";
                    break;
                default:
                    ret = "#20a0ff";
            }
            return ret;
        });
        const statusIcon = _vue.computed(()=>{
            if (props.status === "warning") return _iconsVue.WarningFilled;
            if (props.type === "line") return props.status === "success" ? _iconsVue.CircleCheck : _iconsVue.CircleClose;
            else return props.status === "success" ? _iconsVue.Check : _iconsVue.Close;
        });
        const progressTextSize = _vue.computed(()=>{
            return props.type === "line" ? 12 + props.strokeWidth * 0.4 : props.width * 0.111111 + 2;
        });
        const content = _vue.computed(()=>props.format(props.percentage)
        );
        const getCurrentColor = (percentage)=>{
            var _a;
            const { color  } = props;
            if (typeof color === "function") return color(percentage);
            else if (typeof color === "string") return color;
            else {
                const span = 100 / color.length;
                const seriesColors = color.map((seriesColor, index)=>{
                    if (typeof seriesColor === "string") return {
                        color: seriesColor,
                        percentage: (index + 1) * span
                    };
                    return seriesColor;
                });
                const colors = seriesColors.sort((a, b)=>a.percentage - b.percentage
                );
                for (const color2 of colors){
                    if (color2.percentage > percentage) return color2.color;
                }
                return (_a = colors[colors.length - 1]) == null ? void 0 : _a.color;
            }
        };
        const slotData = _vue.computed(()=>{
            return {
                percentage: props.percentage
            };
        });
        return {
            ns,
            barStyle,
            relativeStrokeWidth,
            radius,
            trackPath,
            perimeter,
            rate,
            strokeDashoffset,
            trailPathStyle,
            circlePathStyle,
            stroke,
            statusIcon,
            progressTextSize,
            content,
            slotData
        };
    }
});
const _hoisted_1 = [
    "aria-valuenow"
];
const _hoisted_2 = {
    viewBox: "0 0 100 100"
};
const _hoisted_3 = [
    "d",
    "stroke-width"
];
const _hoisted_4 = [
    "d",
    "stroke",
    "stroke-linecap",
    "stroke-width"
];
const _hoisted_5 = {
    key: 0
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.m(_ctx.type),
            _ctx.ns.is(_ctx.status),
            {
                [_ctx.ns.m("without-text")]: !_ctx.showText,
                [_ctx.ns.m("text-inside")]: _ctx.textInside
            }
        ]),
        role: "progressbar",
        "aria-valuenow": _ctx.percentage,
        "aria-valuemin": "0",
        "aria-valuemax": "100"
    }, [
        _ctx.type === "line" ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.b("bar"))
        }, [
            _vue.createElementVNode("div", {
                class: _vue.normalizeClass(_ctx.ns.be("bar", "outer")),
                style: _vue.normalizeStyle({
                    height: `${_ctx.strokeWidth}px`
                })
            }, [
                _vue.createElementVNode("div", {
                    class: _vue.normalizeClass([
                        _ctx.ns.be("bar", "inner"),
                        {
                            [_ctx.ns.bem("bar", "inner", "indeterminate")]: _ctx.indeterminate
                        }
                    ]),
                    style: _vue.normalizeStyle(_ctx.barStyle)
                }, [
                    (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (_vue.openBlock(), _vue.createElementBlock("div", {
                        key: 0,
                        class: _vue.normalizeClass(_ctx.ns.be("bar", "innerText"))
                    }, [
                        _vue.renderSlot(_ctx.$slots, "default", _vue.normalizeProps(_vue.guardReactiveProps(_ctx.slotData)), ()=>[
                                _vue.createElementVNode("span", null, _vue.toDisplayString(_ctx.content), 1)
                            ]
                        )
                    ], 2)) : _vue.createCommentVNode("v-if", true)
                ], 6)
            ], 6)
        ], 2)) : (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 1,
            class: _vue.normalizeClass(_ctx.ns.b("circle")),
            style: _vue.normalizeStyle({
                height: `${_ctx.width}px`,
                width: `${_ctx.width}px`
            })
        }, [
            (_vue.openBlock(), _vue.createElementBlock("svg", _hoisted_2, [
                _vue.createElementVNode("path", {
                    class: _vue.normalizeClass(_ctx.ns.be("circle", "track")),
                    d: _ctx.trackPath,
                    stroke: "#e5e9f2",
                    "stroke-width": _ctx.relativeStrokeWidth,
                    fill: "none",
                    style: _vue.normalizeStyle(_ctx.trailPathStyle)
                }, null, 14, _hoisted_3),
                _vue.createElementVNode("path", {
                    class: _vue.normalizeClass(_ctx.ns.be("circle", "path")),
                    d: _ctx.trackPath,
                    stroke: _ctx.stroke,
                    fill: "none",
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": _ctx.percentage ? _ctx.relativeStrokeWidth : 0,
                    style: _vue.normalizeStyle(_ctx.circlePathStyle)
                }, null, 14, _hoisted_4)
            ]))
        ], 6)),
        (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 2,
            class: _vue.normalizeClass(_ctx.ns.e("text")),
            style: _vue.normalizeStyle({
                fontSize: `${_ctx.progressTextSize}px`
            })
        }, [
            _vue.renderSlot(_ctx.$slots, "default", _vue.normalizeProps(_vue.guardReactiveProps(_ctx.slotData)), ()=>[
                    !_ctx.status ? (_vue.openBlock(), _vue.createElementBlock("span", _hoisted_5, _vue.toDisplayString(_ctx.content), 1)) : (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 1
                    }, {
                        default: _vue.withCtx(()=>[
                                (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.statusIcon)))
                            ]
                        ),
                        _: 1
                    }))
                ]
            )
        ], 6)) : _vue.createCommentVNode("v-if", true)
    ], 10, _hoisted_1);
}
var Progress = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../hooks/index.mjs":"1Ansp","./progress.mjs":"iea9L","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iea9L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "progressProps", ()=>progressProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const progressProps = _propsMjs.buildProps({
    type: {
        type: String,
        default: "line",
        values: [
            "line",
            "circle",
            "dashboard"
        ]
    },
    percentage: {
        type: Number,
        default: 0,
        validator: (val)=>val >= 0 && val <= 100
    },
    status: {
        type: String,
        default: "",
        values: [
            "",
            "success",
            "exception",
            "warning"
        ]
    },
    indeterminate: {
        type: Boolean,
        default: false
    },
    duration: {
        type: Number,
        default: 3
    },
    strokeWidth: {
        type: Number,
        default: 6
    },
    strokeLinecap: {
        type: _propsMjs.definePropType(String),
        default: "round"
    },
    textInside: {
        type: Boolean,
        default: false
    },
    width: {
        type: Number,
        default: 126
    },
    showText: {
        type: Boolean,
        default: true
    },
    color: {
        type: _propsMjs.definePropType([
            String,
            Array,
            Function
        ]),
        default: ""
    },
    format: {
        type: _propsMjs.definePropType(Function),
        default: (percentage)=>`${percentage}%`
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8o4Y1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rateEmits", ()=>_rateMjs.rateEmits
);
parcelHelpers.export(exports, "rateProps", ()=>_rateMjs.rateProps
);
parcelHelpers.export(exports, "ElRate", ()=>ElRate
);
parcelHelpers.export(exports, "default", ()=>ElRate
);
var _indexMjs = require("../../utils/index.mjs");
var _rate2Mjs = require("./src/rate2.mjs");
var _rate2MjsDefault = parcelHelpers.interopDefault(_rate2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _rateMjs = require("./src/rate.mjs");
const ElRate = _installMjs.withInstall(_rate2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/rate2.mjs":"duFjw","../../utils/vue/install.mjs":"4TMmv","./src/rate.mjs":"eT6Re","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"duFjw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Rate
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _indexMjs = require("../../../tokens/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _indexMjs2 = require("../../../constants/index.mjs");
var _indexMjs3 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs4 = require("../../../hooks/index.mjs");
var _rateMjs = require("./rate.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _formMjs = require("../../../tokens/form.mjs");
var _indexMjs5 = require("../../../hooks/use-common-props/index.mjs");
var _indexMjs6 = require("../../../hooks/use-namespace/index.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
var _styleMjs = require("../../../utils/dom/style.mjs");
function getValueFromMap(value, map) {
    const isExcludedObject = (val)=>_shared.isObject(val)
    ;
    const matchedKeys = Object.keys(map).map((key)=>+key
    ).filter((key)=>{
        const val = map[key];
        const excluded = isExcludedObject(val) ? val.excluded : false;
        return excluded ? value < key : value <= key;
    }).sort((a, b)=>a - b
    );
    const matchedValue = map[matchedKeys[0]];
    return isExcludedObject(matchedValue) && matchedValue.value || matchedValue;
}
const _sfc_main = _vue.defineComponent({
    name: "ElRate",
    components: {
        ElIcon: _indexMjs3.ElIcon,
        StarFilled: _iconsVue.StarFilled,
        Star: _iconsVue.Star
    },
    props: _rateMjs.rateProps,
    emits: _rateMjs.rateEmits,
    setup (props, { emit  }) {
        const elForm = _vue.inject(_formMjs.elFormKey, {
        });
        const rateSize = _indexMjs5.useSize();
        const ns = _indexMjs6.useNamespace("rate");
        const currentValue = _vue.ref(props.modelValue);
        const hoverIndex = _vue.ref(-1);
        const pointerAtLeftHalf = _vue.ref(true);
        const rateKls = _vue.computed(()=>[
                ns.b(),
                ns.m(rateSize.value)
            ]
        );
        const rateDisabled = _vue.computed(()=>props.disabled || elForm.disabled
        );
        const text = _vue.computed(()=>{
            let result = "";
            if (props.showScore) result = props.scoreTemplate.replace(/\{\s*value\s*\}/, rateDisabled.value ? `${props.modelValue}` : `${currentValue.value}`);
            else if (props.showText) result = props.texts[Math.ceil(currentValue.value) - 1];
            return result;
        });
        const valueDecimal = _vue.computed(()=>props.modelValue * 100 - Math.floor(props.modelValue) * 100
        );
        const colorMap = _vue.computed(()=>_shared.isArray(props.colors) ? {
                [props.lowThreshold]: props.colors[0],
                [props.highThreshold]: {
                    value: props.colors[1],
                    excluded: true
                },
                [props.max]: props.colors[2]
            } : props.colors
        );
        const activeColor = _vue.computed(()=>getValueFromMap(currentValue.value, colorMap.value)
        );
        const decimalStyle = _vue.computed(()=>{
            let width = "";
            if (rateDisabled.value) width = `${valueDecimal.value}%`;
            else if (props.allowHalf) width = "50%";
            return {
                color: activeColor.value,
                width
            };
        });
        const componentMap = _vue.computed(()=>_shared.isArray(props.icons) ? {
                [props.lowThreshold]: props.icons[0],
                [props.highThreshold]: {
                    value: props.icons[1],
                    excluded: true
                },
                [props.max]: props.icons[2]
            } : props.icons
        );
        const decimalIconComponent = _vue.computed(()=>getValueFromMap(props.modelValue, componentMap.value)
        );
        const voidComponent = _vue.computed(()=>rateDisabled.value ? props.disabledvoidIcon : props.voidIcon
        );
        const activeComponent = _vue.computed(()=>getValueFromMap(currentValue.value, componentMap.value)
        );
        const iconComponents = _vue.computed(()=>{
            const result = Array(props.max);
            const threshold = currentValue.value;
            result.fill(activeComponent.value, 0, threshold);
            result.fill(voidComponent.value, threshold, props.max);
            return result;
        });
        function showDecimalIcon(item) {
            const showWhenDisabled = rateDisabled.value && valueDecimal.value > 0 && item - 1 < props.modelValue && item > props.modelValue;
            const showWhenAllowHalf = props.allowHalf && pointerAtLeftHalf.value && item - 0.5 <= currentValue.value && item > currentValue.value;
            return showWhenDisabled || showWhenAllowHalf;
        }
        function getIconStyle(item) {
            const voidColor = rateDisabled.value ? props.disabledVoidColor : props.voidColor;
            return {
                color: item <= currentValue.value ? activeColor.value : voidColor
            };
        }
        function selectValue(value) {
            if (rateDisabled.value) return;
            if (props.allowHalf && pointerAtLeftHalf.value) {
                emit(_eventMjs.UPDATE_MODEL_EVENT, currentValue.value);
                if (props.modelValue !== currentValue.value) emit("change", currentValue.value);
            } else {
                emit(_eventMjs.UPDATE_MODEL_EVENT, value);
                if (props.modelValue !== value) emit("change", value);
            }
        }
        function handleKey(e) {
            if (rateDisabled.value) return;
            let _currentValue = currentValue.value;
            const code = e.code;
            if (code === _ariaMjs.EVENT_CODE.up || code === _ariaMjs.EVENT_CODE.right) {
                if (props.allowHalf) _currentValue += 0.5;
                else _currentValue += 1;
                e.stopPropagation();
                e.preventDefault();
            } else if (code === _ariaMjs.EVENT_CODE.left || code === _ariaMjs.EVENT_CODE.down) {
                if (props.allowHalf) _currentValue -= 0.5;
                else _currentValue -= 1;
                e.stopPropagation();
                e.preventDefault();
            }
            _currentValue = _currentValue < 0 ? 0 : _currentValue;
            _currentValue = _currentValue > props.max ? props.max : _currentValue;
            emit(_eventMjs.UPDATE_MODEL_EVENT, _currentValue);
            emit("change", _currentValue);
            return _currentValue;
        }
        function setCurrentValue(value, event) {
            if (rateDisabled.value) return;
            if (props.allowHalf) {
                let target = event.target;
                if (_styleMjs.hasClass(target, ns.e("item"))) target = target.querySelector(`.${ns.e("icon")}`);
                if (target.clientWidth === 0 || _styleMjs.hasClass(target, ns.e("decimal"))) target = target.parentNode;
                pointerAtLeftHalf.value = event.offsetX * 2 <= target.clientWidth;
                currentValue.value = pointerAtLeftHalf.value ? value - 0.5 : value;
            } else currentValue.value = value;
            hoverIndex.value = value;
        }
        function resetCurrentValue() {
            if (rateDisabled.value) return;
            if (props.allowHalf) pointerAtLeftHalf.value = props.modelValue !== Math.floor(props.modelValue);
            currentValue.value = props.modelValue;
            hoverIndex.value = -1;
        }
        _vue.watch(()=>props.modelValue
        , (val)=>{
            currentValue.value = val;
            pointerAtLeftHalf.value = props.modelValue !== Math.floor(props.modelValue);
        });
        if (!props.modelValue) emit(_eventMjs.UPDATE_MODEL_EVENT, 0);
        return {
            ns,
            hoverIndex,
            currentValue,
            rateDisabled,
            text,
            decimalStyle,
            decimalIconComponent,
            iconComponents,
            rateKls,
            showDecimalIcon,
            getIconStyle,
            selectValue,
            handleKey,
            setCurrentValue,
            resetCurrentValue
        };
    }
});
const _hoisted_1 = [
    "aria-valuenow",
    "aria-valuetext",
    "aria-valuemax"
];
const _hoisted_2 = [
    "onMousemove",
    "onClick"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.rateKls),
        role: "slider",
        "aria-valuenow": _ctx.currentValue,
        "aria-valuetext": _ctx.text,
        "aria-valuemin": "0",
        "aria-valuemax": _ctx.max,
        tabindex: "0",
        onKeydown: _cache[1] || (_cache[1] = (...args)=>_ctx.handleKey && _ctx.handleKey(...args)
        )
    }, [
        (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.max, (item, key)=>{
            return _vue.openBlock(), _vue.createElementBlock("span", {
                key,
                class: _vue.normalizeClass(_ctx.ns.e("item")),
                style: _vue.normalizeStyle({
                    cursor: _ctx.rateDisabled ? "auto" : "pointer"
                }),
                onMousemove: ($event)=>_ctx.setCurrentValue(item, $event)
                ,
                onMouseleave: _cache[0] || (_cache[0] = (...args)=>_ctx.resetCurrentValue && _ctx.resetCurrentValue(...args)
                ),
                onClick: ($event)=>_ctx.selectValue(item)
            }, [
                _vue.createVNode(_component_el_icon, {
                    class: _vue.normalizeClass([
                        _ctx.ns.e("icon"),
                        {
                            hover: _ctx.hoverIndex === item
                        }
                    ]),
                    style: _vue.normalizeStyle(_ctx.getIconStyle(item))
                }, {
                    default: _vue.withCtx(()=>[
                            (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.iconComponents[item - 1]))),
                            _ctx.showDecimalIcon(item) ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                key: 0,
                                style: _vue.normalizeStyle(_ctx.decimalStyle),
                                class: _vue.normalizeClass([
                                    _ctx.ns.e("icon"),
                                    _ctx.ns.e("decimal")
                                ])
                            }, {
                                default: _vue.withCtx(()=>[
                                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.decimalIconComponent)))
                                    ]
                                ),
                                _: 1
                            }, 8, [
                                "style",
                                "class"
                            ])) : _vue.createCommentVNode("v-if", true)
                        ]
                    ),
                    _: 2
                }, 1032, [
                    "class",
                    "style"
                ])
            ], 46, _hoisted_2);
        }), 128)),
        _ctx.showText || _ctx.showScore ? (_vue.openBlock(), _vue.createElementBlock("span", {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.e("text")),
            style: _vue.normalizeStyle({
                color: _ctx.textColor
            })
        }, _vue.toDisplayString(_ctx.text), 7)) : _vue.createCommentVNode("v-if", true)
    ], 42, _hoisted_1);
}
var Rate = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vue/shared":"3SM3y","../../../tokens/index.mjs":"wVNQi","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../hooks/index.mjs":"1Ansp","./rate.mjs":"eT6Re","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../tokens/form.mjs":"2r4O0","../../../hooks/use-common-props/index.mjs":"05czU","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../constants/event.mjs":"92xVn","../../../constants/aria.mjs":"jS6iK","../../../utils/dom/style.mjs":"cA8Mp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eT6Re":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rateEmits", ()=>rateEmits
);
parcelHelpers.export(exports, "rateProps", ()=>rateProps
);
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs = require("../../../constants/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _typescriptMjs = require("../../../utils/typescript.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _validatorMjs = require("../../../utils/vue/validator.mjs");
var _eventMjs = require("../../../constants/event.mjs");
const rateProps = _propsMjs.buildProps({
    modelValue: {
        type: Number,
        default: 0
    },
    lowThreshold: {
        type: Number,
        default: 2
    },
    highThreshold: {
        type: Number,
        default: 4
    },
    max: {
        type: Number,
        default: 5
    },
    colors: {
        type: _propsMjs.definePropType([
            Array,
            Object
        ]),
        default: ()=>_typescriptMjs.mutable([
                "var(--el-rate-star-color)",
                "var(--el-rate-star-color)",
                "var(--el-rate-star-color)"
            ])
    },
    voidColor: {
        type: String,
        default: "var(--el-rate-void-color)"
    },
    disabledVoidColor: {
        type: String,
        default: "var(--el-rate-disable-void-color)"
    },
    icons: {
        type: _propsMjs.definePropType([
            Array,
            Object
        ]),
        default: ()=>[
                _iconsVue.StarFilled,
                _iconsVue.StarFilled,
                _iconsVue.StarFilled
            ]
    },
    voidIcon: {
        type: _iconMjs.iconPropType,
        default: ()=>_iconsVue.Star
    },
    disabledvoidIcon: {
        type: _iconMjs.iconPropType,
        default: ()=>_iconsVue.StarFilled
    },
    disabled: {
        type: Boolean,
        default: false
    },
    allowHalf: {
        type: Boolean,
        default: false
    },
    showText: {
        type: Boolean,
        default: false
    },
    showScore: {
        type: Boolean,
        default: false
    },
    textColor: {
        type: String,
        default: "var(--el-rate-text-color)"
    },
    texts: {
        type: _propsMjs.definePropType(Array),
        default: ()=>_typescriptMjs.mutable([
                "Extremely bad",
                "Disappointed",
                "Fair",
                "Satisfied",
                "Surprise"
            ])
    },
    scoreTemplate: {
        type: String,
        default: "{value}"
    },
    size: {
        type: String,
        validator: _validatorMjs.isValidComponentSize
    }
});
const rateEmits = {
    change: (value)=>typeof value === "number"
    ,
    [_eventMjs.UPDATE_MODEL_EVENT]: (value)=>typeof value === "number"
};

},{"@element-plus/icons-vue":"b18uu","../../../constants/index.mjs":"74Fbn","../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","../../../utils/typescript.mjs":"bRl53","../../../utils/vue/icon.mjs":"3YbE5","../../../utils/vue/validator.mjs":"4UnBa","../../../constants/event.mjs":"92xVn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lHyTs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IconComponentMap", ()=>_resultMjs.IconComponentMap
);
parcelHelpers.export(exports, "IconMap", ()=>_resultMjs.IconMap
);
parcelHelpers.export(exports, "resultProps", ()=>_resultMjs.resultProps
);
parcelHelpers.export(exports, "ElResult", ()=>ElResult
);
parcelHelpers.export(exports, "default", ()=>ElResult
);
var _indexMjs = require("../../utils/index.mjs");
var _result2Mjs = require("./src/result2.mjs");
var _result2MjsDefault = parcelHelpers.interopDefault(_result2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _resultMjs = require("./src/result.mjs");
const ElResult = _installMjs.withInstall(_result2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/result2.mjs":"c0wn4","../../utils/vue/install.mjs":"4TMmv","./src/result.mjs":"lxN2C","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c0wn4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Result
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _resultMjs = require("./result.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElResult",
    props: _resultMjs.resultProps,
    setup (props) {
        const ns = _indexMjs1.useNamespace("result");
        const resultIcon = _vue.computed(()=>{
            const icon = props.icon;
            const iconClass = icon && _resultMjs.IconMap[icon] ? _resultMjs.IconMap[icon] : "icon-info";
            const iconComponent = _resultMjs.IconComponentMap[iconClass] || _resultMjs.IconComponentMap["icon-info"];
            return {
                class: iconClass,
                component: iconComponent
            };
        });
        return {
            ns,
            resultIcon
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.ns.b())
    }, [
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("icon"))
        }, [
            _vue.renderSlot(_ctx.$slots, "icon", {
            }, ()=>[
                    _ctx.resultIcon.component ? (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.resultIcon.component), {
                        key: 0,
                        class: _vue.normalizeClass(_ctx.resultIcon.class)
                    }, null, 8, [
                        "class"
                    ])) : _vue.createCommentVNode("v-if", true)
                ]
            )
        ], 2),
        _ctx.title || _ctx.$slots.title ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.e("title"))
        }, [
            _vue.renderSlot(_ctx.$slots, "title", {
            }, ()=>[
                    _vue.createElementVNode("p", null, _vue.toDisplayString(_ctx.title), 1)
                ]
            )
        ], 2)) : _vue.createCommentVNode("v-if", true),
        _ctx.subTitle || _ctx.$slots.subTitle ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 1,
            class: _vue.normalizeClass(_ctx.ns.e("subtitle"))
        }, [
            _vue.renderSlot(_ctx.$slots, "subTitle", {
            }, ()=>[
                    _vue.createElementVNode("p", null, _vue.toDisplayString(_ctx.subTitle), 1)
                ]
            )
        ], 2)) : _vue.createCommentVNode("v-if", true),
        _ctx.$slots.extra ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 2,
            class: _vue.normalizeClass(_ctx.ns.e("extra"))
        }, [
            _vue.renderSlot(_ctx.$slots, "extra")
        ], 2)) : _vue.createCommentVNode("v-if", true)
    ], 2);
}
var Result = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./result.mjs":"lxN2C","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lxN2C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IconComponentMap", ()=>IconComponentMap
);
parcelHelpers.export(exports, "IconMap", ()=>IconMap
);
parcelHelpers.export(exports, "resultProps", ()=>resultProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _propsMjs = require("../../../utils/vue/props.mjs");
const IconMap = {
    success: "icon-success",
    warning: "icon-warning",
    error: "icon-error",
    info: "icon-info"
};
const IconComponentMap = {
    [IconMap.success]: _iconsVue.CircleCheckFilled,
    [IconMap.warning]: _iconsVue.WarningFilled,
    [IconMap.error]: _iconsVue.CircleCloseFilled,
    [IconMap.info]: _iconsVue.InfoFilled
};
const resultProps = _propsMjs.buildProps({
    title: {
        type: String,
        default: ""
    },
    subTitle: {
        type: String,
        default: ""
    },
    icon: {
        values: [
            "success",
            "warning",
            "info",
            "error"
        ],
        default: "info"
    }
});

},{"../../../utils/index.mjs":"dsdeP","@element-plus/icons-vue":"b18uu","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Vl2s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rowProps", ()=>_rowMjs.rowProps
);
parcelHelpers.export(exports, "ElRow", ()=>ElRow
);
parcelHelpers.export(exports, "default", ()=>ElRow
);
var _indexMjs = require("../../utils/index.mjs");
var _rowMjs = require("./src/row.mjs");
var _rowMjsDefault = parcelHelpers.interopDefault(_rowMjs);
var _installMjs = require("../../utils/vue/install.mjs");
const ElRow = _installMjs.withInstall(_rowMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/row.mjs":"f4k9l","../../utils/vue/install.mjs":"4TMmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f4k9l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Row
);
parcelHelpers.export(exports, "rowProps", ()=>rowProps
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const rowProps = _propsMjs.buildProps({
    tag: {
        type: String,
        default: "div"
    },
    gutter: {
        type: Number,
        default: 0
    },
    justify: {
        type: String,
        values: [
            "start",
            "center",
            "end",
            "space-around",
            "space-between"
        ],
        default: "start"
    },
    align: {
        type: String,
        values: [
            "top",
            "middle",
            "bottom"
        ],
        default: "top"
    }
});
const Row = _vue.defineComponent({
    name: "ElRow",
    props: rowProps,
    setup (props, { slots  }) {
        const ns = _indexMjs2.useNamespace("row");
        const gutter = _vue.computed(()=>props.gutter
        );
        _vue.provide("ElRow", {
            gutter
        });
        const style = _vue.computed(()=>{
            const styles = {
                marginLeft: "",
                marginRight: ""
            };
            if (props.gutter) {
                styles.marginLeft = `-${props.gutter / 2}px`;
                styles.marginRight = styles.marginLeft;
            }
            return styles;
        });
        return ()=>{
            var _a;
            return _vue.h(props.tag, {
                class: [
                    ns.b(),
                    ns.is(`justify-${props.justify}`, props.justify !== "start"),
                    ns.is(`align-${props.align}`, props.align !== "top")
                ],
                style: style.value
            }, (_a = slots.default) == null ? void 0 : _a.call(slots));
        };
    }
});

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","../../../utils/vue/props.mjs":"cpwWK","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lUvDZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "selectV2InjectionKey", ()=>_tokenMjs.selectV2InjectionKey
);
parcelHelpers.export(exports, "ElSelectV2", ()=>ElSelectV2
);
parcelHelpers.export(exports, "default", ()=>_Select
);
var _selectMjs = require("./src/select.mjs");
var _selectMjsDefault = parcelHelpers.interopDefault(_selectMjs);
var _tokenMjs = require("./src/token.mjs");
_selectMjsDefault.default.install = (app)=>{
    app.component(_selectMjsDefault.default.name, _selectMjsDefault.default);
};
const _Select = _selectMjsDefault.default;
const ElSelectV2 = _Select;

},{"./src/select.mjs":"bPk18","./src/token.mjs":"lk8V6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bPk18":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Select
);
var _vue = require("vue");
var _indexMjs = require("../../../directives/index.mjs");
var _indexMjs1 = require("../../tooltip/index.mjs");
var _indexMjs2 = require("../../tag/index.mjs");
var _indexMjs3 = require("../../icon/index.mjs");
var _indexMjs4 = require("../../../constants/index.mjs");
var _selectDropdownMjs = require("./select-dropdown.mjs");
var _selectDropdownMjsDefault = parcelHelpers.interopDefault(_selectDropdownMjs);
var _useSelectMjs = require("./useSelect.mjs");
var _useSelectMjsDefault = parcelHelpers.interopDefault(_useSelectMjs);
var _tokenMjs = require("./token.mjs");
var _defaultsMjs = require("./defaults.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs5 = require("../../../directives/click-outside/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs5);
var _eventMjs = require("../../../constants/event.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElSelectV2",
    components: {
        ElSelectMenu: _selectDropdownMjsDefault.default,
        ElTag: _indexMjs2.ElTag,
        ElTooltip: _indexMjs1.ElTooltip,
        ElIcon: _indexMjs3.ElIcon
    },
    directives: {
        ClickOutside: _indexMjsDefault.default,
        ModelText: _vue.vModelText
    },
    props: _defaultsMjs.SelectProps,
    emits: [
        _eventMjs.UPDATE_MODEL_EVENT,
        _eventMjs.CHANGE_EVENT,
        "remove-tag",
        "clear",
        "visible-change",
        "focus",
        "blur"
    ],
    setup (props, { emit  }) {
        const API = _useSelectMjsDefault.default(props, emit);
        _vue.provide(_tokenMjs.selectV2InjectionKey, {
            props: _vue.reactive({
                ..._vue.toRefs(props),
                height: API.popupHeight
            }),
            onSelect: API.onSelect,
            onHover: API.onHover,
            onKeyboardNavigate: API.onKeyboardNavigate,
            onKeyboardSelect: API.onKeyboardSelect
        });
        return API;
    }
});
const _hoisted_1 = {
    key: 0
};
const _hoisted_2 = [
    "id",
    "autocomplete",
    "aria-expanded",
    "aria-labelledby",
    "disabled",
    "readonly",
    "name",
    "unselectable"
];
const _hoisted_3 = [
    "textContent"
];
const _hoisted_4 = [
    "id",
    "aria-labelledby",
    "aria-expanded",
    "autocomplete",
    "disabled",
    "name",
    "readonly",
    "unselectable"
];
const _hoisted_5 = [
    "textContent"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_tag = _vue.resolveComponent("el-tag");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_select_menu = _vue.resolveComponent("el-select-menu");
    const _component_el_tooltip = _vue.resolveComponent("el-tooltip");
    const _directive_model_text = _vue.resolveDirective("model-text");
    const _directive_click_outside = _vue.resolveDirective("click-outside");
    return _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
        ref: "selectRef",
        class: _vue.normalizeClass([
            _ctx.nsSelectV2.b(),
            _ctx.nsSelectV2.m(_ctx.selectSize)
        ]),
        onClick: _cache[24] || (_cache[24] = _vue.withModifiers((...args)=>_ctx.toggleMenu && _ctx.toggleMenu(...args)
        , [
            "stop"
        ])),
        onMouseenter: _cache[25] || (_cache[25] = ($event)=>_ctx.states.comboBoxHovering = true
        ),
        onMouseleave: _cache[26] || (_cache[26] = ($event)=>_ctx.states.comboBoxHovering = false
        )
    }, [
        _vue.createVNode(_component_el_tooltip, {
            ref: "popper",
            visible: _ctx.dropdownMenuVisible,
            "onUpdate:visible": _cache[22] || (_cache[22] = ($event)=>_ctx.dropdownMenuVisible = $event
            ),
            teleported: _ctx.compatTeleported,
            "popper-class": [
                _ctx.nsSelectV2.e("popper"),
                _ctx.popperClass
            ],
            "gpu-acceleration": false,
            "stop-popper-mouse-event": false,
            "popper-options": _ctx.popperOptions,
            "fallback-placements": [
                "bottom-start",
                "top-start",
                "right",
                "left"
            ],
            effect: _ctx.effect,
            placement: "bottom-start",
            pure: "",
            transition: `${_ctx.nsSelectV2.namespace.value}-zoom-in-top`,
            trigger: "click",
            persistent: "",
            onShow: _ctx.handleMenuEnter,
            onHide: _cache[23] || (_cache[23] = ($event)=>_ctx.states.inputValue = _ctx.states.displayInputValue
            )
        }, {
            default: _vue.withCtx(()=>{
                var _a;
                return [
                    _vue.createElementVNode("div", {
                        ref: "selectionRef",
                        class: _vue.normalizeClass([
                            _ctx.nsSelectV2.e("wrapper"),
                            _ctx.nsSelectV2.is("focused", _ctx.states.isComposing),
                            _ctx.nsSelectV2.is("hovering", _ctx.states.comboBoxHovering),
                            _ctx.nsSelectV2.is("filterable", _ctx.filterable),
                            _ctx.nsSelectV2.is("disabled", _ctx.disabled)
                        ])
                    }, [
                        _ctx.$slots.prefix ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_1, [
                            _vue.renderSlot(_ctx.$slots, "prefix")
                        ])) : _vue.createCommentVNode("v-if", true),
                        _ctx.multiple ? (_vue.openBlock(), _vue.createElementBlock("div", {
                            key: 1,
                            class: _vue.normalizeClass(_ctx.nsSelectV2.e("selection"))
                        }, [
                            _ctx.collapseTags && _ctx.modelValue.length > 0 ? (_vue.openBlock(), _vue.createElementBlock("div", {
                                key: 0,
                                class: _vue.normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                            }, [
                                _vue.createVNode(_component_el_tag, {
                                    closable: !_ctx.selectDisabled && !((_a = _ctx.states.cachedOptions[0]) == null ? void 0 : _a.disable),
                                    size: _ctx.collapseTagSize,
                                    type: "info",
                                    "disable-transitions": "",
                                    onClose: _cache[0] || (_cache[0] = ($event)=>_ctx.deleteTag($event, _ctx.states.cachedOptions[0])
                                    )
                                }, {
                                    default: _vue.withCtx(()=>{
                                        var _a2;
                                        return [
                                            _vue.createElementVNode("span", {
                                                class: _vue.normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                                                style: _vue.normalizeStyle({
                                                    maxWidth: `${_ctx.tagMaxWidth}px`
                                                })
                                            }, _vue.toDisplayString((_a2 = _ctx.states.cachedOptions[0]) == null ? void 0 : _a2.label), 7)
                                        ];
                                    }),
                                    _: 1
                                }, 8, [
                                    "closable",
                                    "size"
                                ]),
                                _ctx.modelValue.length > 1 ? (_vue.openBlock(), _vue.createBlock(_component_el_tag, {
                                    key: 0,
                                    closable: false,
                                    size: _ctx.collapseTagSize,
                                    type: "info",
                                    "disable-transitions": ""
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createElementVNode("span", {
                                                class: _vue.normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                                                style: _vue.normalizeStyle({
                                                    maxWidth: `${_ctx.tagMaxWidth}px`
                                                })
                                            }, "+ " + _vue.toDisplayString(_ctx.modelValue.length - 1), 7)
                                        ]
                                    ),
                                    _: 1
                                }, 8, [
                                    "size"
                                ])) : _vue.createCommentVNode("v-if", true)
                            ], 2)) : (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, {
                                key: 1
                            }, _vue.renderList(_ctx.states.cachedOptions, (selected, idx)=>{
                                return _vue.openBlock(), _vue.createElementBlock("div", {
                                    key: idx,
                                    class: _vue.normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                                }, [
                                    (_vue.openBlock(), _vue.createBlock(_component_el_tag, {
                                        key: _ctx.getValueKey(selected),
                                        closable: !_ctx.selectDisabled && !selected.disabled,
                                        size: _ctx.collapseTagSize,
                                        type: "info",
                                        "disable-transitions": "",
                                        onClose: ($event)=>_ctx.deleteTag($event, selected)
                                    }, {
                                        default: _vue.withCtx(()=>[
                                                _vue.createElementVNode("span", {
                                                    class: _vue.normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                                                    style: _vue.normalizeStyle({
                                                        maxWidth: `${_ctx.tagMaxWidth}px`
                                                    })
                                                }, _vue.toDisplayString(_ctx.getLabel(selected)), 7)
                                            ]
                                        ),
                                        _: 2
                                    }, 1032, [
                                        "closable",
                                        "size",
                                        "onClose"
                                    ]))
                                ], 2);
                            }), 128)),
                            _vue.createElementVNode("div", {
                                class: _vue.normalizeClass([
                                    _ctx.nsSelectV2.e("selected-item"),
                                    _ctx.nsSelectV2.e("input-wrapper")
                                ]),
                                style: _vue.normalizeStyle(_ctx.inputWrapperStyle)
                            }, [
                                _vue.withDirectives(_vue.createElementVNode("input", {
                                    id: _ctx.id,
                                    ref: "inputRef",
                                    autocomplete: _ctx.autocomplete,
                                    "aria-autocomplete": "list",
                                    "aria-haspopup": "listbox",
                                    autocapitalize: "off",
                                    "aria-expanded": _ctx.expanded,
                                    "aria-labelledby": _ctx.label,
                                    class: _vue.normalizeClass([
                                        _ctx.nsSelectV2.is(_ctx.selectSize),
                                        _ctx.nsSelectV2.e("combobox-input")
                                    ]),
                                    disabled: _ctx.disabled,
                                    role: "combobox",
                                    readonly: !_ctx.filterable,
                                    spellcheck: "false",
                                    type: "text",
                                    name: _ctx.name,
                                    unselectable: _ctx.expanded ? "on" : void 0,
                                    "onUpdate:modelValue": _cache[1] || (_cache[1] = (...args)=>_ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args)
                                    ),
                                    onFocus: _cache[2] || (_cache[2] = (...args)=>_ctx.handleFocus && _ctx.handleFocus(...args)
                                    ),
                                    onInput: _cache[3] || (_cache[3] = (...args)=>_ctx.onInput && _ctx.onInput(...args)
                                    ),
                                    onCompositionstart: _cache[4] || (_cache[4] = (...args)=>_ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)
                                    ),
                                    onCompositionupdate: _cache[5] || (_cache[5] = (...args)=>_ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)
                                    ),
                                    onCompositionend: _cache[6] || (_cache[6] = (...args)=>_ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)
                                    ),
                                    onKeydown: [
                                        _cache[7] || (_cache[7] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.onKeyboardNavigate("backward")
                                        , [
                                            "stop",
                                            "prevent"
                                        ]), [
                                            "up"
                                        ])),
                                        _cache[8] || (_cache[8] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.onKeyboardNavigate("forward")
                                        , [
                                            "stop",
                                            "prevent"
                                        ]), [
                                            "down"
                                        ])),
                                        _cache[9] || (_cache[9] = _vue.withKeys(_vue.withModifiers((...args)=>_ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args)
                                        , [
                                            "stop",
                                            "prevent"
                                        ]), [
                                            "enter"
                                        ])),
                                        _cache[10] || (_cache[10] = _vue.withKeys(_vue.withModifiers((...args)=>_ctx.handleEsc && _ctx.handleEsc(...args)
                                        , [
                                            "stop",
                                            "prevent"
                                        ]), [
                                            "esc"
                                        ])),
                                        _cache[11] || (_cache[11] = _vue.withKeys(_vue.withModifiers((...args)=>_ctx.handleDel && _ctx.handleDel(...args)
                                        , [
                                            "stop"
                                        ]), [
                                            "delete"
                                        ]))
                                    ]
                                }, null, 42, _hoisted_2), [
                                    [
                                        _directive_model_text,
                                        _ctx.states.displayInputValue
                                    ]
                                ]),
                                _ctx.filterable ? (_vue.openBlock(), _vue.createElementBlock("span", {
                                    key: 0,
                                    ref: "calculatorRef",
                                    "aria-hidden": "true",
                                    class: _vue.normalizeClass(_ctx.nsSelectV2.e("input-calculator")),
                                    textContent: _vue.toDisplayString(_ctx.states.displayInputValue)
                                }, null, 10, _hoisted_3)) : _vue.createCommentVNode("v-if", true)
                            ], 6)
                        ], 2)) : (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                            key: 2
                        }, [
                            _vue.createElementVNode("div", {
                                class: _vue.normalizeClass([
                                    _ctx.nsSelectV2.e("selected-item"),
                                    _ctx.nsSelectV2.e("input-wrapper")
                                ])
                            }, [
                                _vue.withDirectives(_vue.createElementVNode("input", {
                                    id: _ctx.id,
                                    ref: "inputRef",
                                    "aria-autocomplete": "list",
                                    "aria-haspopup": "listbox",
                                    "aria-labelledby": _ctx.label,
                                    "aria-expanded": _ctx.expanded,
                                    autocapitalize: "off",
                                    autocomplete: _ctx.autocomplete,
                                    class: _vue.normalizeClass(_ctx.nsSelectV2.e("combobox-input")),
                                    disabled: _ctx.disabled,
                                    name: _ctx.name,
                                    role: "combobox",
                                    readonly: !_ctx.filterable,
                                    spellcheck: "false",
                                    type: "text",
                                    unselectable: _ctx.expanded ? "on" : void 0,
                                    onCompositionstart: _cache[12] || (_cache[12] = (...args)=>_ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)
                                    ),
                                    onCompositionupdate: _cache[13] || (_cache[13] = (...args)=>_ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)
                                    ),
                                    onCompositionend: _cache[14] || (_cache[14] = (...args)=>_ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)
                                    ),
                                    onFocus: _cache[15] || (_cache[15] = (...args)=>_ctx.handleFocus && _ctx.handleFocus(...args)
                                    ),
                                    onInput: _cache[16] || (_cache[16] = (...args)=>_ctx.onInput && _ctx.onInput(...args)
                                    ),
                                    onKeydown: [
                                        _cache[17] || (_cache[17] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.onKeyboardNavigate("backward")
                                        , [
                                            "stop",
                                            "prevent"
                                        ]), [
                                            "up"
                                        ])),
                                        _cache[18] || (_cache[18] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.onKeyboardNavigate("forward")
                                        , [
                                            "stop",
                                            "prevent"
                                        ]), [
                                            "down"
                                        ])),
                                        _cache[19] || (_cache[19] = _vue.withKeys(_vue.withModifiers((...args)=>_ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args)
                                        , [
                                            "stop",
                                            "prevent"
                                        ]), [
                                            "enter"
                                        ])),
                                        _cache[20] || (_cache[20] = _vue.withKeys(_vue.withModifiers((...args)=>_ctx.handleEsc && _ctx.handleEsc(...args)
                                        , [
                                            "stop",
                                            "prevent"
                                        ]), [
                                            "esc"
                                        ]))
                                    ],
                                    "onUpdate:modelValue": _cache[21] || (_cache[21] = (...args)=>_ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args)
                                    )
                                }, null, 42, _hoisted_4), [
                                    [
                                        _directive_model_text,
                                        _ctx.states.displayInputValue
                                    ]
                                ])
                            ], 2),
                            _ctx.filterable ? (_vue.openBlock(), _vue.createElementBlock("span", {
                                key: 0,
                                ref: "calculatorRef",
                                "aria-hidden": "true",
                                class: _vue.normalizeClass([
                                    _ctx.nsSelectV2.e("selected-item"),
                                    _ctx.nsSelectV2.e("input-calculator")
                                ]),
                                textContent: _vue.toDisplayString(_ctx.states.displayInputValue)
                            }, null, 10, _hoisted_5)) : _vue.createCommentVNode("v-if", true)
                        ], 64)),
                        _ctx.shouldShowPlaceholder ? (_vue.openBlock(), _vue.createElementBlock("span", {
                            key: 3,
                            class: _vue.normalizeClass([
                                _ctx.nsSelectV2.e("placeholder"),
                                _ctx.nsSelectV2.is("transparent", _ctx.states.isComposing || (_ctx.placeholder && _ctx.multiple ? _ctx.modelValue.length === 0 : !_ctx.hasModelValue))
                            ])
                        }, _vue.toDisplayString(_ctx.currentPlaceholder), 3)) : _vue.createCommentVNode("v-if", true),
                        _vue.createElementVNode("span", {
                            class: _vue.normalizeClass(_ctx.nsSelectV2.e("suffix"))
                        }, [
                            _ctx.iconComponent ? _vue.withDirectives((_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                key: 0,
                                class: _vue.normalizeClass([
                                    _ctx.nsSelectV2.e("caret"),
                                    _ctx.nsInput.e("icon"),
                                    _ctx.iconReverse
                                ])
                            }, {
                                default: _vue.withCtx(()=>[
                                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.iconComponent)))
                                    ]
                                ),
                                _: 1
                            }, 8, [
                                "class"
                            ])), [
                                [
                                    _vue.vShow,
                                    !_ctx.showClearBtn
                                ]
                            ]) : _vue.createCommentVNode("v-if", true),
                            _ctx.showClearBtn && _ctx.clearIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                key: 1,
                                class: _vue.normalizeClass([
                                    _ctx.nsSelectV2.e("caret"),
                                    _ctx.nsInput.e("icon")
                                ]),
                                onClick: _vue.withModifiers(_ctx.handleClear, [
                                    "prevent",
                                    "stop"
                                ])
                            }, {
                                default: _vue.withCtx(()=>[
                                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.clearIcon)))
                                    ]
                                ),
                                _: 1
                            }, 8, [
                                "class",
                                "onClick"
                            ])) : _vue.createCommentVNode("v-if", true),
                            _ctx.validateState && _ctx.validateIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                key: 2,
                                class: _vue.normalizeClass([
                                    _ctx.nsInput.e("icon"),
                                    _ctx.nsInput.e("validateIcon")
                                ])
                            }, {
                                default: _vue.withCtx(()=>[
                                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.validateIcon)))
                                    ]
                                ),
                                _: 1
                            }, 8, [
                                "class"
                            ])) : _vue.createCommentVNode("v-if", true)
                        ], 2)
                    ], 2)
                ];
            }),
            content: _vue.withCtx(()=>[
                    _vue.createVNode(_component_el_select_menu, {
                        ref: "menuRef",
                        data: _ctx.filteredOptions,
                        width: _ctx.popperSize,
                        "hovering-index": _ctx.states.hoveringIndex,
                        "scrollbar-always-on": _ctx.scrollbarAlwaysOn
                    }, {
                        default: _vue.withCtx((scope)=>[
                                _vue.renderSlot(_ctx.$slots, "default", _vue.normalizeProps(_vue.guardReactiveProps(scope)))
                            ]
                        ),
                        empty: _vue.withCtx(()=>[
                                _vue.renderSlot(_ctx.$slots, "empty", {
                                }, ()=>[
                                        _vue.createElementVNode("p", {
                                            class: _vue.normalizeClass(_ctx.nsSelectV2.e("empty"))
                                        }, _vue.toDisplayString(_ctx.emptyText ? _ctx.emptyText : ""), 3)
                                    ]
                                )
                            ]
                        ),
                        _: 3
                    }, 8, [
                        "data",
                        "width",
                        "hovering-index",
                        "scrollbar-always-on"
                    ])
                ]
            ),
            _: 3
        }, 8, [
            "visible",
            "teleported",
            "popper-class",
            "popper-options",
            "effect",
            "transition",
            "onShow"
        ])
    ], 34)), [
        [
            _directive_click_outside,
            _ctx.handleClickOutside,
            _ctx.popperRef
        ]
    ]);
}
var Select = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../directives/index.mjs":"aRbJ2","../../tooltip/index.mjs":"kiwBC","../../tag/index.mjs":"96fQG","../../icon/index.mjs":"hnNTG","../../../constants/index.mjs":"74Fbn","./select-dropdown.mjs":"76OrC","./useSelect.mjs":"kEkvd","./token.mjs":"lk8V6","./defaults.mjs":"7AiGB","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../directives/click-outside/index.mjs":"cdlLW","../../../constants/event.mjs":"92xVn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"76OrC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_sfc_main
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../virtual-list/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _groupItemMjs = require("./group-item.mjs");
var _groupItemMjsDefault = parcelHelpers.interopDefault(_groupItemMjs);
var _optionItemMjs = require("./option-item.mjs");
var _optionItemMjsDefault = parcelHelpers.interopDefault(_optionItemMjs);
var _tokenMjs = require("./token.mjs");
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
var _typesMjs = require("../../../utils/types.mjs");
var _shared = require("@vue/shared");
var _fixedSizeListMjs = require("../../virtual-list/src/components/fixed-size-list.mjs");
var _fixedSizeListMjsDefault = parcelHelpers.interopDefault(_fixedSizeListMjs);
var _dynamicSizeListMjs = require("../../virtual-list/src/components/dynamic-size-list.mjs");
var _dynamicSizeListMjsDefault = parcelHelpers.interopDefault(_dynamicSizeListMjs);
const _sfc_main = _vue.defineComponent({
    name: "ElSelectDropdown",
    props: {
        data: Array,
        hoveringIndex: Number,
        width: Number
    },
    setup (props) {
        const select = _vue.inject(_tokenMjs.selectV2InjectionKey);
        const ns = _indexMjs3.useNamespace("select");
        const cachedHeights = _vue.ref([]);
        const listRef = _vue.ref(null);
        const isSized = _vue.computed(()=>_typesMjs.isUndefined(select.props.estimatedOptionHeight)
        );
        const listProps = _vue.computed(()=>{
            if (isSized.value) return {
                itemSize: select.props.itemHeight
            };
            return {
                estimatedSize: select.props.estimatedOptionHeight,
                itemSize: (idx)=>cachedHeights.value[idx]
            };
        });
        const contains = (arr = [], target)=>{
            const { props: { valueKey  }  } = select;
            if (!_shared.isObject(target)) return arr.includes(target);
            return arr && arr.some((item)=>{
                return _lodashUnified.get(item, valueKey) === _lodashUnified.get(target, valueKey);
            });
        };
        const isEqual = (selected, target)=>{
            if (!_shared.isObject(target)) return selected === target;
            else {
                const { valueKey  } = select.props;
                return _lodashUnified.get(selected, valueKey) === _lodashUnified.get(target, valueKey);
            }
        };
        const isItemSelected = (modelValue, target)=>{
            if (select.props.multiple) return contains(modelValue, target.value);
            return isEqual(modelValue, target.value);
        };
        const isItemDisabled = (modelValue, selected)=>{
            const { disabled , multiple , multipleLimit  } = select.props;
            return disabled || !selected && (multiple ? multipleLimit > 0 && modelValue.length >= multipleLimit : false);
        };
        const isItemHovering = (target)=>props.hoveringIndex === target
        ;
        const scrollToItem = (index)=>{
            const list = listRef.value;
            if (list) list.scrollToItem(index);
        };
        const resetScrollTop = ()=>{
            const list = listRef.value;
            if (list) list.resetScrollTop();
        };
        return {
            ns,
            select,
            listProps,
            listRef,
            isSized,
            isItemDisabled,
            isItemHovering,
            isItemSelected,
            scrollToItem,
            resetScrollTop
        };
    },
    render (_ctx, _cache) {
        var _a;
        const { $slots , data , listProps , select , isSized , width , ns , isItemDisabled , isItemHovering , isItemSelected  } = _ctx;
        const Comp = isSized ? _fixedSizeListMjsDefault.default : _dynamicSizeListMjsDefault.default;
        const { props: selectProps , onSelect , onHover , onKeyboardNavigate , onKeyboardSelect  } = select;
        const { height , modelValue , multiple  } = selectProps;
        if (data.length === 0) return _vue.h("div", {
            class: ns.b("dropdown"),
            style: {
                width: `${width}px`
            }
        }, (_a = $slots.empty) == null ? void 0 : _a.call($slots));
        const ListItem = _vue.withCtx((scoped)=>{
            const { index , data: data2  } = scoped;
            const item = data2[index];
            if (data2[index].type === "Group") return _vue.h(_groupItemMjsDefault.default, {
                item,
                style: scoped.style,
                height: isSized ? listProps.itemSize : listProps.estimatedSize
            });
            const selected = isItemSelected(modelValue, item);
            const itemDisabled = isItemDisabled(modelValue, selected);
            return _vue.h(_optionItemMjsDefault.default, {
                ...scoped,
                selected,
                disabled: item.disabled || itemDisabled,
                created: !!item.created,
                hovering: isItemHovering(index),
                item,
                onSelect,
                onHover
            }, {
                default: _vue.withCtx((props)=>{
                    return _vue.renderSlot($slots, "default", props, ()=>[
                            _vue.h("span", item.label)
                        ]
                    );
                })
            });
        });
        const List = _vue.h(Comp, {
            ref: "listRef",
            className: ns.be("dropdown", "list"),
            data,
            height,
            width,
            total: data.length,
            scrollbarAlwaysOn: selectProps.scrollbarAlwaysOn,
            onKeydown: [
                _cache[1] || (_cache[1] = _vue.withKeys(_vue.withModifiers(()=>onKeyboardNavigate("forward")
                , [
                    "stop",
                    "prevent"
                ]), [
                    "down"
                ])),
                _cache[2] || (_cache[2] = _vue.withKeys(_vue.withModifiers(()=>onKeyboardNavigate("backward")
                , [
                    "stop",
                    "prevent"
                ]), [
                    "up"
                ])),
                _cache[3] || (_cache[3] = _vue.withKeys(_vue.withModifiers(onKeyboardSelect, [
                    "stop",
                    "prevent"
                ]), [
                    "enter"
                ])),
                _cache[4] || (_cache[4] = _vue.withKeys(_vue.withModifiers(()=>select.expanded = false
                , [
                    "stop",
                    "prevent"
                ]), [
                    "esc"
                ])),
                _cache[5] || (_cache[5] = _vue.withKeys(()=>select.expanded = false
                , [
                    "tab"
                ]))
            ],
            ...listProps
        }, {
            default: ListItem
        });
        return _vue.h("div", {
            class: [
                ns.b("dropdown"),
                ns.is("multiple", multiple)
            ]
        }, [
            List
        ]);
    }
});

},{"vue":"gzxs9","lodash-unified":"4Oj4p","../../../utils/index.mjs":"dsdeP","../../virtual-list/index.mjs":"gcf4S","../../../hooks/index.mjs":"1Ansp","./group-item.mjs":"5ZbAX","./option-item.mjs":"a4BWp","./token.mjs":"lk8V6","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/types.mjs":"4VsDK","@vue/shared":"3SM3y","../../virtual-list/src/components/fixed-size-list.mjs":"eaMZD","../../virtual-list/src/components/dynamic-size-list.mjs":"ggHfi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gcf4S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FixedSizeList", ()=>_fixedSizeListMjsDefault.default
);
parcelHelpers.export(exports, "DynamicSizeList", ()=>_dynamicSizeListMjsDefault.default
);
parcelHelpers.export(exports, "FixedSizeGrid", ()=>_fixedSizeGridMjsDefault.default
);
parcelHelpers.export(exports, "DynamicSizeGrid", ()=>_dynamicSizeGridMjsDefault.default
);
parcelHelpers.export(exports, "virtualizedGridProps", ()=>_propsMjs.virtualizedGridProps
);
parcelHelpers.export(exports, "virtualizedListProps", ()=>_propsMjs.virtualizedListProps
);
parcelHelpers.export(exports, "virtualizedProps", ()=>_propsMjs.virtualizedProps
);
parcelHelpers.export(exports, "virtualizedScrollbarProps", ()=>_propsMjs.virtualizedScrollbarProps
);
var _typesMjs = require("./src/types.mjs");
var _fixedSizeListMjs = require("./src/components/fixed-size-list.mjs");
var _fixedSizeListMjsDefault = parcelHelpers.interopDefault(_fixedSizeListMjs);
var _dynamicSizeListMjs = require("./src/components/dynamic-size-list.mjs");
var _dynamicSizeListMjsDefault = parcelHelpers.interopDefault(_dynamicSizeListMjs);
var _fixedSizeGridMjs = require("./src/components/fixed-size-grid.mjs");
var _fixedSizeGridMjsDefault = parcelHelpers.interopDefault(_fixedSizeGridMjs);
var _dynamicSizeGridMjs = require("./src/components/dynamic-size-grid.mjs");
var _dynamicSizeGridMjsDefault = parcelHelpers.interopDefault(_dynamicSizeGridMjs);
var _propsMjs = require("./src/props.mjs");

},{"./src/types.mjs":"bskqF","./src/components/fixed-size-list.mjs":"eaMZD","./src/components/dynamic-size-list.mjs":"ggHfi","./src/components/fixed-size-grid.mjs":"fyL0k","./src/components/dynamic-size-grid.mjs":"9Fq2m","./src/props.mjs":"2CLE6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bskqF":[function(require,module,exports) {

},{}],"eaMZD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>FixedSizeList
);
var _indexMjs = require("../../../../utils/index.mjs");
var _buildListMjs = require("../builders/build-list.mjs");
var _buildListMjsDefault = parcelHelpers.interopDefault(_buildListMjs);
var _utilsMjs = require("../utils.mjs");
var _defaultsMjs = require("../defaults.mjs");
var _shared = require("@vue/shared");
var _errorMjs = require("../../../../utils/error.mjs");
const FixedSizeList = _buildListMjsDefault.default({
    name: "ElFixedSizeList",
    getItemOffset: ({ itemSize  }, index)=>index * itemSize
    ,
    getItemSize: ({ itemSize  })=>itemSize
    ,
    getEstimatedTotalSize: ({ total , itemSize  })=>itemSize * total
    ,
    getOffset: ({ height , total , itemSize , layout , width  }, index, alignment, scrollOffset)=>{
        const size = _utilsMjs.isHorizontal(layout) ? width : height;
        if (_shared.isString(size)) _errorMjs.throwError("[ElVirtualList]", `
        You should set
          width/height
        to number when your layout is
          horizontal/vertical
      `);
        const lastItemOffset = Math.max(0, total * itemSize - size);
        const maxOffset = Math.min(lastItemOffset, index * itemSize);
        const minOffset = Math.max(0, (index + 1) * itemSize - size);
        if (alignment === _defaultsMjs.SMART_ALIGNMENT) {
            if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) alignment = _defaultsMjs.AUTO_ALIGNMENT;
            else alignment = _defaultsMjs.CENTERED_ALIGNMENT;
        }
        switch(alignment){
            case _defaultsMjs.START_ALIGNMENT:
                return maxOffset;
            case _defaultsMjs.END_ALIGNMENT:
                return minOffset;
            case _defaultsMjs.CENTERED_ALIGNMENT:
                {
                    const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
                    if (middleOffset < Math.ceil(size / 2)) return 0;
                    else if (middleOffset > lastItemOffset + Math.floor(size / 2)) return lastItemOffset;
                    else return middleOffset;
                }
            case _defaultsMjs.AUTO_ALIGNMENT:
            default:
                if (scrollOffset >= minOffset && scrollOffset <= maxOffset) return scrollOffset;
                else if (scrollOffset < minOffset) return minOffset;
                else return maxOffset;
        }
    },
    getStartIndexForOffset: ({ total , itemSize  }, offset)=>Math.max(0, Math.min(total - 1, Math.floor(offset / itemSize)))
    ,
    getStopIndexForStartIndex: ({ height , total , itemSize , layout , width  }, startIndex, scrollOffset)=>{
        const offset = startIndex * itemSize;
        const size = _utilsMjs.isHorizontal(layout) ? width : height;
        const numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);
        return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));
    },
    initCache () {
        return void 0;
    },
    clearCache: true,
    validateProps () {
    }
});

},{"../../../../utils/index.mjs":"dsdeP","../builders/build-list.mjs":"9C6oi","../utils.mjs":"6WUsE","../defaults.mjs":"9F1UY","@vue/shared":"3SM3y","../../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9C6oi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createList
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../../utils/index.mjs");
var _useCacheMjs = require("../hooks/use-cache.mjs");
var _useWheelMjs = require("../hooks/use-wheel.mjs");
var _useWheelMjsDefault = parcelHelpers.interopDefault(_useWheelMjs);
var _scrollbarMjs = require("../components/scrollbar.mjs");
var _scrollbarMjsDefault = parcelHelpers.interopDefault(_scrollbarMjs);
var _utilsMjs = require("../utils.mjs");
var _propsMjs = require("../props.mjs");
var _defaultsMjs = require("../defaults.mjs");
var _shared = require("@vue/shared");
const createList = ({ name , getOffset , getItemSize , getItemOffset , getEstimatedTotalSize , getStartIndexForOffset , getStopIndexForStartIndex , initCache , clearCache , validateProps  })=>{
    return _vue.defineComponent({
        name: name != null ? name : "ElVirtualList",
        props: _propsMjs.virtualizedListProps,
        emits: [
            _defaultsMjs.ITEM_RENDER_EVT,
            _defaultsMjs.SCROLL_EVT
        ],
        setup (props, { emit , expose  }) {
            validateProps(props);
            const instance = _vue.getCurrentInstance();
            const dynamicSizeCache = _vue.ref(initCache(props, instance));
            const getItemStyleCache = _useCacheMjs.useCache();
            const windowRef = _vue.ref();
            const innerRef = _vue.ref();
            const scrollbarRef = _vue.ref();
            const states = _vue.ref({
                isScrolling: false,
                scrollDir: "forward",
                scrollOffset: _core.isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,
                updateRequested: false,
                isScrollbarDragging: false,
                scrollbarAlwaysOn: props.scrollbarAlwaysOn
            });
            const itemsToRender = _vue.computed(()=>{
                const { total , cache  } = props;
                const { isScrolling , scrollDir , scrollOffset  } = _vue.unref(states);
                if (total === 0) return [
                    0,
                    0,
                    0,
                    0
                ];
                const startIndex = getStartIndexForOffset(props, scrollOffset, _vue.unref(dynamicSizeCache));
                const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, _vue.unref(dynamicSizeCache));
                const cacheBackward = !isScrolling || scrollDir === _defaultsMjs.BACKWARD ? Math.max(1, cache) : 1;
                const cacheForward = !isScrolling || scrollDir === _defaultsMjs.FORWARD ? Math.max(1, cache) : 1;
                return [
                    Math.max(0, startIndex - cacheBackward),
                    Math.max(0, Math.min(total - 1, stopIndex + cacheForward)),
                    startIndex,
                    stopIndex
                ];
            });
            const estimatedTotalSize = _vue.computed(()=>getEstimatedTotalSize(props, _vue.unref(dynamicSizeCache))
            );
            const _isHorizontal = _vue.computed(()=>_utilsMjs.isHorizontal(props.layout)
            );
            const windowStyle = _vue.computed(()=>[
                    {
                        position: "relative",
                        overflow: "hidden",
                        WebkitOverflowScrolling: "touch",
                        willChange: "transform"
                    },
                    {
                        direction: props.direction,
                        height: _core.isNumber(props.height) ? `${props.height}px` : props.height,
                        width: _core.isNumber(props.width) ? `${props.width}px` : props.width
                    },
                    props.style
                ]
            );
            const innerStyle = _vue.computed(()=>{
                const size = _vue.unref(estimatedTotalSize);
                const horizontal = _vue.unref(_isHorizontal);
                return {
                    height: horizontal ? "100%" : `${size}px`,
                    pointerEvents: _vue.unref(states).isScrolling ? "none" : void 0,
                    width: horizontal ? `${size}px` : "100%"
                };
            });
            const clientSize = _vue.computed(()=>_isHorizontal.value ? props.width : props.height
            );
            const { onWheel  } = _useWheelMjsDefault.default({
                atStartEdge: _vue.computed(()=>states.value.scrollOffset <= 0
                ),
                atEndEdge: _vue.computed(()=>states.value.scrollOffset >= estimatedTotalSize.value
                ),
                layout: _vue.computed(()=>props.layout
                )
            }, (offset)=>{
                var _a, _b;
                (_b = (_a = scrollbarRef.value).onMouseUp) == null || _b.call(_a);
                scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));
            });
            const emitEvents = ()=>{
                const { total  } = props;
                if (total > 0) {
                    const [cacheStart, cacheEnd, visibleStart, visibleEnd] = _vue.unref(itemsToRender);
                    emit(_defaultsMjs.ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);
                }
                const { scrollDir , scrollOffset , updateRequested  } = _vue.unref(states);
                emit(_defaultsMjs.SCROLL_EVT, scrollDir, scrollOffset, updateRequested);
            };
            const scrollVertically = (e)=>{
                const { clientHeight , scrollHeight , scrollTop  } = e.currentTarget;
                const _states = _vue.unref(states);
                if (_states.scrollOffset === scrollTop) return;
                const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
                states.value = {
                    ..._states,
                    isScrolling: true,
                    scrollDir: _utilsMjs.getScrollDir(_states.scrollOffset, scrollOffset),
                    scrollOffset,
                    updateRequested: false
                };
                _vue.nextTick(resetIsScrolling);
            };
            const scrollHorizontally = (e)=>{
                const { clientWidth , scrollLeft , scrollWidth  } = e.currentTarget;
                const _states = _vue.unref(states);
                if (_states.scrollOffset === scrollLeft) return;
                const { direction  } = props;
                let scrollOffset = scrollLeft;
                if (direction === _defaultsMjs.RTL) switch(_utilsMjs.getRTLOffsetType()){
                    case _defaultsMjs.RTL_OFFSET_NAG:
                        scrollOffset = -scrollLeft;
                        break;
                    case _defaultsMjs.RTL_OFFSET_POS_DESC:
                        scrollOffset = scrollWidth - clientWidth - scrollLeft;
                        break;
                }
                scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
                states.value = {
                    ..._states,
                    isScrolling: true,
                    scrollDir: _utilsMjs.getScrollDir(_states.scrollOffset, scrollOffset),
                    scrollOffset,
                    updateRequested: false
                };
                _vue.nextTick(resetIsScrolling);
            };
            const onScroll = (e)=>{
                _vue.unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);
                emitEvents();
            };
            const onScrollbarScroll = (distanceToGo, totalSteps)=>{
                const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;
                scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));
            };
            const scrollTo = (offset)=>{
                offset = Math.max(offset, 0);
                if (offset === _vue.unref(states).scrollOffset) return;
                states.value = {
                    ..._vue.unref(states),
                    scrollOffset: offset,
                    scrollDir: _utilsMjs.getScrollDir(_vue.unref(states).scrollOffset, offset),
                    updateRequested: true
                };
                _vue.nextTick(resetIsScrolling);
            };
            const scrollToItem = (idx, alignment = _defaultsMjs.AUTO_ALIGNMENT)=>{
                const { scrollOffset  } = _vue.unref(states);
                idx = Math.max(0, Math.min(idx, props.total - 1));
                scrollTo(getOffset(props, idx, alignment, scrollOffset, _vue.unref(dynamicSizeCache)));
            };
            const getItemStyle = (idx)=>{
                const { direction , itemSize , layout  } = props;
                const itemStyleCache = getItemStyleCache.value(clearCache && itemSize, clearCache && layout, clearCache && direction);
                let style;
                if (_shared.hasOwn(itemStyleCache, String(idx))) style = itemStyleCache[idx];
                else {
                    const offset = getItemOffset(props, idx, _vue.unref(dynamicSizeCache));
                    const size = getItemSize(props, idx, _vue.unref(dynamicSizeCache));
                    const horizontal = _vue.unref(_isHorizontal);
                    const isRtl = direction === _defaultsMjs.RTL;
                    const offsetHorizontal = horizontal ? offset : 0;
                    itemStyleCache[idx] = style = {
                        position: "absolute",
                        left: isRtl ? void 0 : `${offsetHorizontal}px`,
                        right: isRtl ? `${offsetHorizontal}px` : void 0,
                        top: !horizontal ? `${offset}px` : 0,
                        height: !horizontal ? `${size}px` : "100%",
                        width: horizontal ? `${size}px` : "100%"
                    };
                }
                return style;
            };
            const resetIsScrolling = ()=>{
                states.value.isScrolling = false;
                _vue.nextTick(()=>{
                    getItemStyleCache.value(-1, null, null);
                });
            };
            const resetScrollTop = ()=>{
                const window = windowRef.value;
                if (window) window.scrollTop = 0;
            };
            _vue.onMounted(()=>{
                if (!_core.isClient) return;
                const { initScrollOffset  } = props;
                const windowElement = _vue.unref(windowRef);
                if (_core.isNumber(initScrollOffset) && windowElement) {
                    if (_vue.unref(_isHorizontal)) windowElement.scrollLeft = initScrollOffset;
                    else windowElement.scrollTop = initScrollOffset;
                }
                emitEvents();
            });
            _vue.onUpdated(()=>{
                const { direction , layout  } = props;
                const { scrollOffset , updateRequested  } = _vue.unref(states);
                const windowElement = _vue.unref(windowRef);
                if (updateRequested && windowElement) {
                    if (layout === _defaultsMjs.HORIZONTAL) {
                        if (direction === _defaultsMjs.RTL) switch(_utilsMjs.getRTLOffsetType()){
                            case "negative":
                                windowElement.scrollLeft = -scrollOffset;
                                break;
                            case "positive-ascending":
                                windowElement.scrollLeft = scrollOffset;
                                break;
                            default:
                                {
                                    const { clientWidth , scrollWidth  } = windowElement;
                                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                                    break;
                                }
                        }
                        else windowElement.scrollLeft = scrollOffset;
                    } else windowElement.scrollTop = scrollOffset;
                }
            });
            const api = {
                clientSize,
                estimatedTotalSize,
                windowStyle,
                windowRef,
                innerRef,
                innerStyle,
                itemsToRender,
                scrollbarRef,
                states,
                getItemStyle,
                onScroll,
                onScrollbarScroll,
                onWheel,
                scrollTo,
                scrollToItem,
                resetScrollTop
            };
            expose({
                windowRef,
                innerRef,
                getItemStyleCache,
                scrollTo,
                scrollToItem,
                resetScrollTop,
                states
            });
            return api;
        },
        render (ctx) {
            var _a;
            const { $slots , className , clientSize , containerElement , data , getItemStyle , innerElement , itemsToRender , innerStyle , layout , total , onScroll , onScrollbarScroll , onWheel , states , useIsScrolling , windowStyle  } = ctx;
            const [start, end] = itemsToRender;
            const Container = _vue.resolveDynamicComponent(containerElement);
            const Inner = _vue.resolveDynamicComponent(innerElement);
            const children = [];
            if (total > 0) for(let i = start; i <= end; i++)children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {
                data,
                key: i,
                index: i,
                isScrolling: useIsScrolling ? states.isScrolling : void 0,
                style: getItemStyle(i)
            }));
            const InnerNode = [
                _vue.h(Inner, {
                    style: innerStyle,
                    ref: "innerRef"
                }, !_shared.isString(Inner) ? {
                    default: ()=>children
                } : children)
            ];
            const scrollbar = _vue.h(_scrollbarMjsDefault.default, {
                ref: "scrollbarRef",
                clientSize,
                layout,
                onScroll: onScrollbarScroll,
                ratio: clientSize * 100 / this.estimatedTotalSize,
                scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),
                total
            });
            const listContainer = _vue.h(Container, {
                class: className,
                style: windowStyle,
                onScroll,
                onWheel,
                ref: "windowRef",
                key: 0
            }, !_shared.isString(Container) ? {
                default: ()=>[
                        InnerNode
                    ]
            } : [
                InnerNode
            ]);
            return _vue.h("div", {
                key: 0,
                class: [
                    "el-vl__wrapper",
                    states.scrollbarAlwaysOn ? "always-on" : ""
                ]
            }, [
                listContainer,
                scrollbar
            ]);
        }
    });
};

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../../utils/index.mjs":"dsdeP","../hooks/use-cache.mjs":"j4BQY","../hooks/use-wheel.mjs":"4Xlpo","../components/scrollbar.mjs":"8bpQg","../utils.mjs":"6WUsE","../props.mjs":"2CLE6","../defaults.mjs":"9F1UY","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j4BQY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useCache", ()=>useCache
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _memoizeOne = require("memoize-one");
var _memoizeOneDefault = parcelHelpers.interopDefault(_memoizeOne);
const useCache = ()=>{
    const vm = _vue.getCurrentInstance();
    const props = vm.proxy.$props;
    return _vue.computed(()=>{
        const _getItemStyleCache = (_, __, ___)=>({
            })
        ;
        return props.perfMode ? _lodashUnified.memoize(_getItemStyleCache) : _memoizeOneDefault.default(_getItemStyleCache);
    });
};

},{"vue":"gzxs9","lodash-unified":"4Oj4p","memoize-one":"ajWd5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ajWd5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>memoizeOne
);
var safeIsNaN = Number.isNaN || function ponyfill(value) {
    return typeof value === 'number' && value !== value;
};
function isEqual(first, second) {
    if (first === second) return true;
    if (safeIsNaN(first) && safeIsNaN(second)) return true;
    return false;
}
function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) return false;
    for(var i = 0; i < newInputs.length; i++){
        if (!isEqual(newInputs[i], lastInputs[i])) return false;
    }
    return true;
}
function memoizeOne(resultFn, isEqual1) {
    if (isEqual1 === void 0) isEqual1 = areInputsEqual;
    var cache = null;
    function memoized() {
        var newArgs = [];
        for(var _i = 0; _i < arguments.length; _i++)newArgs[_i] = arguments[_i];
        if (cache && cache.lastThis === this && isEqual1(newArgs, cache.lastArgs)) return cache.lastResult;
        var lastResult = resultFn.apply(this, newArgs);
        cache = {
            lastResult: lastResult,
            lastArgs: newArgs,
            lastThis: this
        };
        return lastResult;
    }
    memoized.clear = function clear() {
        cache = null;
    };
    return memoized;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Xlpo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useWheel
);
var _indexMjs = require("../../../../utils/index.mjs");
var _utilsMjs = require("../utils.mjs");
var _defaultsMjs = require("../defaults.mjs");
var _rafMjs = require("../../../../utils/raf.mjs");
const LayoutKeys = {
    [_defaultsMjs.HORIZONTAL]: "deltaX",
    [_defaultsMjs.VERTICAL]: "deltaY"
};
const useWheel = ({ atEndEdge , atStartEdge , layout  }, onWheelDelta)=>{
    let frameHandle;
    let offset = 0;
    const hasReachedEdge = (offset2)=>{
        const edgeReached = offset2 < 0 && atStartEdge.value || offset2 > 0 && atEndEdge.value;
        return edgeReached;
    };
    const onWheel = (e)=>{
        _rafMjs.cAF(frameHandle);
        const newOffset = e[LayoutKeys[layout.value]];
        if (hasReachedEdge(offset) && hasReachedEdge(offset + newOffset)) return;
        offset += newOffset;
        if (!_utilsMjs.isFF) e.preventDefault();
        frameHandle = _rafMjs.rAF(()=>{
            onWheelDelta(offset);
            offset = 0;
        });
    };
    return {
        hasReachedEdge,
        onWheel
    };
};

},{"../../../../utils/index.mjs":"dsdeP","../utils.mjs":"6WUsE","../defaults.mjs":"9F1UY","../../../../utils/raf.mjs":"apnDl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6WUsE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getRTLOffsetType", ()=>getRTLOffsetType
);
parcelHelpers.export(exports, "getRelativePos", ()=>getRelativePos
);
parcelHelpers.export(exports, "getScrollDir", ()=>getScrollDir
);
parcelHelpers.export(exports, "isFF", ()=>isFF
);
parcelHelpers.export(exports, "isHorizontal", ()=>isHorizontal
);
parcelHelpers.export(exports, "isRTL", ()=>isRTL
);
parcelHelpers.export(exports, "renderThumbStyle", ()=>renderThumbStyle
);
var _shared = require("@vue/shared");
var _defaultsMjs = require("./defaults.mjs");
const getScrollDir = (prev, cur)=>prev < cur ? _defaultsMjs.FORWARD : _defaultsMjs.BACKWARD
;
const isHorizontal = (dir)=>dir === _defaultsMjs.LTR || dir === _defaultsMjs.RTL || dir === _defaultsMjs.HORIZONTAL
;
const isRTL = (dir)=>dir === _defaultsMjs.RTL
;
let cachedRTLResult = null;
function getRTLOffsetType(recalculate = false) {
    if (cachedRTLResult === null || recalculate) {
        const outerDiv = document.createElement("div");
        const outerStyle = outerDiv.style;
        outerStyle.width = "50px";
        outerStyle.height = "50px";
        outerStyle.overflow = "scroll";
        outerStyle.direction = "rtl";
        const innerDiv = document.createElement("div");
        const innerStyle = innerDiv.style;
        innerStyle.width = "100px";
        innerStyle.height = "100px";
        outerDiv.appendChild(innerDiv);
        document.body.appendChild(outerDiv);
        if (outerDiv.scrollLeft > 0) cachedRTLResult = _defaultsMjs.RTL_OFFSET_POS_DESC;
        else {
            outerDiv.scrollLeft = 1;
            if (outerDiv.scrollLeft === 0) cachedRTLResult = _defaultsMjs.RTL_OFFSET_NAG;
            else cachedRTLResult = _defaultsMjs.RTL_OFFSET_POS_ASC;
        }
        document.body.removeChild(outerDiv);
        return cachedRTLResult;
    }
    return cachedRTLResult;
}
const getRelativePos = (e, layout)=>{
    return "touches" in e ? e.touches[0][_defaultsMjs.PageKey[layout]] : e[_defaultsMjs.PageKey[layout]];
};
function renderThumbStyle({ move , size , bar  }, layout) {
    const style = {
    };
    const translate = `translate${bar.axis}(${move}px)`;
    style[bar.size] = size;
    style.transform = translate;
    style.msTransform = translate;
    style.webkitTransform = translate;
    if (layout === "horizontal") style.height = "100%";
    else style.width = "100%";
    return style;
}
const isFF = typeof navigator !== "undefined" && _shared.isObject(navigator) && /Firefox/i.test(navigator.userAgent);

},{"@vue/shared":"3SM3y","./defaults.mjs":"9F1UY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9F1UY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AUTO_ALIGNMENT", ()=>AUTO_ALIGNMENT
);
parcelHelpers.export(exports, "BACKWARD", ()=>BACKWARD
);
parcelHelpers.export(exports, "CENTERED_ALIGNMENT", ()=>CENTERED_ALIGNMENT
);
parcelHelpers.export(exports, "DEFAULT_DYNAMIC_LIST_ITEM_SIZE", ()=>DEFAULT_DYNAMIC_LIST_ITEM_SIZE
);
parcelHelpers.export(exports, "END_ALIGNMENT", ()=>END_ALIGNMENT
);
parcelHelpers.export(exports, "FORWARD", ()=>FORWARD
);
parcelHelpers.export(exports, "HORIZONTAL", ()=>HORIZONTAL
);
parcelHelpers.export(exports, "ITEM_RENDER_EVT", ()=>ITEM_RENDER_EVT
);
parcelHelpers.export(exports, "LTR", ()=>LTR
);
parcelHelpers.export(exports, "PageKey", ()=>PageKey
);
parcelHelpers.export(exports, "RTL", ()=>RTL
);
parcelHelpers.export(exports, "RTL_OFFSET_NAG", ()=>RTL_OFFSET_NAG
);
parcelHelpers.export(exports, "RTL_OFFSET_POS_ASC", ()=>RTL_OFFSET_POS_ASC
);
parcelHelpers.export(exports, "RTL_OFFSET_POS_DESC", ()=>RTL_OFFSET_POS_DESC
);
parcelHelpers.export(exports, "SCROLLBAR_MIN_SIZE", ()=>SCROLLBAR_MIN_SIZE
);
parcelHelpers.export(exports, "SCROLL_EVT", ()=>SCROLL_EVT
);
parcelHelpers.export(exports, "SMART_ALIGNMENT", ()=>SMART_ALIGNMENT
);
parcelHelpers.export(exports, "START_ALIGNMENT", ()=>START_ALIGNMENT
);
parcelHelpers.export(exports, "ScrollbarDirKey", ()=>ScrollbarDirKey
);
parcelHelpers.export(exports, "ScrollbarSizeKey", ()=>ScrollbarSizeKey
);
parcelHelpers.export(exports, "VERTICAL", ()=>VERTICAL
);
const DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;
const ITEM_RENDER_EVT = "item-rendered";
const SCROLL_EVT = "scroll";
const FORWARD = "forward";
const BACKWARD = "backward";
const AUTO_ALIGNMENT = "auto";
const SMART_ALIGNMENT = "smart";
const START_ALIGNMENT = "start";
const CENTERED_ALIGNMENT = "center";
const END_ALIGNMENT = "end";
const HORIZONTAL = "horizontal";
const VERTICAL = "vertical";
const LTR = "ltr";
const RTL = "rtl";
const RTL_OFFSET_NAG = "negative";
const RTL_OFFSET_POS_ASC = "positive-ascending";
const RTL_OFFSET_POS_DESC = "positive-descending";
const PageKey = {
    [HORIZONTAL]: "pageX",
    [VERTICAL]: "pageY"
};
const ScrollbarSizeKey = {
    [HORIZONTAL]: "height",
    [VERTICAL]: "width"
};
const ScrollbarDirKey = {
    [HORIZONTAL]: "left",
    [VERTICAL]: "top"
};
const SCROLLBAR_MIN_SIZE = 20;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bpQg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ScrollBar
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../scrollbar/index.mjs");
var _indexMjs1 = require("../../../../utils/index.mjs");
var _defaultsMjs = require("../defaults.mjs");
var _propsMjs = require("../props.mjs");
var _utilsMjs = require("../utils.mjs");
var _utilMjs = require("../../../scrollbar/src/util.mjs");
var _eventMjs = require("../../../../utils/dom/event.mjs");
var _rafMjs = require("../../../../utils/raf.mjs");
const ScrollBar = _vue.defineComponent({
    name: "ElVirtualScrollBar",
    props: _propsMjs.virtualizedScrollbarProps,
    emits: [
        "scroll",
        "start-move",
        "stop-move"
    ],
    setup (props, { emit  }) {
        const GAP = 4;
        const trackRef = _vue.ref();
        const thumbRef = _vue.ref();
        let frameHandle = null;
        let onselectstartStore = null;
        const state = _vue.reactive({
            isDragging: false,
            traveled: 0
        });
        const bar = _vue.computed(()=>_utilMjs.BAR_MAP[props.layout]
        );
        const trackSize = _vue.computed(()=>props.clientSize - GAP
        );
        const trackStyle = _vue.computed(()=>({
                position: "absolute",
                width: _defaultsMjs.HORIZONTAL === props.layout ? `${trackSize.value}px` : "6px",
                height: _defaultsMjs.HORIZONTAL === props.layout ? "6px" : `${trackSize.value}px`,
                [_defaultsMjs.ScrollbarDirKey[props.layout]]: "2px",
                right: "2px",
                bottom: "2px",
                borderRadius: "4px"
            })
        );
        const thumbSize = _vue.computed(()=>{
            const ratio = props.ratio;
            const clientSize = props.clientSize;
            if (ratio >= 100) return Number.POSITIVE_INFINITY;
            if (ratio >= 50) return ratio * clientSize / 100;
            const SCROLLBAR_MAX_SIZE = clientSize / 3;
            return Math.floor(Math.min(Math.max(ratio * clientSize, _defaultsMjs.SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));
        });
        const thumbStyle = _vue.computed(()=>{
            if (!Number.isFinite(thumbSize.value)) return {
                display: "none"
            };
            const thumb = `${thumbSize.value}px`;
            const style = _utilsMjs.renderThumbStyle({
                bar: bar.value,
                size: thumb,
                move: state.traveled
            }, props.layout);
            return style;
        });
        const totalSteps = _vue.computed(()=>Math.floor(props.clientSize - thumbSize.value - GAP)
        );
        const attachEvents = ()=>{
            _eventMjs.on(window, "mousemove", onMouseMove);
            _eventMjs.on(window, "mouseup", onMouseUp);
            const thumbEl = _vue.unref(thumbRef);
            if (!thumbEl) return;
            onselectstartStore = document.onselectstart;
            document.onselectstart = ()=>false
            ;
            _eventMjs.on(thumbEl, "touchmove", onMouseMove);
            _eventMjs.on(thumbEl, "touchend", onMouseUp);
        };
        const detachEvents = ()=>{
            _eventMjs.off(window, "mousemove", onMouseMove);
            _eventMjs.off(window, "mouseup", onMouseUp);
            document.onselectstart = onselectstartStore;
            onselectstartStore = null;
            const thumbEl = _vue.unref(thumbRef);
            if (!thumbEl) return;
            _eventMjs.off(thumbEl, "touchmove", onMouseMove);
            _eventMjs.off(thumbEl, "touchend", onMouseUp);
        };
        const onThumbMouseDown = (e)=>{
            e.stopImmediatePropagation();
            if (e.ctrlKey || [
                1,
                2
            ].includes(e.button)) return;
            state.isDragging = true;
            state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);
            emit("start-move");
            attachEvents();
        };
        const onMouseUp = ()=>{
            state.isDragging = false;
            state[bar.value.axis] = 0;
            emit("stop-move");
            detachEvents();
        };
        const onMouseMove = (e)=>{
            const { isDragging  } = state;
            if (!isDragging) return;
            if (!thumbRef.value || !trackRef.value) return;
            const prevPage = state[bar.value.axis];
            if (!prevPage) return;
            _rafMjs.cAF(frameHandle);
            const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
            const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;
            const distance = offset - thumbClickPosition;
            frameHandle = _rafMjs.rAF(()=>{
                state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
                emit("scroll", distance, totalSteps.value);
            });
        };
        const clickTrackHandler = (e)=>{
            const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
            const thumbHalf = thumbRef.value[bar.value.offset] / 2;
            const distance = offset - thumbHalf;
            state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
            emit("scroll", distance, totalSteps.value);
        };
        const onScrollbarTouchStart = (e)=>e.preventDefault()
        ;
        _vue.watch(()=>props.scrollFrom
        , (v)=>{
            if (state.isDragging) return;
            state.traveled = Math.ceil(v * totalSteps.value);
        });
        _vue.onMounted(()=>{
            if (!_core.isClient) return;
            _eventMjs.on(trackRef.value, "touchstart", onScrollbarTouchStart);
            _eventMjs.on(thumbRef.value, "touchstart", onThumbMouseDown);
        });
        _vue.onBeforeUnmount(()=>{
            _eventMjs.off(trackRef.value, "touchstart", onScrollbarTouchStart);
            detachEvents();
        });
        return ()=>{
            return _vue.h("div", {
                role: "presentation",
                ref: trackRef,
                class: "el-virtual-scrollbar",
                style: trackStyle.value,
                onMousedown: _vue.withModifiers(clickTrackHandler, [
                    "stop",
                    "prevent"
                ])
            }, _vue.h("div", {
                ref: thumbRef,
                class: "el-scrollbar__thumb",
                style: thumbStyle.value,
                onMousedown: onThumbMouseDown
            }, []));
        };
    }
});

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../scrollbar/index.mjs":"kXLHt","../../../../utils/index.mjs":"dsdeP","../defaults.mjs":"9F1UY","../props.mjs":"2CLE6","../utils.mjs":"6WUsE","../../../scrollbar/src/util.mjs":"eBQCF","../../../../utils/dom/event.mjs":"fnXSh","../../../../utils/raf.mjs":"apnDl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2CLE6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "virtualizedGridProps", ()=>virtualizedGridProps
);
parcelHelpers.export(exports, "virtualizedListProps", ()=>virtualizedListProps
);
parcelHelpers.export(exports, "virtualizedProps", ()=>virtualizedProps
);
parcelHelpers.export(exports, "virtualizedScrollbarProps", ()=>virtualizedScrollbarProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _defaultsMjs = require("./defaults.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _typescriptMjs = require("../../../utils/typescript.mjs");
const itemSize = _propsMjs.buildProp({
    type: _propsMjs.definePropType([
        Number,
        Function
    ]),
    required: true
});
const estimatedItemSize = _propsMjs.buildProp({
    type: Number
});
const cache = _propsMjs.buildProp({
    type: Number,
    default: 2
});
const direction = _propsMjs.buildProp({
    type: String,
    values: [
        "ltr",
        "rtl"
    ],
    default: "ltr"
});
const initScrollOffset = _propsMjs.buildProp({
    type: Number,
    default: 0
});
const total = _propsMjs.buildProp({
    type: Number,
    required: true
});
const layout = _propsMjs.buildProp({
    type: String,
    values: [
        "horizontal",
        "vertical"
    ],
    default: _defaultsMjs.VERTICAL
});
const virtualizedProps = _propsMjs.buildProps({
    className: {
        type: String,
        default: ""
    },
    containerElement: {
        type: _propsMjs.definePropType([
            String,
            Object
        ]),
        default: "div"
    },
    data: {
        type: _propsMjs.definePropType(Array),
        default: ()=>_typescriptMjs.mutable([])
    },
    direction,
    height: {
        type: [
            String,
            Number
        ],
        required: true
    },
    innerElement: {
        type: [
            String,
            Object
        ],
        default: "div"
    },
    style: {
        type: _propsMjs.definePropType([
            Object,
            String,
            Array
        ])
    },
    useIsScrolling: {
        type: Boolean,
        default: false
    },
    width: {
        type: [
            Number,
            String
        ],
        required: false
    },
    perfMode: {
        type: Boolean,
        default: true
    },
    scrollbarAlwaysOn: {
        type: Boolean,
        default: false
    }
});
const virtualizedListProps = _propsMjs.buildProps({
    cache,
    estimatedItemSize,
    layout,
    initScrollOffset,
    total,
    itemSize,
    ...virtualizedProps
});
const virtualizedGridProps = _propsMjs.buildProps({
    columnCache: cache,
    columnWidth: itemSize,
    estimatedColumnWidth: estimatedItemSize,
    estimatedRowHeight: estimatedItemSize,
    initScrollLeft: initScrollOffset,
    initScrollTop: initScrollOffset,
    rowCache: cache,
    rowHeight: itemSize,
    totalColumn: total,
    totalRow: total,
    ...virtualizedProps
});
const virtualizedScrollbarProps = _propsMjs.buildProps({
    layout,
    total,
    ratio: {
        type: Number,
        required: true
    },
    clientSize: {
        type: Number,
        required: true
    },
    scrollFrom: {
        type: Number,
        required: true
    },
    visible: Boolean
});

},{"../../../utils/index.mjs":"dsdeP","./defaults.mjs":"9F1UY","../../../utils/vue/props.mjs":"cpwWK","../../../utils/typescript.mjs":"bRl53","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ggHfi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>DynamicSizeList
);
var _indexMjs = require("../../../../utils/index.mjs");
var _buildListMjs = require("../builders/build-list.mjs");
var _buildListMjsDefault = parcelHelpers.interopDefault(_buildListMjs);
var _utilsMjs = require("../utils.mjs");
var _defaultsMjs = require("../defaults.mjs");
var _errorMjs = require("../../../../utils/error.mjs");
const SCOPE = "ElDynamicSizeList";
const getItemFromCache = (props, index, listCache)=>{
    const { itemSize  } = props;
    const { items , lastVisitedIndex  } = listCache;
    if (index > lastVisitedIndex) {
        let offset = 0;
        if (lastVisitedIndex >= 0) {
            const item = items[lastVisitedIndex];
            offset = item.offset + item.size;
        }
        for(let i = lastVisitedIndex + 1; i <= index; i++){
            const size = itemSize(i);
            items[i] = {
                offset,
                size
            };
            offset += size;
        }
        listCache.lastVisitedIndex = index;
    }
    return items[index];
};
const findItem = (props, listCache, offset)=>{
    const { items , lastVisitedIndex  } = listCache;
    const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;
    if (lastVisitedOffset >= offset) return bs(props, listCache, 0, lastVisitedIndex, offset);
    return es(props, listCache, Math.max(0, lastVisitedIndex), offset);
};
const bs = (props, listCache, low, high, offset)=>{
    while(low <= high){
        const mid = low + Math.floor((high - low) / 2);
        const currentOffset = getItemFromCache(props, mid, listCache).offset;
        if (currentOffset === offset) return mid;
        else if (currentOffset < offset) low = mid + 1;
        else if (currentOffset > offset) high = mid - 1;
    }
    return Math.max(0, low - 1);
};
const es = (props, listCache, index, offset)=>{
    const { total  } = props;
    let exponent = 1;
    while(index < total && getItemFromCache(props, index, listCache).offset < offset){
        index += exponent;
        exponent *= 2;
    }
    return bs(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);
};
const getEstimatedTotalSize = ({ total  }, { items , estimatedItemSize , lastVisitedIndex  })=>{
    let totalSizeOfMeasuredItems = 0;
    if (lastVisitedIndex >= total) lastVisitedIndex = total - 1;
    if (lastVisitedIndex >= 0) {
        const item = items[lastVisitedIndex];
        totalSizeOfMeasuredItems = item.offset + item.size;
    }
    const numUnmeasuredItems = total - lastVisitedIndex - 1;
    const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;
    return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
};
const DynamicSizeList = _buildListMjsDefault.default({
    name: "ElDynamicSizeList",
    getItemOffset: (props, index, listCache)=>getItemFromCache(props, index, listCache).offset
    ,
    getItemSize: (_, index, { items  })=>items[index].size
    ,
    getEstimatedTotalSize,
    getOffset: (props, index, alignment, scrollOffset, listCache)=>{
        const { height , layout , width  } = props;
        const size = _utilsMjs.isHorizontal(layout) ? width : height;
        const item = getItemFromCache(props, index, listCache);
        const estimatedTotalSize = getEstimatedTotalSize(props, listCache);
        const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));
        const minOffset = Math.max(0, item.offset - size + item.size);
        if (alignment === _defaultsMjs.SMART_ALIGNMENT) {
            if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) alignment = _defaultsMjs.AUTO_ALIGNMENT;
            else alignment = _defaultsMjs.CENTERED_ALIGNMENT;
        }
        switch(alignment){
            case _defaultsMjs.START_ALIGNMENT:
                return maxOffset;
            case _defaultsMjs.END_ALIGNMENT:
                return minOffset;
            case _defaultsMjs.CENTERED_ALIGNMENT:
                return Math.round(minOffset + (maxOffset - minOffset) / 2);
            case _defaultsMjs.AUTO_ALIGNMENT:
            default:
                if (scrollOffset >= minOffset && scrollOffset <= maxOffset) return scrollOffset;
                else if (scrollOffset < minOffset) return minOffset;
                else return maxOffset;
        }
    },
    getStartIndexForOffset: (props, offset, listCache)=>findItem(props, listCache, offset)
    ,
    getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache)=>{
        const { height , total , layout , width  } = props;
        const size = _utilsMjs.isHorizontal(layout) ? width : height;
        const item = getItemFromCache(props, startIndex, listCache);
        const maxOffset = scrollOffset + size;
        let offset = item.offset + item.size;
        let stopIndex = startIndex;
        while(stopIndex < total - 1 && offset < maxOffset){
            stopIndex++;
            offset += getItemFromCache(props, stopIndex, listCache).size;
        }
        return stopIndex;
    },
    initCache ({ estimatedItemSize =_defaultsMjs.DEFAULT_DYNAMIC_LIST_ITEM_SIZE  }, instance) {
        const cache = {
            items: {
            },
            estimatedItemSize,
            lastVisitedIndex: -1
        };
        cache.clearCacheAfterIndex = (index, forceUpdate = true)=>{
            var _a, _b;
            cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);
            (_a = instance.exposed) == null || _a.getItemStyleCache(-1);
            if (forceUpdate) (_b = instance.proxy) == null || _b.$forceUpdate();
        };
        return cache;
    },
    clearCache: false,
    validateProps: ({ itemSize  })=>{
        if (typeof itemSize !== "function") _errorMjs.throwError(SCOPE, `
          itemSize is required as function, but the given value was ${typeof itemSize}
        `);
    }
});

},{"../../../../utils/index.mjs":"dsdeP","../builders/build-list.mjs":"9C6oi","../utils.mjs":"6WUsE","../defaults.mjs":"9F1UY","../../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fyL0k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>FixedSizeGrid
);
var _indexMjs = require("../../../../utils/index.mjs");
var _buildGridMjs = require("../builders/build-grid.mjs");
var _buildGridMjsDefault = parcelHelpers.interopDefault(_buildGridMjs);
var _defaultsMjs = require("../defaults.mjs");
var _core = require("@vueuse/core");
var _errorMjs = require("../../../../utils/error.mjs");
const SCOPE = "ElFixedSizeGrid";
const FixedSizeGrid = _buildGridMjsDefault.default({
    name: "ElFixedSizeGrid",
    getColumnPosition: ({ columnWidth  }, index)=>[
            columnWidth,
            index * columnWidth
        ]
    ,
    getRowPosition: ({ rowHeight  }, index)=>[
            rowHeight,
            index * rowHeight
        ]
    ,
    getEstimatedTotalHeight: ({ totalRow , rowHeight  })=>rowHeight * totalRow
    ,
    getEstimatedTotalWidth: ({ totalColumn , columnWidth  })=>columnWidth * totalColumn
    ,
    getColumnOffset: ({ totalColumn , columnWidth , width  }, columnIndex, alignment, scrollLeft, _, scrollBarWidth)=>{
        width = Number(width);
        const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);
        const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);
        const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);
        if (alignment === "smart") {
            if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) alignment = _defaultsMjs.AUTO_ALIGNMENT;
            else alignment = _defaultsMjs.CENTERED_ALIGNMENT;
        }
        switch(alignment){
            case _defaultsMjs.START_ALIGNMENT:
                return maxOffset;
            case _defaultsMjs.END_ALIGNMENT:
                return minOffset;
            case _defaultsMjs.CENTERED_ALIGNMENT:
                {
                    const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
                    if (middleOffset < Math.ceil(width / 2)) return 0;
                    else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) return lastColumnOffset;
                    else return middleOffset;
                }
            case _defaultsMjs.AUTO_ALIGNMENT:
            default:
                if (scrollLeft >= minOffset && scrollLeft <= maxOffset) return scrollLeft;
                else if (minOffset > maxOffset) return minOffset;
                else if (scrollLeft < minOffset) return minOffset;
                else return maxOffset;
        }
    },
    getRowOffset: ({ rowHeight , height , totalRow  }, rowIndex, align, scrollTop, _, scrollBarWidth)=>{
        height = Number(height);
        const lastRowOffset = Math.max(0, totalRow * rowHeight - height);
        const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);
        const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);
        if (align === _defaultsMjs.SMART_ALIGNMENT) {
            if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) align = _defaultsMjs.AUTO_ALIGNMENT;
            else align = _defaultsMjs.CENTERED_ALIGNMENT;
        }
        switch(align){
            case _defaultsMjs.START_ALIGNMENT:
                return maxOffset;
            case _defaultsMjs.END_ALIGNMENT:
                return minOffset;
            case _defaultsMjs.CENTERED_ALIGNMENT:
                {
                    const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
                    if (middleOffset < Math.ceil(height / 2)) return 0;
                    else if (middleOffset > lastRowOffset + Math.floor(height / 2)) return lastRowOffset;
                    else return middleOffset;
                }
            case _defaultsMjs.AUTO_ALIGNMENT:
            default:
                if (scrollTop >= minOffset && scrollTop <= maxOffset) return scrollTop;
                else if (minOffset > maxOffset) return minOffset;
                else if (scrollTop < minOffset) return minOffset;
                else return maxOffset;
        }
    },
    getColumnStartIndexForOffset: ({ columnWidth , totalColumn  }, scrollLeft)=>Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth)))
    ,
    getColumnStopIndexForStartIndex: ({ columnWidth , totalColumn , width  }, startIndex, scrollLeft)=>{
        const left = startIndex * columnWidth;
        const visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);
        return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));
    },
    getRowStartIndexForOffset: ({ rowHeight , totalRow  }, scrollTop)=>Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight)))
    ,
    getRowStopIndexForStartIndex: ({ rowHeight , totalRow , height  }, startIndex, scrollTop)=>{
        const top = startIndex * rowHeight;
        const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);
        return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));
    },
    initCache: ()=>void 0
    ,
    clearCache: true,
    validateProps: ({ columnWidth , rowHeight  })=>{
        if (!_core.isNumber(columnWidth)) _errorMjs.throwError(SCOPE, `
          "columnWidth" must be passed as number,
            instead ${typeof columnWidth} was given.
        `);
        if (!_core.isNumber(rowHeight)) _errorMjs.throwError(SCOPE, `
          "columnWidth" must be passed as number,
            instead ${typeof rowHeight} was given.
        `);
    }
});

},{"../../../../utils/index.mjs":"dsdeP","../builders/build-grid.mjs":"5yvoE","../defaults.mjs":"9F1UY","@vueuse/core":"eEHP9","../../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5yvoE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createGrid
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../../utils/index.mjs");
var _scrollbarMjs = require("../components/scrollbar.mjs");
var _scrollbarMjsDefault = parcelHelpers.interopDefault(_scrollbarMjs);
var _useGridWheelMjs = require("../hooks/use-grid-wheel.mjs");
var _useCacheMjs = require("../hooks/use-cache.mjs");
var _propsMjs = require("../props.mjs");
var _utilsMjs = require("../utils.mjs");
var _defaultsMjs = require("../defaults.mjs");
var _scrollMjs = require("../../../../utils/dom/scroll.mjs");
var _shared = require("@vue/shared");
const createGrid = ({ name , clearCache , getColumnPosition , getColumnStartIndexForOffset , getColumnStopIndexForStartIndex , getEstimatedTotalHeight , getEstimatedTotalWidth , getColumnOffset , getRowOffset , getRowPosition , getRowStartIndexForOffset , getRowStopIndexForStartIndex , initCache , validateProps  })=>{
    return _vue.defineComponent({
        name: name != null ? name : "ElVirtualList",
        props: _propsMjs.virtualizedGridProps,
        emits: [
            _defaultsMjs.ITEM_RENDER_EVT,
            _defaultsMjs.SCROLL_EVT
        ],
        setup (props, { emit , expose , slots  }) {
            validateProps(props);
            const instance = _vue.getCurrentInstance();
            const cache = _vue.ref(initCache(props, instance));
            const windowRef = _vue.ref();
            const hScrollbar = _vue.ref();
            const vScrollbar = _vue.ref();
            const innerRef = _vue.ref(null);
            const states = _vue.ref({
                isScrolling: false,
                scrollLeft: _core.isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,
                scrollTop: _core.isNumber(props.initScrollTop) ? props.initScrollTop : 0,
                updateRequested: false,
                xAxisScrollDir: _defaultsMjs.FORWARD,
                yAxisScrollDir: _defaultsMjs.FORWARD
            });
            const getItemStyleCache = _useCacheMjs.useCache();
            const parsedHeight = _vue.computed(()=>parseInt(`${props.height}`, 10)
            );
            const parsedWidth = _vue.computed(()=>parseInt(`${props.width}`, 10)
            );
            const columnsToRender = _vue.computed(()=>{
                const { totalColumn , totalRow , columnCache  } = props;
                const { isScrolling , xAxisScrollDir , scrollLeft  } = _vue.unref(states);
                if (totalColumn === 0 || totalRow === 0) return [
                    0,
                    0,
                    0,
                    0
                ];
                const startIndex = getColumnStartIndexForOffset(props, scrollLeft, _vue.unref(cache));
                const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, _vue.unref(cache));
                const cacheBackward = !isScrolling || xAxisScrollDir === _defaultsMjs.BACKWARD ? Math.max(1, columnCache) : 1;
                const cacheForward = !isScrolling || xAxisScrollDir === _defaultsMjs.FORWARD ? Math.max(1, columnCache) : 1;
                return [
                    Math.max(0, startIndex - cacheBackward),
                    Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)),
                    startIndex,
                    stopIndex
                ];
            });
            const rowsToRender = _vue.computed(()=>{
                const { totalColumn , totalRow , rowCache  } = props;
                const { isScrolling , yAxisScrollDir , scrollTop  } = _vue.unref(states);
                if (totalColumn === 0 || totalRow === 0) return [
                    0,
                    0,
                    0,
                    0
                ];
                const startIndex = getRowStartIndexForOffset(props, scrollTop, _vue.unref(cache));
                const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, _vue.unref(cache));
                const cacheBackward = !isScrolling || yAxisScrollDir === _defaultsMjs.BACKWARD ? Math.max(1, rowCache) : 1;
                const cacheForward = !isScrolling || yAxisScrollDir === _defaultsMjs.FORWARD ? Math.max(1, rowCache) : 1;
                return [
                    Math.max(0, startIndex - cacheBackward),
                    Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)),
                    startIndex,
                    stopIndex
                ];
            });
            const estimatedTotalHeight = _vue.computed(()=>getEstimatedTotalHeight(props, _vue.unref(cache))
            );
            const estimatedTotalWidth = _vue.computed(()=>getEstimatedTotalWidth(props, _vue.unref(cache))
            );
            const windowStyle = _vue.computed(()=>{
                var _a;
                return [
                    {
                        position: "relative",
                        overflow: "hidden",
                        WebkitOverflowScrolling: "touch",
                        willChange: "transform"
                    },
                    {
                        direction: props.direction,
                        height: _core.isNumber(props.height) ? `${props.height}px` : props.height,
                        width: _core.isNumber(props.width) ? `${props.width}px` : props.width
                    },
                    (_a = props.style) != null ? _a : {
                    }
                ];
            });
            const innerStyle = _vue.computed(()=>{
                const width = `${_vue.unref(estimatedTotalWidth)}px`;
                const height = `${_vue.unref(estimatedTotalHeight)}px`;
                return {
                    height,
                    pointerEvents: _vue.unref(states).isScrolling ? "none" : void 0,
                    width
                };
            });
            const emitEvents = ()=>{
                const { totalColumn , totalRow  } = props;
                if (totalColumn > 0 && totalRow > 0) {
                    const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = _vue.unref(columnsToRender);
                    const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = _vue.unref(rowsToRender);
                    emit(_defaultsMjs.ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);
                }
                const { scrollLeft , scrollTop , updateRequested , xAxisScrollDir , yAxisScrollDir  } = _vue.unref(states);
                emit(_defaultsMjs.SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);
            };
            const onScroll = (e)=>{
                const { clientHeight , clientWidth , scrollHeight , scrollLeft , scrollTop , scrollWidth  } = e.currentTarget;
                const _states = _vue.unref(states);
                if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) return;
                let _scrollLeft = scrollLeft;
                if (_utilsMjs.isRTL(props.direction)) switch(_utilsMjs.getRTLOffsetType()){
                    case _defaultsMjs.RTL_OFFSET_NAG:
                        _scrollLeft = -scrollLeft;
                        break;
                    case _defaultsMjs.RTL_OFFSET_POS_DESC:
                        _scrollLeft = scrollWidth - clientWidth - scrollLeft;
                        break;
                }
                states.value = {
                    ..._states,
                    isScrolling: true,
                    scrollLeft: _scrollLeft,
                    scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),
                    updateRequested: false,
                    xAxisScrollDir: _utilsMjs.getScrollDir(_states.scrollLeft, _scrollLeft),
                    yAxisScrollDir: _utilsMjs.getScrollDir(_states.scrollTop, scrollTop)
                };
                _vue.nextTick(resetIsScrolling);
                emitEvents();
            };
            const onVerticalScroll = (distance, totalSteps)=>{
                const height = _vue.unref(parsedHeight);
                const offset = (estimatedTotalHeight.value - height) / totalSteps * distance;
                scrollTo({
                    scrollTop: Math.min(estimatedTotalHeight.value - height, offset)
                });
            };
            const onHorizontalScroll = (distance, totalSteps)=>{
                const width = _vue.unref(parsedWidth);
                const offset = (estimatedTotalWidth.value - width) / totalSteps * distance;
                scrollTo({
                    scrollLeft: Math.min(estimatedTotalWidth.value - width, offset)
                });
            };
            const { onWheel  } = _useGridWheelMjs.useGridWheel({
                atXStartEdge: _vue.computed(()=>states.value.scrollLeft <= 0
                ),
                atXEndEdge: _vue.computed(()=>states.value.scrollLeft >= estimatedTotalWidth.value
                ),
                atYStartEdge: _vue.computed(()=>states.value.scrollTop <= 0
                ),
                atYEndEdge: _vue.computed(()=>states.value.scrollTop >= estimatedTotalHeight.value
                )
            }, (x, y)=>{
                var _a, _b, _c, _d;
                (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null || _b.call(_a);
                (_d = (_c = hScrollbar.value) == null ? void 0 : _c.onMouseUp) == null || _d.call(_c);
                const width = _vue.unref(parsedWidth);
                const height = _vue.unref(parsedHeight);
                scrollTo({
                    scrollLeft: Math.min(states.value.scrollLeft + x, estimatedTotalWidth.value - width),
                    scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)
                });
            });
            const scrollTo = ({ scrollLeft =states.value.scrollLeft , scrollTop =states.value.scrollTop  })=>{
                scrollLeft = Math.max(scrollLeft, 0);
                scrollTop = Math.max(scrollTop, 0);
                const _states = _vue.unref(states);
                if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) return;
                states.value = {
                    ..._states,
                    xAxisScrollDir: _utilsMjs.getScrollDir(_states.scrollLeft, scrollLeft),
                    yAxisScrollDir: _utilsMjs.getScrollDir(_states.scrollTop, scrollTop),
                    scrollLeft,
                    scrollTop,
                    updateRequested: true
                };
                _vue.nextTick(resetIsScrolling);
            };
            const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = _defaultsMjs.AUTO_ALIGNMENT)=>{
                const _states = _vue.unref(states);
                columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));
                rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));
                const scrollBarWidth = _scrollMjs.getScrollBarWidth();
                const _cache = _vue.unref(cache);
                const estimatedHeight = getEstimatedTotalHeight(props, _cache);
                const estimatedWidth = getEstimatedTotalWidth(props, _cache);
                scrollTo({
                    scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),
                    scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)
                });
            };
            const getItemStyle = (rowIndex, columnIndex)=>{
                const { columnWidth , direction , rowHeight  } = props;
                const itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);
                const key = `${rowIndex},${columnIndex}`;
                if (_shared.hasOwn(itemStyleCache, key)) return itemStyleCache[key];
                else {
                    const [, left] = getColumnPosition(props, columnIndex, _vue.unref(cache));
                    const _cache = _vue.unref(cache);
                    const rtl = _utilsMjs.isRTL(direction);
                    const [height, top] = getRowPosition(props, rowIndex, _cache);
                    const [width] = getColumnPosition(props, columnIndex, _cache);
                    itemStyleCache[key] = {
                        position: "absolute",
                        left: rtl ? void 0 : `${left}px`,
                        right: rtl ? `${left}px` : void 0,
                        top: `${top}px`,
                        height: `${height}px`,
                        width: `${width}px`
                    };
                    return itemStyleCache[key];
                }
            };
            const resetIsScrolling = ()=>{
                states.value.isScrolling = false;
                _vue.nextTick(()=>{
                    getItemStyleCache.value(-1, null, null);
                });
            };
            _vue.onMounted(()=>{
                if (!_core.isClient) return;
                const { initScrollLeft , initScrollTop  } = props;
                const windowElement = _vue.unref(windowRef);
                if (windowElement) {
                    if (_core.isNumber(initScrollLeft)) windowElement.scrollLeft = initScrollLeft;
                    if (_core.isNumber(initScrollTop)) windowElement.scrollTop = initScrollTop;
                }
                emitEvents();
            });
            _vue.onUpdated(()=>{
                const { direction  } = props;
                const { scrollLeft , scrollTop , updateRequested  } = _vue.unref(states);
                const windowElement = _vue.unref(windowRef);
                if (updateRequested && windowElement) {
                    if (direction === _defaultsMjs.RTL) switch(_utilsMjs.getRTLOffsetType()){
                        case _defaultsMjs.RTL_OFFSET_NAG:
                            windowElement.scrollLeft = -scrollLeft;
                            break;
                        case _defaultsMjs.RTL_OFFSET_POS_ASC:
                            windowElement.scrollLeft = scrollLeft;
                            break;
                        default:
                            {
                                const { clientWidth , scrollWidth  } = windowElement;
                                windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;
                                break;
                            }
                    }
                    else windowElement.scrollLeft = Math.max(0, scrollLeft);
                    windowElement.scrollTop = Math.max(0, scrollTop);
                }
            });
            expose({
                windowRef,
                innerRef,
                getItemStyleCache,
                scrollTo,
                scrollToItem,
                states
            });
            const renderScrollbars = ()=>{
                const { totalColumn , totalRow  } = props;
                const width = _vue.unref(parsedWidth);
                const height = _vue.unref(parsedHeight);
                const estimatedWidth = _vue.unref(estimatedTotalWidth);
                const estimatedHeight = _vue.unref(estimatedTotalHeight);
                const { scrollLeft , scrollTop  } = _vue.unref(states);
                const horizontalScrollbar = _vue.h(_scrollbarMjsDefault.default, {
                    ref: hScrollbar,
                    clientSize: width,
                    layout: "horizontal",
                    onScroll: onHorizontalScroll,
                    ratio: width * 100 / estimatedWidth,
                    scrollFrom: scrollLeft / (estimatedWidth - width),
                    total: totalRow,
                    visible: true
                });
                const verticalScrollbar = _vue.h(_scrollbarMjsDefault.default, {
                    ref: vScrollbar,
                    clientSize: height,
                    layout: "vertical",
                    onScroll: onVerticalScroll,
                    ratio: height * 100 / estimatedHeight,
                    scrollFrom: scrollTop / (estimatedHeight - height),
                    total: totalColumn,
                    visible: true
                });
                return {
                    horizontalScrollbar,
                    verticalScrollbar
                };
            };
            const renderItems = ()=>{
                var _a;
                const [columnStart, columnEnd] = _vue.unref(columnsToRender);
                const [rowStart, rowEnd] = _vue.unref(rowsToRender);
                const { data , totalColumn , totalRow , useIsScrolling  } = props;
                const children = [];
                if (totalRow > 0 && totalColumn > 0) {
                    for(let row = rowStart; row <= rowEnd; row++)for(let column = columnStart; column <= columnEnd; column++)children.push((_a = slots.default) == null ? void 0 : _a.call(slots, {
                        columnIndex: column,
                        data,
                        key: column,
                        isScrolling: useIsScrolling ? _vue.unref(states).isScrolling : void 0,
                        style: getItemStyle(row, column),
                        rowIndex: row
                    }));
                }
                return children;
            };
            const renderInner = ()=>{
                const Inner = _vue.resolveDynamicComponent(props.innerElement);
                const children = renderItems();
                return [
                    _vue.h(Inner, {
                        style: _vue.unref(innerStyle),
                        ref: innerRef
                    }, !_shared.isString(Inner) ? {
                        default: ()=>children
                    } : children)
                ];
            };
            const renderWindow = ()=>{
                const Container = _vue.resolveDynamicComponent(props.containerElement);
                const { horizontalScrollbar , verticalScrollbar  } = renderScrollbars();
                const Inner = renderInner();
                return _vue.h("div", {
                    key: 0,
                    class: "el-vg__wrapper"
                }, [
                    _vue.h(Container, {
                        class: props.className,
                        style: _vue.unref(windowStyle),
                        onScroll,
                        onWheel,
                        ref: windowRef
                    }, !_shared.isString(Container) ? {
                        default: ()=>Inner
                    } : Inner),
                    horizontalScrollbar,
                    verticalScrollbar
                ]);
            };
            return renderWindow;
        }
    });
};

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../../utils/index.mjs":"dsdeP","../components/scrollbar.mjs":"8bpQg","../hooks/use-grid-wheel.mjs":"gON1D","../hooks/use-cache.mjs":"j4BQY","../props.mjs":"2CLE6","../utils.mjs":"6WUsE","../defaults.mjs":"9F1UY","../../../../utils/dom/scroll.mjs":"hpitc","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gON1D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useGridWheel", ()=>useGridWheel
);
var _indexMjs = require("../../../../utils/index.mjs");
var _utilsMjs = require("../utils.mjs");
var _rafMjs = require("../../../../utils/raf.mjs");
const useGridWheel = ({ atXEndEdge , atXStartEdge , atYEndEdge , atYStartEdge  }, onWheelDelta)=>{
    let frameHandle = null;
    let xOffset = 0;
    let yOffset = 0;
    const hasReachedEdge = (x, y)=>{
        const xEdgeReached = x < 0 && atXStartEdge.value || x > 0 && atXEndEdge.value;
        const yEdgeReached = y < 0 && atYStartEdge.value || y > 0 && atYEndEdge.value;
        return xEdgeReached && yEdgeReached;
    };
    const onWheel = (e)=>{
        _rafMjs.cAF(frameHandle);
        const x = e.deltaX;
        const y = e.deltaY;
        if (hasReachedEdge(xOffset, yOffset) && hasReachedEdge(xOffset + x, yOffset + y)) return;
        xOffset += x;
        yOffset += y;
        if (!_utilsMjs.isFF) e.preventDefault();
        frameHandle = _rafMjs.rAF(()=>{
            onWheelDelta(xOffset, yOffset);
            xOffset = 0;
            yOffset = 0;
        });
    };
    return {
        hasReachedEdge,
        onWheel
    };
};

},{"../../../../utils/index.mjs":"dsdeP","../utils.mjs":"6WUsE","../../../../utils/raf.mjs":"apnDl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9Fq2m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>FixedSizeGrid
);
var _shared = require("@vue/shared");
var _indexMjs = require("../../../../utils/index.mjs");
var _buildGridMjs = require("../builders/build-grid.mjs");
var _buildGridMjsDefault = parcelHelpers.interopDefault(_buildGridMjs);
var _defaultsMjs = require("../defaults.mjs");
var _errorMjs = require("../../../../utils/error.mjs");
const { max , min , floor  } = Math;
const SCOPE = "ElDynamicSizeGrid";
const ACCESS_SIZER_KEY_MAP = {
    column: "columnWidth",
    row: "rowHeight"
};
const ACCESS_LAST_VISITED_KEY_MAP = {
    column: "lastVisitedColumnIndex",
    row: "lastVisitedRowIndex"
};
const getItemFromCache = (props, index, gridCache, type)=>{
    const [cachedItems, sizer, lastVisited] = [
        gridCache[type],
        props[ACCESS_SIZER_KEY_MAP[type]],
        gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]
    ];
    if (index > lastVisited) {
        let offset = 0;
        if (lastVisited >= 0) {
            const item = cachedItems[lastVisited];
            offset = item.offset + item.size;
        }
        for(let i = lastVisited + 1; i <= index; i++){
            const size = sizer(i);
            cachedItems[i] = {
                offset,
                size
            };
            offset += size;
        }
        gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;
    }
    return cachedItems[index];
};
const bs = (props, gridCache, low, high, offset, type)=>{
    while(low <= high){
        const mid = low + floor((high - low) / 2);
        const currentOffset = getItemFromCache(props, mid, gridCache, type).offset;
        if (currentOffset === offset) return mid;
        else if (currentOffset < offset) low = mid + 1;
        else high = mid - 1;
    }
    return max(0, low - 1);
};
const es = (props, gridCache, idx, offset, type)=>{
    const total = type === "column" ? props.totalColumn : props.totalRow;
    let exponent = 1;
    while(idx < total && getItemFromCache(props, idx, gridCache, type).offset < offset){
        idx += exponent;
        exponent *= 2;
    }
    return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);
};
const findItem = (props, gridCache, offset, type)=>{
    const [cache, lastVisitedIndex] = [
        gridCache[type],
        gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]
    ];
    const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;
    if (lastVisitedItemOffset >= offset) return bs(props, gridCache, 0, lastVisitedIndex, offset, type);
    return es(props, gridCache, max(0, lastVisitedIndex), offset, type);
};
const getEstimatedTotalHeight = ({ totalRow  }, { estimatedRowHeight , lastVisitedRowIndex , row  })=>{
    let sizeOfVisitedRows = 0;
    if (lastVisitedRowIndex >= totalRow) lastVisitedRowIndex = totalRow - 1;
    if (lastVisitedRowIndex >= 0) {
        const item = row[lastVisitedRowIndex];
        sizeOfVisitedRows = item.offset + item.size;
    }
    const unvisitedItems = totalRow - lastVisitedRowIndex - 1;
    const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;
    return sizeOfVisitedRows + sizeOfUnvisitedItems;
};
const getEstimatedTotalWidth = ({ totalColumn  }, { column , estimatedColumnWidth , lastVisitedColumnIndex  })=>{
    let sizeOfVisitedColumns = 0;
    if (lastVisitedColumnIndex > totalColumn) lastVisitedColumnIndex = totalColumn - 1;
    if (lastVisitedColumnIndex >= 0) {
        const item = column[lastVisitedColumnIndex];
        sizeOfVisitedColumns = item.offset + item.size;
    }
    const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;
    const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;
    return sizeOfVisitedColumns + sizeOfUnvisitedItems;
};
const ACCESS_ESTIMATED_SIZE_KEY_MAP = {
    column: getEstimatedTotalWidth,
    row: getEstimatedTotalHeight
};
const getOffset = (props, index, alignment, scrollOffset, cache, type, scrollBarWidth)=>{
    const [size, estimatedSizeAssociates] = [
        type === "row" ? props.height : props.width,
        ACCESS_ESTIMATED_SIZE_KEY_MAP[type]
    ];
    const item = getItemFromCache(props, index, cache, type);
    const estimatedSize = estimatedSizeAssociates(props, cache);
    const maxOffset = max(0, min(estimatedSize - size, item.offset));
    const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);
    if (alignment === _defaultsMjs.SMART_ALIGNMENT) {
        if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) alignment = _defaultsMjs.AUTO_ALIGNMENT;
        else alignment = _defaultsMjs.CENTERED_ALIGNMENT;
    }
    switch(alignment){
        case _defaultsMjs.START_ALIGNMENT:
            return maxOffset;
        case _defaultsMjs.END_ALIGNMENT:
            return minOffset;
        case _defaultsMjs.CENTERED_ALIGNMENT:
            return Math.round(minOffset + (maxOffset - minOffset) / 2);
        case _defaultsMjs.AUTO_ALIGNMENT:
        default:
            if (scrollOffset >= minOffset && scrollOffset <= maxOffset) return scrollOffset;
            else if (minOffset > maxOffset) return minOffset;
            else if (scrollOffset < minOffset) return minOffset;
            else return maxOffset;
    }
};
const FixedSizeGrid = _buildGridMjsDefault.default({
    name: "ElDynamicSizeGrid",
    getColumnPosition: (props, idx, cache)=>{
        const item = getItemFromCache(props, idx, cache, "column");
        return [
            item.size,
            item.offset
        ];
    },
    getRowPosition: (props, idx, cache)=>{
        const item = getItemFromCache(props, idx, cache, "row");
        return [
            item.size,
            item.offset
        ];
    },
    getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth)=>getOffset(props, columnIndex, alignment, scrollLeft, cache, "column", scrollBarWidth)
    ,
    getRowOffset: (props, rowIndex, alignment, scrollTop, cache, scrollBarWidth)=>getOffset(props, rowIndex, alignment, scrollTop, cache, "row", scrollBarWidth)
    ,
    getColumnStartIndexForOffset: (props, scrollLeft, cache)=>findItem(props, cache, scrollLeft, "column")
    ,
    getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache)=>{
        const item = getItemFromCache(props, startIndex, cache, "column");
        const maxOffset = scrollLeft + props.width;
        let offset = item.offset + item.size;
        let stopIndex = startIndex;
        while(stopIndex < props.totalColumn - 1 && offset < maxOffset){
            stopIndex++;
            offset += getItemFromCache(props, startIndex, cache, "column").size;
        }
        return stopIndex;
    },
    getEstimatedTotalHeight,
    getEstimatedTotalWidth,
    getRowStartIndexForOffset: (props, scrollTop, cache)=>findItem(props, cache, scrollTop, "row")
    ,
    getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache)=>{
        const { totalRow , height  } = props;
        const item = getItemFromCache(props, startIndex, cache, "row");
        const maxOffset = scrollTop + height;
        let offset = item.size + item.offset;
        let stopIndex = startIndex;
        while(stopIndex < totalRow - 1 && offset < maxOffset){
            stopIndex++;
            offset += getItemFromCache(props, stopIndex, cache, "row").size;
        }
        return stopIndex;
    },
    initCache: ({ estimatedColumnWidth =_defaultsMjs.DEFAULT_DYNAMIC_LIST_ITEM_SIZE , estimatedRowHeight =_defaultsMjs.DEFAULT_DYNAMIC_LIST_ITEM_SIZE  })=>{
        const cache = {
            column: {
            },
            estimatedColumnWidth,
            estimatedRowHeight,
            lastVisitedColumnIndex: -1,
            lastVisitedRowIndex: -1,
            row: {
            }
        };
        return cache;
    },
    clearCache: true,
    validateProps: ({ columnWidth , rowHeight  })=>{
        if (!_shared.isFunction(columnWidth)) _errorMjs.throwError(SCOPE, `
          "columnWidth" must be passed as function,
            instead ${typeof columnWidth} was given.
        `);
        if (!_shared.isFunction(rowHeight)) _errorMjs.throwError(SCOPE, `
          "columnWidth" must be passed as function,
            instead ${typeof rowHeight} was given.
        `);
    }
});

},{"@vue/shared":"3SM3y","../../../../utils/index.mjs":"dsdeP","../builders/build-grid.mjs":"5yvoE","../defaults.mjs":"9F1UY","../../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5ZbAX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>GroupItem
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    props: {
        item: {
            type: Object,
            required: true
        },
        style: Object,
        height: Number
    },
    setup () {
        const ns = _indexMjs1.useNamespace("select");
        return {
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _ctx.item.isTitle ? (_vue.openBlock(), _vue.createElementBlock("div", {
        key: 0,
        class: _vue.normalizeClass(_ctx.ns.be("group", "title")),
        style: _vue.normalizeStyle([
            _ctx.style,
            {
                lineHeight: `${_ctx.height}px`
            }
        ])
    }, _vue.toDisplayString(_ctx.item.label), 7)) : (_vue.openBlock(), _vue.createElementBlock("div", {
        key: 1,
        class: _vue.normalizeClass(_ctx.ns.be("group", "split")),
        style: _vue.normalizeStyle(_ctx.style)
    }, [
        _vue.createElementVNode("span", {
            class: _vue.normalizeClass(_ctx.ns.be("group", "split-dash")),
            style: _vue.normalizeStyle({
                top: `${_ctx.height / 2}px`
            })
        }, null, 6)
    ], 6));
}
var GroupItem = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a4BWp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>OptionItem
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _useOptionMjs = require("./useOption.mjs");
var _defaultsMjs = require("./defaults.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    props: _defaultsMjs.OptionProps,
    emits: [
        "select",
        "hover"
    ],
    setup (props, { emit  }) {
        const ns = _indexMjs1.useNamespace("select");
        const { hoverItem , selectOptionClick  } = _useOptionMjs.useOption(props, {
            emit
        });
        return {
            ns,
            hoverItem,
            selectOptionClick
        };
    }
});
const _hoisted_1 = [
    "aria-selected"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("li", {
        "aria-selected": _ctx.selected,
        style: _vue.normalizeStyle(_ctx.style),
        class: _vue.normalizeClass([
            _ctx.ns.be("dropdown", "option-item"),
            _ctx.ns.is("selected", _ctx.selected),
            _ctx.ns.is("disabled", _ctx.disabled),
            _ctx.ns.is("created", _ctx.created),
            {
                hover: _ctx.hovering
            }
        ]),
        onMouseenter: _cache[0] || (_cache[0] = (...args)=>_ctx.hoverItem && _ctx.hoverItem(...args)
        ),
        onClick: _cache[1] || (_cache[1] = _vue.withModifiers((...args)=>_ctx.selectOptionClick && _ctx.selectOptionClick(...args)
        , [
            "stop"
        ]))
    }, [
        _vue.renderSlot(_ctx.$slots, "default", {
            item: _ctx.item,
            index: _ctx.index,
            disabled: _ctx.disabled
        }, ()=>[
                _vue.createElementVNode("span", null, _vue.toDisplayString(_ctx.item.label), 1)
            ]
        )
    ], 46, _hoisted_1);
}
var OptionItem = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./useOption.mjs":"6Ozs4","./defaults.mjs":"7AiGB","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Ozs4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useOption", ()=>useOption
);
function useOption(props, { emit  }) {
    return {
        hoverItem: ()=>{
            if (!props.disabled) emit("hover", props.index);
        },
        selectOptionClick: ()=>{
            if (!props.disabled) emit("select", props.item, props.index);
        }
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7AiGB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OptionProps", ()=>OptionProps
);
parcelHelpers.export(exports, "SelectProps", ()=>SelectProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../tooltip/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _tooltipMjs = require("../../tooltip/src/tooltip.mjs");
var _validatorMjs = require("../../../utils/vue/validator.mjs");
const SelectProps = {
    allowCreate: Boolean,
    autocomplete: {
        type: String,
        default: "none"
    },
    automaticDropdown: Boolean,
    clearable: Boolean,
    clearIcon: {
        type: [
            String,
            Object
        ],
        default: _iconsVue.CircleClose
    },
    effect: {
        type: String,
        default: "light"
    },
    collapseTags: Boolean,
    defaultFirstOption: Boolean,
    disabled: Boolean,
    estimatedOptionHeight: {
        type: Number,
        default: void 0
    },
    filterable: Boolean,
    filterMethod: Function,
    height: {
        type: Number,
        default: 170
    },
    itemHeight: {
        type: Number,
        default: 34
    },
    id: String,
    loading: Boolean,
    loadingText: String,
    label: String,
    modelValue: [
        Array,
        String,
        Number,
        Boolean,
        Object
    ],
    multiple: Boolean,
    multipleLimit: {
        type: Number,
        default: 0
    },
    name: String,
    noDataText: String,
    noMatchText: String,
    remoteMethod: Function,
    reserveKeyword: {
        type: Boolean,
        default: true
    },
    options: {
        type: Array,
        required: true
    },
    placeholder: {
        type: String
    },
    popperAppendToBody: {
        type: Boolean,
        default: void 0
    },
    teleported: _tooltipMjs.useTooltipContentProps.teleported,
    popperClass: {
        type: String,
        default: ""
    },
    popperOptions: {
        type: Object,
        default: ()=>({
            })
    },
    remote: Boolean,
    size: {
        type: String,
        validator: _validatorMjs.isValidComponentSize
    },
    valueKey: {
        type: String,
        default: "value"
    },
    scrollbarAlwaysOn: {
        type: Boolean,
        default: false
    }
};
const OptionProps = {
    data: Array,
    disabled: Boolean,
    hovering: Boolean,
    item: Object,
    index: Number,
    style: Object,
    selected: Boolean,
    created: Boolean
};

},{"../../../utils/index.mjs":"dsdeP","../../tooltip/index.mjs":"kiwBC","@element-plus/icons-vue":"b18uu","../../tooltip/src/tooltip.mjs":"7LVFi","../../../utils/vue/validator.mjs":"4UnBa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lk8V6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "selectV2InjectionKey", ()=>selectV2InjectionKey
);
const selectV2InjectionKey = "ElSelectV2Injection";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kEkvd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useSelect
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../../utils/index.mjs");
var _indexMjs3 = require("../../popper/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _useAllowCreateMjs = require("./useAllowCreate.mjs");
var _utilMjs = require("./util.mjs");
var _useInputMjs = require("./useInput.mjs");
var _indexMjs4 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs5 = require("../../../hooks/use-namespace/index.mjs");
var _indexMjs6 = require("../../../hooks/use-form-item/index.mjs");
var _deprecationMjs = require("../../popper/src/deprecation.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _indexMjs7 = require("../../../hooks/use-common-props/index.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _resizeEventMjs = require("../../../utils/dom/resize-event.mjs");
const DEFAULT_INPUT_PLACEHOLDER = "";
const MINIMUM_INPUT_WIDTH = 11;
const TAG_BASE_WIDTH = {
    larget: 51,
    default: 42,
    small: 33
};
const COMPONENT_NAME = "ElSelectV2";
const useSelect = (props, emit)=>{
    const { t  } = _indexMjs4.useLocale();
    const nsSelectV2 = _indexMjs5.useNamespace("select-v2");
    const nsInput = _indexMjs5.useNamespace("input");
    const { form: elForm , formItem: elFormItem  } = _indexMjs6.useFormItem();
    const { compatTeleported  } = _deprecationMjs.useDeprecateAppendToBody(COMPONENT_NAME, "popperAppendToBody");
    const states = _vue.reactive({
        inputValue: DEFAULT_INPUT_PLACEHOLDER,
        displayInputValue: DEFAULT_INPUT_PLACEHOLDER,
        calculatedWidth: 0,
        cachedPlaceholder: "",
        cachedOptions: [],
        createdOptions: [],
        createdLabel: "",
        createdSelected: false,
        currentPlaceholder: "",
        hoveringIndex: -1,
        comboBoxHovering: false,
        isOnComposition: false,
        isSilentBlur: false,
        isComposing: false,
        inputLength: 20,
        selectWidth: 200,
        initialInputHeight: 0,
        previousQuery: null,
        previousValue: "",
        query: "",
        selectedLabel: "",
        softFocus: false,
        tagInMultiLine: false
    });
    const selectedIndex = _vue.ref(-1);
    const popperSize = _vue.ref(-1);
    const controlRef = _vue.ref(null);
    const inputRef = _vue.ref(null);
    const menuRef = _vue.ref(null);
    const popper = _vue.ref(null);
    const selectRef = _vue.ref(null);
    const selectionRef = _vue.ref(null);
    const calculatorRef = _vue.ref(null);
    const expanded = _vue.ref(false);
    const selectDisabled = _vue.computed(()=>props.disabled || (elForm == null ? void 0 : elForm.disabled)
    );
    const popupHeight = _vue.computed(()=>{
        const totalHeight = filteredOptions.value.length * 34;
        return totalHeight > props.height ? props.height : totalHeight;
    });
    const hasModelValue = _vue.computed(()=>{
        return props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
    });
    const showClearBtn = _vue.computed(()=>{
        const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : hasModelValue.value;
        const criteria = props.clearable && !selectDisabled.value && states.comboBoxHovering && hasValue;
        return criteria;
    });
    const iconComponent = _vue.computed(()=>props.remote && props.filterable ? "" : _iconsVue.ArrowUp
    );
    const iconReverse = _vue.computed(()=>iconComponent.value && nsSelectV2.is("reverse", expanded.value)
    );
    const validateState = _vue.computed(()=>(elFormItem == null ? void 0 : elFormItem.validateState) || ""
    );
    const validateIcon = _vue.computed(()=>_iconMjs.ValidateComponentsMap[validateState.value]
    );
    const debounce$1 = _vue.computed(()=>props.remote ? 300 : 0
    );
    const emptyText = _vue.computed(()=>{
        const options = filteredOptions.value;
        if (props.loading) return props.loadingText || t("el.select.loading");
        else {
            if (props.remote && states.inputValue === "" && options.length === 0) return false;
            if (props.filterable && states.inputValue && options.length > 0) return props.noMatchText || t("el.select.noMatch");
            if (options.length === 0) return props.noDataText || t("el.select.noData");
        }
        return null;
    });
    const filteredOptions = _vue.computed(()=>{
        const isValidOption = (o)=>{
            const query = states.inputValue;
            const containsQueryString = query ? o.label.includes(query) : true;
            return containsQueryString;
        };
        if (props.loading) return [];
        return _utilMjs.flattenOptions(props.options.concat(states.createdOptions).map((v)=>{
            if (_shared.isArray(v.options)) {
                const filtered = v.options.filter(isValidOption);
                if (filtered.length > 0) return {
                    ...v,
                    options: filtered
                };
            } else {
                if (props.remote || isValidOption(v)) return v;
            }
            return null;
        }).filter((v)=>v !== null
        ));
    });
    const optionsAllDisabled = _vue.computed(()=>filteredOptions.value.every((option)=>option.disabled
        )
    );
    const selectSize = _indexMjs7.useSize();
    const collapseTagSize = _vue.computed(()=>selectSize.value === "small" ? "small" : "default"
    );
    const tagMaxWidth = _vue.computed(()=>{
        const select = selectionRef.value;
        const size = collapseTagSize.value || "default";
        const paddingLeft = select ? parseInt(getComputedStyle(select).paddingLeft) : 0;
        const paddingRight = select ? parseInt(getComputedStyle(select).paddingRight) : 0;
        return states.selectWidth - paddingRight - paddingLeft - TAG_BASE_WIDTH[size];
    });
    const calculatePopperSize = ()=>{
        var _a, _b, _c;
        popperSize.value = ((_c = (_b = (_a = selectRef.value) == null ? void 0 : _a.getBoundingClientRect) == null ? void 0 : _b.call(_a)) == null ? void 0 : _c.width) || 200;
    };
    const inputWrapperStyle = _vue.computed(()=>{
        return {
            width: `${states.calculatedWidth === 0 ? MINIMUM_INPUT_WIDTH : Math.ceil(states.calculatedWidth) + MINIMUM_INPUT_WIDTH}px`
        };
    });
    const shouldShowPlaceholder = _vue.computed(()=>{
        if (_shared.isArray(props.modelValue)) return props.modelValue.length === 0 && !states.displayInputValue;
        return props.filterable ? states.displayInputValue.length === 0 : true;
    });
    const currentPlaceholder = _vue.computed(()=>{
        const _placeholder = props.placeholder || t("el.select.placeholder");
        return props.multiple ? _placeholder : states.selectedLabel || _placeholder;
    });
    const popperRef = _vue.computed(()=>{
        var _a, _b;
        return (_b = (_a = popper.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
    });
    const indexRef = _vue.computed(()=>{
        if (props.multiple) {
            const len = props.modelValue.length;
            if (props.modelValue.length > 0) return filteredOptions.value.findIndex((o)=>o.value === props.modelValue[len - 1]
            );
        } else {
            if (props.modelValue) return filteredOptions.value.findIndex((o)=>o.value === props.modelValue
            );
        }
        return -1;
    });
    const dropdownMenuVisible = _vue.computed(()=>{
        return expanded.value && emptyText.value !== false;
    });
    const { createNewOption , removeNewOption , selectNewOption , clearAllNewOption  } = _useAllowCreateMjs.useAllowCreate(props, states);
    const { handleCompositionStart , handleCompositionUpdate , handleCompositionEnd  } = _useInputMjs.useInput((e)=>onInput(e)
    );
    const focusAndUpdatePopup = ()=>{
        var _a, _b, _c;
        (_b = (_a = inputRef.value).focus) == null || _b.call(_a);
        (_c = popper.value) == null || _c.updatePopper();
    };
    const toggleMenu = ()=>{
        if (props.automaticDropdown) return;
        if (!selectDisabled.value) {
            if (states.isComposing) states.softFocus = true;
            return _vue.nextTick(()=>{
                var _a, _b;
                expanded.value = !expanded.value;
                (_b = (_a = inputRef.value) == null ? void 0 : _a.focus) == null || _b.call(_a);
            });
        }
    };
    const onInputChange = ()=>{
        if (props.filterable && states.inputValue !== states.selectedLabel) states.query = states.selectedLabel;
        handleQueryChange(states.inputValue);
        return _vue.nextTick(()=>{
            createNewOption(states.inputValue);
        });
    };
    const debouncedOnInputChange = _lodashUnified.debounce(onInputChange, debounce$1.value);
    const handleQueryChange = (val)=>{
        if (states.previousQuery === val) return;
        states.previousQuery = val;
        if (props.filterable && _shared.isFunction(props.filterMethod)) props.filterMethod(val);
        else if (props.filterable && props.remote && _shared.isFunction(props.remoteMethod)) props.remoteMethod(val);
    };
    const emitChange = (val)=>{
        if (!_lodashUnified.isEqual(props.modelValue, val)) emit(_eventMjs.CHANGE_EVENT, val);
    };
    const update = (val)=>{
        emit(_eventMjs.UPDATE_MODEL_EVENT, val);
        emitChange(val);
        states.previousValue = val.toString();
    };
    const getValueIndex = (arr = [], value)=>{
        if (!_shared.isObject(value)) return arr.indexOf(value);
        const valueKey = props.valueKey;
        let index = -1;
        arr.some((item, i)=>{
            if (_lodashUnified.get(item, valueKey) === _lodashUnified.get(value, valueKey)) {
                index = i;
                return true;
            }
            return false;
        });
        return index;
    };
    const getValueKey = (item)=>{
        return _shared.isObject(item) ? _lodashUnified.get(item, props.valueKey) : item;
    };
    const getLabel = (item)=>{
        return _shared.isObject(item) ? item.label : item;
    };
    const resetInputHeight = ()=>{
        if (props.collapseTags && !props.filterable) return;
        return _vue.nextTick(()=>{
            var _a, _b;
            if (!inputRef.value) return;
            const selection = selectionRef.value;
            selectRef.value.height = selection.offsetHeight;
            if (expanded.value && emptyText.value !== false) (_b = (_a = popper.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
        });
    };
    const handleResize = ()=>{
        var _a, _b;
        resetInputWidth();
        calculatePopperSize();
        (_b = (_a = popper.value) == null ? void 0 : _a.updatePopper) == null || _b.call(_a);
        if (props.multiple) return resetInputHeight();
    };
    const resetInputWidth = ()=>{
        const select = selectionRef.value;
        if (select) states.selectWidth = select.getBoundingClientRect().width;
    };
    const onSelect = (option, idx, byClick = true)=>{
        var _a, _b;
        if (props.multiple) {
            let selectedOptions = props.modelValue.slice();
            const index = getValueIndex(selectedOptions, getValueKey(option));
            if (index > -1) {
                selectedOptions = [
                    ...selectedOptions.slice(0, index),
                    ...selectedOptions.slice(index + 1)
                ];
                states.cachedOptions.splice(index, 1);
                removeNewOption(option);
            } else if (props.multipleLimit <= 0 || selectedOptions.length < props.multipleLimit) {
                selectedOptions = [
                    ...selectedOptions,
                    getValueKey(option)
                ];
                states.cachedOptions.push(option);
                selectNewOption(option);
                updateHoveringIndex(idx);
            }
            update(selectedOptions);
            if (option.created) {
                states.query = "";
                handleQueryChange("");
                states.inputLength = 20;
            }
            if (props.filterable && !props.reserveKeyword) {
                (_b = (_a = inputRef.value).focus) == null || _b.call(_a);
                onUpdateInputValue("");
            }
            if (props.filterable) states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
            resetInputHeight();
            setSoftFocus();
        } else {
            selectedIndex.value = idx;
            states.selectedLabel = option.label;
            update(getValueKey(option));
            expanded.value = false;
            states.isComposing = false;
            states.isSilentBlur = byClick;
            selectNewOption(option);
            if (!option.created) clearAllNewOption();
            updateHoveringIndex(idx);
        }
    };
    const deleteTag = (event, tag)=>{
        const index = props.modelValue.indexOf(tag.value);
        if (index > -1 && !selectDisabled.value) {
            const value = [
                ...props.modelValue.slice(0, index),
                ...props.modelValue.slice(index + 1)
            ];
            states.cachedOptions.splice(index, 1);
            update(value);
            emit("remove-tag", tag.value);
            states.softFocus = true;
            removeNewOption(tag);
            return _vue.nextTick(focusAndUpdatePopup);
        }
        event.stopPropagation();
    };
    const handleFocus = (event)=>{
        const focused = states.isComposing;
        states.isComposing = true;
        if (!states.softFocus) {
            if (!focused) emit("focus", event);
        } else states.softFocus = false;
    };
    const handleBlur = ()=>{
        states.softFocus = false;
        return _vue.nextTick(()=>{
            var _a, _b;
            (_b = (_a = inputRef.value) == null ? void 0 : _a.blur) == null || _b.call(_a);
            if (calculatorRef.value) states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
            if (states.isSilentBlur) states.isSilentBlur = false;
            else if (states.isComposing) emit("blur");
            states.isComposing = false;
        });
    };
    const handleEsc = ()=>{
        if (states.displayInputValue.length > 0) onUpdateInputValue("");
        else expanded.value = false;
    };
    const handleDel = (e)=>{
        if (states.displayInputValue.length === 0) {
            e.preventDefault();
            const selected = props.modelValue.slice();
            selected.pop();
            removeNewOption(states.cachedOptions.pop());
            update(selected);
        }
    };
    const handleClear = ()=>{
        let emptyValue;
        if (_shared.isArray(props.modelValue)) emptyValue = [];
        else emptyValue = "";
        states.softFocus = true;
        if (props.multiple) states.cachedOptions = [];
        else states.selectedLabel = "";
        expanded.value = false;
        update(emptyValue);
        emit("clear");
        clearAllNewOption();
        return _vue.nextTick(focusAndUpdatePopup);
    };
    const onUpdateInputValue = (val)=>{
        states.displayInputValue = val;
        states.inputValue = val;
    };
    const onKeyboardNavigate = (direction, hoveringIndex)=>{
        const options = filteredOptions.value;
        if (![
            "forward",
            "backward"
        ].includes(direction) || selectDisabled.value || options.length <= 0 || optionsAllDisabled.value) return;
        if (!expanded.value) return toggleMenu();
        if (hoveringIndex === void 0) hoveringIndex = states.hoveringIndex;
        let newIndex = -1;
        if (direction === "forward") {
            newIndex = hoveringIndex + 1;
            if (newIndex >= options.length) newIndex = 0;
        } else if (direction === "backward") {
            newIndex = hoveringIndex - 1;
            if (newIndex < 0) newIndex = options.length - 1;
        }
        const option = options[newIndex];
        if (option.disabled || option.type === "Group") return onKeyboardNavigate(direction, newIndex);
        else {
            updateHoveringIndex(newIndex);
            scrollToItem(newIndex);
        }
    };
    const onKeyboardSelect = ()=>{
        if (!expanded.value) return toggleMenu();
        else if (~states.hoveringIndex && filteredOptions.value[states.hoveringIndex]) onSelect(filteredOptions.value[states.hoveringIndex], states.hoveringIndex, false);
    };
    const updateHoveringIndex = (idx)=>{
        states.hoveringIndex = idx;
    };
    const resetHoveringIndex = ()=>{
        states.hoveringIndex = -1;
    };
    const setSoftFocus = ()=>{
        var _a;
        const _input = inputRef.value;
        if (_input) (_a = _input.focus) == null || _a.call(_input);
    };
    const onInput = (event)=>{
        const value = event.target.value;
        onUpdateInputValue(value);
        if (states.displayInputValue.length > 0 && !expanded.value) expanded.value = true;
        states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
        if (props.multiple) resetInputHeight();
        if (props.remote) debouncedOnInputChange();
        else return onInputChange();
    };
    const handleClickOutside = ()=>{
        expanded.value = false;
        return handleBlur();
    };
    const handleMenuEnter = ()=>{
        states.inputValue = states.displayInputValue;
        return _vue.nextTick(()=>{
            if (~indexRef.value) {
                updateHoveringIndex(indexRef.value);
                scrollToItem(states.hoveringIndex);
            }
        });
    };
    const scrollToItem = (index)=>{
        menuRef.value.scrollToItem(index);
    };
    const initStates = ()=>{
        resetHoveringIndex();
        if (props.multiple) {
            if (props.modelValue.length > 0) {
                let initHovering = false;
                states.cachedOptions.length = 0;
                states.previousValue = props.modelValue.toString();
                props.modelValue.map((selected)=>{
                    const itemIndex = filteredOptions.value.findIndex((option)=>getValueKey(option) === selected
                    );
                    if (~itemIndex) {
                        states.cachedOptions.push(filteredOptions.value[itemIndex]);
                        if (!initHovering) updateHoveringIndex(itemIndex);
                        initHovering = true;
                    }
                });
            } else {
                states.cachedOptions = [];
                states.previousValue = "";
            }
        } else if (hasModelValue.value) {
            states.previousValue = props.modelValue;
            const options = filteredOptions.value;
            const selectedItemIndex = options.findIndex((option)=>getValueKey(option) === props.modelValue
            );
            if (~selectedItemIndex) {
                states.selectedLabel = options[selectedItemIndex].label;
                updateHoveringIndex(selectedItemIndex);
            } else states.selectedLabel = `${props.modelValue}`;
        } else {
            states.selectedLabel = "";
            states.previousValue = "";
        }
        calculatePopperSize();
    };
    _vue.watch(expanded, (val)=>{
        var _a, _b;
        emit("visible-change", val);
        if (val) (_b = (_a = popper.value).update) == null || _b.call(_a);
        else {
            states.displayInputValue = "";
            createNewOption("");
        }
    });
    _vue.watch(()=>props.modelValue
    , (val, oldVal)=>{
        var _a;
        if (!val || val.toString() !== states.previousValue) initStates();
        if (!_lodashUnified.isEqual(val, oldVal)) (_a = elFormItem == null ? void 0 : elFormItem.validate) == null || _a.call(elFormItem, "change");
    }, {
        deep: true
    });
    _vue.watch(()=>props.options
    , ()=>{
        const input = inputRef.value;
        if (!input || input && document.activeElement !== input) initStates();
    }, {
        deep: true
    });
    _vue.watch(filteredOptions, ()=>{
        return _vue.nextTick(menuRef.value.resetScrollTop);
    });
    _vue.onMounted(()=>{
        initStates();
        _resizeEventMjs.addResizeListener(selectRef.value, handleResize);
    });
    _vue.onBeforeMount(()=>{
        _resizeEventMjs.removeResizeListener(selectRef.value, handleResize);
    });
    return {
        collapseTagSize,
        currentPlaceholder,
        expanded,
        emptyText,
        popupHeight,
        debounce: debounce$1,
        filteredOptions,
        iconComponent,
        iconReverse,
        inputWrapperStyle,
        popperSize,
        dropdownMenuVisible,
        hasModelValue,
        shouldShowPlaceholder,
        selectDisabled,
        selectSize,
        showClearBtn,
        states,
        tagMaxWidth,
        nsSelectV2,
        nsInput,
        calculatorRef,
        controlRef,
        inputRef,
        menuRef,
        popper,
        selectRef,
        selectionRef,
        popperRef,
        validateState,
        validateIcon,
        compatTeleported,
        debouncedOnInputChange,
        deleteTag,
        getLabel,
        getValueKey,
        handleBlur,
        handleClear,
        handleClickOutside,
        handleDel,
        handleEsc,
        handleFocus,
        handleMenuEnter,
        handleResize,
        toggleMenu,
        scrollTo: scrollToItem,
        onInput,
        onKeyboardNavigate,
        onKeyboardSelect,
        onSelect,
        onHover: updateHoveringIndex,
        onUpdateInputValue,
        handleCompositionStart,
        handleCompositionEnd,
        handleCompositionUpdate
    };
};

},{"vue":"gzxs9","@vue/shared":"3SM3y","lodash-unified":"4Oj4p","../../../hooks/index.mjs":"1Ansp","../../../constants/index.mjs":"74Fbn","../../../utils/index.mjs":"dsdeP","../../popper/index.mjs":"kIV7g","@element-plus/icons-vue":"b18uu","./useAllowCreate.mjs":"gnamR","./util.mjs":"leehc","./useInput.mjs":"15zDn","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../hooks/use-form-item/index.mjs":"jSs21","../../popper/src/deprecation.mjs":"jm0Kb","../../../utils/vue/icon.mjs":"3YbE5","../../../hooks/use-common-props/index.mjs":"05czU","../../../constants/event.mjs":"92xVn","../../../utils/dom/resize-event.mjs":"TzEEU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gnamR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useAllowCreate", ()=>useAllowCreate
);
var _vue = require("vue");
function useAllowCreate(props, states) {
    const createOptionCount = _vue.ref(0);
    const cachedSelectedOption = _vue.ref(null);
    const enableAllowCreateMode = _vue.computed(()=>{
        return props.allowCreate && props.filterable;
    });
    function hasExistingOption(query) {
        const hasValue = (option)=>option.value === query
        ;
        return props.options && props.options.some(hasValue) || states.createdOptions.some(hasValue);
    }
    function selectNewOption(option) {
        if (!enableAllowCreateMode.value) return;
        if (props.multiple && option.created) createOptionCount.value++;
        else cachedSelectedOption.value = option;
    }
    function createNewOption(query) {
        if (enableAllowCreateMode.value) {
            if (query && query.length > 0 && !hasExistingOption(query)) {
                const newOption = {
                    value: query,
                    label: query,
                    created: true,
                    disabled: false
                };
                if (states.createdOptions.length >= createOptionCount.value) states.createdOptions[createOptionCount.value] = newOption;
                else states.createdOptions.push(newOption);
            } else if (props.multiple) states.createdOptions.length = createOptionCount.value;
            else {
                const selectedOption = cachedSelectedOption.value;
                states.createdOptions.length = 0;
                if (selectedOption && selectedOption.created) states.createdOptions.push(selectedOption);
            }
        }
    }
    function removeNewOption(option) {
        if (!enableAllowCreateMode.value || !option || !option.created || option.created && props.reserveKeyword && states.inputValue === option.label) return;
        const idx = states.createdOptions.findIndex((it)=>it.value === option.value
        );
        if (~idx) {
            states.createdOptions.splice(idx, 1);
            createOptionCount.value--;
        }
    }
    function clearAllNewOption() {
        if (enableAllowCreateMode.value) {
            states.createdOptions.length = 0;
            createOptionCount.value = 0;
        }
    }
    return {
        createNewOption,
        removeNewOption,
        selectNewOption,
        clearAllNewOption
    };
}

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"leehc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "flattenOptions", ()=>flattenOptions
);
var _shared = require("@vue/shared");
const flattenOptions = (options)=>{
    const flattened = [];
    options.map((option)=>{
        if (_shared.isArray(option.options)) {
            flattened.push({
                label: option.label,
                isTitle: true,
                type: "Group"
            });
            option.options.forEach((o)=>{
                flattened.push(o);
            });
            flattened.push({
                type: "Group"
            });
        } else flattened.push(option);
    });
    return flattened;
};

},{"@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"15zDn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useInput", ()=>useInput
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _indexMjs = require("../../../utils/index.mjs");
var _i18NMjs = require("../../../utils/i18n.mjs");
function useInput(handleInput) {
    const isComposing = _vue.ref(false);
    const handleCompositionStart = ()=>{
        isComposing.value = true;
    };
    const handleCompositionUpdate = (event)=>{
        const text = event.target.value;
        const lastCharacter = text[text.length - 1] || "";
        isComposing.value = !_i18NMjs.isKorean(lastCharacter);
    };
    const handleCompositionEnd = (event)=>{
        if (isComposing.value) {
            isComposing.value = false;
            if (_shared.isFunction(handleInput)) handleInput(event);
        }
    };
    return {
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd
    };
}

},{"vue":"gzxs9","@vue/shared":"3SM3y","../../../utils/index.mjs":"dsdeP","../../../utils/i18n.mjs":"5xQne","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2N5x8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "skeletonProps", ()=>_skeletonMjs.skeletonProps
);
parcelHelpers.export(exports, "skeletonItemProps", ()=>_skeletonItemMjs.skeletonItemProps
);
parcelHelpers.export(exports, "ElSkeleton", ()=>ElSkeleton
);
parcelHelpers.export(exports, "ElSkeletonItem", ()=>ElSkeletonItem
);
parcelHelpers.export(exports, "default", ()=>ElSkeleton
);
var _indexMjs = require("../../utils/index.mjs");
var _skeleton2Mjs = require("./src/skeleton2.mjs");
var _skeleton2MjsDefault = parcelHelpers.interopDefault(_skeleton2Mjs);
var _skeletonItem2Mjs = require("./src/skeleton-item2.mjs");
var _skeletonItem2MjsDefault = parcelHelpers.interopDefault(_skeletonItem2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _skeletonMjs = require("./src/skeleton.mjs");
var _skeletonItemMjs = require("./src/skeleton-item.mjs");
const ElSkeleton = _installMjs.withInstall(_skeleton2MjsDefault.default, {
    SkeletonItem: _skeletonItem2MjsDefault.default
});
const ElSkeletonItem = _installMjs.withNoopInstall(_skeletonItem2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/skeleton2.mjs":"8kUaY","./src/skeleton-item2.mjs":"kcTSH","../../utils/vue/install.mjs":"4TMmv","./src/skeleton.mjs":"9BfJP","./src/skeleton-item.mjs":"3Kx1r","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8kUaY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Skeleton
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _skeletonItem2Mjs = require("./skeleton-item2.mjs");
var _skeletonItem2MjsDefault = parcelHelpers.interopDefault(_skeletonItem2Mjs);
var _skeletonMjs = require("./skeleton.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
var _indexMjs2 = require("../../../hooks/use-throttle-render/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElSkeleton",
    components: {
        [_skeletonItem2MjsDefault.default.name]: _skeletonItem2MjsDefault.default
    },
    props: _skeletonMjs.skeletonProps,
    setup (props) {
        const ns = _indexMjs1.useNamespace("skeleton");
        const innerLoading = _vue.computed(()=>{
            return props.loading;
        });
        const uiLoading = _indexMjs2.useThrottleRender(innerLoading, props.throttle);
        return {
            ns,
            uiLoading
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_skeleton_item = _vue.resolveComponent("el-skeleton-item");
    return _ctx.uiLoading ? (_vue.openBlock(), _vue.createElementBlock("div", _vue.mergeProps({
        key: 0,
        class: [
            _ctx.ns.b(),
            _ctx.ns.is("animated", _ctx.animated)
        ]
    }, _ctx.$attrs), [
        (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.count, (i)=>{
            return _vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                key: i
            }, [
                _ctx.loading ? _vue.renderSlot(_ctx.$slots, "template", {
                    key: i
                }, ()=>[
                        _vue.createVNode(_component_el_skeleton_item, {
                            class: _vue.normalizeClass(_ctx.ns.is("first")),
                            variant: "p"
                        }, null, 8, [
                            "class"
                        ]),
                        (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.rows, (item)=>{
                            return _vue.openBlock(), _vue.createBlock(_component_el_skeleton_item, {
                                key: item,
                                class: _vue.normalizeClass([
                                    _ctx.ns.e("paragraph"),
                                    _ctx.ns.is("last", item === _ctx.rows && _ctx.rows > 1)
                                ]),
                                variant: "p"
                            }, null, 8, [
                                "class"
                            ]);
                        }), 128))
                    ]
                ) : _vue.createCommentVNode("v-if", true)
            ], 64);
        }), 128))
    ], 16)) : _vue.renderSlot(_ctx.$slots, "default", _vue.normalizeProps(_vue.mergeProps({
        key: 1
    }, _ctx.$attrs)));
}
var Skeleton = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./skeleton-item2.mjs":"kcTSH","./skeleton.mjs":"9BfJP","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../hooks/use-throttle-render/index.mjs":"azm2F","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kcTSH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>SkeletonItem
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _imagePlaceholderMjs = require("./image-placeholder.mjs");
var _imagePlaceholderMjsDefault = parcelHelpers.interopDefault(_imagePlaceholderMjs);
var _skeletonItemMjs = require("./skeleton-item.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElSkeletonItem",
    components: {
        ImgPlaceholder: _imagePlaceholderMjsDefault.default
    },
    props: _skeletonItemMjs.skeletonItemProps,
    setup () {
        const ns = _indexMjs1.useNamespace("skeleton");
        return {
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_img_placeholder = _vue.resolveComponent("img-placeholder");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.ns.e("item"),
            _ctx.ns.e(_ctx.variant)
        ])
    }, [
        _ctx.variant === "image" ? (_vue.openBlock(), _vue.createBlock(_component_img_placeholder, {
            key: 0
        })) : _vue.createCommentVNode("v-if", true)
    ], 2);
}
var SkeletonItem = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./image-placeholder.mjs":"gpFmg","./skeleton-item.mjs":"3Kx1r","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gpFmg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ImgPlaceholder
);
var _vue = require("vue");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
const _sfc_main = _vue.defineComponent({
    name: "ImgPlaceholder"
});
const _hoisted_1 = {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2 = /* @__PURE__ */ _vue.createElementVNode("path", {
    d: "M64 896V128h896v768H64z m64-128l192-192 116.352 116.352L640 448l256 307.2V192H128v576z m224-480a96 96 0 1 1-0.064 192.064A96 96 0 0 1 352 288z"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var ImgPlaceholder = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Kx1r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "skeletonItemProps", ()=>skeletonItemProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const skeletonItemProps = _propsMjs.buildProps({
    variant: {
        type: String,
        values: [
            "circle",
            "rect",
            "h1",
            "h3",
            "text",
            "caption",
            "p",
            "image",
            "button"
        ],
        default: "text"
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9BfJP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "skeletonProps", ()=>skeletonProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const skeletonProps = _propsMjs.buildProps({
    animated: {
        type: Boolean,
        default: false
    },
    count: {
        type: Number,
        default: 1
    },
    rows: {
        type: Number,
        default: 3
    },
    loading: {
        type: Boolean,
        default: true
    },
    throttle: {
        type: Number
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6YyBo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElSlider", ()=>ElSlider
);
parcelHelpers.export(exports, "default", ()=>_Slider
);
var _indexMjs = require("./src/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _sliderTypeMjs = require("./src/slider.type.mjs");
_indexMjsDefault.default.install = (app)=>{
    app.component(_indexMjsDefault.default.name, _indexMjsDefault.default);
};
const _Slider = _indexMjsDefault.default;
const ElSlider = _Slider;

},{"./src/index.mjs":"bhMwv","./src/slider.type.mjs":"aAqL3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bhMwv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Slider
);
var _vue = require("vue");
var _indexMjs = require("../../input-number/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../../utils/index.mjs");
var _indexMjs3 = require("../../../hooks/index.mjs");
var _buttonMjs = require("./button.mjs");
var _buttonMjsDefault = parcelHelpers.interopDefault(_buttonMjs);
var _markerMjs = require("./marker.mjs");
var _markerMjsDefault = parcelHelpers.interopDefault(_markerMjs);
var _useMarksMjs = require("./useMarks.mjs");
var _useSlideMjs = require("./useSlide.mjs");
var _useStopsMjs = require("./useStops.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _validatorMjs = require("../../../utils/vue/validator.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs4 = require("../../../hooks/use-namespace/index.mjs");
var _indexMjs5 = require("../../../hooks/use-common-props/index.mjs");
var _errorMjs = require("../../../utils/error.mjs");
var _eventMjs1 = require("../../../utils/dom/event.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElSlider",
    components: {
        ElInputNumber: _indexMjs.ElInputNumber,
        SliderButton: _buttonMjsDefault.default,
        SliderMarker: _markerMjsDefault.default
    },
    props: {
        modelValue: {
            type: [
                Number,
                Array
            ],
            default: 0
        },
        min: {
            type: Number,
            default: 0
        },
        max: {
            type: Number,
            default: 100
        },
        step: {
            type: Number,
            default: 1
        },
        showInput: {
            type: Boolean,
            default: false
        },
        showInputControls: {
            type: Boolean,
            default: true
        },
        size: {
            type: String,
            validator: _validatorMjs.isValidComponentSize
        },
        inputSize: {
            type: String,
            validator: _validatorMjs.isValidComponentSize
        },
        showStops: {
            type: Boolean,
            default: false
        },
        showTooltip: {
            type: Boolean,
            default: true
        },
        formatTooltip: {
            type: Function,
            default: void 0
        },
        disabled: {
            type: Boolean,
            default: false
        },
        range: {
            type: Boolean,
            default: false
        },
        vertical: {
            type: Boolean,
            default: false
        },
        height: {
            type: String,
            default: ""
        },
        debounce: {
            type: Number,
            default: 300
        },
        label: {
            type: String,
            default: void 0
        },
        tooltipClass: {
            type: String,
            default: void 0
        },
        marks: Object
    },
    emits: [
        _eventMjs.UPDATE_MODEL_EVENT,
        _eventMjs.CHANGE_EVENT,
        _eventMjs.INPUT_EVENT
    ],
    setup (props, { emit  }) {
        const ns = _indexMjs4.useNamespace("slider");
        const initData = _vue.reactive({
            firstValue: 0,
            secondValue: 0,
            oldValue: 0,
            dragging: false,
            sliderSize: 1
        });
        const { elFormItem , slider , firstButton , secondButton , sliderDisabled , minValue , maxValue , runwayStyle , barStyle , resetSize , emitChange , onSliderClick , setFirstValue , setSecondValue  } = _useSlideMjs.useSlide(props, initData, emit);
        const { stops , getStopStyle  } = _useStopsMjs.useStops(props, initData, minValue, maxValue);
        const sliderWrapperSize = _indexMjs5.useSize();
        const sliderInputSize = _vue.computed(()=>props.inputSize || sliderWrapperSize.value
        );
        const sliderKls = _vue.computed(()=>[
                ns.b(),
                ns.m(sliderWrapperSize.value),
                ns.is("vertical", props.vertical),
                {
                    [ns.m("with-input")]: props.showInput
                }
            ]
        );
        const markList = _useMarksMjs.useMarks(props);
        useWatch(props, initData, minValue, maxValue, emit, elFormItem);
        const precision = _vue.computed(()=>{
            const precisions = [
                props.min,
                props.max,
                props.step
            ].map((item)=>{
                const decimal = `${item}`.split(".")[1];
                return decimal ? decimal.length : 0;
            });
            return Math.max.apply(null, precisions);
        });
        const { sliderWrapper  } = useLifecycle(props, initData, resetSize);
        const { firstValue , secondValue , oldValue , dragging , sliderSize  } = _vue.toRefs(initData);
        const updateDragging = (val)=>{
            initData.dragging = val;
        };
        _vue.provide("SliderProvider", {
            ..._vue.toRefs(props),
            sliderSize,
            disabled: sliderDisabled,
            precision,
            emitChange,
            resetSize,
            updateDragging
        });
        return {
            ns,
            firstValue,
            secondValue,
            oldValue,
            dragging,
            sliderSize,
            slider,
            firstButton,
            secondButton,
            sliderDisabled,
            runwayStyle,
            barStyle,
            emitChange,
            onSliderClick,
            getStopStyle,
            setFirstValue,
            setSecondValue,
            stops,
            markList,
            sliderWrapper,
            sliderWrapperSize,
            sliderInputSize,
            sliderKls
        };
    }
});
const useWatch = (props, initData, minValue, maxValue, emit, elFormItem)=>{
    const _emit = (val)=>{
        emit(_eventMjs.UPDATE_MODEL_EVENT, val);
        emit(_eventMjs.INPUT_EVENT, val);
    };
    const valueChanged = ()=>{
        if (props.range) return ![
            minValue.value,
            maxValue.value
        ].every((item, index)=>item === initData.oldValue[index]
        );
        else return props.modelValue !== initData.oldValue;
    };
    const setValues = ()=>{
        var _a, _b;
        if (props.min > props.max) {
            _errorMjs.throwError("Slider", "min should not be greater than max.");
            return;
        }
        const val = props.modelValue;
        if (props.range && Array.isArray(val)) {
            if (val[1] < props.min) _emit([
                props.min,
                props.min
            ]);
            else if (val[0] > props.max) _emit([
                props.max,
                props.max
            ]);
            else if (val[0] < props.min) _emit([
                props.min,
                val[1]
            ]);
            else if (val[1] > props.max) _emit([
                val[0],
                props.max
            ]);
            else {
                initData.firstValue = val[0];
                initData.secondValue = val[1];
                if (valueChanged()) {
                    (_a = elFormItem.validate) == null || _a.call(elFormItem, "change");
                    initData.oldValue = val.slice();
                }
            }
        } else if (!props.range && typeof val === "number" && !isNaN(val)) {
            if (val < props.min) _emit(props.min);
            else if (val > props.max) _emit(props.max);
            else {
                initData.firstValue = val;
                if (valueChanged()) {
                    (_b = elFormItem.validate) == null || _b.call(elFormItem, "change");
                    initData.oldValue = val;
                }
            }
        }
    };
    setValues();
    _vue.watch(()=>initData.dragging
    , (val)=>{
        if (!val) setValues();
    });
    _vue.watch(()=>props.modelValue
    , (val, oldVal)=>{
        if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index)=>item === oldVal[index]
        ) && initData.firstValue === val[0] && initData.secondValue === val[1]) return;
        setValues();
    }, {
        deep: true
    });
    _vue.watch(()=>[
            props.min,
            props.max
        ]
    , ()=>{
        setValues();
    });
};
const useLifecycle = (props, initData, resetSize)=>{
    const sliderWrapper = _vue.ref(null);
    _vue.onMounted(async ()=>{
        let valuetext;
        if (props.range) {
            if (Array.isArray(props.modelValue)) {
                initData.firstValue = Math.max(props.min, props.modelValue[0]);
                initData.secondValue = Math.min(props.max, props.modelValue[1]);
            } else {
                initData.firstValue = props.min;
                initData.secondValue = props.max;
            }
            initData.oldValue = [
                initData.firstValue,
                initData.secondValue
            ];
            valuetext = `${initData.firstValue}-${initData.secondValue}`;
        } else {
            if (typeof props.modelValue !== "number" || isNaN(props.modelValue)) initData.firstValue = props.min;
            else initData.firstValue = Math.min(props.max, Math.max(props.min, props.modelValue));
            initData.oldValue = initData.firstValue;
            valuetext = initData.firstValue;
        }
        sliderWrapper.value.setAttribute("aria-valuetext", valuetext);
        sliderWrapper.value.setAttribute("aria-label", props.label ? props.label : `slider between ${props.min} and ${props.max}`);
        _eventMjs1.on(window, "resize", resetSize);
        await _vue.nextTick();
        resetSize();
    });
    _vue.onBeforeUnmount(()=>{
        _eventMjs1.off(window, "resize", resetSize);
    });
    return {
        sliderWrapper
    };
};
const _hoisted_1 = [
    "aria-valuemin",
    "aria-valuemax",
    "aria-orientation",
    "aria-disabled"
];
const _hoisted_2 = {
    key: 1
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_slider_button = _vue.resolveComponent("slider-button");
    const _component_slider_marker = _vue.resolveComponent("slider-marker");
    const _component_el_input_number = _vue.resolveComponent("el-input-number");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "sliderWrapper",
        class: _vue.normalizeClass(_ctx.sliderKls),
        role: "slider",
        "aria-valuemin": _ctx.min,
        "aria-valuemax": _ctx.max,
        "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
        "aria-disabled": _ctx.sliderDisabled
    }, [
        _vue.createElementVNode("div", {
            ref: "slider",
            class: _vue.normalizeClass([
                _ctx.ns.e("runway"),
                {
                    "show-input": _ctx.showInput && !_ctx.range,
                    disabled: _ctx.sliderDisabled
                }
            ]),
            style: _vue.normalizeStyle(_ctx.runwayStyle),
            onClick: _cache[0] || (_cache[0] = (...args)=>_ctx.onSliderClick && _ctx.onSliderClick(...args)
            )
        }, [
            _vue.createElementVNode("div", {
                class: _vue.normalizeClass(_ctx.ns.e("bar")),
                style: _vue.normalizeStyle(_ctx.barStyle)
            }, null, 6),
            _vue.createVNode(_component_slider_button, {
                ref: "firstButton",
                "model-value": _ctx.firstValue,
                vertical: _ctx.vertical,
                "tooltip-class": _ctx.tooltipClass,
                "onUpdate:modelValue": _ctx.setFirstValue
            }, null, 8, [
                "model-value",
                "vertical",
                "tooltip-class",
                "onUpdate:modelValue"
            ]),
            _ctx.range ? (_vue.openBlock(), _vue.createBlock(_component_slider_button, {
                key: 0,
                ref: "secondButton",
                "model-value": _ctx.secondValue,
                vertical: _ctx.vertical,
                "tooltip-class": _ctx.tooltipClass,
                "onUpdate:modelValue": _ctx.setSecondValue
            }, null, 8, [
                "model-value",
                "vertical",
                "tooltip-class",
                "onUpdate:modelValue"
            ])) : _vue.createCommentVNode("v-if", true),
            _ctx.showStops ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_2, [
                (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.stops, (item, key)=>{
                    return _vue.openBlock(), _vue.createElementBlock("div", {
                        key,
                        class: _vue.normalizeClass(_ctx.ns.e("stop")),
                        style: _vue.normalizeStyle(_ctx.getStopStyle(item))
                    }, null, 6);
                }), 128))
            ])) : _vue.createCommentVNode("v-if", true),
            _ctx.markList.length > 0 ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                key: 2
            }, [
                _vue.createElementVNode("div", null, [
                    (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.markList, (item, key)=>{
                        return _vue.openBlock(), _vue.createElementBlock("div", {
                            key,
                            style: _vue.normalizeStyle(_ctx.getStopStyle(item.position)),
                            class: _vue.normalizeClass([
                                _ctx.ns.e("stop"),
                                _ctx.ns.e("marks-stop")
                            ])
                        }, null, 6);
                    }), 128))
                ]),
                _vue.createElementVNode("div", {
                    class: _vue.normalizeClass(_ctx.ns.e("marks"))
                }, [
                    (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.markList, (item, key)=>{
                        return _vue.openBlock(), _vue.createBlock(_component_slider_marker, {
                            key,
                            mark: item.mark,
                            style: _vue.normalizeStyle(_ctx.getStopStyle(item.position))
                        }, null, 8, [
                            "mark",
                            "style"
                        ]);
                    }), 128))
                ], 2)
            ], 64)) : _vue.createCommentVNode("v-if", true)
        ], 6),
        _ctx.showInput && !_ctx.range ? (_vue.openBlock(), _vue.createBlock(_component_el_input_number, {
            key: 0,
            ref: "input",
            "model-value": _ctx.firstValue,
            class: _vue.normalizeClass(_ctx.ns.e("input")),
            step: _ctx.step,
            disabled: _ctx.sliderDisabled,
            controls: _ctx.showInputControls,
            min: _ctx.min,
            max: _ctx.max,
            debounce: _ctx.debounce,
            size: _ctx.sliderInputSize,
            "onUpdate:modelValue": _ctx.setFirstValue,
            onChange: _ctx.emitChange
        }, null, 8, [
            "model-value",
            "class",
            "step",
            "disabled",
            "controls",
            "min",
            "max",
            "debounce",
            "size",
            "onUpdate:modelValue",
            "onChange"
        ])) : _vue.createCommentVNode("v-if", true)
    ], 10, _hoisted_1);
}
var Slider = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../input-number/index.mjs":"1U2Gu","../../../constants/index.mjs":"74Fbn","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./button.mjs":"9so6L","./marker.mjs":"d4dgs","./useMarks.mjs":"bzUHx","./useSlide.mjs":"hMZYN","./useStops.mjs":"gYqlz","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/vue/validator.mjs":"4UnBa","../../../constants/event.mjs":"92xVn","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../hooks/use-common-props/index.mjs":"05czU","../../../utils/error.mjs":"2zPBN","../../../utils/dom/event.mjs":"fnXSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9so6L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>SliderButton
);
var _vue = require("vue");
var _indexMjs = require("../../tooltip/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _useSliderButtonMjs = require("./useSliderButton.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElSliderButton",
    components: {
        ElTooltip: _indexMjs.ElTooltip
    },
    props: {
        modelValue: {
            type: Number,
            default: 0
        },
        vertical: {
            type: Boolean,
            default: false
        },
        tooltipClass: {
            type: String,
            default: ""
        }
    },
    emits: [
        _eventMjs.UPDATE_MODEL_EVENT
    ],
    setup (props, { emit  }) {
        const ns = _indexMjs3.useNamespace("slider");
        const initData = _vue.reactive({
            hovering: false,
            dragging: false,
            isClick: false,
            startX: 0,
            currentX: 0,
            startY: 0,
            currentY: 0,
            startPosition: 0,
            newPosition: 0,
            oldValue: props.modelValue
        });
        const { tooltip , showTooltip , tooltipVisible , wrapperStyle , formatValue , handleMouseEnter , handleMouseLeave , onButtonDown , onLeftKeyDown , onRightKeyDown , setPosition  } = _useSliderButtonMjs.useSliderButton(props, initData, emit);
        const { hovering , dragging  } = _vue.toRefs(initData);
        return {
            ns,
            tooltip,
            tooltipVisible,
            showTooltip,
            wrapperStyle,
            formatValue,
            handleMouseEnter,
            handleMouseLeave,
            onButtonDown,
            onLeftKeyDown,
            onRightKeyDown,
            setPosition,
            hovering,
            dragging
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_tooltip = _vue.resolveComponent("el-tooltip");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "button",
        class: _vue.normalizeClass([
            _ctx.ns.e("button-wrapper"),
            {
                hover: _ctx.hovering,
                dragging: _ctx.dragging
            }
        ]),
        style: _vue.normalizeStyle(_ctx.wrapperStyle),
        tabindex: "0",
        onMouseenter: _cache[1] || (_cache[1] = (...args)=>_ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)
        ),
        onMouseleave: _cache[2] || (_cache[2] = (...args)=>_ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)
        ),
        onMousedown: _cache[3] || (_cache[3] = (...args)=>_ctx.onButtonDown && _ctx.onButtonDown(...args)
        ),
        onTouchstart: _cache[4] || (_cache[4] = (...args)=>_ctx.onButtonDown && _ctx.onButtonDown(...args)
        ),
        onFocus: _cache[5] || (_cache[5] = (...args)=>_ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)
        ),
        onBlur: _cache[6] || (_cache[6] = (...args)=>_ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)
        ),
        onKeydown: [
            _cache[7] || (_cache[7] = _vue.withKeys((...args)=>_ctx.onLeftKeyDown && _ctx.onLeftKeyDown(...args)
            , [
                "left"
            ])),
            _cache[8] || (_cache[8] = _vue.withKeys((...args)=>_ctx.onRightKeyDown && _ctx.onRightKeyDown(...args)
            , [
                "right"
            ])),
            _cache[9] || (_cache[9] = _vue.withKeys(_vue.withModifiers((...args)=>_ctx.onLeftKeyDown && _ctx.onLeftKeyDown(...args)
            , [
                "prevent"
            ]), [
                "down"
            ])),
            _cache[10] || (_cache[10] = _vue.withKeys(_vue.withModifiers((...args)=>_ctx.onRightKeyDown && _ctx.onRightKeyDown(...args)
            , [
                "prevent"
            ]), [
                "up"
            ]))
        ]
    }, [
        _vue.createVNode(_component_el_tooltip, {
            ref: "tooltip",
            visible: _ctx.tooltipVisible,
            "onUpdate:visible": _cache[0] || (_cache[0] = ($event)=>_ctx.tooltipVisible = $event
            ),
            placement: "top",
            "stop-popper-mouse-event": false,
            "popper-class": _ctx.tooltipClass,
            disabled: !_ctx.showTooltip,
            persistent: ""
        }, {
            content: _vue.withCtx(()=>[
                    _vue.createElementVNode("span", null, _vue.toDisplayString(_ctx.formatValue), 1)
                ]
            ),
            default: _vue.withCtx(()=>[
                    _vue.createElementVNode("div", {
                        class: _vue.normalizeClass([
                            _ctx.ns.e("button"),
                            {
                                hover: _ctx.hovering,
                                dragging: _ctx.dragging
                            }
                        ])
                    }, null, 2)
                ]
            ),
            _: 1
        }, 8, [
            "visible",
            "popper-class",
            "disabled"
        ])
    ], 38);
}
var SliderButton = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../tooltip/index.mjs":"kiwBC","../../../constants/index.mjs":"74Fbn","../../../hooks/index.mjs":"1Ansp","./useSliderButton.mjs":"jiroF","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../constants/event.mjs":"92xVn","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jiroF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useSliderButton", ()=>useSliderButton
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../constants/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _eventMjs = require("../../../utils/dom/event.mjs");
var _eventMjs1 = require("../../../constants/event.mjs");
const useTooltip = (props, formatTooltip, showTooltip)=>{
    const tooltip = _vue.ref(null);
    const tooltipVisible = _vue.ref(false);
    const enableFormat = _vue.computed(()=>{
        return formatTooltip.value instanceof Function;
    });
    const formatValue = _vue.computed(()=>{
        return enableFormat.value && formatTooltip.value(props.modelValue) || props.modelValue;
    });
    const displayTooltip = _lodashUnified.debounce(()=>{
        showTooltip.value && (tooltipVisible.value = true);
    }, 50);
    const hideTooltip = _lodashUnified.debounce(()=>{
        showTooltip.value && (tooltipVisible.value = false);
    }, 50);
    return {
        tooltip,
        tooltipVisible,
        formatValue,
        displayTooltip,
        hideTooltip
    };
};
const useSliderButton = (props, initData, emit)=>{
    const { disabled , min , max , step , showTooltip , precision , sliderSize , formatTooltip , emitChange , resetSize , updateDragging  } = _vue.inject("SliderProvider");
    const { tooltip , tooltipVisible , formatValue , displayTooltip , hideTooltip  } = useTooltip(props, formatTooltip, showTooltip);
    const currentPosition = _vue.computed(()=>{
        return `${(props.modelValue - min.value) / (max.value - min.value) * 100}%`;
    });
    const wrapperStyle = _vue.computed(()=>{
        return props.vertical ? {
            bottom: currentPosition.value
        } : {
            left: currentPosition.value
        };
    });
    const handleMouseEnter = ()=>{
        initData.hovering = true;
        displayTooltip();
    };
    const handleMouseLeave = ()=>{
        initData.hovering = false;
        if (!initData.dragging) hideTooltip();
    };
    const onButtonDown = (event)=>{
        if (disabled.value) return;
        event.preventDefault();
        onDragStart(event);
        _eventMjs.on(window, "mousemove", onDragging);
        _eventMjs.on(window, "touchmove", onDragging);
        _eventMjs.on(window, "mouseup", onDragEnd);
        _eventMjs.on(window, "touchend", onDragEnd);
        _eventMjs.on(window, "contextmenu", onDragEnd);
    };
    const onLeftKeyDown = ()=>{
        if (disabled.value) return;
        initData.newPosition = parseFloat(currentPosition.value) - step.value / (max.value - min.value) * 100;
        setPosition(initData.newPosition);
        emitChange();
    };
    const onRightKeyDown = ()=>{
        if (disabled.value) return;
        initData.newPosition = parseFloat(currentPosition.value) + step.value / (max.value - min.value) * 100;
        setPosition(initData.newPosition);
        emitChange();
    };
    const getClientXY = (event)=>{
        let clientX;
        let clientY;
        if (event.type.startsWith("touch")) {
            clientY = event.touches[0].clientY;
            clientX = event.touches[0].clientX;
        } else {
            clientY = event.clientY;
            clientX = event.clientX;
        }
        return {
            clientX,
            clientY
        };
    };
    const onDragStart = (event)=>{
        initData.dragging = true;
        initData.isClick = true;
        const { clientX , clientY  } = getClientXY(event);
        if (props.vertical) initData.startY = clientY;
        else initData.startX = clientX;
        initData.startPosition = parseFloat(currentPosition.value);
        initData.newPosition = initData.startPosition;
    };
    const onDragging = (event)=>{
        if (initData.dragging) {
            initData.isClick = false;
            displayTooltip();
            resetSize();
            let diff;
            const { clientX , clientY  } = getClientXY(event);
            if (props.vertical) {
                initData.currentY = clientY;
                diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
            } else {
                initData.currentX = clientX;
                diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
            }
            initData.newPosition = initData.startPosition + diff;
            setPosition(initData.newPosition);
        }
    };
    const onDragEnd = ()=>{
        if (initData.dragging) {
            setTimeout(()=>{
                initData.dragging = false;
                if (!initData.hovering) hideTooltip();
                if (!initData.isClick) {
                    setPosition(initData.newPosition);
                    emitChange();
                }
            }, 0);
            _eventMjs.off(window, "mousemove", onDragging);
            _eventMjs.off(window, "touchmove", onDragging);
            _eventMjs.off(window, "mouseup", onDragEnd);
            _eventMjs.off(window, "touchend", onDragEnd);
            _eventMjs.off(window, "contextmenu", onDragEnd);
        }
    };
    const setPosition = async (newPosition)=>{
        if (newPosition === null || isNaN(newPosition)) return;
        if (newPosition < 0) newPosition = 0;
        else if (newPosition > 100) newPosition = 100;
        const lengthPerStep = 100 / ((max.value - min.value) / step.value);
        const steps = Math.round(newPosition / lengthPerStep);
        let value = steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value;
        value = parseFloat(value.toFixed(precision.value));
        emit(_eventMjs1.UPDATE_MODEL_EVENT, value);
        if (!initData.dragging && props.modelValue !== initData.oldValue) initData.oldValue = props.modelValue;
        await _vue.nextTick();
        initData.dragging && displayTooltip();
        tooltip.value.updatePopper();
    };
    _vue.watch(()=>initData.dragging
    , (val)=>{
        updateDragging(val);
    });
    return {
        tooltip,
        tooltipVisible,
        showTooltip,
        wrapperStyle,
        formatValue,
        handleMouseEnter,
        handleMouseLeave,
        onButtonDown,
        onLeftKeyDown,
        onRightKeyDown,
        setPosition
    };
};

},{"vue":"gzxs9","lodash-unified":"4Oj4p","../../../constants/index.mjs":"74Fbn","../../../utils/index.mjs":"dsdeP","../../../utils/dom/event.mjs":"fnXSh","../../../constants/event.mjs":"92xVn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d4dgs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_sfc_main
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElMarker",
    props: {
        mark: {
            type: [
                String,
                Object
            ],
            default: ()=>void 0
        }
    },
    setup (props) {
        const ns = _indexMjs1.useNamespace("slider");
        const label = _vue.computed(()=>{
            return typeof props.mark === "string" ? props.mark : props.mark.label;
        });
        return {
            ns,
            label
        };
    },
    render () {
        var _a;
        return _vue.h("div", {
            class: this.ns.e("marks-text"),
            style: (_a = this.mark) == null ? void 0 : _a.style
        }, this.label);
    }
});

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bzUHx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useMarks", ()=>useMarks
);
var _vue = require("vue");
const useMarks = (props)=>{
    return _vue.computed(()=>{
        if (!props.marks) return [];
        const marksKeys = Object.keys(props.marks);
        return marksKeys.map(parseFloat).sort((a, b)=>a - b
        ).filter((point)=>point <= props.max && point >= props.min
        ).map((point)=>({
                point,
                position: (point - props.min) * 100 / (props.max - props.min),
                mark: props.marks[point]
            })
        );
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hMZYN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useSlide", ()=>useSlide
);
var _vue = require("vue");
var _indexMjs = require("../../../constants/index.mjs");
var _indexMjs1 = require("../../../tokens/index.mjs");
var _formMjs = require("../../../tokens/form.mjs");
var _eventMjs = require("../../../constants/event.mjs");
const useSlide = (props, initData, emit)=>{
    const elForm = _vue.inject(_formMjs.elFormKey, {
    });
    const elFormItem = _vue.inject(_formMjs.elFormItemKey, {
    });
    const slider = _vue.shallowRef(null);
    const firstButton = _vue.ref(null);
    const secondButton = _vue.ref(null);
    const buttonRefs = {
        firstButton,
        secondButton
    };
    const sliderDisabled = _vue.computed(()=>{
        return props.disabled || elForm.disabled || false;
    });
    const minValue = _vue.computed(()=>{
        return Math.min(initData.firstValue, initData.secondValue);
    });
    const maxValue = _vue.computed(()=>{
        return Math.max(initData.firstValue, initData.secondValue);
    });
    const barSize = _vue.computed(()=>{
        return props.range ? `${100 * (maxValue.value - minValue.value) / (props.max - props.min)}%` : `${100 * (initData.firstValue - props.min) / (props.max - props.min)}%`;
    });
    const barStart = _vue.computed(()=>{
        return props.range ? `${100 * (minValue.value - props.min) / (props.max - props.min)}%` : "0%";
    });
    const runwayStyle = _vue.computed(()=>{
        return props.vertical ? {
            height: props.height
        } : {
        };
    });
    const barStyle = _vue.computed(()=>{
        return props.vertical ? {
            height: barSize.value,
            bottom: barStart.value
        } : {
            width: barSize.value,
            left: barStart.value
        };
    });
    const resetSize = ()=>{
        if (slider.value) initData.sliderSize = slider.value[`client${props.vertical ? "Height" : "Width"}`];
    };
    const setPosition = (percent)=>{
        const targetValue = props.min + percent * (props.max - props.min) / 100;
        if (!props.range) {
            firstButton.value.setPosition(percent);
            return;
        }
        let buttonRefName;
        if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) buttonRefName = initData.firstValue < initData.secondValue ? "firstButton" : "secondButton";
        else buttonRefName = initData.firstValue > initData.secondValue ? "firstButton" : "secondButton";
        buttonRefs[buttonRefName].value.setPosition(percent);
    };
    const setFirstValue = (firstValue)=>{
        initData.firstValue = firstValue;
        _emit(props.range ? [
            minValue.value,
            maxValue.value
        ] : firstValue);
    };
    const setSecondValue = (secondValue)=>{
        initData.secondValue = secondValue;
        if (props.range) _emit([
            minValue.value,
            maxValue.value
        ]);
    };
    const _emit = (val)=>{
        emit(_eventMjs.UPDATE_MODEL_EVENT, val);
        emit(_eventMjs.INPUT_EVENT, val);
    };
    const emitChange = async ()=>{
        await _vue.nextTick();
        emit(_eventMjs.CHANGE_EVENT, props.range ? [
            minValue.value,
            maxValue.value
        ] : props.modelValue);
    };
    const onSliderClick = (event)=>{
        if (sliderDisabled.value || initData.dragging) return;
        resetSize();
        if (props.vertical) {
            const sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
            setPosition((sliderOffsetBottom - event.clientY) / initData.sliderSize * 100);
        } else {
            const sliderOffsetLeft = slider.value.getBoundingClientRect().left;
            setPosition((event.clientX - sliderOffsetLeft) / initData.sliderSize * 100);
        }
        emitChange();
    };
    return {
        elFormItem,
        slider,
        firstButton,
        secondButton,
        sliderDisabled,
        minValue,
        maxValue,
        runwayStyle,
        barStyle,
        resetSize,
        setPosition,
        emitChange,
        onSliderClick,
        setFirstValue,
        setSecondValue
    };
};

},{"vue":"gzxs9","../../../constants/index.mjs":"74Fbn","../../../tokens/index.mjs":"wVNQi","../../../tokens/form.mjs":"2r4O0","../../../constants/event.mjs":"92xVn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gYqlz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useStops", ()=>useStops
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const useStops = (props, initData, minValue, maxValue)=>{
    const stops = _vue.computed(()=>{
        if (!props.showStops || props.min > props.max) return [];
        if (props.step === 0) {
            _errorMjs.debugWarn("Slider", "step should not be 0.");
            return [];
        }
        const stopCount = (props.max - props.min) / props.step;
        const stepWidth = 100 * props.step / (props.max - props.min);
        const result = Array.from({
            length: stopCount - 1
        }).map((_, index)=>(index + 1) * stepWidth
        );
        if (props.range) return result.filter((step)=>{
            return step < 100 * (minValue.value - props.min) / (props.max - props.min) || step > 100 * (maxValue.value - props.min) / (props.max - props.min);
        });
        else return result.filter((step)=>step > 100 * (initData.firstValue - props.min) / (props.max - props.min)
        );
    });
    const getStopStyle = (position)=>{
        return props.vertical ? {
            bottom: `${position}%`
        } : {
            left: `${position}%`
        };
    };
    return {
        stops,
        getStopStyle
    };
};

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aAqL3":[function(require,module,exports) {

},{}],"fdm11":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "spaceProps", ()=>_spaceMjs.spaceProps
);
parcelHelpers.export(exports, "useSpace", ()=>_useSpaceMjs.useSpace
);
parcelHelpers.export(exports, "ElSpace", ()=>ElSpace
);
parcelHelpers.export(exports, "default", ()=>ElSpace
);
var _indexMjs = require("../../utils/index.mjs");
var _spaceMjs = require("./src/space.mjs");
var _spaceMjsDefault = parcelHelpers.interopDefault(_spaceMjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _useSpaceMjs = require("./src/use-space.mjs");
const ElSpace = _installMjs.withInstall(_spaceMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/space.mjs":"5tyjs","../../utils/vue/install.mjs":"4TMmv","./src/use-space.mjs":"gYCpP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5tyjs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Space
);
parcelHelpers.export(exports, "spaceProps", ()=>spaceProps
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _itemMjs = require("./item.mjs");
var _itemMjsDefault = parcelHelpers.interopDefault(_itemMjs);
var _useSpaceMjs = require("./use-space.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _core = require("@vueuse/core");
var _sizeMjs = require("../../../constants/size.mjs");
var _vnodeMjs = require("../../../utils/vue/vnode.mjs");
const spaceProps = _propsMjs.buildProps({
    direction: {
        type: String,
        values: [
            "horizontal",
            "vertical"
        ],
        default: "horizontal"
    },
    class: {
        type: _propsMjs.definePropType([
            String,
            Object,
            Array
        ]),
        default: ""
    },
    style: {
        type: _propsMjs.definePropType([
            String,
            Array,
            Object
        ]),
        default: ""
    },
    alignment: {
        type: _propsMjs.definePropType(String),
        default: "center"
    },
    prefixCls: {
        type: String
    },
    spacer: {
        type: _propsMjs.definePropType([
            Object,
            String,
            Number,
            Array
        ]),
        default: null,
        validator: (val)=>_vue.isVNode(val) || _core.isNumber(val) || _shared.isString(val)
    },
    wrap: {
        type: Boolean,
        default: false
    },
    fill: {
        type: Boolean,
        default: false
    },
    fillRatio: {
        type: Number,
        default: 100
    },
    size: {
        type: [
            String,
            Array,
            Number
        ],
        values: _sizeMjs.componentSizes,
        validator: (val)=>{
            return _core.isNumber(val) || _shared.isArray(val) && val.length === 2 && val.every((i)=>_core.isNumber(i)
            );
        }
    }
});
var Space = _vue.defineComponent({
    name: "ElSpace",
    props: spaceProps,
    setup (props, { slots  }) {
        const { classes , containerStyle , itemStyle  } = _useSpaceMjs.useSpace(props);
        return ()=>{
            var _a;
            const { spacer , prefixCls , direction  } = props;
            const children = _vue.renderSlot(slots, "default", {
                key: 0
            }, ()=>[]
            );
            if (((_a = children.children) != null ? _a : []).length === 0) return null;
            if (_shared.isArray(children.children)) {
                let extractedChildren = [];
                children.children.forEach((child, loopKey)=>{
                    if (_vnodeMjs.isFragment(child)) {
                        if (_shared.isArray(child.children)) child.children.forEach((nested, key)=>{
                            extractedChildren.push(_vue.createVNode(_itemMjsDefault.default, {
                                style: itemStyle.value,
                                prefixCls,
                                key: `nested-${key}`
                            }, {
                                default: ()=>[
                                        nested
                                    ]
                            }, _vnodeMjs.PatchFlags.PROPS | _vnodeMjs.PatchFlags.STYLE, [
                                "style",
                                "prefixCls"
                            ]));
                        });
                    } else if (_vnodeMjs.isValidElementNode(child)) extractedChildren.push(_vue.createVNode(_itemMjsDefault.default, {
                        style: itemStyle.value,
                        prefixCls,
                        key: `LoopKey${loopKey}`
                    }, {
                        default: ()=>[
                                child
                            ]
                    }, _vnodeMjs.PatchFlags.PROPS | _vnodeMjs.PatchFlags.STYLE, [
                        "style",
                        "prefixCls"
                    ]));
                });
                if (spacer) {
                    const len = extractedChildren.length - 1;
                    extractedChildren = extractedChildren.reduce((acc, child, idx)=>{
                        const children2 = [
                            ...acc,
                            child
                        ];
                        if (idx !== len) children2.push(_vue.createVNode("span", {
                            style: [
                                itemStyle.value,
                                direction === "vertical" ? "width: 100%" : null
                            ],
                            key: idx
                        }, [
                            _vue.isVNode(spacer) ? spacer : _vue.createTextVNode(spacer, _vnodeMjs.PatchFlags.TEXT)
                        ], _vnodeMjs.PatchFlags.STYLE));
                        return children2;
                    }, []);
                }
                return _vue.createVNode("div", {
                    class: classes.value,
                    style: containerStyle.value
                }, extractedChildren, _vnodeMjs.PatchFlags.STYLE | _vnodeMjs.PatchFlags.CLASS);
            }
            return children.children;
        };
    }
});

},{"vue":"gzxs9","@vue/shared":"3SM3y","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","./item.mjs":"ezjem","./use-space.mjs":"gYCpP","../../../utils/vue/props.mjs":"cpwWK","@vueuse/core":"eEHP9","../../../constants/size.mjs":"jelXi","../../../utils/vue/vnode.mjs":"ljPKw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ezjem":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Item
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _propsMjs = require("../../../utils/vue/props.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const spaceItem = _propsMjs.buildProps({
    prefixCls: {
        type: String,
        default: ""
    }
});
const _sfc_main = _vue.defineComponent({
    props: spaceItem,
    setup (props) {
        const ns = _indexMjs2.useNamespace("space");
        const classes = _vue.computed(()=>`${props.prefixCls || ns.b()}__item`
        );
        return {
            classes
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.classes)
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 2);
}
var Item = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/vue/props.mjs":"cpwWK","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gYCpP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useSpace", ()=>useSpace
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
var _core = require("@vueuse/core");
const SIZE_MAP = {
    small: 8,
    default: 12,
    large: 16
};
function useSpace(props) {
    const ns = _indexMjs2.useNamespace("space");
    const classes = _vue.computed(()=>[
            ns.b(),
            ns.m(props.direction),
            props.class
        ]
    );
    const horizontalSize = _vue.ref(0);
    const verticalSize = _vue.ref(0);
    const containerStyle = _vue.computed(()=>{
        const wrapKls = props.wrap || props.fill ? {
            flexWrap: "wrap",
            marginBottom: `-${verticalSize.value}px`
        } : {
        };
        const alignment = {
            alignItems: props.alignment
        };
        return [
            wrapKls,
            alignment,
            props.style
        ];
    });
    const itemStyle = _vue.computed(()=>{
        const itemBaseStyle = {
            paddingBottom: `${verticalSize.value}px`,
            marginRight: `${horizontalSize.value}px`
        };
        const fillStyle = props.fill ? {
            flexGrow: 1,
            minWidth: `${props.fillRatio}%`
        } : {
        };
        return [
            itemBaseStyle,
            fillStyle
        ];
    });
    _vue.watchEffect(()=>{
        const { size ="small" , wrap , direction: dir , fill  } = props;
        if (Array.isArray(size)) {
            const [h = 0, v = 0] = size;
            horizontalSize.value = h;
            verticalSize.value = v;
        } else {
            let val;
            if (_core.isNumber(size)) val = size;
            else val = SIZE_MAP[size] || SIZE_MAP.small;
            if ((wrap || fill) && dir === "horizontal") horizontalSize.value = verticalSize.value = val;
            else if (dir === "horizontal") {
                horizontalSize.value = val;
                verticalSize.value = 0;
            } else {
                verticalSize.value = val;
                horizontalSize.value = 0;
            }
        }
    });
    return {
        classes,
        containerStyle,
        itemStyle
    };
}

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","../../../hooks/use-namespace/index.mjs":"a1pcf","@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9fit0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElStep", ()=>ElStep
);
parcelHelpers.export(exports, "ElSteps", ()=>ElSteps
);
parcelHelpers.export(exports, "default", ()=>ElSteps
);
var _indexMjs = require("../../utils/index.mjs");
var _indexMjs1 = require("./src/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _itemMjs = require("./src/item.mjs");
var _itemMjsDefault = parcelHelpers.interopDefault(_itemMjs);
var _installMjs = require("../../utils/vue/install.mjs");
const ElSteps = _installMjs.withInstall(_indexMjsDefault.default, {
    Step: _itemMjsDefault.default
});
const ElStep = _installMjs.withNoopInstall(_itemMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/index.mjs":"5N9cR","./src/item.mjs":"fw9iL","../../utils/vue/install.mjs":"4TMmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5N9cR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Steps
);
var _vue = require("vue");
var _indexMjs = require("../../../constants/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElSteps",
    props: {
        space: {
            type: [
                Number,
                String
            ],
            default: ""
        },
        active: {
            type: Number,
            default: 0
        },
        direction: {
            type: String,
            default: "horizontal",
            validator: (val)=>[
                    "horizontal",
                    "vertical"
                ].includes(val)
        },
        alignCenter: {
            type: Boolean,
            default: false
        },
        simple: {
            type: Boolean,
            default: false
        },
        finishStatus: {
            type: String,
            default: "finish",
            validator: (val)=>[
                    "wait",
                    "process",
                    "finish",
                    "error",
                    "success"
                ].includes(val)
        },
        processStatus: {
            type: String,
            default: "process",
            validator: (val)=>[
                    "wait",
                    "process",
                    "finish",
                    "error",
                    "success"
                ].includes(val)
        }
    },
    emits: [
        _eventMjs.CHANGE_EVENT
    ],
    setup (props, { emit  }) {
        const ns = _indexMjs2.useNamespace("steps");
        const steps = _vue.ref([]);
        _vue.watch(steps, ()=>{
            steps.value.forEach((instance, index)=>{
                instance.setIndex(index);
            });
        });
        _vue.provide("ElSteps", {
            props,
            steps
        });
        _vue.watch(()=>props.active
        , (newVal, oldVal)=>{
            emit(_eventMjs.CHANGE_EVENT, newVal, oldVal);
        });
        return {
            steps,
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.m(_ctx.simple ? "simple" : _ctx.direction)
        ])
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 2);
}
var Steps = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../constants/index.mjs":"74Fbn","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../constants/event.mjs":"92xVn","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fw9iL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Step
);
var _vue = require("vue");
var _indexMjs = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElStep",
    components: {
        ElIcon: _indexMjs.ElIcon,
        Close: _iconsVue.Close,
        Check: _iconsVue.Check
    },
    props: {
        title: {
            type: String,
            default: ""
        },
        icon: {
            type: [
                String,
                Object
            ],
            default: ""
        },
        description: {
            type: String,
            default: ""
        },
        status: {
            type: String,
            default: "",
            validator: (val)=>[
                    "",
                    "wait",
                    "process",
                    "finish",
                    "error",
                    "success"
                ].includes(val)
        }
    },
    setup (props) {
        const ns = _indexMjs2.useNamespace("step");
        const index = _vue.ref(-1);
        const lineStyle = _vue.ref({
        });
        const internalStatus = _vue.ref("");
        const parent = _vue.inject("ElSteps");
        const currentInstance = _vue.getCurrentInstance();
        _vue.onMounted(()=>{
            _vue.watch([
                ()=>parent.props.active
                ,
                ()=>parent.props.processStatus
                ,
                ()=>parent.props.finishStatus
            ], ([active])=>{
                updateStatus(active);
            }, {
                immediate: true
            });
        });
        _vue.onBeforeUnmount(()=>{
            parent.steps.value = parent.steps.value.filter((instance)=>instance.uid !== currentInstance.uid
            );
        });
        const currentStatus = _vue.computed(()=>{
            return props.status || internalStatus.value;
        });
        const prevStatus = _vue.computed(()=>{
            const prevStep = parent.steps.value[index.value - 1];
            return prevStep ? prevStep.currentStatus : "wait";
        });
        const isCenter = _vue.computed(()=>{
            return parent.props.alignCenter;
        });
        const isVertical = _vue.computed(()=>{
            return parent.props.direction === "vertical";
        });
        const isSimple = _vue.computed(()=>{
            return parent.props.simple;
        });
        const stepsCount = _vue.computed(()=>{
            return parent.steps.value.length;
        });
        const isLast = _vue.computed(()=>{
            var _a;
            return ((_a = parent.steps.value[stepsCount.value - 1]) == null ? void 0 : _a.uid) === currentInstance.uid;
        });
        const space = _vue.computed(()=>{
            return isSimple.value ? "" : parent.props.space;
        });
        const style = _vue.computed(()=>{
            const style2 = {
                flexBasis: typeof space.value === "number" ? `${space.value}px` : space.value ? space.value : `${100 / (stepsCount.value - (isCenter.value ? 0 : 1))}%`
            };
            if (isVertical.value) return style2;
            if (isLast.value) style2.maxWidth = `${100 / stepsCount.value}%`;
            return style2;
        });
        const setIndex = (val)=>{
            index.value = val;
        };
        const calcProgress = (status)=>{
            let step = 100;
            const style2 = {
            };
            style2.transitionDelay = `${150 * index.value}ms`;
            if (status === parent.props.processStatus) step = 0;
            else if (status === "wait") {
                step = 0;
                style2.transitionDelay = `${-150 * index.value}ms`;
            }
            style2.borderWidth = step && !isSimple.value ? "1px" : 0;
            style2[parent.props.direction === "vertical" ? "height" : "width"] = `${step}%`;
            lineStyle.value = style2;
        };
        const updateStatus = (activeIndex)=>{
            if (activeIndex > index.value) internalStatus.value = parent.props.finishStatus;
            else if (activeIndex === index.value && prevStatus.value !== "error") internalStatus.value = parent.props.processStatus;
            else internalStatus.value = "wait";
            const prevChild = parent.steps.value[stepsCount.value - 1];
            if (prevChild) prevChild.calcProgress(internalStatus.value);
        };
        const stepItemState = _vue.reactive({
            uid: _vue.computed(()=>currentInstance.uid
            ),
            currentStatus,
            setIndex,
            calcProgress
        });
        parent.steps.value = [
            ...parent.steps.value,
            stepItemState
        ];
        return {
            ns,
            index,
            lineStyle,
            currentStatus,
            isCenter,
            isVertical,
            isSimple,
            isLast,
            space,
            style,
            parent,
            setIndex,
            calcProgress,
            updateStatus
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_check = _vue.resolveComponent("check");
    const _component_close = _vue.resolveComponent("close");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        style: _vue.normalizeStyle(_ctx.style),
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.is(_ctx.isSimple ? "simple" : _ctx.parent.props.direction),
            _ctx.ns.is("flex", _ctx.isLast && !_ctx.space && !_ctx.isCenter),
            _ctx.ns.is("center", _ctx.isCenter && !_ctx.isVertical && !_ctx.isSimple)
        ])
    }, [
        _vue.createCommentVNode(" icon & line "),
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass([
                _ctx.ns.e("head"),
                _ctx.ns.is(_ctx.currentStatus)
            ])
        }, [
            !_ctx.isSimple ? (_vue.openBlock(), _vue.createElementBlock("div", {
                key: 0,
                class: _vue.normalizeClass(_ctx.ns.e("line"))
            }, [
                _vue.createElementVNode("i", {
                    class: _vue.normalizeClass(_ctx.ns.e("line-inner")),
                    style: _vue.normalizeStyle(_ctx.lineStyle)
                }, null, 6)
            ], 2)) : _vue.createCommentVNode("v-if", true),
            _vue.createElementVNode("div", {
                class: _vue.normalizeClass([
                    _ctx.ns.e("icon"),
                    _ctx.ns.is(_ctx.icon ? "icon" : "text")
                ])
            }, [
                _ctx.currentStatus !== "success" && _ctx.currentStatus !== "error" ? _vue.renderSlot(_ctx.$slots, "icon", {
                    key: 0
                }, ()=>[
                        _ctx.icon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                            key: 0,
                            class: _vue.normalizeClass(_ctx.ns.e("icon-inner"))
                        }, {
                            default: _vue.withCtx(()=>[
                                    (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.icon)))
                                ]
                            ),
                            _: 1
                        }, 8, [
                            "class"
                        ])) : _vue.createCommentVNode("v-if", true),
                        !_ctx.icon && !_ctx.isSimple ? (_vue.openBlock(), _vue.createElementBlock("div", {
                            key: 1,
                            class: _vue.normalizeClass(_ctx.ns.e("icon-inner"))
                        }, _vue.toDisplayString(_ctx.index + 1), 3)) : _vue.createCommentVNode("v-if", true)
                    ]
                ) : (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                    key: 1,
                    class: _vue.normalizeClass([
                        _ctx.ns.e("icon-inner"),
                        _ctx.ns.is("status")
                    ])
                }, {
                    default: _vue.withCtx(()=>[
                            _ctx.currentStatus === "success" ? (_vue.openBlock(), _vue.createBlock(_component_check, {
                                key: 0
                            })) : (_vue.openBlock(), _vue.createBlock(_component_close, {
                                key: 1
                            }))
                        ]
                    ),
                    _: 1
                }, 8, [
                    "class"
                ]))
            ], 2)
        ], 2),
        _vue.createCommentVNode(" title & description "),
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("main"))
        }, [
            _vue.createElementVNode("div", {
                class: _vue.normalizeClass([
                    _ctx.ns.e("title"),
                    _ctx.ns.is(_ctx.currentStatus)
                ])
            }, [
                _vue.renderSlot(_ctx.$slots, "title", {
                }, ()=>[
                        _vue.createTextVNode(_vue.toDisplayString(_ctx.title), 1)
                    ]
                )
            ], 2),
            _ctx.isSimple ? (_vue.openBlock(), _vue.createElementBlock("div", {
                key: 0,
                class: _vue.normalizeClass(_ctx.ns.e("arrow"))
            }, null, 2)) : (_vue.openBlock(), _vue.createElementBlock("div", {
                key: 1,
                class: _vue.normalizeClass([
                    _ctx.ns.e("description"),
                    _ctx.ns.is(_ctx.currentStatus)
                ])
            }, [
                _vue.renderSlot(_ctx.$slots, "description", {
                }, ()=>[
                        _vue.createTextVNode(_vue.toDisplayString(_ctx.description), 1)
                    ]
                )
            ], 2))
        ], 2)
    ], 6);
}
var Step = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aErYv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "switchEmits", ()=>_switchMjs.switchEmits
);
parcelHelpers.export(exports, "switchProps", ()=>_switchMjs.switchProps
);
parcelHelpers.export(exports, "ElSwitch", ()=>ElSwitch
);
parcelHelpers.export(exports, "default", ()=>ElSwitch
);
var _indexMjs = require("../../utils/index.mjs");
var _switch2Mjs = require("./src/switch2.mjs");
var _switch2MjsDefault = parcelHelpers.interopDefault(_switch2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _switchMjs = require("./src/switch.mjs");
const ElSwitch = _installMjs.withInstall(_switch2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/switch2.mjs":"3TSo8","../../utils/vue/install.mjs":"4TMmv","./src/switch.mjs":"77sPp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3TSo8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Switch
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs2 = require("../../../constants/index.mjs");
var _indexMjs3 = require("../../../hooks/index.mjs");
var _switchMjs = require("./switch.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs4 = require("../../../hooks/use-form-item/index.mjs");
var _indexMjs5 = require("../../../hooks/use-common-props/index.mjs");
var _indexMjs6 = require("../../../hooks/use-namespace/index.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _core = require("@vueuse/core");
var _errorMjs = require("../../../utils/error.mjs");
const COMPONENT_NAME = "ElSwitch";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    components: {
        ElIcon: _indexMjs1.ElIcon,
        Loading: _iconsVue.Loading
    },
    props: _switchMjs.switchProps,
    emits: _switchMjs.switchEmits,
    setup (props, { emit  }) {
        const { formItem  } = _indexMjs4.useFormItem();
        const switchDisabled = _indexMjs5.useDisabled(_vue.computed(()=>props.loading
        ));
        const ns = _indexMjs6.useNamespace("switch");
        const switchSize = _indexMjs5.useSize();
        const isModelValue = _vue.ref(props.modelValue !== false);
        const input = _vue.ref();
        const core = _vue.ref();
        const switchKls = _vue.computed(()=>[
                ns.b(),
                ns.m(switchSize.value),
                ns.is("disabled", switchDisabled.value),
                ns.is("checked", checked.value)
            ]
        );
        _vue.watch(()=>props.modelValue
        , ()=>{
            isModelValue.value = true;
        });
        _vue.watch(()=>props.value
        , ()=>{
            isModelValue.value = false;
        });
        const actualValue = _vue.computed(()=>{
            return isModelValue.value ? props.modelValue : props.value;
        });
        const checked = _vue.computed(()=>actualValue.value === props.activeValue
        );
        if (![
            props.activeValue,
            props.inactiveValue
        ].includes(actualValue.value)) {
            emit(_eventMjs.UPDATE_MODEL_EVENT, props.inactiveValue);
            emit(_eventMjs.CHANGE_EVENT, props.inactiveValue);
            emit(_eventMjs.INPUT_EVENT, props.inactiveValue);
        }
        _vue.watch(checked, ()=>{
            var _a;
            input.value.checked = checked.value;
            if (props.activeColor || props.inactiveColor) setBackgroundColor();
            if (props.validateEvent) (_a = formItem == null ? void 0 : formItem.validate) == null || _a.call(formItem, "change");
        });
        const handleChange = ()=>{
            const val = checked.value ? props.inactiveValue : props.activeValue;
            emit(_eventMjs.UPDATE_MODEL_EVENT, val);
            emit(_eventMjs.CHANGE_EVENT, val);
            emit(_eventMjs.INPUT_EVENT, val);
            _vue.nextTick(()=>{
                input.value.checked = checked.value;
            });
        };
        const switchValue = ()=>{
            if (switchDisabled.value) return;
            const { beforeChange  } = props;
            if (!beforeChange) {
                handleChange();
                return;
            }
            const shouldChange = beforeChange();
            const isExpectType = [
                _shared.isPromise(shouldChange),
                _core.isBoolean(shouldChange)
            ].some((i)=>i
            );
            if (!isExpectType) _errorMjs.throwError(COMPONENT_NAME, "beforeChange must return type `Promise<boolean>` or `boolean`");
            if (_shared.isPromise(shouldChange)) shouldChange.then((result)=>{
                if (result) handleChange();
            }).catch((e)=>{
                _errorMjs.debugWarn(COMPONENT_NAME, `some error occurred: ${e}`);
            });
            else if (shouldChange) handleChange();
        };
        const setBackgroundColor = ()=>{
            const newColor = checked.value ? props.activeColor : props.inactiveColor;
            const coreEl = core.value;
            if (props.borderColor) coreEl.style.borderColor = props.borderColor;
            else if (!props.borderColor) coreEl.style.borderColor = newColor;
            coreEl.style.backgroundColor = newColor;
            coreEl.children[0].style.color = newColor;
        };
        const focus = ()=>{
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.focus) == null || _b.call(_a);
        };
        _vue.onMounted(()=>{
            if (props.activeColor || props.inactiveColor || props.borderColor) setBackgroundColor();
            input.value.checked = checked.value;
        });
        return {
            ns,
            input,
            core,
            switchDisabled,
            checked,
            switchKls,
            handleChange,
            switchValue,
            focus
        };
    }
});
const _hoisted_1 = [
    "aria-checked",
    "aria-disabled"
];
const _hoisted_2 = [
    "id",
    "name",
    "true-value",
    "false-value",
    "disabled"
];
const _hoisted_3 = [
    "aria-hidden"
];
const _hoisted_4 = [
    "aria-hidden"
];
const _hoisted_5 = [
    "aria-hidden"
];
const _hoisted_6 = [
    "aria-hidden"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_loading = _vue.resolveComponent("loading");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.switchKls),
        role: "switch",
        "aria-checked": _ctx.checked,
        "aria-disabled": _ctx.switchDisabled,
        onClick: _cache[2] || (_cache[2] = _vue.withModifiers((...args)=>_ctx.switchValue && _ctx.switchValue(...args)
        , [
            "prevent"
        ]))
    }, [
        _vue.createElementVNode("input", {
            id: _ctx.id,
            ref: "input",
            class: _vue.normalizeClass(_ctx.ns.e("input")),
            type: "checkbox",
            name: _ctx.name,
            "true-value": _ctx.activeValue,
            "false-value": _ctx.inactiveValue,
            disabled: _ctx.switchDisabled,
            onChange: _cache[0] || (_cache[0] = (...args)=>_ctx.handleChange && _ctx.handleChange(...args)
            ),
            onKeydown: _cache[1] || (_cache[1] = _vue.withKeys((...args)=>_ctx.switchValue && _ctx.switchValue(...args)
            , [
                "enter"
            ]))
        }, null, 42, _hoisted_2),
        !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (_vue.openBlock(), _vue.createElementBlock("span", {
            key: 0,
            class: _vue.normalizeClass([
                _ctx.ns.e("label"),
                _ctx.ns.em("label", "left"),
                _ctx.ns.is("active", !_ctx.checked)
            ])
        }, [
            _ctx.inactiveIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                key: 0
            }, {
                default: _vue.withCtx(()=>[
                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.inactiveIcon)))
                    ]
                ),
                _: 1
            })) : _vue.createCommentVNode("v-if", true),
            !_ctx.inactiveIcon && _ctx.inactiveText ? (_vue.openBlock(), _vue.createElementBlock("span", {
                key: 1,
                "aria-hidden": _ctx.checked
            }, _vue.toDisplayString(_ctx.inactiveText), 9, _hoisted_3)) : _vue.createCommentVNode("v-if", true)
        ], 2)) : _vue.createCommentVNode("v-if", true),
        _vue.createElementVNode("span", {
            ref: "core",
            class: _vue.normalizeClass(_ctx.ns.e("core")),
            style: _vue.normalizeStyle({
                width: (_ctx.width || 40) + "px"
            })
        }, [
            _ctx.inlinePrompt ? (_vue.openBlock(), _vue.createElementBlock("div", {
                key: 0,
                class: _vue.normalizeClass(_ctx.ns.e("inner"))
            }, [
                _ctx.activeIcon || _ctx.inactiveIcon ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                    key: 0
                }, [
                    _ctx.activeIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 0,
                        class: _vue.normalizeClass([
                            _ctx.ns.is("icon"),
                            _ctx.checked ? _ctx.ns.is("show") : _ctx.ns.is("hide")
                        ])
                    }, {
                        default: _vue.withCtx(()=>[
                                (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.activeIcon)))
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "class"
                    ])) : _vue.createCommentVNode("v-if", true),
                    _ctx.inactiveIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 1,
                        class: _vue.normalizeClass([
                            _ctx.ns.is("icon"),
                            !_ctx.checked ? _ctx.ns.is("show") : _ctx.ns.is("hide")
                        ])
                    }, {
                        default: _vue.withCtx(()=>[
                                (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.inactiveIcon)))
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "class"
                    ])) : _vue.createCommentVNode("v-if", true)
                ], 64)) : _ctx.activeText || _ctx.inactiveIcon ? (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                    key: 1
                }, [
                    _ctx.activeText ? (_vue.openBlock(), _vue.createElementBlock("span", {
                        key: 0,
                        class: _vue.normalizeClass([
                            _ctx.ns.is("text"),
                            _ctx.checked ? _ctx.ns.is("show") : _ctx.ns.is("hide")
                        ]),
                        "aria-hidden": !_ctx.checked
                    }, _vue.toDisplayString(_ctx.activeText.substr(0, 1)), 11, _hoisted_4)) : _vue.createCommentVNode("v-if", true),
                    _ctx.inactiveText ? (_vue.openBlock(), _vue.createElementBlock("span", {
                        key: 1,
                        class: _vue.normalizeClass([
                            _ctx.ns.is("text"),
                            !_ctx.checked ? _ctx.ns.is("show") : _ctx.ns.is("hide")
                        ]),
                        "aria-hidden": _ctx.checked
                    }, _vue.toDisplayString(_ctx.inactiveText.substr(0, 1)), 11, _hoisted_5)) : _vue.createCommentVNode("v-if", true)
                ], 64)) : _vue.createCommentVNode("v-if", true)
            ], 2)) : _vue.createCommentVNode("v-if", true),
            _vue.createElementVNode("div", {
                class: _vue.normalizeClass(_ctx.ns.e("action"))
            }, [
                _ctx.loading ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                    key: 0,
                    class: _vue.normalizeClass(_ctx.ns.is("loading"))
                }, {
                    default: _vue.withCtx(()=>[
                            _vue.createVNode(_component_loading)
                        ]
                    ),
                    _: 1
                }, 8, [
                    "class"
                ])) : _vue.createCommentVNode("v-if", true)
            ], 2)
        ], 6),
        !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (_vue.openBlock(), _vue.createElementBlock("span", {
            key: 1,
            class: _vue.normalizeClass([
                _ctx.ns.e("label"),
                _ctx.ns.em("label", "right"),
                _ctx.ns.is("active", _ctx.checked)
            ])
        }, [
            _ctx.activeIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                key: 0
            }, {
                default: _vue.withCtx(()=>[
                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.activeIcon)))
                    ]
                ),
                _: 1
            })) : _vue.createCommentVNode("v-if", true),
            !_ctx.activeIcon && _ctx.activeText ? (_vue.openBlock(), _vue.createElementBlock("span", {
                key: 1,
                "aria-hidden": !_ctx.checked
            }, _vue.toDisplayString(_ctx.activeText), 9, _hoisted_6)) : _vue.createCommentVNode("v-if", true)
        ], 2)) : _vue.createCommentVNode("v-if", true)
    ], 10, _hoisted_1);
}
var Switch = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vue/shared":"3SM3y","../../../utils/index.mjs":"dsdeP","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../constants/index.mjs":"74Fbn","../../../hooks/index.mjs":"1Ansp","./switch.mjs":"77sPp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-form-item/index.mjs":"jSs21","../../../hooks/use-common-props/index.mjs":"05czU","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../constants/event.mjs":"92xVn","@vueuse/core":"eEHP9","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"77sPp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "switchEmits", ()=>switchEmits
);
parcelHelpers.export(exports, "switchProps", ()=>switchProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _validatorMjs = require("../../../utils/vue/validator.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _core = require("@vueuse/core");
var _shared = require("@vue/shared");
const switchProps = _propsMjs.buildProps({
    modelValue: {
        type: [
            Boolean,
            String,
            Number
        ],
        default: false
    },
    value: {
        type: [
            Boolean,
            String,
            Number
        ],
        default: false
    },
    disabled: {
        type: Boolean,
        default: false
    },
    width: {
        type: Number,
        default: 40
    },
    inlinePrompt: {
        type: Boolean,
        default: false
    },
    activeIcon: {
        type: _iconMjs.iconPropType,
        default: ""
    },
    inactiveIcon: {
        type: _iconMjs.iconPropType,
        default: ""
    },
    activeText: {
        type: String,
        default: ""
    },
    inactiveText: {
        type: String,
        default: ""
    },
    activeColor: {
        type: String,
        default: ""
    },
    inactiveColor: {
        type: String,
        default: ""
    },
    borderColor: {
        type: String,
        default: ""
    },
    activeValue: {
        type: [
            Boolean,
            String,
            Number
        ],
        default: true
    },
    inactiveValue: {
        type: [
            Boolean,
            String,
            Number
        ],
        default: false
    },
    name: {
        type: String,
        default: ""
    },
    validateEvent: {
        type: Boolean,
        default: true
    },
    id: String,
    loading: {
        type: Boolean,
        default: false
    },
    beforeChange: {
        type: _propsMjs.definePropType(Function)
    },
    size: {
        type: String,
        validator: _validatorMjs.isValidComponentSize
    }
});
const switchEmits = {
    [_eventMjs.UPDATE_MODEL_EVENT]: (val)=>_core.isBoolean(val) || _shared.isString(val) || _core.isNumber(val)
    ,
    [_eventMjs.CHANGE_EVENT]: (val)=>_core.isBoolean(val) || _shared.isString(val) || _core.isNumber(val)
    ,
    [_eventMjs.INPUT_EVENT]: (val)=>_core.isBoolean(val) || _shared.isString(val) || _core.isNumber(val)
};

},{"../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../../utils/vue/props.mjs":"cpwWK","../../../utils/vue/icon.mjs":"3YbE5","../../../utils/vue/validator.mjs":"4UnBa","../../../constants/event.mjs":"92xVn","@vueuse/core":"eEHP9","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"imp1h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElTable", ()=>ElTable
);
parcelHelpers.export(exports, "ElTableColumn", ()=>ElTableColumn
);
parcelHelpers.export(exports, "default", ()=>ElTable
);
var _indexMjs = require("../../utils/index.mjs");
var _tableMjs = require("./src/table.mjs");
var _tableMjsDefault = parcelHelpers.interopDefault(_tableMjs);
var _tableColumnMjs = require("./src/tableColumn.mjs");
var _installMjs = require("../../utils/vue/install.mjs");
var _indexMjs1 = require("./src/table-column/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
const ElTable = _installMjs.withInstall(_tableMjsDefault.default, {
    TableColumn: _indexMjsDefault.default
});
const ElTableColumn = _installMjs.withNoopInstall(_indexMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/table.mjs":"9cJLC","./src/tableColumn.mjs":"jsBSi","../../utils/vue/install.mjs":"4TMmv","./src/table-column/index.mjs":"bU6Xf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9cJLC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Table
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../directives/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _indexMjs2 = require("../../scrollbar/index.mjs");
var _helperMjs = require("./store/helper.mjs");
var _tableLayoutMjs = require("./table-layout.mjs");
var _tableLayoutMjsDefault = parcelHelpers.interopDefault(_tableLayoutMjs);
var _indexMjs3 = require("./table-header/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs3);
var _indexMjs4 = require("./table-body/index.mjs");
var _indexMjsDefault1 = parcelHelpers.interopDefault(_indexMjs4);
var _indexMjs5 = require("./table-footer/index.mjs");
var _indexMjsDefault2 = parcelHelpers.interopDefault(_indexMjs5);
var _utilsHelperMjs = require("./table/utils-helper.mjs");
var _utilsHelperMjsDefault = parcelHelpers.interopDefault(_utilsHelperMjs);
var _styleHelperMjs = require("./table/style-helper.mjs");
var _styleHelperMjsDefault = parcelHelpers.interopDefault(_styleHelperMjs);
var _defaultsMjs = require("./table/defaults.mjs");
var _defaultsMjsDefault = parcelHelpers.interopDefault(_defaultsMjs);
var _tokensMjs = require("./tokens.mjs");
var _hHelperMjs = require("./h-helper.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs6 = require("../../../directives/mousewheel/index.mjs");
var _indexMjsDefault3 = parcelHelpers.interopDefault(_indexMjs6);
var _indexMjs7 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs8 = require("../../../hooks/use-namespace/index.mjs");
let tableIdSeed = 1;
const _sfc_main = _vue.defineComponent({
    name: "ElTable",
    directives: {
        Mousewheel: _indexMjsDefault3.default
    },
    components: {
        TableHeader: _indexMjsDefault.default,
        TableBody: _indexMjsDefault1.default,
        TableFooter: _indexMjsDefault2.default,
        ElScrollbar: _indexMjs2.ElScrollbar,
        hColgroup: _hHelperMjs.hColgroup
    },
    props: _defaultsMjsDefault.default,
    emits: [
        "select",
        "select-all",
        "selection-change",
        "cell-mouse-enter",
        "cell-mouse-leave",
        "cell-contextmenu",
        "cell-click",
        "cell-dblclick",
        "row-click",
        "row-contextmenu",
        "row-dblclick",
        "header-click",
        "header-contextmenu",
        "sort-change",
        "filter-change",
        "current-change",
        "header-dragend",
        "expand-change"
    ],
    setup (props) {
        const { t  } = _indexMjs7.useLocale();
        const ns = _indexMjs8.useNamespace("table");
        const table = _vue.getCurrentInstance();
        _vue.provide(_tokensMjs.TABLE_INJECTION_KEY, table);
        const store = _helperMjs.createStore(table, props);
        table.store = store;
        const layout = new _tableLayoutMjsDefault.default({
            store: table.store,
            table,
            fit: props.fit,
            showHeader: props.showHeader
        });
        table.layout = layout;
        const isEmpty = _vue.computed(()=>(store.states.data.value || []).length === 0
        );
        const { setCurrentRow , toggleRowSelection , clearSelection , clearFilter , toggleAllSelection , toggleRowExpansion , clearSort , sort  } = _utilsHelperMjsDefault.default(store);
        const { isHidden , renderExpanded , setDragVisible , isGroup , handleMouseLeave , handleHeaderFooterMousewheel , tableSize , bodyHeight , height , emptyBlockStyle , handleFixedMousewheel , fixedHeight , fixedBodyHeight , resizeProxyVisible , bodyWidth , resizeState , doLayout , tableBodyStyles , tableLayout  } = _styleHelperMjsDefault.default(props, layout, store, table);
        const debouncedUpdateLayout = _lodashUnified.debounce(doLayout, 50);
        const tableId = `el-table_${tableIdSeed++}`;
        table.tableId = tableId;
        table.state = {
            isGroup,
            resizeState,
            doLayout,
            debouncedUpdateLayout
        };
        const computedSumText = _vue.computed(()=>props.sumText || t("el.table.sumText")
        );
        const computedEmptyText = _vue.computed(()=>{
            return props.emptyText || t("el.table.emptyText");
        });
        return {
            ns,
            layout,
            store,
            handleHeaderFooterMousewheel,
            handleMouseLeave,
            tableId,
            tableSize,
            isHidden,
            isEmpty,
            renderExpanded,
            resizeProxyVisible,
            resizeState,
            isGroup,
            bodyWidth,
            bodyHeight,
            height,
            tableBodyStyles,
            emptyBlockStyle,
            debouncedUpdateLayout,
            handleFixedMousewheel,
            fixedHeight,
            fixedBodyHeight,
            setCurrentRow,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            doLayout,
            sort,
            t,
            setDragVisible,
            context: table,
            computedSumText,
            computedEmptyText,
            tableLayout
        };
    }
});
const _hoisted_1 = [
    "data-prefix"
];
const _hoisted_2 = {
    ref: "hiddenColumns",
    class: "hidden-columns"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_hColgroup = _vue.resolveComponent("hColgroup");
    const _component_table_header = _vue.resolveComponent("table-header");
    const _component_table_body = _vue.resolveComponent("table-body");
    const _component_el_scrollbar = _vue.resolveComponent("el-scrollbar");
    const _component_table_footer = _vue.resolveComponent("table-footer");
    const _directive_mousewheel = _vue.resolveDirective("mousewheel");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "tableWrapper",
        class: _vue.normalizeClass([
            {
                [_ctx.ns.m("fit")]: _ctx.fit,
                [_ctx.ns.m("striped")]: _ctx.stripe,
                [_ctx.ns.m("border")]: _ctx.border || _ctx.isGroup,
                [_ctx.ns.m("hidden")]: _ctx.isHidden,
                [_ctx.ns.m("group")]: _ctx.isGroup,
                [_ctx.ns.m("fluid-height")]: _ctx.maxHeight,
                [_ctx.ns.m("scrollable-x")]: _ctx.layout.scrollX.value,
                [_ctx.ns.m("scrollable-y")]: _ctx.layout.scrollY.value,
                [_ctx.ns.m("enable-row-hover")]: !_ctx.store.states.isComplex.value,
                [_ctx.ns.m("enable-row-transition")]: (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100,
                "has-footer": _ctx.showSummary
            },
            _ctx.ns.m(_ctx.tableSize),
            _ctx.className,
            _ctx.ns.b(),
            _ctx.ns.m(`layout-${_ctx.tableLayout}`)
        ]),
        style: _vue.normalizeStyle(_ctx.style),
        "data-prefix": _ctx.ns.namespace.value,
        onMouseleave: _cache[0] || (_cache[0] = ($event)=>_ctx.handleMouseLeave()
        )
    }, [
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("inner-wrapper"))
        }, [
            _vue.createElementVNode("div", _hoisted_2, [
                _vue.renderSlot(_ctx.$slots, "default")
            ], 512),
            _ctx.showHeader && _ctx.tableLayout === "fixed" ? _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
                key: 0,
                ref: "headerWrapper",
                class: _vue.normalizeClass(_ctx.ns.e("header-wrapper"))
            }, [
                _vue.createElementVNode("table", {
                    ref: "tableHeader",
                    class: _vue.normalizeClass(_ctx.ns.e("header")),
                    style: _vue.normalizeStyle(_ctx.tableBodyStyles),
                    border: "0",
                    cellpadding: "0",
                    cellspacing: "0"
                }, [
                    _vue.createVNode(_component_hColgroup, {
                        columns: _ctx.store.states.columns.value,
                        "table-layout": _ctx.tableLayout
                    }, null, 8, [
                        "columns",
                        "table-layout"
                    ]),
                    _vue.createVNode(_component_table_header, {
                        border: _ctx.border,
                        "default-sort": _ctx.defaultSort,
                        store: _ctx.store,
                        onSetDragVisible: _ctx.setDragVisible
                    }, null, 8, [
                        "border",
                        "default-sort",
                        "store",
                        "onSetDragVisible"
                    ])
                ], 6)
            ], 2)), [
                [
                    _directive_mousewheel,
                    _ctx.handleHeaderFooterMousewheel
                ]
            ]) : _vue.createCommentVNode("v-if", true),
            _vue.createElementVNode("div", {
                ref: "bodyWrapper",
                style: _vue.normalizeStyle(_ctx.bodyHeight),
                class: _vue.normalizeClass(_ctx.ns.e("body-wrapper"))
            }, [
                _vue.createVNode(_component_el_scrollbar, {
                    ref: "scrollWrapper",
                    height: _ctx.maxHeight ? void 0 : _ctx.height,
                    "max-height": _ctx.maxHeight ? _ctx.height : void 0
                }, {
                    default: _vue.withCtx(()=>[
                            _vue.createElementVNode("table", {
                                ref: "tableBody",
                                class: _vue.normalizeClass(_ctx.ns.e("body")),
                                cellspacing: "0",
                                cellpadding: "0",
                                border: "0",
                                style: _vue.normalizeStyle({
                                    width: _ctx.bodyWidth,
                                    tableLayout: _ctx.tableLayout
                                })
                            }, [
                                _vue.createVNode(_component_hColgroup, {
                                    columns: _ctx.store.states.columns.value,
                                    "table-layout": _ctx.tableLayout
                                }, null, 8, [
                                    "columns",
                                    "table-layout"
                                ]),
                                _ctx.showHeader && _ctx.tableLayout === "auto" ? (_vue.openBlock(), _vue.createBlock(_component_table_header, {
                                    key: 0,
                                    border: _ctx.border,
                                    "default-sort": _ctx.defaultSort,
                                    store: _ctx.store,
                                    onSetDragVisible: _ctx.setDragVisible
                                }, null, 8, [
                                    "border",
                                    "default-sort",
                                    "store",
                                    "onSetDragVisible"
                                ])) : _vue.createCommentVNode("v-if", true),
                                _vue.createVNode(_component_table_body, {
                                    context: _ctx.context,
                                    highlight: _ctx.highlightCurrentRow,
                                    "row-class-name": _ctx.rowClassName,
                                    "tooltip-effect": _ctx.tooltipEffect,
                                    "row-style": _ctx.rowStyle,
                                    store: _ctx.store,
                                    stripe: _ctx.stripe
                                }, null, 8, [
                                    "context",
                                    "highlight",
                                    "row-class-name",
                                    "tooltip-effect",
                                    "row-style",
                                    "store",
                                    "stripe"
                                ])
                            ], 6),
                            _ctx.isEmpty ? (_vue.openBlock(), _vue.createElementBlock("div", {
                                key: 0,
                                ref: "emptyBlock",
                                style: _vue.normalizeStyle(_ctx.emptyBlockStyle),
                                class: _vue.normalizeClass(_ctx.ns.e("empty-block"))
                            }, [
                                _vue.createElementVNode("span", {
                                    class: _vue.normalizeClass(_ctx.ns.e("empty-text"))
                                }, [
                                    _vue.renderSlot(_ctx.$slots, "empty", {
                                    }, ()=>[
                                            _vue.createTextVNode(_vue.toDisplayString(_ctx.computedEmptyText), 1)
                                        ]
                                    )
                                ], 2)
                            ], 6)) : _vue.createCommentVNode("v-if", true),
                            _ctx.$slots.append ? (_vue.openBlock(), _vue.createElementBlock("div", {
                                key: 1,
                                ref: "appendWrapper",
                                class: _vue.normalizeClass(_ctx.ns.e("append-wrapper"))
                            }, [
                                _vue.renderSlot(_ctx.$slots, "append")
                            ], 2)) : _vue.createCommentVNode("v-if", true)
                        ]
                    ),
                    _: 3
                }, 8, [
                    "height",
                    "max-height"
                ])
            ], 6),
            _ctx.border || _ctx.isGroup ? (_vue.openBlock(), _vue.createElementBlock("div", {
                key: 1,
                class: _vue.normalizeClass(_ctx.ns.e("border-left-patch"))
            }, null, 2)) : _vue.createCommentVNode("v-if", true)
        ], 2),
        _ctx.showSummary ? _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
            key: 0,
            ref: "footerWrapper",
            class: _vue.normalizeClass(_ctx.ns.e("footer-wrapper"))
        }, [
            _vue.createVNode(_component_table_footer, {
                border: _ctx.border,
                "default-sort": _ctx.defaultSort,
                store: _ctx.store,
                style: _vue.normalizeStyle(_ctx.tableBodyStyles),
                "sum-text": _ctx.computedSumText,
                "summary-method": _ctx.summaryMethod
            }, null, 8, [
                "border",
                "default-sort",
                "store",
                "style",
                "sum-text",
                "summary-method"
            ])
        ], 2)), [
            [
                _vue.vShow,
                !_ctx.isEmpty
            ],
            [
                _directive_mousewheel,
                _ctx.handleHeaderFooterMousewheel
            ]
        ]) : _vue.createCommentVNode("v-if", true),
        _vue.withDirectives(_vue.createElementVNode("div", {
            ref: "resizeProxy",
            class: _vue.normalizeClass(_ctx.ns.e("column-resize-proxy"))
        }, null, 2), [
            [
                _vue.vShow,
                _ctx.resizeProxyVisible
            ]
        ])
    ], 46, _hoisted_1);
}
var Table = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","lodash-unified":"4Oj4p","../../../directives/index.mjs":"aRbJ2","../../../hooks/index.mjs":"1Ansp","../../scrollbar/index.mjs":"kXLHt","./store/helper.mjs":"43egj","./table-layout.mjs":"dzXVW","./table-header/index.mjs":"hHH1e","./table-body/index.mjs":"kn3SA","./table-footer/index.mjs":"2rpOC","./table/utils-helper.mjs":"hFYbt","./table/style-helper.mjs":"3o8Uq","./table/defaults.mjs":"7x6Fm","./tokens.mjs":"cGfBP","./h-helper.mjs":"33tBo","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../directives/mousewheel/index.mjs":"5NhJf","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"43egj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createStore", ()=>createStore
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("./index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
const InitialStateMap = {
    rowKey: "rowKey",
    defaultExpandAll: "defaultExpandAll",
    selectOnIndeterminate: "selectOnIndeterminate",
    indent: "indent",
    lazy: "lazy",
    data: "data",
    ["treeProps.hasChildren"]: {
        key: "lazyColumnIdentifier",
        default: "hasChildren"
    },
    ["treeProps.children"]: {
        key: "childrenColumnName",
        default: "children"
    }
};
function createStore(table, props) {
    if (!table) throw new Error("Table is required.");
    const store = _indexMjsDefault.default();
    store.toggleAllSelection = _lodashUnified.debounce(store._toggleAllSelection, 10);
    Object.keys(InitialStateMap).forEach((key)=>{
        handleValue(getArrKeysValue(props, key), key, store);
    });
    proxyTableProps(store, props);
    return store;
}
function proxyTableProps(store, props) {
    Object.keys(InitialStateMap).forEach((key)=>{
        _vue.watch(()=>getArrKeysValue(props, key)
        , (value)=>{
            handleValue(value, key, store);
        });
    });
}
function handleValue(value, propsKey, store) {
    let newVal = value;
    let storeKey = InitialStateMap[propsKey];
    if (typeof InitialStateMap[propsKey] === "object") {
        storeKey = storeKey.key;
        newVal = newVal || InitialStateMap[propsKey].default;
    }
    store.states[storeKey].value = newVal;
}
function getArrKeysValue(props, keys) {
    if (keys.includes(".")) {
        const keyList = keys.split(".");
        let value = props;
        keyList.forEach((key)=>{
            value = value[key];
        });
        return value;
    } else return props[keys];
}

},{"vue":"gzxs9","lodash-unified":"4Oj4p","./index.mjs":"Lg343","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Lg343":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useStore
);
var _vue = require("vue");
var _indexMjs = require("../../../../hooks/index.mjs");
var _watcherMjs = require("./watcher.mjs");
var _watcherMjsDefault = parcelHelpers.interopDefault(_watcherMjs);
var _indexMjs1 = require("../../../../hooks/use-namespace/index.mjs");
function replaceColumn(array, column) {
    return array.map((item)=>{
        var _a;
        if (item.id === column.id) return column;
        else if ((_a = item.children) == null ? void 0 : _a.length) item.children = replaceColumn(item.children, column);
        return item;
    });
}
function sortColumn(array) {
    array.forEach((item)=>{
        var _a, _b;
        item.no = (_a = item.getColumnIndex) == null ? void 0 : _a.call(item);
        if ((_b = item.children) == null ? void 0 : _b.length) sortColumn(item.children);
    });
    array.sort((cur, pre)=>cur.no - pre.no
    );
}
function useStore() {
    const instance = _vue.getCurrentInstance();
    const watcher = _watcherMjsDefault.default();
    const ns = _indexMjs1.useNamespace("table");
    const mutations = {
        setData (states, data) {
            const dataInstanceChanged = _vue.unref(states._data) !== data;
            states.data.value = data;
            states._data.value = data;
            instance.store.execQuery();
            instance.store.updateCurrentRowData();
            instance.store.updateExpandRows();
            instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
            if (_vue.unref(states.reserveSelection)) {
                instance.store.assertRowKey();
                instance.store.updateSelectionByRowKey();
            } else if (dataInstanceChanged) instance.store.clearSelection();
            else instance.store.cleanSelection();
            instance.store.updateAllSelected();
            if (instance.$ready) instance.store.scheduleLayout();
        },
        insertColumn (states, column, parent) {
            const array = _vue.unref(states._columns);
            let newColumns = [];
            if (!parent) {
                array.push(column);
                newColumns = array;
            } else {
                if (parent && !parent.children) parent.children = [];
                parent.children.push(column);
                newColumns = replaceColumn(array, parent);
            }
            sortColumn(newColumns);
            states._columns.value = newColumns;
            if (column.type === "selection") {
                states.selectable.value = column.selectable;
                states.reserveSelection.value = column.reserveSelection;
            }
            if (instance.$ready) {
                instance.store.updateColumns();
                instance.store.scheduleLayout();
            }
        },
        removeColumn (states, column, parent) {
            const array = _vue.unref(states._columns) || [];
            if (parent) {
                parent.children.splice(parent.children.findIndex((item)=>item.id === column.id
                ), 1);
                if (parent.children.length === 0) delete parent.children;
                states._columns.value = replaceColumn(array, parent);
            } else {
                const index = array.indexOf(column);
                if (index > -1) {
                    array.splice(index, 1);
                    states._columns.value = array;
                }
            }
            if (instance.$ready) {
                instance.store.updateColumns();
                instance.store.scheduleLayout();
            }
        },
        sort (states, options) {
            const { prop , order , init  } = options;
            if (prop) {
                const column = _vue.unref(states.columns).find((column2)=>column2.property === prop
                );
                if (column) {
                    column.order = order;
                    instance.store.updateSort(column, prop, order);
                    instance.store.commit("changeSortCondition", {
                        init
                    });
                }
            }
        },
        changeSortCondition (states, options) {
            const { sortingColumn: column , sortProp: prop , sortOrder: order  } = states;
            if (_vue.unref(order) === null) {
                states.sortingColumn.value = null;
                states.sortProp.value = null;
            }
            const ingore = {
                filter: true
            };
            instance.store.execQuery(ingore);
            if (!options || !(options.silent || options.init)) instance.emit("sort-change", {
                column: _vue.unref(column),
                prop: _vue.unref(prop),
                order: _vue.unref(order)
            });
            instance.store.updateTableScrollY();
        },
        filterChange (_states, options) {
            const { column , values , silent  } = options;
            const newFilters = instance.store.updateFilters(column, values);
            instance.store.execQuery();
            if (!silent) instance.emit("filter-change", newFilters);
            instance.store.updateTableScrollY();
        },
        toggleAllSelection () {
            instance.store.toggleAllSelection();
        },
        rowSelectedChanged (_states, row) {
            instance.store.toggleRowSelection(row);
            instance.store.updateAllSelected();
        },
        setHoverRow (states, row) {
            states.hoverRow.value = row;
        },
        setCurrentRow (_states, row) {
            instance.store.updateCurrentRow(row);
        }
    };
    const commit = function(name, ...args) {
        const mutations2 = instance.store.mutations;
        if (mutations2[name]) mutations2[name].apply(instance, [
            instance.store.states
        ].concat(args));
        else throw new Error(`Action not found: ${name}`);
    };
    const updateTableScrollY = function() {
        _vue.nextTick(()=>instance.layout.updateScrollY.apply(instance.layout)
        );
    };
    return {
        ns,
        ...watcher,
        mutations,
        commit,
        updateTableScrollY
    };
}
class HelperStore {
    constructor(){
        this.Return = useStore();
    }
}

},{"vue":"gzxs9","../../../../hooks/index.mjs":"1Ansp","./watcher.mjs":"lJD6X","../../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lJD6X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useWatcher
);
var _vue = require("vue");
var _indexMjs = require("../../../../utils/index.mjs");
var _utilMjs = require("../util.mjs");
var _expandMjs = require("./expand.mjs");
var _expandMjsDefault = parcelHelpers.interopDefault(_expandMjs);
var _currentMjs = require("./current.mjs");
var _currentMjsDefault = parcelHelpers.interopDefault(_currentMjs);
var _treeMjs = require("./tree.mjs");
var _treeMjsDefault = parcelHelpers.interopDefault(_treeMjs);
var _shared = require("@vue/shared");
const sortData = (data, states)=>{
    const sortingColumn = states.sortingColumn;
    if (!sortingColumn || typeof sortingColumn.sortable === "string") return data;
    return _utilMjs.orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
};
const doFlattenColumns = (columns)=>{
    const result = [];
    columns.forEach((column)=>{
        if (column.children) result.push.apply(result, doFlattenColumns(column.children));
        else result.push(column);
    });
    return result;
};
function useWatcher() {
    var _a;
    const instance = _vue.getCurrentInstance();
    const { size: tableSize  } = _vue.toRefs((_a = instance.proxy) == null ? void 0 : _a.$props);
    const rowKey = _vue.ref(null);
    const data = _vue.ref([]);
    const _data = _vue.ref([]);
    const isComplex = _vue.ref(false);
    const _columns = _vue.ref([]);
    const originColumns = _vue.ref([]);
    const columns = _vue.ref([]);
    const fixedColumns = _vue.ref([]);
    const rightFixedColumns = _vue.ref([]);
    const leafColumns = _vue.ref([]);
    const fixedLeafColumns = _vue.ref([]);
    const rightFixedLeafColumns = _vue.ref([]);
    const leafColumnsLength = _vue.ref(0);
    const fixedLeafColumnsLength = _vue.ref(0);
    const rightFixedLeafColumnsLength = _vue.ref(0);
    const isAllSelected = _vue.ref(false);
    const selection = _vue.ref([]);
    const reserveSelection = _vue.ref(false);
    const selectOnIndeterminate = _vue.ref(false);
    const selectable = _vue.ref(null);
    const filters = _vue.ref({
    });
    const filteredData = _vue.ref(null);
    const sortingColumn = _vue.ref(null);
    const sortProp = _vue.ref(null);
    const sortOrder = _vue.ref(null);
    const hoverRow = _vue.ref(null);
    _vue.watch(data, ()=>instance.state && scheduleLayout(false)
    , {
        deep: true
    });
    const assertRowKey = ()=>{
        if (!rowKey.value) throw new Error("[ElTable] prop row-key is required");
    };
    const updateColumns = ()=>{
        fixedColumns.value = _columns.value.filter((column)=>column.fixed === true || column.fixed === "left"
        );
        rightFixedColumns.value = _columns.value.filter((column)=>column.fixed === "right"
        );
        if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === "selection" && !_columns.value[0].fixed) {
            _columns.value[0].fixed = true;
            fixedColumns.value.unshift(_columns.value[0]);
        }
        const notFixedColumns = _columns.value.filter((column)=>!column.fixed
        );
        originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
        const leafColumns2 = doFlattenColumns(notFixedColumns);
        const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
        const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
        leafColumnsLength.value = leafColumns2.length;
        fixedLeafColumnsLength.value = fixedLeafColumns2.length;
        rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
        columns.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
        isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
    };
    const scheduleLayout = (needUpdateColumns, immediate = false)=>{
        if (needUpdateColumns) updateColumns();
        if (immediate) instance.state.doLayout();
        else instance.state.debouncedUpdateLayout();
    };
    const isSelected = (row)=>{
        return selection.value.indexOf(row) > -1;
    };
    const clearSelection = ()=>{
        isAllSelected.value = false;
        const oldSelection = selection.value;
        if (oldSelection.length) {
            selection.value = [];
            instance.emit("selection-change", []);
        }
    };
    const cleanSelection = ()=>{
        let deleted;
        if (rowKey.value) {
            deleted = [];
            const selectedMap = _utilMjs.getKeysMap(selection.value, rowKey.value);
            const dataMap = _utilMjs.getKeysMap(data.value, rowKey.value);
            for(const key in selectedMap)if (_shared.hasOwn(selectedMap, key) && !dataMap[key]) deleted.push(selectedMap[key].row);
        } else deleted = selection.value.filter((item)=>data.value.indexOf(item) === -1
        );
        if (deleted.length) {
            const newSelection = selection.value.filter((item)=>deleted.indexOf(item) === -1
            );
            selection.value = newSelection;
            instance.emit("selection-change", newSelection.slice());
        }
    };
    const toggleRowSelection = (row, selected, emitChange = true)=>{
        const changed = _utilMjs.toggleRowStatus(selection.value, row, selected);
        if (changed) {
            const newSelection = (selection.value || []).slice();
            if (emitChange) instance.emit("select", newSelection, row);
            instance.emit("selection-change", newSelection);
        }
    };
    const _toggleAllSelection = ()=>{
        var _a2, _b;
        const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
        isAllSelected.value = value;
        let selectionChanged = false;
        let childrenCount = 0;
        const rowKey2 = (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.rowKey.value;
        data.value.forEach((row, index)=>{
            const rowIndex = index + childrenCount;
            if (selectable.value) {
                if (selectable.value.call(null, row, rowIndex) && _utilMjs.toggleRowStatus(selection.value, row, value)) selectionChanged = true;
            } else if (_utilMjs.toggleRowStatus(selection.value, row, value)) selectionChanged = true;
            childrenCount += getChildrenCount(_utilMjs.getRowIdentity(row, rowKey2));
        });
        if (selectionChanged) instance.emit("selection-change", selection.value ? selection.value.slice() : []);
        instance.emit("select-all", selection.value);
    };
    const updateSelectionByRowKey = ()=>{
        const selectedMap = _utilMjs.getKeysMap(selection.value, rowKey.value);
        data.value.forEach((row)=>{
            const rowId = _utilMjs.getRowIdentity(row, rowKey.value);
            const rowInfo = selectedMap[rowId];
            if (rowInfo) selection.value[rowInfo.index] = row;
        });
    };
    const updateAllSelected = ()=>{
        var _a2, _b, _c;
        if (((_a2 = data.value) == null ? void 0 : _a2.length) === 0) {
            isAllSelected.value = false;
            return;
        }
        let selectedMap;
        if (rowKey.value) selectedMap = _utilMjs.getKeysMap(selection.value, rowKey.value);
        const isSelected2 = function(row) {
            if (selectedMap) return !!selectedMap[_utilMjs.getRowIdentity(row, rowKey.value)];
            else return selection.value.indexOf(row) !== -1;
        };
        let isAllSelected_ = true;
        let selectedCount = 0;
        let childrenCount = 0;
        for(let i = 0, j = (data.value || []).length; i < j; i++){
            const keyProp = (_c = (_b = instance == null ? void 0 : instance.store) == null ? void 0 : _b.states) == null ? void 0 : _c.rowKey.value;
            const rowIndex = i + childrenCount;
            const item = data.value[i];
            const isRowSelectable = selectable.value && selectable.value.call(null, item, rowIndex);
            if (!isSelected2(item)) {
                if (!selectable.value || isRowSelectable) {
                    isAllSelected_ = false;
                    break;
                }
            } else selectedCount++;
            childrenCount += getChildrenCount(_utilMjs.getRowIdentity(item, keyProp));
        }
        if (selectedCount === 0) isAllSelected_ = false;
        isAllSelected.value = isAllSelected_;
    };
    const getChildrenCount = (rowKey2)=>{
        var _a2;
        if (!instance || !instance.store) return 0;
        const { treeData  } = instance.store.states;
        let count = 0;
        const children = (_a2 = treeData.value[rowKey2]) == null ? void 0 : _a2.children;
        if (children) {
            count += children.length;
            children.forEach((childKey)=>{
                count += getChildrenCount(childKey);
            });
        }
        return count;
    };
    const updateFilters = (columns2, values)=>{
        if (!Array.isArray(columns2)) columns2 = [
            columns2
        ];
        const filters_ = {
        };
        columns2.forEach((col)=>{
            filters.value[col.id] = values;
            filters_[col.columnKey || col.id] = values;
        });
        return filters_;
    };
    const updateSort = (column, prop, order)=>{
        if (sortingColumn.value && sortingColumn.value !== column) sortingColumn.value.order = null;
        sortingColumn.value = column;
        sortProp.value = prop;
        sortOrder.value = order;
    };
    const execFilter = ()=>{
        let sourceData = _vue.unref(_data);
        Object.keys(filters.value).forEach((columnId)=>{
            const values = filters.value[columnId];
            if (!values || values.length === 0) return;
            const column = _utilMjs.getColumnById({
                columns: columns.value
            }, columnId);
            if (column && column.filterMethod) sourceData = sourceData.filter((row)=>{
                return values.some((value)=>column.filterMethod.call(null, value, row, column)
                );
            });
        });
        filteredData.value = sourceData;
    };
    const execSort = ()=>{
        data.value = sortData(filteredData.value, {
            sortingColumn: sortingColumn.value,
            sortProp: sortProp.value,
            sortOrder: sortOrder.value
        });
    };
    const execQuery = (ignore)=>{
        if (!(ignore && ignore.filter)) execFilter();
        execSort();
    };
    const clearFilter = (columnKeys)=>{
        const { tableHeader , fixedTableHeader , rightFixedTableHeader  } = instance.refs;
        let panels = {
        };
        if (tableHeader) panels = Object.assign(panels, tableHeader.filterPanels);
        if (fixedTableHeader) panels = Object.assign(panels, fixedTableHeader.filterPanels);
        if (rightFixedTableHeader) panels = Object.assign(panels, rightFixedTableHeader.filterPanels);
        const keys = Object.keys(panels);
        if (!keys.length) return;
        if (typeof columnKeys === "string") columnKeys = [
            columnKeys
        ];
        if (Array.isArray(columnKeys)) {
            const columns_ = columnKeys.map((key)=>_utilMjs.getColumnByKey({
                    columns: columns.value
                }, key)
            );
            keys.forEach((key)=>{
                const column = columns_.find((col)=>col.id === key
                );
                if (column) column.filteredValue = [];
            });
            instance.store.commit("filterChange", {
                column: columns_,
                values: [],
                silent: true,
                multi: true
            });
        } else {
            keys.forEach((key)=>{
                const column = columns.value.find((col)=>col.id === key
                );
                if (column) column.filteredValue = [];
            });
            filters.value = {
            };
            instance.store.commit("filterChange", {
                column: {
                },
                values: [],
                silent: true
            });
        }
    };
    const clearSort = ()=>{
        if (!sortingColumn.value) return;
        updateSort(null, null, null);
        instance.store.commit("changeSortCondition", {
            silent: true
        });
    };
    const { setExpandRowKeys , toggleRowExpansion , updateExpandRows , states: expandStates , isRowExpanded  } = _expandMjsDefault.default({
        data,
        rowKey
    });
    const { updateTreeExpandKeys , toggleTreeExpansion , updateTreeData , loadOrToggle , states: treeStates  } = _treeMjsDefault.default({
        data,
        rowKey
    });
    const { updateCurrentRowData , updateCurrentRow , setCurrentRowKey , states: currentData  } = _currentMjsDefault.default({
        data,
        rowKey
    });
    const setExpandRowKeysAdapter = (val)=>{
        setExpandRowKeys(val);
        updateTreeExpandKeys(val);
    };
    const toggleRowExpansionAdapter = (row, expanded)=>{
        const hasExpandColumn = columns.value.some(({ type  })=>type === "expand"
        );
        if (hasExpandColumn) toggleRowExpansion(row, expanded);
        else toggleTreeExpansion(row, expanded);
    };
    return {
        assertRowKey,
        updateColumns,
        scheduleLayout,
        isSelected,
        clearSelection,
        cleanSelection,
        toggleRowSelection,
        _toggleAllSelection,
        toggleAllSelection: null,
        updateSelectionByRowKey,
        updateAllSelected,
        updateFilters,
        updateCurrentRow,
        updateSort,
        execFilter,
        execSort,
        execQuery,
        clearFilter,
        clearSort,
        toggleRowExpansion,
        setExpandRowKeysAdapter,
        setCurrentRowKey,
        toggleRowExpansionAdapter,
        isRowExpanded,
        updateExpandRows,
        updateCurrentRowData,
        loadOrToggle,
        updateTreeData,
        states: {
            tableSize,
            rowKey,
            data,
            _data,
            isComplex,
            _columns,
            originColumns,
            columns,
            fixedColumns,
            rightFixedColumns,
            leafColumns,
            fixedLeafColumns,
            rightFixedLeafColumns,
            leafColumnsLength,
            fixedLeafColumnsLength,
            rightFixedLeafColumnsLength,
            isAllSelected,
            selection,
            reserveSelection,
            selectOnIndeterminate,
            selectable,
            filters,
            filteredData,
            sortingColumn,
            sortProp,
            sortOrder,
            hoverRow,
            ...expandStates,
            ...treeStates,
            ...currentData
        }
    };
}

},{"vue":"gzxs9","../../../../utils/index.mjs":"dsdeP","../util.mjs":"isd9T","./expand.mjs":"bAsSn","./current.mjs":"7QmmK","./tree.mjs":"dYlut","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"isd9T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compose", ()=>compose
);
parcelHelpers.export(exports, "createTablePopper", ()=>createTablePopper
);
parcelHelpers.export(exports, "ensurePosition", ()=>ensurePosition
);
parcelHelpers.export(exports, "getCell", ()=>getCell
);
parcelHelpers.export(exports, "getColumnByCell", ()=>getColumnByCell
);
parcelHelpers.export(exports, "getColumnById", ()=>getColumnById
);
parcelHelpers.export(exports, "getColumnByKey", ()=>getColumnByKey
);
parcelHelpers.export(exports, "getFixedColumnOffset", ()=>getFixedColumnOffset
);
parcelHelpers.export(exports, "getFixedColumnsClass", ()=>getFixedColumnsClass
);
parcelHelpers.export(exports, "getKeysMap", ()=>getKeysMap
);
parcelHelpers.export(exports, "getRowIdentity", ()=>getRowIdentity
);
parcelHelpers.export(exports, "isFixedColumn", ()=>isFixedColumn
);
parcelHelpers.export(exports, "mergeOptions", ()=>mergeOptions
);
parcelHelpers.export(exports, "orderBy", ()=>orderBy
);
parcelHelpers.export(exports, "parseHeight", ()=>parseHeight
);
parcelHelpers.export(exports, "parseMinWidth", ()=>parseMinWidth
);
parcelHelpers.export(exports, "parseWidth", ()=>parseWidth
);
parcelHelpers.export(exports, "removePopper", ()=>removePopper
);
parcelHelpers.export(exports, "toggleRowStatus", ()=>toggleRowStatus
);
parcelHelpers.export(exports, "walkTreeNode", ()=>walkTreeNode
);
var _core = require("@popperjs/core");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _shared = require("@vue/shared");
var _indexMjs2 = require("../../../hooks/use-z-index/index.mjs");
var _eventMjs = require("../../../utils/dom/event.mjs");
const getCell = function(event) {
    let cell = event.target;
    while(cell && cell.tagName.toUpperCase() !== "HTML"){
        if (cell.tagName.toUpperCase() === "TD") return cell;
        cell = cell.parentNode;
    }
    return null;
};
const isObject = function(obj) {
    return obj !== null && typeof obj === "object";
};
const orderBy = function(array, sortKey, reverse, sortMethod, sortBy) {
    if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) return array;
    if (typeof reverse === "string") reverse = reverse === "descending" ? -1 : 1;
    else reverse = reverse && reverse < 0 ? -1 : 1;
    const getKey = sortMethod ? null : function(value, index) {
        if (sortBy) {
            if (!Array.isArray(sortBy)) sortBy = [
                sortBy
            ];
            return sortBy.map(function(by) {
                if (typeof by === "string") return _lodashUnified.get(value, by);
                else return by(value, index, array);
            });
        }
        if (sortKey !== "$key") {
            if (isObject(value) && "$value" in value) value = value.$value;
        }
        return [
            isObject(value) ? _lodashUnified.get(value, sortKey) : value
        ];
    };
    const compare = function(a, b) {
        if (sortMethod) return sortMethod(a.value, b.value);
        for(let i = 0, len = a.key.length; i < len; i++){
            if (a.key[i] < b.key[i]) return -1;
            if (a.key[i] > b.key[i]) return 1;
        }
        return 0;
    };
    return array.map(function(value, index) {
        return {
            value,
            index,
            key: getKey ? getKey(value, index) : null
        };
    }).sort(function(a, b) {
        let order = compare(a, b);
        if (!order) order = a.index - b.index;
        return order * +reverse;
    }).map((item)=>item.value
    );
};
const getColumnById = function(table, columnId) {
    let column = null;
    table.columns.forEach(function(item) {
        if (item.id === columnId) column = item;
    });
    return column;
};
const getColumnByKey = function(table, columnKey) {
    let column = null;
    for(let i = 0; i < table.columns.length; i++){
        const item = table.columns[i];
        if (item.columnKey === columnKey) {
            column = item;
            break;
        }
    }
    return column;
};
const getColumnByCell = function(table, cell, namespace) {
    const matches = (cell.className || "").match(new RegExp(`${namespace}-table_[^\\s]+`, "gm"));
    if (matches) return getColumnById(table, matches[0]);
    return null;
};
const getRowIdentity = (row, rowKey)=>{
    if (!row) throw new Error("Row is required when get row identity");
    if (typeof rowKey === "string") {
        if (rowKey.indexOf(".") < 0) return `${row[rowKey]}`;
        const key = rowKey.split(".");
        let current = row;
        for(let i = 0; i < key.length; i++)current = current[key[i]];
        return `${current}`;
    } else if (typeof rowKey === "function") return rowKey.call(null, row);
};
const getKeysMap = function(array, rowKey) {
    const arrayMap = {
    };
    (array || []).forEach((row, index)=>{
        arrayMap[getRowIdentity(row, rowKey)] = {
            row,
            index
        };
    });
    return arrayMap;
};
function mergeOptions(defaults, config) {
    const options = {
    };
    let key;
    for(key in defaults)options[key] = defaults[key];
    for(key in config)if (_shared.hasOwn(config, key)) {
        const value = config[key];
        if (typeof value !== "undefined") options[key] = value;
    }
    return options;
}
function parseWidth(width) {
    if (width === "") return width;
    if (width !== void 0) {
        width = parseInt(width, 10);
        if (Number.isNaN(width)) width = "";
    }
    return width;
}
function parseMinWidth(minWidth) {
    if (minWidth === "") return minWidth;
    if (minWidth !== void 0) {
        minWidth = parseWidth(minWidth);
        if (Number.isNaN(minWidth)) minWidth = 80;
    }
    return minWidth;
}
function parseHeight(height) {
    if (typeof height === "number") return height;
    if (typeof height === "string") {
        if (/^\d+(?:px)?$/.test(height)) return parseInt(height, 10);
        else return height;
    }
    return null;
}
function compose(...funcs) {
    if (funcs.length === 0) return (arg)=>arg
    ;
    if (funcs.length === 1) return funcs[0];
    return funcs.reduce((a, b)=>(...args)=>a(b(...args))
    );
}
function toggleRowStatus(statusArr, row, newVal) {
    let changed = false;
    const index = statusArr.indexOf(row);
    const included = index !== -1;
    const addRow = ()=>{
        statusArr.push(row);
        changed = true;
    };
    const removeRow = ()=>{
        statusArr.splice(index, 1);
        changed = true;
    };
    if (typeof newVal === "boolean") {
        if (newVal && !included) addRow();
        else if (!newVal && included) removeRow();
    } else if (included) removeRow();
    else addRow();
    return changed;
}
function walkTreeNode(root, cb, childrenKey = "children", lazyKey = "hasChildren") {
    const isNil = (array)=>!(Array.isArray(array) && array.length)
    ;
    function _walker(parent, children, level) {
        cb(parent, children, level);
        children.forEach((item)=>{
            if (item[lazyKey]) {
                cb(item, null, level + 1);
                return;
            }
            const children2 = item[childrenKey];
            if (!isNil(children2)) _walker(item, children2, level + 1);
        });
    }
    root.forEach((item)=>{
        if (item[lazyKey]) {
            cb(item, null, 0);
            return;
        }
        const children = item[childrenKey];
        if (!isNil(children)) _walker(item, children, 0);
    });
}
let removePopper;
function createTablePopper(trigger, popperContent, popperOptions, tooltipEffect) {
    const { nextZIndex  } = _indexMjs2.useZIndex();
    function renderContent() {
        const isLight = tooltipEffect === "light";
        const content2 = document.createElement("div");
        content2.className = `el-popper ${isLight ? "is-light" : "is-dark"}`;
        content2.innerHTML = popperContent;
        content2.style.zIndex = String(nextZIndex());
        document.body.appendChild(content2);
        return content2;
    }
    function renderArrow() {
        const arrow2 = document.createElement("div");
        arrow2.className = "el-popper__arrow";
        return arrow2;
    }
    function showPopper() {
        popperInstance && popperInstance.update();
    }
    removePopper = function removePopper2() {
        try {
            popperInstance && popperInstance.destroy();
            content && document.body.removeChild(content);
            _eventMjs.off(trigger, "mouseenter", showPopper);
            _eventMjs.off(trigger, "mouseleave", removePopper2);
        } catch (e) {
        }
    };
    let popperInstance = null;
    const content = renderContent();
    const arrow = renderArrow();
    content.appendChild(arrow);
    popperInstance = _core.createPopper(trigger, content, {
        modifiers: [
            {
                name: "offset",
                options: {
                    offset: [
                        0,
                        8
                    ]
                }
            },
            {
                name: "arrow",
                options: {
                    element: arrow,
                    padding: 10
                }
            }
        ],
        ...popperOptions
    });
    _eventMjs.on(trigger, "mouseenter", showPopper);
    _eventMjs.on(trigger, "mouseleave", removePopper);
    return popperInstance;
}
const isFixedColumn = (index, fixed, store, realColumns)=>{
    let start = 0;
    let after = index;
    if (realColumns) {
        if (realColumns[index].colSpan > 1) return {
        };
        for(let i = 0; i < index; i++)start += realColumns[i].colSpan;
        after = start + realColumns[index].colSpan - 1;
    } else start = index;
    let fixedLayout;
    const columns = store.states.columns;
    switch(fixed){
        case "left":
            if (after < store.states.fixedLeafColumnsLength.value) fixedLayout = "left";
            break;
        case "right":
            if (start >= columns.value.length - store.states.rightFixedLeafColumnsLength.value) fixedLayout = "right";
            break;
        default:
            if (after < store.states.fixedLeafColumnsLength.value) fixedLayout = "left";
            else if (start >= columns.value.length - store.states.rightFixedLeafColumnsLength.value) fixedLayout = "right";
    }
    return fixedLayout ? {
        direction: fixedLayout,
        start,
        after
    } : {
    };
};
const getFixedColumnsClass = (namespace, index, fixed, store, realColumns)=>{
    const classes = [];
    const { direction , start  } = isFixedColumn(index, fixed, store, realColumns);
    if (direction) {
        const isLeft = direction === "left";
        classes.push(`${namespace}-fixed-column--${direction}`);
        if (isLeft && start === store.states.fixedLeafColumnsLength.value - 1) classes.push("is-last-column");
        else if (!isLeft && start === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) classes.push("is-first-column");
    }
    return classes;
};
function getOffset(offset, column) {
    return offset + (column.realWidth === null || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);
}
const getFixedColumnOffset = (index, fixed, store, realColumns)=>{
    const { direction , start =0  } = isFixedColumn(index, fixed, store, realColumns);
    if (!direction) return;
    const styles = {
    };
    const isLeft = direction === "left";
    const columns = store.states.columns.value;
    if (isLeft) styles.left = columns.slice(0, index).reduce(getOffset, 0);
    else styles.right = columns.slice(start + 1).reverse().reduce(getOffset, 0);
    return styles;
};
const ensurePosition = (style, key)=>{
    if (!style) return;
    if (!Number.isNaN(style[key])) style[key] = `${style[key]}px`;
};

},{"@popperjs/core":"7unqC","lodash-unified":"4Oj4p","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","@vue/shared":"3SM3y","../../../hooks/use-z-index/index.mjs":"7aKZA","../../../utils/dom/event.mjs":"fnXSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bAsSn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useExpand
);
var _vue = require("vue");
var _utilMjs = require("../util.mjs");
function useExpand(watcherData) {
    const instance = _vue.getCurrentInstance();
    const defaultExpandAll = _vue.ref(false);
    const expandRows = _vue.ref([]);
    const updateExpandRows = ()=>{
        const data = watcherData.data.value || [];
        const rowKey = watcherData.rowKey.value;
        if (defaultExpandAll.value) expandRows.value = data.slice();
        else if (rowKey) {
            const expandRowsMap = _utilMjs.getKeysMap(expandRows.value, rowKey);
            expandRows.value = data.reduce((prev, row)=>{
                const rowId = _utilMjs.getRowIdentity(row, rowKey);
                const rowInfo = expandRowsMap[rowId];
                if (rowInfo) prev.push(row);
                return prev;
            }, []);
        } else expandRows.value = [];
    };
    const toggleRowExpansion = (row, expanded)=>{
        const changed = _utilMjs.toggleRowStatus(expandRows.value, row, expanded);
        if (changed) {
            instance.emit("expand-change", row, expandRows.value.slice());
            instance.store.scheduleLayout();
        }
    };
    const setExpandRowKeys = (rowKeys)=>{
        instance.store.assertRowKey();
        const data = watcherData.data.value || [];
        const rowKey = watcherData.rowKey.value;
        const keysMap = _utilMjs.getKeysMap(data, rowKey);
        expandRows.value = rowKeys.reduce((prev, cur)=>{
            const info = keysMap[cur];
            if (info) prev.push(info.row);
            return prev;
        }, []);
    };
    const isRowExpanded = (row)=>{
        const rowKey = watcherData.rowKey.value;
        if (rowKey) {
            const expandMap = _utilMjs.getKeysMap(expandRows.value, rowKey);
            return !!expandMap[_utilMjs.getRowIdentity(row, rowKey)];
        }
        return expandRows.value.indexOf(row) !== -1;
    };
    return {
        updateExpandRows,
        toggleRowExpansion,
        setExpandRowKeys,
        isRowExpanded,
        states: {
            expandRows,
            defaultExpandAll
        }
    };
}

},{"vue":"gzxs9","../util.mjs":"isd9T","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7QmmK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useCurrent
);
var _vue = require("vue");
var _utilMjs = require("../util.mjs");
function useCurrent(watcherData) {
    const instance = _vue.getCurrentInstance();
    const _currentRowKey = _vue.ref(null);
    const currentRow = _vue.ref(null);
    const setCurrentRowKey = (key)=>{
        instance.store.assertRowKey();
        _currentRowKey.value = key;
        setCurrentRowByKey(key);
    };
    const restoreCurrentRowKey = ()=>{
        _currentRowKey.value = null;
    };
    const setCurrentRowByKey = (key)=>{
        const { data , rowKey  } = watcherData;
        let _currentRow = null;
        if (rowKey.value) _currentRow = (_vue.unref(data) || []).find((item)=>_utilMjs.getRowIdentity(item, rowKey.value) === key
        );
        currentRow.value = _currentRow;
    };
    const updateCurrentRow = (_currentRow)=>{
        const oldCurrentRow = currentRow.value;
        if (_currentRow && _currentRow !== oldCurrentRow) {
            currentRow.value = _currentRow;
            instance.emit("current-change", currentRow.value, oldCurrentRow);
            return;
        }
        if (!_currentRow && oldCurrentRow) {
            currentRow.value = null;
            instance.emit("current-change", null, oldCurrentRow);
        }
    };
    const updateCurrentRowData = ()=>{
        const rowKey = watcherData.rowKey.value;
        const data = watcherData.data.value || [];
        const oldCurrentRow = currentRow.value;
        if (data.indexOf(oldCurrentRow) === -1 && oldCurrentRow) {
            if (rowKey) {
                const currentRowKey = _utilMjs.getRowIdentity(oldCurrentRow, rowKey);
                setCurrentRowByKey(currentRowKey);
            } else currentRow.value = null;
            if (currentRow.value === null) instance.emit("current-change", null, oldCurrentRow);
        } else if (_currentRowKey.value) {
            setCurrentRowByKey(_currentRowKey.value);
            restoreCurrentRowKey();
        }
    };
    return {
        setCurrentRowKey,
        restoreCurrentRowKey,
        setCurrentRowByKey,
        updateCurrentRow,
        updateCurrentRowData,
        states: {
            _currentRowKey,
            currentRow
        }
    };
}

},{"vue":"gzxs9","../util.mjs":"isd9T","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dYlut":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useTree
);
var _vue = require("vue");
var _utilMjs = require("../util.mjs");
function useTree(watcherData) {
    const expandRowKeys = _vue.ref([]);
    const treeData = _vue.ref({
    });
    const indent = _vue.ref(16);
    const lazy = _vue.ref(false);
    const lazyTreeNodeMap = _vue.ref({
    });
    const lazyColumnIdentifier = _vue.ref("hasChildren");
    const childrenColumnName = _vue.ref("children");
    const instance = _vue.getCurrentInstance();
    const normalizedData = _vue.computed(()=>{
        if (!watcherData.rowKey.value) return {
        };
        const data = watcherData.data.value || [];
        return normalize(data);
    });
    const normalizedLazyNode = _vue.computed(()=>{
        const rowKey = watcherData.rowKey.value;
        const keys = Object.keys(lazyTreeNodeMap.value);
        const res = {
        };
        if (!keys.length) return res;
        keys.forEach((key)=>{
            if (lazyTreeNodeMap.value[key].length) {
                const item = {
                    children: []
                };
                lazyTreeNodeMap.value[key].forEach((row)=>{
                    const currentRowKey = _utilMjs.getRowIdentity(row, rowKey);
                    item.children.push(currentRowKey);
                    if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) res[currentRowKey] = {
                        children: []
                    };
                });
                res[key] = item;
            }
        });
        return res;
    });
    const normalize = (data)=>{
        const rowKey = watcherData.rowKey.value;
        const res = {
        };
        _utilMjs.walkTreeNode(data, (parent, children, level)=>{
            const parentId = _utilMjs.getRowIdentity(parent, rowKey);
            if (Array.isArray(children)) res[parentId] = {
                children: children.map((row)=>_utilMjs.getRowIdentity(row, rowKey)
                ),
                level
            };
            else if (lazy.value) res[parentId] = {
                children: [],
                lazy: true,
                level
            };
        }, childrenColumnName.value, lazyColumnIdentifier.value);
        return res;
    };
    const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = ((_a)=>(_a = instance.store) == null ? void 0 : _a.states.defaultExpandAll.value
    )())=>{
        var _a2;
        const nested = normalizedData.value;
        const normalizedLazyNode_ = normalizedLazyNode.value;
        const keys = Object.keys(nested);
        const newTreeData = {
        };
        if (keys.length) {
            const oldTreeData = _vue.unref(treeData);
            const rootLazyRowKeys = [];
            const getExpanded = (oldValue, key)=>{
                if (ifChangeExpandRowKeys) {
                    if (expandRowKeys.value) return ifExpandAll || expandRowKeys.value.includes(key);
                    else return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
                } else {
                    const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);
                    return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
                }
            };
            keys.forEach((key)=>{
                const oldValue = oldTreeData[key];
                const newValue = {
                    ...nested[key]
                };
                newValue.expanded = getExpanded(oldValue, key);
                if (newValue.lazy) {
                    const { loaded =false , loading =false  } = oldValue || {
                    };
                    newValue.loaded = !!loaded;
                    newValue.loading = !!loading;
                    rootLazyRowKeys.push(key);
                }
                newTreeData[key] = newValue;
            });
            const lazyKeys = Object.keys(normalizedLazyNode_);
            if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) lazyKeys.forEach((key)=>{
                const oldValue = oldTreeData[key];
                const lazyNodeChildren = normalizedLazyNode_[key].children;
                if (rootLazyRowKeys.indexOf(key) !== -1) {
                    if (newTreeData[key].children.length !== 0) throw new Error("[ElTable]children must be an empty array.");
                    newTreeData[key].children = lazyNodeChildren;
                } else {
                    const { loaded =false , loading =false  } = oldValue || {
                    };
                    newTreeData[key] = {
                        lazy: true,
                        loaded: !!loaded,
                        loading: !!loading,
                        expanded: getExpanded(oldValue, key),
                        children: lazyNodeChildren,
                        level: ""
                    };
                }
            });
        }
        treeData.value = newTreeData;
        (_a2 = instance.store) == null || _a2.updateTableScrollY();
    };
    _vue.watch(()=>expandRowKeys.value
    , ()=>{
        updateTreeData(true);
    });
    _vue.watch(()=>normalizedData.value
    , ()=>{
        updateTreeData();
    });
    _vue.watch(()=>normalizedLazyNode.value
    , ()=>{
        updateTreeData();
    });
    const updateTreeExpandKeys = (value)=>{
        expandRowKeys.value = value;
        updateTreeData();
    };
    const toggleTreeExpansion = (row, expanded)=>{
        instance.store.assertRowKey();
        const rowKey = watcherData.rowKey.value;
        const id = _utilMjs.getRowIdentity(row, rowKey);
        const data = id && treeData.value[id];
        if (id && data && "expanded" in data) {
            const oldExpanded = data.expanded;
            expanded = typeof expanded === "undefined" ? !data.expanded : expanded;
            treeData.value[id].expanded = expanded;
            if (oldExpanded !== expanded) instance.emit("expand-change", row, expanded);
            instance.store.updateTableScrollY();
        }
    };
    const loadOrToggle = (row)=>{
        instance.store.assertRowKey();
        const rowKey = watcherData.rowKey.value;
        const id = _utilMjs.getRowIdentity(row, rowKey);
        const data = treeData.value[id];
        if (lazy.value && data && "loaded" in data && !data.loaded) loadData(row, id, data);
        else toggleTreeExpansion(row, void 0);
    };
    const loadData = (row, key, treeNode)=>{
        const { load  } = instance.props;
        if (load && !treeData.value[key].loaded) {
            treeData.value[key].loading = true;
            load(row, treeNode, (data)=>{
                if (!Array.isArray(data)) throw new Error("[ElTable] data must be an array");
                treeData.value[key].loading = false;
                treeData.value[key].loaded = true;
                treeData.value[key].expanded = true;
                if (data.length) lazyTreeNodeMap.value[key] = data;
                instance.emit("expand-change", row, true);
            });
        }
    };
    return {
        loadData,
        loadOrToggle,
        toggleTreeExpansion,
        updateTreeExpandKeys,
        updateTreeData,
        normalize,
        states: {
            expandRowKeys,
            treeData,
            indent,
            lazy,
            lazyTreeNodeMap,
            lazyColumnIdentifier,
            childrenColumnName
        }
    };
}

},{"vue":"gzxs9","../util.mjs":"isd9T","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dzXVW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TableLayout
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../utils/index.mjs");
var _utilMjs = require("./util.mjs");
var _shared = require("@vue/shared");
class TableLayout {
    constructor(options){
        this.observers = [];
        this.table = null;
        this.store = null;
        this.columns = [];
        this.fit = true;
        this.showHeader = true;
        this.height = _vue.ref(null);
        this.scrollX = _vue.ref(false);
        this.scrollY = _vue.ref(false);
        this.bodyWidth = _vue.ref(null);
        this.fixedWidth = _vue.ref(null);
        this.rightFixedWidth = _vue.ref(null);
        this.tableHeight = _vue.ref(null);
        this.headerHeight = _vue.ref(44);
        this.appendHeight = _vue.ref(0);
        this.footerHeight = _vue.ref(44);
        this.viewportHeight = _vue.ref(null);
        this.bodyHeight = _vue.ref(null);
        this.bodyScrollHeight = _vue.ref(0);
        this.fixedBodyHeight = _vue.ref(null);
        this.gutterWidth = 0;
        for(const name in options)if (_shared.hasOwn(options, name)) {
            if (_vue.isRef(this[name])) this[name].value = options[name];
            else this[name] = options[name];
        }
        if (!this.table) throw new Error("Table is required for Table Layout");
        if (!this.store) throw new Error("Store is required for Table Layout");
    }
    updateScrollY() {
        const height = this.height.value;
        if (height === null) return false;
        const bodyWrapper = this.table.refs.bodyWrapper;
        if (this.table.vnode.el && bodyWrapper) {
            let scrollY = true;
            const prevScrollY = this.scrollY.value;
            if (this.bodyHeight.value === null) scrollY = false;
            else scrollY = bodyWrapper.scrollHeight > this.bodyHeight.value;
            this.scrollY.value = scrollY;
            return prevScrollY !== scrollY;
        }
        return false;
    }
    setHeight(value, prop = "height") {
        if (!_core.isClient) return;
        const el = this.table.vnode.el;
        value = _utilMjs.parseHeight(value);
        this.height.value = Number(value);
        if (!el && (value || value === 0)) return _vue.nextTick(()=>this.setHeight(value, prop)
        );
        if (typeof value === "number") {
            el.style[prop] = `${value}px`;
            this.updateElsHeight();
        } else if (typeof value === "string") {
            el.style[prop] = value;
            this.updateElsHeight();
        }
    }
    setMaxHeight(value) {
        this.setHeight(value, "max-height");
    }
    getFlattenColumns() {
        const flattenColumns = [];
        const columns = this.table.store.states.columns.value;
        columns.forEach((column)=>{
            if (column.isColumnGroup) flattenColumns.push.apply(flattenColumns, column.columns);
            else flattenColumns.push(column);
        });
        return flattenColumns;
    }
    updateElsHeight() {
        var _a, _b;
        if (!this.table.$ready) return _vue.nextTick(()=>this.updateElsHeight()
        );
        const { tableWrapper , headerWrapper , appendWrapper , footerWrapper , tableHeader , tableBody  } = this.table.refs;
        if (tableWrapper && tableWrapper.style.display === "none") return;
        this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0;
        if (this.showHeader && !headerWrapper) return;
        const headerTrElm = tableHeader ? tableHeader : null;
        const noneHeader = this.headerDisplayNone(headerTrElm);
        const headerHeight = this.headerHeight.value = !this.showHeader ? 0 : headerWrapper.offsetHeight;
        if (this.showHeader && !noneHeader && headerWrapper.offsetWidth > 0 && (this.table.store.states.columns.value || []).length > 0 && headerHeight < 2) return _vue.nextTick(()=>this.updateElsHeight()
        );
        const tableHeight = this.tableHeight.value = (_b = (_a = this.table) == null ? void 0 : _a.vnode.el) == null ? void 0 : _b.clientHeight;
        const footerHeight = this.footerHeight.value = footerWrapper ? footerWrapper.offsetHeight : 0;
        if (this.height.value !== null) {
            if (this.bodyHeight.value === null) requestAnimationFrame(()=>this.updateElsHeight()
            );
            this.bodyHeight.value = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
            this.bodyScrollHeight.value = tableBody == null ? void 0 : tableBody.scrollHeight;
        }
        this.fixedBodyHeight.value = this.scrollX.value ? this.bodyHeight.value - this.gutterWidth : this.bodyHeight.value;
        this.viewportHeight.value = this.scrollX.value ? tableHeight - this.gutterWidth : tableHeight;
        this.updateScrollY();
        this.notifyObservers("scrollable");
    }
    headerDisplayNone(elm) {
        if (!elm) return true;
        let headerChild = elm;
        while(headerChild.tagName !== "DIV"){
            if (getComputedStyle(headerChild).display === "none") return true;
            headerChild = headerChild.parentElement;
        }
        return false;
    }
    updateColumnsWidth() {
        if (!_core.isClient) return;
        const fit = this.fit;
        const bodyWidth = this.table.vnode.el.clientWidth;
        const { tableBody  } = this.table.refs;
        const bodyScrollWidth = (tableBody == null ? void 0 : tableBody.scrollWidth) || 0;
        let bodyMinWidth = 0;
        const flattenColumns = this.getFlattenColumns();
        const flexColumns = flattenColumns.filter((column)=>typeof column.width !== "number"
        );
        flattenColumns.forEach((column)=>{
            if (typeof column.width === "number" && column.realWidth) column.realWidth = null;
        });
        if (flexColumns.length > 0 && fit) {
            flattenColumns.forEach((column)=>{
                bodyMinWidth += Number(column.width || column.minWidth || 80);
            });
            const scrollYWidth = 0;
            if (bodyMinWidth <= bodyWidth - scrollYWidth && bodyScrollWidth <= bodyWidth) {
                this.scrollX.value = false;
                const totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth;
                if (flexColumns.length === 1) flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
                else {
                    const allColumnsWidth = flexColumns.reduce((prev, column)=>prev + Number(column.minWidth || 80)
                    , 0);
                    const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
                    let noneFirstWidth = 0;
                    flexColumns.forEach((column, index)=>{
                        if (index === 0) return;
                        const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
                        noneFirstWidth += flexWidth;
                        column.realWidth = Number(column.minWidth || 80) + flexWidth;
                    });
                    flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
                }
            } else {
                this.scrollX.value = true;
                flexColumns.forEach(function(column) {
                    column.realWidth = Number(column.minWidth);
                });
            }
            this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
            this.table.state.resizeState.value.width = this.bodyWidth.value;
        } else {
            flattenColumns.forEach((column)=>{
                if (!column.width && !column.minWidth) column.realWidth = 80;
                else column.realWidth = Number(column.width || column.minWidth);
                bodyMinWidth += column.realWidth;
            });
            this.scrollX.value = bodyMinWidth > bodyWidth;
            this.bodyWidth.value = bodyMinWidth;
        }
        const fixedColumns = this.store.states.fixedColumns.value;
        if (fixedColumns.length > 0) {
            let fixedWidth = 0;
            fixedColumns.forEach(function(column) {
                fixedWidth += Number(column.realWidth || column.width);
            });
            this.fixedWidth.value = fixedWidth;
        }
        const rightFixedColumns = this.store.states.rightFixedColumns.value;
        if (rightFixedColumns.length > 0) {
            let rightFixedWidth = 0;
            rightFixedColumns.forEach(function(column) {
                rightFixedWidth += Number(column.realWidth || column.width);
            });
            this.rightFixedWidth.value = rightFixedWidth;
        }
        this.notifyObservers("columns");
    }
    addObserver(observer) {
        this.observers.push(observer);
    }
    removeObserver(observer) {
        const index = this.observers.indexOf(observer);
        if (index !== -1) this.observers.splice(index, 1);
    }
    notifyObservers(event) {
        const observers = this.observers;
        observers.forEach((observer)=>{
            var _a, _b;
            switch(event){
                case "columns":
                    (_a = observer.state) == null || _a.onColumnsChange(this);
                    break;
                case "scrollable":
                    (_b = observer.state) == null || _b.onScrollableChange(this);
                    break;
                default:
                    throw new Error(`Table Layout don't have event ${event}.`);
            }
        });
    }
}

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../utils/index.mjs":"dsdeP","./util.mjs":"isd9T","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hHH1e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TableHeader
);
var _vue = require("vue");
var _indexMjs = require("../../../checkbox/index.mjs");
var _indexMjs1 = require("../../../../hooks/index.mjs");
var _filterPanelMjs = require("../filter-panel.mjs");
var _filterPanelMjsDefault = parcelHelpers.interopDefault(_filterPanelMjs);
var _layoutObserverMjs = require("../layout-observer.mjs");
var _layoutObserverMjsDefault = parcelHelpers.interopDefault(_layoutObserverMjs);
var _tokensMjs = require("../tokens.mjs");
var _eventHelperMjs = require("./event-helper.mjs");
var _eventHelperMjsDefault = parcelHelpers.interopDefault(_eventHelperMjs);
var _styleHelperMjs = require("./style.helper.mjs");
var _styleHelperMjsDefault = parcelHelpers.interopDefault(_styleHelperMjs);
var _utilsHelperMjs = require("./utils-helper.mjs");
var _utilsHelperMjsDefault = parcelHelpers.interopDefault(_utilsHelperMjs);
var _indexMjs2 = require("../../../../hooks/use-namespace/index.mjs");
var TableHeader = _vue.defineComponent({
    name: "ElTableHeader",
    components: {
        ElCheckbox: _indexMjs.ElCheckbox
    },
    props: {
        fixed: {
            type: String,
            default: ""
        },
        store: {
            required: true,
            type: Object
        },
        border: Boolean,
        defaultSort: {
            type: Object,
            default: ()=>{
                return {
                    prop: "",
                    order: ""
                };
            }
        }
    },
    setup (props, { emit  }) {
        const instance = _vue.getCurrentInstance();
        const parent = _vue.inject(_tokensMjs.TABLE_INJECTION_KEY);
        const ns = _indexMjs2.useNamespace("table");
        const filterPanels = _vue.ref({
        });
        const { onColumnsChange , onScrollableChange  } = _layoutObserverMjsDefault.default(parent);
        _vue.onMounted(()=>{
            _vue.nextTick(()=>{
                const { prop , order  } = props.defaultSort;
                const init = true;
                parent == null || parent.store.commit("sort", {
                    prop,
                    order,
                    init
                });
            });
        });
        const { handleHeaderClick , handleHeaderContextMenu , handleMouseDown , handleMouseMove , handleMouseOut , handleSortClick , handleFilterClick  } = _eventHelperMjsDefault.default(props, emit);
        const { getHeaderRowStyle , getHeaderRowClass , getHeaderCellStyle , getHeaderCellClass  } = _styleHelperMjsDefault.default(props);
        const { isGroup , toggleAllSelection , columnRows  } = _utilsHelperMjsDefault.default(props);
        instance.state = {
            onColumnsChange,
            onScrollableChange
        };
        instance.filterPanels = filterPanels;
        return {
            ns,
            filterPanels,
            onColumnsChange,
            onScrollableChange,
            columnRows,
            getHeaderRowClass,
            getHeaderRowStyle,
            getHeaderCellClass,
            getHeaderCellStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick,
            isGroup,
            toggleAllSelection
        };
    },
    render () {
        const { ns , isGroup , columnRows , getHeaderCellStyle , getHeaderCellClass , getHeaderRowClass , getHeaderRowStyle , handleHeaderClick , handleHeaderContextMenu , handleMouseDown , handleMouseMove , handleSortClick , handleMouseOut , store , $parent  } = this;
        let rowSpan = 1;
        return _vue.h("thead", {
            class: {
                [ns.is("group")]: isGroup
            }
        }, columnRows.map((subColumns, rowIndex)=>_vue.h("tr", {
                class: getHeaderRowClass(rowIndex),
                key: rowIndex,
                style: getHeaderRowStyle(rowIndex)
            }, subColumns.map((column, cellIndex)=>{
                if (column.rowSpan > rowSpan) rowSpan = column.rowSpan;
                return _vue.h("th", {
                    class: getHeaderCellClass(rowIndex, cellIndex, subColumns, column),
                    colspan: column.colSpan,
                    key: `${column.id}-thead`,
                    rowspan: column.rowSpan,
                    style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
                    onClick: ($event)=>handleHeaderClick($event, column)
                    ,
                    onContextmenu: ($event)=>handleHeaderContextMenu($event, column)
                    ,
                    onMousedown: ($event)=>handleMouseDown($event, column)
                    ,
                    onMousemove: ($event)=>handleMouseMove($event, column)
                    ,
                    onMouseout: handleMouseOut
                }, [
                    _vue.h("div", {
                        class: [
                            "cell",
                            column.filteredValue && column.filteredValue.length > 0 ? "highlight" : "",
                            column.labelClassName
                        ]
                    }, [
                        column.renderHeader ? column.renderHeader({
                            column,
                            $index: cellIndex,
                            store,
                            _self: $parent
                        }) : column.label,
                        column.sortable && _vue.h("span", {
                            onClick: ($event)=>handleSortClick($event, column)
                            ,
                            class: "caret-wrapper"
                        }, [
                            _vue.h("i", {
                                onClick: ($event)=>handleSortClick($event, column, "ascending")
                                ,
                                class: "sort-caret ascending"
                            }),
                            _vue.h("i", {
                                onClick: ($event)=>handleSortClick($event, column, "descending")
                                ,
                                class: "sort-caret descending"
                            })
                        ]),
                        column.filterable && _vue.h(_filterPanelMjsDefault.default, {
                            store: $parent.store,
                            placement: column.filterPlacement || "bottom-start",
                            column,
                            upDataColumn: (key, value)=>{
                                column[key] = value;
                            }
                        })
                    ])
                ]);
            }))
        ));
    }
});

},{"vue":"gzxs9","../../../checkbox/index.mjs":"jMNjD","../../../../hooks/index.mjs":"1Ansp","../filter-panel.mjs":"5XLSs","../layout-observer.mjs":"3wEie","../tokens.mjs":"cGfBP","./event-helper.mjs":"icJr2","./style.helper.mjs":"a8klC","./utils-helper.mjs":"aH75h","../../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5XLSs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>FilterPanel
);
var _vue = require("vue");
var _indexMjs = require("../../checkbox/index.mjs");
var _indexMjs1 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs2 = require("../../../directives/index.mjs");
var _indexMjs3 = require("../../../hooks/index.mjs");
var _indexMjs4 = require("../../tooltip/index.mjs");
var _indexMjs5 = require("../../scrollbar/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs6 = require("../../../directives/click-outside/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs6);
var _indexMjs7 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs8 = require("../../../hooks/use-namespace/index.mjs");
const { CheckboxGroup: ElCheckboxGroup  } = _indexMjs.ElCheckbox;
const _sfc_main = _vue.defineComponent({
    name: "ElTableFilterPanel",
    components: {
        ElCheckbox: _indexMjs.ElCheckbox,
        ElCheckboxGroup,
        ElScrollbar: _indexMjs5.ElScrollbar,
        ElTooltip: _indexMjs4.ElTooltip,
        ElIcon: _indexMjs1.ElIcon,
        ArrowDown: _iconsVue.ArrowDown,
        ArrowUp: _iconsVue.ArrowUp
    },
    directives: {
        ClickOutside: _indexMjsDefault.default
    },
    props: {
        placement: {
            type: String,
            default: "bottom-start"
        },
        store: {
            type: Object
        },
        column: {
            type: Object
        },
        upDataColumn: {
            type: Function
        }
    },
    setup (props) {
        const instance = _vue.getCurrentInstance();
        const { t  } = _indexMjs7.useLocale();
        const ns = _indexMjs8.useNamespace("table-filter");
        const parent = instance == null ? void 0 : instance.parent;
        if (!parent.filterPanels.value[props.column.id]) parent.filterPanels.value[props.column.id] = instance;
        const tooltipVisible = _vue.ref(false);
        const tooltip = _vue.ref(null);
        const filters = _vue.computed(()=>{
            return props.column && props.column.filters;
        });
        const filterValue = _vue.computed({
            get: ()=>{
                var _a;
                return (((_a = props.column) == null ? void 0 : _a.filteredValue) || [])[0];
            },
            set: (value)=>{
                if (filteredValue.value) {
                    if (typeof value !== "undefined" && value !== null) filteredValue.value.splice(0, 1, value);
                    else filteredValue.value.splice(0, 1);
                }
            }
        });
        const filteredValue = _vue.computed({
            get () {
                if (props.column) return props.column.filteredValue || [];
                return [];
            },
            set (value) {
                if (props.column) props.upDataColumn("filteredValue", value);
            }
        });
        const multiple = _vue.computed(()=>{
            if (props.column) return props.column.filterMultiple;
            return true;
        });
        const isActive = (filter)=>{
            return filter.value === filterValue.value;
        };
        const hidden = ()=>{
            tooltipVisible.value = false;
        };
        const showFilterPanel = (e)=>{
            e.stopPropagation();
            tooltipVisible.value = !tooltipVisible.value;
        };
        const hideFilterPanel = ()=>{
            tooltipVisible.value = false;
        };
        const handleConfirm = ()=>{
            confirmFilter(filteredValue.value);
            hidden();
        };
        const handleReset = ()=>{
            filteredValue.value = [];
            confirmFilter(filteredValue.value);
            hidden();
        };
        const handleSelect = (_filterValue)=>{
            filterValue.value = _filterValue;
            if (typeof _filterValue !== "undefined" && _filterValue !== null) confirmFilter(filteredValue.value);
            else confirmFilter([]);
            hidden();
        };
        const confirmFilter = (filteredValue2)=>{
            props.store.commit("filterChange", {
                column: props.column,
                values: filteredValue2
            });
            props.store.updateAllSelected();
        };
        _vue.watch(tooltipVisible, (value)=>{
            if (props.column) props.upDataColumn("filterOpened", value);
        }, {
            immediate: true
        });
        const popperPaneRef = _vue.computed(()=>{
            var _a, _b;
            return (_b = (_a = tooltip.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
        });
        return {
            tooltipVisible,
            multiple,
            filteredValue,
            filterValue,
            filters,
            handleConfirm,
            handleReset,
            handleSelect,
            isActive,
            t,
            ns,
            showFilterPanel,
            hideFilterPanel,
            popperPaneRef,
            tooltip
        };
    }
});
const _hoisted_1 = {
    key: 0
};
const _hoisted_2 = [
    "disabled"
];
const _hoisted_3 = [
    "label",
    "onClick"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_checkbox = _vue.resolveComponent("el-checkbox");
    const _component_el_checkbox_group = _vue.resolveComponent("el-checkbox-group");
    const _component_el_scrollbar = _vue.resolveComponent("el-scrollbar");
    const _component_arrow_up = _vue.resolveComponent("arrow-up");
    const _component_arrow_down = _vue.resolveComponent("arrow-down");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_tooltip = _vue.resolveComponent("el-tooltip");
    const _directive_click_outside = _vue.resolveDirective("click-outside");
    return _vue.openBlock(), _vue.createBlock(_component_el_tooltip, {
        ref: "tooltip",
        visible: _ctx.tooltipVisible,
        "onUpdate:visible": _cache[5] || (_cache[5] = ($event)=>_ctx.tooltipVisible = $event
        ),
        offset: 0,
        placement: _ctx.placement,
        "show-arrow": false,
        "stop-popper-mouse-event": false,
        "append-to-body": "",
        effect: "light",
        pure: "",
        "popper-class": _ctx.ns.b(),
        persistent: ""
    }, {
        content: _vue.withCtx(()=>[
                _ctx.multiple ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_1, [
                    _vue.createElementVNode("div", {
                        class: _vue.normalizeClass(_ctx.ns.e("content"))
                    }, [
                        _vue.createVNode(_component_el_scrollbar, {
                            "wrap-class": _ctx.ns.e("wrap")
                        }, {
                            default: _vue.withCtx(()=>[
                                    _vue.createVNode(_component_el_checkbox_group, {
                                        modelValue: _ctx.filteredValue,
                                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>_ctx.filteredValue = $event
                                        ),
                                        class: _vue.normalizeClass(_ctx.ns.e("checkbox-group"))
                                    }, {
                                        default: _vue.withCtx(()=>[
                                                (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.filters, (filter)=>{
                                                    return _vue.openBlock(), _vue.createBlock(_component_el_checkbox, {
                                                        key: filter.value,
                                                        label: filter.value
                                                    }, {
                                                        default: _vue.withCtx(()=>[
                                                                _vue.createTextVNode(_vue.toDisplayString(filter.text), 1)
                                                            ]
                                                        ),
                                                        _: 2
                                                    }, 1032, [
                                                        "label"
                                                    ]);
                                                }), 128))
                                            ]
                                        ),
                                        _: 1
                                    }, 8, [
                                        "modelValue",
                                        "class"
                                    ])
                                ]
                            ),
                            _: 1
                        }, 8, [
                            "wrap-class"
                        ])
                    ], 2),
                    _vue.createElementVNode("div", {
                        class: _vue.normalizeClass(_ctx.ns.e("bottom"))
                    }, [
                        _vue.createElementVNode("button", {
                            class: _vue.normalizeClass({
                                [_ctx.ns.is("disabled")]: _ctx.filteredValue.length === 0
                            }),
                            disabled: _ctx.filteredValue.length === 0,
                            type: "button",
                            onClick: _cache[1] || (_cache[1] = (...args)=>_ctx.handleConfirm && _ctx.handleConfirm(...args)
                            )
                        }, _vue.toDisplayString(_ctx.t("el.table.confirmFilter")), 11, _hoisted_2),
                        _vue.createElementVNode("button", {
                            type: "button",
                            onClick: _cache[2] || (_cache[2] = (...args)=>_ctx.handleReset && _ctx.handleReset(...args)
                            )
                        }, _vue.toDisplayString(_ctx.t("el.table.resetFilter")), 1)
                    ], 2)
                ])) : (_vue.openBlock(), _vue.createElementBlock("ul", {
                    key: 1,
                    class: _vue.normalizeClass(_ctx.ns.e("list"))
                }, [
                    _vue.createElementVNode("li", {
                        class: _vue.normalizeClass([
                            _ctx.ns.e("list-item"),
                            {
                                [_ctx.ns.is("active")]: _ctx.filterValue === void 0 || _ctx.filterValue === null
                            }
                        ]),
                        onClick: _cache[3] || (_cache[3] = ($event)=>_ctx.handleSelect(null)
                        )
                    }, _vue.toDisplayString(_ctx.t("el.table.clearFilter")), 3),
                    (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.filters, (filter)=>{
                        return _vue.openBlock(), _vue.createElementBlock("li", {
                            key: filter.value,
                            class: _vue.normalizeClass([
                                _ctx.ns.e("list-item"),
                                _ctx.ns.is("active", _ctx.isActive(filter))
                            ]),
                            label: filter.value,
                            onClick: ($event)=>_ctx.handleSelect(filter.value)
                        }, _vue.toDisplayString(filter.text), 11, _hoisted_3);
                    }), 128))
                ], 2))
            ]
        ),
        default: _vue.withCtx(()=>[
                _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("span", {
                    class: _vue.normalizeClass([
                        `${_ctx.ns.namespace.value}-table__column-filter-trigger`,
                        `${_ctx.ns.namespace.value}-none-outline`
                    ]),
                    onClick: _cache[4] || (_cache[4] = (...args)=>_ctx.showFilterPanel && _ctx.showFilterPanel(...args)
                    )
                }, [
                    _vue.createVNode(_component_el_icon, null, {
                        default: _vue.withCtx(()=>[
                                _ctx.column.filterOpened ? (_vue.openBlock(), _vue.createBlock(_component_arrow_up, {
                                    key: 0
                                })) : (_vue.openBlock(), _vue.createBlock(_component_arrow_down, {
                                    key: 1
                                }))
                            ]
                        ),
                        _: 1
                    })
                ], 2)), [
                    [
                        _directive_click_outside,
                        _ctx.hideFilterPanel,
                        _ctx.popperPaneRef
                    ]
                ])
            ]
        ),
        _: 1
    }, 8, [
        "visible",
        "placement",
        "popper-class"
    ]);
}
var FilterPanel = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../checkbox/index.mjs":"jMNjD","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../directives/index.mjs":"aRbJ2","../../../hooks/index.mjs":"1Ansp","../../tooltip/index.mjs":"kiwBC","../../scrollbar/index.mjs":"kXLHt","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../directives/click-outside/index.mjs":"cdlLW","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3wEie":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useLayoutObserver
);
var _vue = require("vue");
function useLayoutObserver(root) {
    const instance = _vue.getCurrentInstance();
    _vue.onBeforeMount(()=>{
        tableLayout.value.addObserver(instance);
    });
    _vue.onMounted(()=>{
        onColumnsChange(tableLayout.value);
        onScrollableChange(tableLayout.value);
    });
    _vue.onUpdated(()=>{
        onColumnsChange(tableLayout.value);
        onScrollableChange(tableLayout.value);
    });
    _vue.onUnmounted(()=>{
        tableLayout.value.removeObserver(instance);
    });
    const tableLayout = _vue.computed(()=>{
        const layout = root.layout;
        if (!layout) throw new Error("Can not find table layout.");
        return layout;
    });
    const onColumnsChange = (layout)=>{
        var _a;
        const cols = ((_a = root.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col")) || [];
        if (!cols.length) return;
        const flattenColumns = layout.getFlattenColumns();
        const columnsMap = {
        };
        flattenColumns.forEach((column)=>{
            columnsMap[column.id] = column;
        });
        for(let i = 0, j = cols.length; i < j; i++){
            const col = cols[i];
            const name = col.getAttribute("name");
            const column = columnsMap[name];
            if (column) col.setAttribute("width", column.realWidth || column.width);
        }
    };
    const onScrollableChange = (layout)=>{
        var _a, _b;
        const cols = ((_a = root.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col[name=gutter]")) || [];
        for(let i = 0, j = cols.length; i < j; i++){
            const col = cols[i];
            col.setAttribute("width", layout.scrollY.value ? layout.gutterWidth : "0");
        }
        const ths = ((_b = root.vnode.el) == null ? void 0 : _b.querySelectorAll("th.gutter")) || [];
        for(let i1 = 0, j1 = ths.length; i1 < j1; i1++){
            const th = ths[i1];
            th.style.width = layout.scrollY.value ? `${layout.gutterWidth}px` : "0";
            th.style.display = layout.scrollY.value ? "" : "none";
        }
    };
    return {
        tableLayout: tableLayout.value,
        onColumnsChange,
        onScrollableChange
    };
}

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cGfBP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TABLE_INJECTION_KEY", ()=>TABLE_INJECTION_KEY
);
const TABLE_INJECTION_KEY = Symbol("ElTable");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"icJr2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useEvent
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../../utils/index.mjs");
var _tokensMjs = require("../tokens.mjs");
var _styleMjs = require("../../../../utils/dom/style.mjs");
function useEvent(props, emit) {
    const instance = _vue.getCurrentInstance();
    const parent = _vue.inject(_tokensMjs.TABLE_INJECTION_KEY);
    const handleFilterClick = (event)=>{
        event.stopPropagation();
        return;
    };
    const handleHeaderClick = (event, column)=>{
        if (!column.filters && column.sortable) handleSortClick(event, column, false);
        else if (column.filterable && !column.sortable) handleFilterClick(event);
        parent == null || parent.emit("header-click", column, event);
    };
    const handleHeaderContextMenu = (event, column)=>{
        parent == null || parent.emit("header-contextmenu", column, event);
    };
    const draggingColumn = _vue.ref(null);
    const dragging = _vue.ref(false);
    const dragState = _vue.ref({
    });
    const handleMouseDown = (event, column)=>{
        if (!_core.isClient) return;
        if (column.children && column.children.length > 0) return;
        if (draggingColumn.value && props.border) {
            dragging.value = true;
            const table = parent;
            emit("set-drag-visible", true);
            const tableEl = table == null ? void 0 : table.vnode.el;
            const tableLeft = tableEl.getBoundingClientRect().left;
            const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
            const columnRect = columnEl.getBoundingClientRect();
            const minLeft = columnRect.left - tableLeft + 30;
            _styleMjs.addClass(columnEl, "noclick");
            dragState.value = {
                startMouseLeft: event.clientX,
                startLeft: columnRect.right - tableLeft,
                startColumnLeft: columnRect.left - tableLeft,
                tableLeft
            };
            const resizeProxy = table == null ? void 0 : table.refs.resizeProxy;
            resizeProxy.style.left = `${dragState.value.startLeft}px`;
            document.onselectstart = function() {
                return false;
            };
            document.ondragstart = function() {
                return false;
            };
            const handleMouseMove2 = (event2)=>{
                const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
                const proxyLeft = dragState.value.startLeft + deltaLeft;
                resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
            };
            const handleMouseUp = ()=>{
                if (dragging.value) {
                    const { startColumnLeft , startLeft  } = dragState.value;
                    const finalLeft = parseInt(resizeProxy.style.left, 10);
                    const columnWidth = finalLeft - startColumnLeft;
                    column.width = column.realWidth = columnWidth;
                    table == null || table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
                    requestAnimationFrame(()=>{
                        props.store.scheduleLayout(false, true);
                    });
                    document.body.style.cursor = "";
                    dragging.value = false;
                    draggingColumn.value = null;
                    dragState.value = {
                    };
                    emit("set-drag-visible", false);
                }
                document.removeEventListener("mousemove", handleMouseMove2);
                document.removeEventListener("mouseup", handleMouseUp);
                document.onselectstart = null;
                document.ondragstart = null;
                setTimeout(function() {
                    _styleMjs.removeClass(columnEl, "noclick");
                }, 0);
            };
            document.addEventListener("mousemove", handleMouseMove2);
            document.addEventListener("mouseup", handleMouseUp);
        }
    };
    const handleMouseMove = (event, column)=>{
        if (column.children && column.children.length > 0) return;
        let target = event.target;
        while(target && target.tagName !== "TH")target = target.parentNode;
        if (!column || !column.resizable) return;
        if (!dragging.value && props.border) {
            const rect = target.getBoundingClientRect();
            const bodyStyle = document.body.style;
            if (rect.width > 12 && rect.right - event.pageX < 8) {
                bodyStyle.cursor = "col-resize";
                if (_styleMjs.hasClass(target, "is-sortable")) target.style.cursor = "col-resize";
                draggingColumn.value = column;
            } else if (!dragging.value) {
                bodyStyle.cursor = "";
                if (_styleMjs.hasClass(target, "is-sortable")) target.style.cursor = "pointer";
                draggingColumn.value = null;
            }
        }
    };
    const handleMouseOut = ()=>{
        if (!_core.isClient) return;
        document.body.style.cursor = "";
    };
    const toggleOrder = ({ order , sortOrders  })=>{
        if (order === "") return sortOrders[0];
        const index = sortOrders.indexOf(order || null);
        return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
    };
    const handleSortClick = (event, column, givenOrder)=>{
        event.stopPropagation();
        const order = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
        let target = event.target;
        while(target && target.tagName !== "TH")target = target.parentNode;
        if (target && target.tagName === "TH") {
            if (_styleMjs.hasClass(target, "noclick")) {
                _styleMjs.removeClass(target, "noclick");
                return;
            }
        }
        if (!column.sortable) return;
        const states = props.store.states;
        let sortProp = states.sortProp.value;
        let sortOrder;
        const sortingColumn = states.sortingColumn.value;
        if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
            if (sortingColumn) sortingColumn.order = null;
            states.sortingColumn.value = column;
            sortProp = column.property;
        }
        if (!order) sortOrder = column.order = null;
        else sortOrder = column.order = order;
        states.sortProp.value = sortProp;
        states.sortOrder.value = sortOrder;
        parent == null || parent.store.commit("changeSortCondition");
    };
    return {
        handleHeaderClick,
        handleHeaderContextMenu,
        handleMouseDown,
        handleMouseMove,
        handleMouseOut,
        handleSortClick,
        handleFilterClick
    };
}

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../../utils/index.mjs":"dsdeP","../tokens.mjs":"cGfBP","../../../../utils/dom/style.mjs":"cA8Mp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a8klC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useStyle
);
var _vue = require("vue");
var _indexMjs = require("../../../../hooks/index.mjs");
var _utilMjs = require("../util.mjs");
var _tokensMjs = require("../tokens.mjs");
var _indexMjs1 = require("../../../../hooks/use-namespace/index.mjs");
function useStyle(props) {
    const parent = _vue.inject(_tokensMjs.TABLE_INJECTION_KEY);
    const ns = _indexMjs1.useNamespace("table");
    const getHeaderRowStyle = (rowIndex)=>{
        const headerRowStyle = parent == null ? void 0 : parent.props.headerRowStyle;
        if (typeof headerRowStyle === "function") return headerRowStyle.call(null, {
            rowIndex
        });
        return headerRowStyle;
    };
    const getHeaderRowClass = (rowIndex)=>{
        const classes = [];
        const headerRowClassName = parent == null ? void 0 : parent.props.headerRowClassName;
        if (typeof headerRowClassName === "string") classes.push(headerRowClassName);
        else if (typeof headerRowClassName === "function") classes.push(headerRowClassName.call(null, {
            rowIndex
        }));
        return classes.join(" ");
    };
    const getHeaderCellStyle = (rowIndex, columnIndex, row, column)=>{
        var _a;
        let headerCellStyles = (_a = parent == null ? void 0 : parent.props.headerCellStyle) != null ? _a : {
        };
        if (typeof headerCellStyles === "function") headerCellStyles = headerCellStyles.call(null, {
            rowIndex,
            columnIndex,
            row,
            column
        });
        const fixedStyle = column.isSubColumn ? null : _utilMjs.getFixedColumnOffset(columnIndex, column.fixed, props.store, row);
        _utilMjs.ensurePosition(fixedStyle, "left");
        _utilMjs.ensurePosition(fixedStyle, "right");
        return Object.assign({
        }, headerCellStyles, fixedStyle);
    };
    const getHeaderCellClass = (rowIndex, columnIndex, row, column)=>{
        const fixedClasses = column.isSubColumn ? [] : _utilMjs.getFixedColumnsClass(ns.b(), columnIndex, column.fixed, props.store, row);
        const classes = [
            column.id,
            column.order,
            column.headerAlign,
            column.className,
            column.labelClassName,
            ...fixedClasses
        ];
        if (!column.children) classes.push("is-leaf");
        if (column.sortable) classes.push("is-sortable");
        const headerCellClassName = parent == null ? void 0 : parent.props.headerCellClassName;
        if (typeof headerCellClassName === "string") classes.push(headerCellClassName);
        else if (typeof headerCellClassName === "function") classes.push(headerCellClassName.call(null, {
            rowIndex,
            columnIndex,
            row,
            column
        }));
        classes.push(ns.e("cell"));
        return classes.join(" ");
    };
    return {
        getHeaderRowStyle,
        getHeaderRowClass,
        getHeaderCellStyle,
        getHeaderCellClass
    };
}

},{"vue":"gzxs9","../../../../hooks/index.mjs":"1Ansp","../util.mjs":"isd9T","../tokens.mjs":"cGfBP","../../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aH75h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useUtils
);
var _vue = require("vue");
var _tokensMjs = require("../tokens.mjs");
const getAllColumns = (columns)=>{
    const result = [];
    columns.forEach((column)=>{
        if (column.children) {
            result.push(column);
            result.push.apply(result, getAllColumns(column.children));
        } else result.push(column);
    });
    return result;
};
const convertToRows = (originColumns)=>{
    let maxLevel = 1;
    const traverse = (column, parent)=>{
        if (parent) {
            column.level = parent.level + 1;
            if (maxLevel < column.level) maxLevel = column.level;
        }
        if (column.children) {
            let colSpan = 0;
            column.children.forEach((subColumn)=>{
                traverse(subColumn, column);
                colSpan += subColumn.colSpan;
            });
            column.colSpan = colSpan;
        } else column.colSpan = 1;
    };
    originColumns.forEach((column)=>{
        column.level = 1;
        traverse(column, void 0);
    });
    const rows = [];
    for(let i = 0; i < maxLevel; i++)rows.push([]);
    const allColumns = getAllColumns(originColumns);
    allColumns.forEach((column)=>{
        if (!column.children) column.rowSpan = maxLevel - column.level + 1;
        else {
            column.rowSpan = 1;
            column.children.forEach((col)=>col.isSubColumn = true
            );
        }
        rows[column.level - 1].push(column);
    });
    return rows;
};
function useUtils(props) {
    const parent = _vue.inject(_tokensMjs.TABLE_INJECTION_KEY);
    const columnRows = _vue.computed(()=>{
        return convertToRows(props.store.states.originColumns.value);
    });
    const isGroup = _vue.computed(()=>{
        const result = columnRows.value.length > 1;
        if (result && parent) parent.state.isGroup.value = true;
        return result;
    });
    const toggleAllSelection = (event)=>{
        event.stopPropagation();
        parent == null || parent.store.commit("toggleAllSelection");
    };
    return {
        isGroup,
        toggleAllSelection,
        columnRows
    };
}

},{"vue":"gzxs9","../tokens.mjs":"cGfBP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kn3SA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TableBody
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../../utils/index.mjs");
var _indexMjs1 = require("../../../../hooks/index.mjs");
var _layoutObserverMjs = require("../layout-observer.mjs");
var _layoutObserverMjsDefault = parcelHelpers.interopDefault(_layoutObserverMjs);
var _utilMjs = require("../util.mjs");
var _tokensMjs = require("../tokens.mjs");
var _renderHelperMjs = require("./render-helper.mjs");
var _renderHelperMjsDefault = parcelHelpers.interopDefault(_renderHelperMjs);
var _defaultsMjs = require("./defaults.mjs");
var _defaultsMjsDefault = parcelHelpers.interopDefault(_defaultsMjs);
var _indexMjs2 = require("../../../../hooks/use-namespace/index.mjs");
var _styleMjs = require("../../../../utils/dom/style.mjs");
var TableBody = _vue.defineComponent({
    name: "ElTableBody",
    props: _defaultsMjsDefault.default,
    setup (props) {
        const instance = _vue.getCurrentInstance();
        const parent = _vue.inject(_tokensMjs.TABLE_INJECTION_KEY);
        const ns = _indexMjs2.useNamespace("table");
        const { wrappedRowRender , tooltipContent , tooltipTrigger  } = _renderHelperMjsDefault.default(props);
        const { onColumnsChange , onScrollableChange  } = _layoutObserverMjsDefault.default(parent);
        _vue.watch(props.store.states.hoverRow, (newVal, oldVal)=>{
            if (!props.store.states.isComplex.value || !_core.isClient) return;
            let raf = window.requestAnimationFrame;
            if (!raf) raf = (fn)=>window.setTimeout(fn, 16)
            ;
            raf(()=>{
                var _a;
                const rows = (_a = instance == null ? void 0 : instance.vnode.el) == null ? void 0 : _a.querySelectorAll(`.${ns.e("row")}`);
                const oldRow = rows[oldVal];
                const newRow = rows[newVal];
                if (oldRow) _styleMjs.removeClass(oldRow, "hover-row");
                if (newRow) _styleMjs.addClass(newRow, "hover-row");
            });
        });
        _vue.onUnmounted(()=>{
            var _a;
            (_a = _utilMjs.removePopper) == null || _a();
        });
        _vue.onUpdated(()=>{
            var _a;
            (_a = _utilMjs.removePopper) == null || _a();
        });
        return {
            ns,
            onColumnsChange,
            onScrollableChange,
            wrappedRowRender,
            tooltipContent,
            tooltipTrigger
        };
    },
    render () {
        const { wrappedRowRender , store  } = this;
        const data = store.states.data.value || [];
        return _vue.h("tbody", {
        }, [
            data.reduce((acc, row)=>{
                return acc.concat(wrappedRowRender(row, acc.length));
            }, [])
        ]);
    }
});

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../../utils/index.mjs":"dsdeP","../../../../hooks/index.mjs":"1Ansp","../layout-observer.mjs":"3wEie","../util.mjs":"isd9T","../tokens.mjs":"cGfBP","./render-helper.mjs":"aT3Hj","./defaults.mjs":"3YhAi","../../../../hooks/use-namespace/index.mjs":"a1pcf","../../../../utils/dom/style.mjs":"cA8Mp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aT3Hj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useRender
);
var _vue = require("vue");
var _utilMjs = require("../util.mjs");
var _tokensMjs = require("../tokens.mjs");
var _eventsHelperMjs = require("./events-helper.mjs");
var _eventsHelperMjsDefault = parcelHelpers.interopDefault(_eventsHelperMjs);
var _stylesHelperMjs = require("./styles-helper.mjs");
var _stylesHelperMjsDefault = parcelHelpers.interopDefault(_stylesHelperMjs);
function useRender(props) {
    const parent = _vue.inject(_tokensMjs.TABLE_INJECTION_KEY);
    const { handleDoubleClick , handleClick , handleContextMenu , handleMouseEnter , handleMouseLeave , handleCellMouseEnter , handleCellMouseLeave , tooltipContent , tooltipTrigger  } = _eventsHelperMjsDefault.default(props);
    const { getRowStyle , getRowClass , getCellStyle , getCellClass , getSpan , getColspanRealWidth  } = _stylesHelperMjsDefault.default(props);
    const firstDefaultColumnIndex = _vue.computed(()=>{
        return props.store.states.columns.value.findIndex(({ type  })=>type === "default"
        );
    });
    const getKeyOfRow = (row, index)=>{
        const rowKey = parent.props.rowKey;
        if (rowKey) return _utilMjs.getRowIdentity(row, rowKey);
        return index;
    };
    const rowRender = (row, $index, treeRowData)=>{
        const { tooltipEffect , store  } = props;
        const { indent , columns  } = store.states;
        const rowClasses = getRowClass(row, $index);
        let display = true;
        if (treeRowData) {
            rowClasses.push(`el-table__row--level-${treeRowData.level}`);
            display = treeRowData.display;
        }
        const displayStyle = display ? null : {
            display: "none"
        };
        return _vue.h("tr", {
            style: [
                displayStyle,
                getRowStyle(row, $index)
            ],
            class: rowClasses,
            key: getKeyOfRow(row, $index),
            onDblclick: ($event)=>handleDoubleClick($event, row)
            ,
            onClick: ($event)=>handleClick($event, row)
            ,
            onContextmenu: ($event)=>handleContextMenu($event, row)
            ,
            onMouseenter: ()=>handleMouseEnter($index)
            ,
            onMouseleave: handleMouseLeave
        }, columns.value.map((column, cellIndex)=>{
            const { rowspan , colspan  } = getSpan(row, column, $index, cellIndex);
            if (!rowspan || !colspan) return null;
            const columnData = {
                ...column
            };
            columnData.realWidth = getColspanRealWidth(columns.value, colspan, cellIndex);
            const data = {
                store: props.store,
                _self: props.context || parent,
                column: columnData,
                row,
                $index
            };
            if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
                data.treeNode = {
                    indent: treeRowData.level * indent.value,
                    level: treeRowData.level
                };
                if (typeof treeRowData.expanded === "boolean") {
                    data.treeNode.expanded = treeRowData.expanded;
                    if ("loading" in treeRowData) data.treeNode.loading = treeRowData.loading;
                    if ("noLazyChildren" in treeRowData) data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
                }
            }
            const baseKey = `${$index},${cellIndex}`;
            const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
            const tdChildren = cellChildren(cellIndex, column, data);
            return _vue.h("td", {
                style: getCellStyle($index, cellIndex, row, column),
                class: getCellClass($index, cellIndex, row, column),
                key: `${patchKey}${baseKey}`,
                rowspan,
                colspan,
                onMouseenter: ($event)=>handleCellMouseEnter($event, {
                        ...row,
                        tooltipEffect
                    })
                ,
                onMouseleave: handleCellMouseLeave
            }, [
                tdChildren
            ]);
        }));
    };
    const cellChildren = (cellIndex, column, data)=>{
        return column.renderCell(data);
    };
    const wrappedRowRender = (row, $index)=>{
        const store = props.store;
        const { isRowExpanded , assertRowKey  } = store;
        const { treeData , lazyTreeNodeMap , childrenColumnName , rowKey  } = store.states;
        const hasExpandColumn = store.states.columns.value.some(({ type  })=>type === "expand"
        );
        if (hasExpandColumn && isRowExpanded(row)) {
            const renderExpanded = parent.renderExpanded;
            const tr = rowRender(row, $index, void 0);
            if (!renderExpanded) {
                console.error("[Element Error]renderExpanded is required.");
                return tr;
            }
            return [
                [
                    tr,
                    _vue.h("tr", {
                        key: `expanded-row__${tr.key}`
                    }, [
                        _vue.h("td", {
                            colspan: store.states.columns.value.length,
                            class: "el-table__cell el-table__expanded-cell"
                        }, [
                            renderExpanded({
                                row,
                                $index,
                                store
                            })
                        ])
                    ])
                ]
            ];
        } else if (Object.keys(treeData.value).length) {
            assertRowKey();
            const key = _utilMjs.getRowIdentity(row, rowKey.value);
            let cur = treeData.value[key];
            let treeRowData = null;
            if (cur) {
                treeRowData = {
                    expanded: cur.expanded,
                    level: cur.level,
                    display: true
                };
                if (typeof cur.lazy === "boolean") {
                    if (typeof cur.loaded === "boolean" && cur.loaded) treeRowData.noLazyChildren = !(cur.children && cur.children.length);
                    treeRowData.loading = cur.loading;
                }
            }
            const tmp = [
                rowRender(row, $index, treeRowData)
            ];
            if (cur) {
                let i = 0;
                const traverse = (children, parent2)=>{
                    if (!(children && children.length && parent2)) return;
                    children.forEach((node)=>{
                        const innerTreeRowData = {
                            display: parent2.display && parent2.expanded,
                            level: parent2.level + 1,
                            expanded: false,
                            noLazyChildren: false,
                            loading: false
                        };
                        const childKey = _utilMjs.getRowIdentity(node, rowKey.value);
                        if (childKey === void 0 || childKey === null) throw new Error("For nested data item, row-key is required.");
                        cur = {
                            ...treeData.value[childKey]
                        };
                        if (cur) {
                            innerTreeRowData.expanded = cur.expanded;
                            cur.level = cur.level || innerTreeRowData.level;
                            cur.display = !!(cur.expanded && innerTreeRowData.display);
                            if (typeof cur.lazy === "boolean") {
                                if (typeof cur.loaded === "boolean" && cur.loaded) innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                                innerTreeRowData.loading = cur.loading;
                            }
                        }
                        i++;
                        tmp.push(rowRender(node, $index + i, innerTreeRowData));
                        if (cur) {
                            const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
                            traverse(nodes2, cur);
                        }
                    });
                };
                cur.display = true;
                const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
                traverse(nodes, cur);
            }
            return tmp;
        } else return rowRender(row, $index, void 0);
    };
    return {
        wrappedRowRender,
        tooltipContent,
        tooltipTrigger
    };
}

},{"vue":"gzxs9","../util.mjs":"isd9T","../tokens.mjs":"cGfBP","./events-helper.mjs":"5qDLz","./styles-helper.mjs":"6uRn7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5qDLz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useEvents
);
var _vue = require("vue");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../../utils/index.mjs");
var _utilMjs = require("../util.mjs");
var _tokensMjs = require("../tokens.mjs");
var _styleMjs = require("../../../../utils/dom/style.mjs");
function useEvents(props) {
    const parent = _vue.inject(_tokensMjs.TABLE_INJECTION_KEY);
    const tooltipContent = _vue.ref("");
    const tooltipTrigger = _vue.ref(_vue.h("div"));
    const handleEvent = (event, row, name)=>{
        var _a;
        const table = parent;
        const cell = _utilMjs.getCell(event);
        let column;
        const namespace = (_a = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a.dataset.prefix;
        if (cell) {
            column = _utilMjs.getColumnByCell({
                columns: props.store.states.columns.value
            }, cell, namespace);
            if (column) table == null || table.emit(`cell-${name}`, row, column, cell, event);
        }
        table == null || table.emit(`row-${name}`, row, column, event);
    };
    const handleDoubleClick = (event, row)=>{
        handleEvent(event, row, "dblclick");
    };
    const handleClick = (event, row)=>{
        props.store.commit("setCurrentRow", row);
        handleEvent(event, row, "click");
    };
    const handleContextMenu = (event, row)=>{
        handleEvent(event, row, "contextmenu");
    };
    const handleMouseEnter = _lodashUnified.debounce(function(index) {
        props.store.commit("setHoverRow", index);
    }, 30);
    const handleMouseLeave = _lodashUnified.debounce(function() {
        props.store.commit("setHoverRow", null);
    }, 30);
    const handleCellMouseEnter = (event, row)=>{
        var _a;
        const table = parent;
        const cell = _utilMjs.getCell(event);
        const namespace = (_a = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a.dataset.prefix;
        if (cell) {
            const column = _utilMjs.getColumnByCell({
                columns: props.store.states.columns.value
            }, cell, namespace);
            const hoverState = table.hoverState = {
                cell,
                column,
                row
            };
            table == null || table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
        }
        const cellChild = event.target.querySelector(".cell");
        if (!(_styleMjs.hasClass(cellChild, `${namespace}-tooltip`) && cellChild.childNodes.length)) return;
        const range = document.createRange();
        range.setStart(cellChild, 0);
        range.setEnd(cellChild, cellChild.childNodes.length);
        const rangeWidth = range.getBoundingClientRect().width;
        const padding = (parseInt(_styleMjs.getStyle(cellChild, "paddingLeft"), 10) || 0) + (parseInt(_styleMjs.getStyle(cellChild, "paddingRight"), 10) || 0);
        if (rangeWidth + padding > cellChild.offsetWidth || cellChild.scrollWidth > cellChild.offsetWidth) _utilMjs.createTablePopper(cell, cell.innerText || cell.textContent, {
            placement: "top",
            strategy: "fixed"
        }, row.tooltipEffect);
    };
    const handleCellMouseLeave = (event)=>{
        const cell = _utilMjs.getCell(event);
        if (!cell) return;
        const oldHoverState = parent == null ? void 0 : parent.hoverState;
        parent == null || parent.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
    };
    return {
        handleDoubleClick,
        handleClick,
        handleContextMenu,
        handleMouseEnter,
        handleMouseLeave,
        handleCellMouseEnter,
        handleCellMouseLeave,
        tooltipContent,
        tooltipTrigger
    };
}

},{"vue":"gzxs9","lodash-unified":"4Oj4p","../../../../utils/index.mjs":"dsdeP","../util.mjs":"isd9T","../tokens.mjs":"cGfBP","../../../../utils/dom/style.mjs":"cA8Mp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6uRn7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useStyles
);
var _vue = require("vue");
var _indexMjs = require("../../../../hooks/index.mjs");
var _utilMjs = require("../util.mjs");
var _tokensMjs = require("../tokens.mjs");
var _indexMjs1 = require("../../../../hooks/use-namespace/index.mjs");
function useStyles(props) {
    const parent = _vue.inject(_tokensMjs.TABLE_INJECTION_KEY);
    const ns = _indexMjs1.useNamespace("table");
    const getRowStyle = (row, rowIndex)=>{
        const rowStyle = parent == null ? void 0 : parent.props.rowStyle;
        if (typeof rowStyle === "function") return rowStyle.call(null, {
            row,
            rowIndex
        });
        return rowStyle || null;
    };
    const getRowClass = (row, rowIndex)=>{
        const classes = [
            ns.e("row")
        ];
        if ((parent == null ? void 0 : parent.props.highlightCurrentRow) && row === props.store.states.currentRow.value) classes.push("current-row");
        if (props.stripe && rowIndex % 2 === 1) classes.push(ns.em("row", "striped"));
        const rowClassName = parent == null ? void 0 : parent.props.rowClassName;
        if (typeof rowClassName === "string") classes.push(rowClassName);
        else if (typeof rowClassName === "function") classes.push(rowClassName.call(null, {
            row,
            rowIndex
        }));
        if (props.store.states.expandRows.value.indexOf(row) > -1) classes.push("expanded");
        return classes;
    };
    const getCellStyle = (rowIndex, columnIndex, row, column)=>{
        const cellStyle = parent == null ? void 0 : parent.props.cellStyle;
        let cellStyles = cellStyle != null ? cellStyle : {
        };
        if (typeof cellStyle === "function") cellStyles = cellStyle.call(null, {
            rowIndex,
            columnIndex,
            row,
            column
        });
        const fixedStyle = column.isSubColumn ? null : _utilMjs.getFixedColumnOffset(columnIndex, props == null ? void 0 : props.fixed, props.store);
        _utilMjs.ensurePosition(fixedStyle, "left");
        _utilMjs.ensurePosition(fixedStyle, "right");
        return Object.assign({
        }, cellStyles, fixedStyle);
    };
    const getCellClass = (rowIndex, columnIndex, row, column)=>{
        const fixedClasses = column.isSubColumn ? [] : _utilMjs.getFixedColumnsClass(ns.b(), columnIndex, props == null ? void 0 : props.fixed, props.store);
        const classes = [
            column.id,
            column.align,
            column.className,
            ...fixedClasses
        ];
        const cellClassName = parent == null ? void 0 : parent.props.cellClassName;
        if (typeof cellClassName === "string") classes.push(cellClassName);
        else if (typeof cellClassName === "function") classes.push(cellClassName.call(null, {
            rowIndex,
            columnIndex,
            row,
            column
        }));
        classes.push(ns.e("cell"));
        return classes.join(" ");
    };
    const getSpan = (row, column, rowIndex, columnIndex)=>{
        let rowspan = 1;
        let colspan = 1;
        const fn = parent == null ? void 0 : parent.props.spanMethod;
        if (typeof fn === "function") {
            const result = fn({
                row,
                column,
                rowIndex,
                columnIndex
            });
            if (Array.isArray(result)) {
                rowspan = result[0];
                colspan = result[1];
            } else if (typeof result === "object") {
                rowspan = result.rowspan;
                colspan = result.colspan;
            }
        }
        return {
            rowspan,
            colspan
        };
    };
    const getColspanRealWidth = (columns, colspan, index)=>{
        if (colspan < 1) return columns[index].realWidth;
        const widthArr = columns.map(({ realWidth , width  })=>realWidth || width
        ).slice(index, index + colspan);
        return Number(widthArr.reduce((acc, width)=>Number(acc) + Number(width)
        , -1));
    };
    return {
        getRowStyle,
        getRowClass,
        getCellStyle,
        getCellClass,
        getSpan,
        getColspanRealWidth
    };
}

},{"vue":"gzxs9","../../../../hooks/index.mjs":"1Ansp","../util.mjs":"isd9T","../tokens.mjs":"cGfBP","../../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3YhAi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>defaultProps
);
const defaultProps = {
    store: {
        required: true,
        type: Object
    },
    stripe: Boolean,
    tooltipEffect: String,
    context: {
        default: ()=>({
            })
        ,
        type: Object
    },
    rowClassName: [
        String,
        Function
    ],
    rowStyle: [
        Object,
        Function
    ],
    fixed: {
        type: String,
        default: ""
    },
    highlight: Boolean
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2rpOC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TableFooter
);
var _vue = require("vue");
var _indexMjs = require("../../../../hooks/index.mjs");
var _hHelperMjs = require("../h-helper.mjs");
var _styleHelperMjs = require("./style-helper.mjs");
var _styleHelperMjsDefault = parcelHelpers.interopDefault(_styleHelperMjs);
var _indexMjs1 = require("../../../../hooks/use-namespace/index.mjs");
var TableFooter = _vue.defineComponent({
    name: "ElTableFooter",
    props: {
        fixed: {
            type: String,
            default: ""
        },
        store: {
            required: true,
            type: Object
        },
        summaryMethod: Function,
        sumText: String,
        border: Boolean,
        defaultSort: {
            type: Object,
            default: ()=>{
                return {
                    prop: "",
                    order: ""
                };
            }
        }
    },
    setup (props) {
        const { getCellClasses , getCellStyles , columns  } = _styleHelperMjsDefault.default(props);
        const ns = _indexMjs1.useNamespace("table");
        return {
            ns,
            getCellClasses,
            getCellStyles,
            columns
        };
    },
    render () {
        const { columns , getCellStyles , getCellClasses , summaryMethod , sumText , ns  } = this;
        const data = this.store.states.data.value;
        let sums = [];
        if (summaryMethod) sums = summaryMethod({
            columns,
            data
        });
        else columns.forEach((column, index)=>{
            if (index === 0) {
                sums[index] = sumText;
                return;
            }
            const values = data.map((item)=>Number(item[column.property])
            );
            const precisions = [];
            let notNumber = true;
            values.forEach((value)=>{
                if (!isNaN(value)) {
                    notNumber = false;
                    const decimal = `${value}`.split(".")[1];
                    precisions.push(decimal ? decimal.length : 0);
                }
            });
            const precision = Math.max.apply(null, precisions);
            if (!notNumber) sums[index] = values.reduce((prev, curr)=>{
                const value = Number(curr);
                if (!isNaN(value)) return parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
                else return prev;
            }, 0);
            else sums[index] = "";
        });
        return _vue.h("table", {
            class: ns.e("footer"),
            cellspacing: "0",
            cellpadding: "0",
            border: "0"
        }, [
            _hHelperMjs.hColgroup(columns),
            _vue.h("tbody", [
                _vue.h("tr", {
                }, [
                    ...columns.map((column, cellIndex)=>_vue.h("td", {
                            key: cellIndex,
                            colspan: column.colSpan,
                            rowspan: column.rowSpan,
                            class: getCellClasses(columns, cellIndex),
                            style: getCellStyles(column, cellIndex)
                        }, [
                            _vue.h("div", {
                                class: [
                                    "cell",
                                    column.labelClassName
                                ]
                            }, [
                                sums[cellIndex]
                            ])
                        ])
                    )
                ])
            ])
        ]);
    }
});

},{"vue":"gzxs9","../../../../hooks/index.mjs":"1Ansp","../h-helper.mjs":"33tBo","./style-helper.mjs":"ak6C5","../../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"33tBo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hColgroup", ()=>hColgroup
);
var _vue = require("vue");
function hColgroup(props) {
    const isAuto = props.tableLayout === "auto";
    let columns = props.columns || [];
    if (isAuto) {
        if (columns.every((column)=>column.width === void 0
        )) columns = [];
    }
    const getPropsData = (column)=>{
        const propsData = {
            key: `${props.tableLayout}_${column.id}`,
            style: {
            },
            name: void 0
        };
        if (isAuto) propsData.style = {
            width: `${column.width}px`
        };
        else propsData.name = column.id;
        return propsData;
    };
    return _vue.h("colgroup", {
    }, columns.map((column)=>_vue.h("col", getPropsData(column))
    ));
}
hColgroup.props = [
    "columns",
    "tableLayout"
];

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ak6C5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useStyle
);
var _indexMjs = require("../../../../hooks/index.mjs");
var _utilMjs = require("../util.mjs");
var _mapStateHelperMjs = require("./mapState-helper.mjs");
var _mapStateHelperMjsDefault = parcelHelpers.interopDefault(_mapStateHelperMjs);
var _indexMjs1 = require("../../../../hooks/use-namespace/index.mjs");
function useStyle(props) {
    const { columns  } = _mapStateHelperMjsDefault.default();
    const ns = _indexMjs1.useNamespace("table");
    const getCellClasses = (columns2, cellIndex)=>{
        const column = columns2[cellIndex];
        const classes = [
            ns.e("cell"),
            column.id,
            column.align,
            column.labelClassName,
            ..._utilMjs.getFixedColumnsClass(ns.b(), cellIndex, column.fixed, props.store)
        ];
        if (column.className) classes.push(column.className);
        if (!column.children) classes.push(ns.is("leaf"));
        return classes;
    };
    const getCellStyles = (column, cellIndex)=>{
        const fixedStyle = _utilMjs.getFixedColumnOffset(cellIndex, column.fixed, props.store);
        _utilMjs.ensurePosition(fixedStyle, "left");
        _utilMjs.ensurePosition(fixedStyle, "right");
        return fixedStyle;
    };
    return {
        getCellClasses,
        getCellStyles,
        columns
    };
}

},{"../../../../hooks/index.mjs":"1Ansp","../util.mjs":"isd9T","./mapState-helper.mjs":"dbOjs","../../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dbOjs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useMapState
);
var _vue = require("vue");
var _tokensMjs = require("../tokens.mjs");
function useMapState() {
    const table = _vue.inject(_tokensMjs.TABLE_INJECTION_KEY);
    const store = table == null ? void 0 : table.store;
    const leftFixedLeafCount = _vue.computed(()=>{
        return store.states.fixedLeafColumnsLength.value;
    });
    const rightFixedLeafCount = _vue.computed(()=>{
        return store.states.rightFixedColumns.value.length;
    });
    const columnsCount = _vue.computed(()=>{
        return store.states.columns.value.length;
    });
    const leftFixedCount = _vue.computed(()=>{
        return store.states.fixedColumns.value.length;
    });
    const rightFixedCount = _vue.computed(()=>{
        return store.states.rightFixedColumns.value.length;
    });
    return {
        leftFixedLeafCount,
        rightFixedLeafCount,
        columnsCount,
        leftFixedCount,
        rightFixedCount,
        columns: store.states.columns
    };
}

},{"vue":"gzxs9","../tokens.mjs":"cGfBP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hFYbt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useUtils
);
function useUtils(store) {
    const setCurrentRow = (row)=>{
        store.commit("setCurrentRow", row);
    };
    const toggleRowSelection = (row, selected)=>{
        store.toggleRowSelection(row, selected, false);
        store.updateAllSelected();
    };
    const clearSelection = ()=>{
        store.clearSelection();
    };
    const clearFilter = (columnKeys)=>{
        store.clearFilter(columnKeys);
    };
    const toggleAllSelection = ()=>{
        store.commit("toggleAllSelection");
    };
    const toggleRowExpansion = (row, expanded)=>{
        store.toggleRowExpansionAdapter(row, expanded);
    };
    const clearSort = ()=>{
        store.clearSort();
    };
    const sort = (prop, order)=>{
        store.commit("sort", {
            prop,
            order
        });
    };
    return {
        setCurrentRow,
        toggleRowSelection,
        clearSelection,
        clearFilter,
        toggleAllSelection,
        toggleRowExpansion,
        clearSort,
        sort
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3o8Uq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useStyle
);
var _vue = require("vue");
var _indexMjs = require("../../../../utils/index.mjs");
var _indexMjs1 = require("../../../../hooks/index.mjs");
var _utilMjs = require("../util.mjs");
var _resizeEventMjs = require("../../../../utils/dom/resize-event.mjs");
var _eventMjs = require("../../../../utils/dom/event.mjs");
var _indexMjs2 = require("../../../../hooks/use-common-props/index.mjs");
var _shared = require("@vue/shared");
var _core = require("@vueuse/core");
function useStyle(props, layout, store, table) {
    const isHidden = _vue.ref(false);
    const renderExpanded = _vue.ref(null);
    const resizeProxyVisible = _vue.ref(false);
    const setDragVisible = (visible)=>{
        resizeProxyVisible.value = visible;
    };
    const resizeState = _vue.ref({
        width: null,
        height: null
    });
    const isGroup = _vue.ref(false);
    _vue.watchEffect(()=>{
        layout.setHeight(props.height);
    });
    _vue.watchEffect(()=>{
        layout.setMaxHeight(props.maxHeight);
    });
    _vue.watch(()=>[
            props.currentRowKey,
            store.states.rowKey
        ]
    , ([currentRowKey, rowKey])=>{
        if (!_vue.unref(rowKey)) return;
        store.setCurrentRowKey(`${currentRowKey}`);
    }, {
        immediate: true
    });
    _vue.watch(()=>props.data
    , (data)=>{
        table.store.commit("setData", data);
    }, {
        immediate: true,
        deep: true
    });
    _vue.watchEffect(()=>{
        if (props.expandRowKeys) store.setExpandRowKeysAdapter(props.expandRowKeys);
    });
    const handleMouseLeave = ()=>{
        table.store.commit("setHoverRow", null);
        if (table.hoverState) table.hoverState = null;
    };
    const handleHeaderFooterMousewheel = (event, data)=>{
        const { pixelX , pixelY  } = data;
        if (Math.abs(pixelX) >= Math.abs(pixelY)) table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
    };
    const shouldUpdateHeight = _vue.computed(()=>{
        return props.height || props.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
    });
    const tableBodyStyles = _vue.computed(()=>{
        return {
            width: layout.bodyWidth.value ? `${layout.bodyWidth.value}px` : ""
        };
    });
    const doLayout = ()=>{
        if (shouldUpdateHeight.value) layout.updateElsHeight();
        layout.updateColumnsWidth();
        requestAnimationFrame(syncPostion);
    };
    _vue.onMounted(async ()=>{
        setScrollClass("is-scrolling-left");
        store.updateColumns();
        await _vue.nextTick();
        bindEvents();
        requestAnimationFrame(doLayout);
        resizeState.value = {
            width: table.vnode.el.offsetWidth,
            height: table.vnode.el.offsetHeight
        };
        store.states.columns.value.forEach((column)=>{
            if (column.filteredValue && column.filteredValue.length) table.store.commit("filterChange", {
                column,
                values: column.filteredValue,
                silent: true
            });
        });
        table.$ready = true;
    });
    const setScrollClassByEl = (el, className)=>{
        if (!el) return;
        const classList = Array.from(el.classList).filter((item)=>!item.startsWith("is-scrolling-")
        );
        classList.push(layout.scrollX.value ? className : "is-scrolling-none");
        el.className = classList.join(" ");
    };
    const setScrollClass = (className)=>{
        const { tableWrapper  } = table.refs;
        setScrollClassByEl(tableWrapper, className);
    };
    const syncPostion = function() {
        if (!table.refs.scrollWrapper) return;
        const scrollContainer = table.refs.scrollWrapper.wrap$;
        if (!scrollContainer) return;
        const { scrollLeft , offsetWidth , scrollWidth  } = scrollContainer;
        const { headerWrapper , footerWrapper  } = table.refs;
        if (headerWrapper) headerWrapper.scrollLeft = scrollLeft;
        if (footerWrapper) footerWrapper.scrollLeft = scrollLeft;
        const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
        if (scrollLeft >= maxScrollLeftPosition) setScrollClass("is-scrolling-right");
        else if (scrollLeft === 0) setScrollClass("is-scrolling-left");
        else setScrollClass("is-scrolling-middle");
    };
    const bindEvents = ()=>{
        var _a;
        if (!table.refs.scrollWrapper) return;
        (_a = table.refs.scrollWrapper.wrap$) == null || _a.addEventListener("scroll", syncPostion, {
            passive: true
        });
        if (props.fit) _resizeEventMjs.addResizeListener(table.vnode.el, resizeListener);
        else _eventMjs.on(window, "resize", doLayout);
    };
    _vue.onBeforeUnmount(()=>{
        unbindEvents();
    });
    const unbindEvents = ()=>{
        var _a;
        (_a = table.refs.scrollWrapper.wrap$) == null || _a.removeEventListener("scroll", syncPostion, true);
        if (props.fit) _resizeEventMjs.removeResizeListener(table.vnode.el, resizeListener);
        else _eventMjs.off(window, "resize", doLayout);
    };
    const resizeListener = ()=>{
        if (!table.$ready) return;
        let shouldUpdateLayout = false;
        const el = table.vnode.el;
        const { width: oldWidth , height: oldHeight  } = resizeState.value;
        const width = el.offsetWidth;
        if (oldWidth !== width) shouldUpdateLayout = true;
        const height2 = el.offsetHeight;
        if ((props.height || shouldUpdateHeight.value) && oldHeight !== height2) shouldUpdateLayout = true;
        if (shouldUpdateLayout) {
            resizeState.value = {
                width,
                height: height2
            };
            doLayout();
        }
    };
    const tableSize = _indexMjs2.useSize();
    const bodyWidth = _vue.computed(()=>{
        const { bodyWidth: bodyWidth_ , scrollY , gutterWidth  } = layout;
        return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
    });
    const tableLayout = _vue.computed(()=>{
        if (props.maxHeight) return "fixed";
        return props.tableLayout;
    });
    function calcMaxHeight(maxHeight, footerHeight, headerHeight) {
        const parsedMaxHeight = _utilMjs.parseHeight(maxHeight);
        const tableHeaderHeight = props.showHeader ? headerHeight : 0;
        if (parsedMaxHeight === null) return;
        if (_shared.isString(parsedMaxHeight)) return `calc(${parsedMaxHeight} - ${footerHeight}px - ${tableHeaderHeight}px)`;
        return parsedMaxHeight - footerHeight - tableHeaderHeight;
    }
    const height = _vue.computed(()=>{
        const headerHeight = layout.headerHeight.value || 0;
        const bodyHeight2 = layout.bodyHeight.value;
        const footerHeight = layout.footerHeight.value || 0;
        if (props.height) return bodyHeight2 ? bodyHeight2 : void 0;
        else if (props.maxHeight) return calcMaxHeight(props.maxHeight, footerHeight, headerHeight);
        return void 0;
    });
    const bodyHeight = _vue.computed(()=>{
        const headerHeight = layout.headerHeight.value || 0;
        const bodyHeight2 = layout.bodyHeight.value;
        const footerHeight = layout.footerHeight.value || 0;
        if (props.height) return {
            height: bodyHeight2 ? `${bodyHeight2}px` : ""
        };
        else if (props.maxHeight) {
            const maxHeight = calcMaxHeight(props.maxHeight, footerHeight, headerHeight);
            if (maxHeight !== null) return {
                "max-height": `${maxHeight}${_core.isNumber(maxHeight) ? "px" : ""}`
            };
        }
        return {
        };
    });
    const emptyBlockStyle = _vue.computed(()=>{
        if (props.data && props.data.length) return null;
        let height2 = "100%";
        if (layout.appendHeight.value) height2 = `calc(100% - ${layout.appendHeight.value}px)`;
        return {
            width: bodyWidth.value,
            height: height2
        };
    });
    const handleFixedMousewheel = (event, data)=>{
        const bodyWrapper = table.refs.bodyWrapper;
        if (Math.abs(data.spinY) > 0) {
            const currentScrollTop = bodyWrapper.scrollTop;
            if (data.pixelY < 0 && currentScrollTop !== 0) event.preventDefault();
            if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) event.preventDefault();
            bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
        } else bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
    };
    const fixedHeight = _vue.computed(()=>{
        if (props.maxHeight) {
            if (props.showSummary) return {
                bottom: 0
            };
            return {
                bottom: layout.scrollX.value && props.data.length ? `${layout.gutterWidth}px` : ""
            };
        } else {
            if (props.showSummary) return {
                height: layout.tableHeight.value ? `${layout.tableHeight.value}px` : ""
            };
            return {
                height: layout.viewportHeight.value ? `${layout.viewportHeight.value}px` : ""
            };
        }
    });
    const fixedBodyHeight = _vue.computed(()=>{
        if (props.height) return {
            height: layout.fixedBodyHeight.value ? `${layout.fixedBodyHeight.value}px` : ""
        };
        else if (props.maxHeight) {
            let maxHeight = _utilMjs.parseHeight(props.maxHeight);
            if (typeof maxHeight === "number") {
                maxHeight = layout.scrollX.value ? maxHeight - layout.gutterWidth : maxHeight;
                if (props.showHeader) maxHeight -= layout.headerHeight.value;
                maxHeight -= layout.footerHeight.value;
                return {
                    "max-height": `${maxHeight}px`
                };
            }
        }
        return {
        };
    });
    return {
        isHidden,
        renderExpanded,
        setDragVisible,
        isGroup,
        handleMouseLeave,
        handleHeaderFooterMousewheel,
        tableSize,
        bodyHeight,
        height,
        emptyBlockStyle,
        handleFixedMousewheel,
        fixedHeight,
        fixedBodyHeight,
        resizeProxyVisible,
        bodyWidth,
        resizeState,
        doLayout,
        tableBodyStyles,
        tableLayout
    };
}

},{"vue":"gzxs9","../../../../utils/index.mjs":"dsdeP","../../../../hooks/index.mjs":"1Ansp","../util.mjs":"isd9T","../../../../utils/dom/resize-event.mjs":"TzEEU","../../../../utils/dom/event.mjs":"fnXSh","../../../../hooks/use-common-props/index.mjs":"05czU","@vue/shared":"3SM3y","@vueuse/core":"eEHP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7x6Fm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>defaultProps
);
var defaultProps = {
    data: {
        type: Array,
        default: ()=>{
            return [];
        }
    },
    size: String,
    width: [
        String,
        Number
    ],
    height: [
        String,
        Number
    ],
    maxHeight: [
        String,
        Number
    ],
    fit: {
        type: Boolean,
        default: true
    },
    stripe: Boolean,
    border: Boolean,
    rowKey: [
        String,
        Function
    ],
    showHeader: {
        type: Boolean,
        default: true
    },
    showSummary: Boolean,
    sumText: String,
    summaryMethod: Function,
    rowClassName: [
        String,
        Function
    ],
    rowStyle: [
        Object,
        Function
    ],
    cellClassName: [
        String,
        Function
    ],
    cellStyle: [
        Object,
        Function
    ],
    headerRowClassName: [
        String,
        Function
    ],
    headerRowStyle: [
        Object,
        Function
    ],
    headerCellClassName: [
        String,
        Function
    ],
    headerCellStyle: [
        Object,
        Function
    ],
    highlightCurrentRow: Boolean,
    currentRowKey: [
        String,
        Number
    ],
    emptyText: String,
    expandRowKeys: Array,
    defaultExpandAll: Boolean,
    defaultSort: Object,
    tooltipEffect: String,
    spanMethod: Function,
    selectOnIndeterminate: {
        type: Boolean,
        default: true
    },
    indent: {
        type: Number,
        default: 16
    },
    treeProps: {
        type: Object,
        default: ()=>{
            return {
                hasChildren: "hasChildren",
                children: "children"
            };
        }
    },
    lazy: Boolean,
    load: Function,
    style: {
        type: Object,
        default: ()=>({
            })
    },
    className: {
        type: String,
        default: ""
    },
    tableLayout: {
        type: String,
        default: "fixed"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jsBSi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_indexMjsDefault.default
);
var _indexMjs = require("./table-column/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);

},{"./table-column/index.mjs":"bU6Xf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bU6Xf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElTableColumn
);
var _vue = require("vue");
var _indexMjs = require("../../../checkbox/index.mjs");
var _configMjs = require("../config.mjs");
var _utilMjs = require("../util.mjs");
var _watcherHelperMjs = require("./watcher-helper.mjs");
var _watcherHelperMjsDefault = parcelHelpers.interopDefault(_watcherHelperMjs);
var _renderHelperMjs = require("./render-helper.mjs");
var _renderHelperMjsDefault = parcelHelpers.interopDefault(_renderHelperMjs);
var _defaultsMjs = require("./defaults.mjs");
var _defaultsMjsDefault = parcelHelpers.interopDefault(_defaultsMjs);
let columnIdSeed = 1;
var ElTableColumn = _vue.defineComponent({
    name: "ElTableColumn",
    components: {
        ElCheckbox: _indexMjs.ElCheckbox
    },
    props: _defaultsMjsDefault.default,
    setup (props, { slots  }) {
        const instance = _vue.getCurrentInstance();
        const columnConfig = _vue.ref({
        });
        const owner = _vue.computed(()=>{
            let parent2 = instance.parent;
            while(parent2 && !parent2.tableId)parent2 = parent2.parent;
            return parent2;
        });
        const { registerNormalWatchers , registerComplexWatchers  } = _watcherHelperMjsDefault.default(owner, props);
        const { columnId , isSubColumn , realHeaderAlign , columnOrTableParent , setColumnWidth , setColumnForcedProps , setColumnRenders , getPropsData , getColumnElIndex , realAlign  } = _renderHelperMjsDefault.default(props, slots, owner);
        const parent = columnOrTableParent.value;
        columnId.value = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;
        _vue.onBeforeMount(()=>{
            isSubColumn.value = owner.value !== parent;
            const type = props.type || "default";
            const sortable = props.sortable === "" ? true : props.sortable;
            const defaults = {
                ..._configMjs.cellStarts[type],
                id: columnId.value,
                type,
                property: props.prop || props.property,
                align: realAlign,
                headerAlign: realHeaderAlign,
                showOverflowTooltip: props.showOverflowTooltip || props.showTooltipWhenOverflow,
                filterable: props.filters || props.filterMethod,
                filteredValue: [],
                filterPlacement: "",
                isColumnGroup: false,
                isSubColumn: false,
                filterOpened: false,
                sortable,
                index: props.index,
                rawColumnKey: instance.vnode.key
            };
            const basicProps = [
                "columnKey",
                "label",
                "className",
                "labelClassName",
                "type",
                "renderHeader",
                "formatter",
                "fixed",
                "resizable"
            ];
            const sortProps = [
                "sortMethod",
                "sortBy",
                "sortOrders"
            ];
            const selectProps = [
                "selectable",
                "reserveSelection"
            ];
            const filterProps = [
                "filterMethod",
                "filters",
                "filterMultiple",
                "filterOpened",
                "filteredValue",
                "filterPlacement"
            ];
            let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
            column = _utilMjs.mergeOptions(defaults, column);
            const chains = _utilMjs.compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
            column = chains(column);
            columnConfig.value = column;
            registerNormalWatchers();
            registerComplexWatchers();
        });
        _vue.onMounted(()=>{
            var _a;
            const parent2 = columnOrTableParent.value;
            const children = isSubColumn.value ? parent2.vnode.el.children : (_a = parent2.refs.hiddenColumns) == null ? void 0 : _a.children;
            const getColumnIndex = ()=>getColumnElIndex(children || [], instance.vnode.el)
            ;
            columnConfig.value.getColumnIndex = getColumnIndex;
            const columnIndex = getColumnIndex();
            columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null);
        });
        _vue.onBeforeUnmount(()=>{
            owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent.columnConfig.value : null);
        });
        instance.columnId = columnId.value;
        instance.columnConfig = columnConfig;
        return;
    },
    render () {
        var _a, _b, _c;
        let children = [];
        try {
            const renderDefault = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a, {
                row: {
                },
                column: {
                },
                $index: -1
            });
            if (renderDefault instanceof Array) for (const childNode of renderDefault){
                if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn" || childNode.shapeFlag & 2) children.push(childNode);
                else if (childNode.type === _vue.Fragment && childNode.children instanceof Array) children.push(...childNode.children);
            }
        } catch (e) {
            children = [];
        }
        return _vue.h("div", children);
    }
});

},{"vue":"gzxs9","../../../checkbox/index.mjs":"jMNjD","../config.mjs":"dyUSW","../util.mjs":"isd9T","./watcher-helper.mjs":"WIS6o","./render-helper.mjs":"26vNQ","./defaults.mjs":"bbGA6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dyUSW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cellForced", ()=>cellForced
);
parcelHelpers.export(exports, "cellStarts", ()=>cellStarts
);
parcelHelpers.export(exports, "defaultRenderCell", ()=>defaultRenderCell
);
parcelHelpers.export(exports, "getDefaultClassName", ()=>getDefaultClassName
);
parcelHelpers.export(exports, "treeCellPrefix", ()=>treeCellPrefix
);
var _vue = require("vue");
var _indexMjs = require("../../checkbox/index.mjs");
var _indexMjs1 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs2 = require("../../../utils/index.mjs");
var _objectsMjs = require("../../../utils/objects.mjs");
const defaultClassNames = {
    selection: "table-column--selection",
    expand: "table__expand-column"
};
const cellStarts = {
    default: {
        order: ""
    },
    selection: {
        width: 48,
        minWidth: 48,
        realWidth: 48,
        order: ""
    },
    expand: {
        width: 48,
        minWidth: 48,
        realWidth: 48,
        order: ""
    },
    index: {
        width: 48,
        minWidth: 48,
        realWidth: 48,
        order: ""
    }
};
const getDefaultClassName = (type)=>{
    return defaultClassNames[type] || "";
};
const cellForced = {
    selection: {
        renderHeader ({ store  }) {
            function isDisabled() {
                return store.states.data.value && store.states.data.value.length === 0;
            }
            return _vue.h(_indexMjs.ElCheckbox, {
                disabled: isDisabled(),
                size: store.states.tableSize.value,
                indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
                "onUpdate:modelValue": store.toggleAllSelection,
                modelValue: store.states.isAllSelected.value
            });
        },
        renderCell ({ row , column , store , $index  }) {
            return _vue.h(_indexMjs.ElCheckbox, {
                disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
                size: store.states.tableSize.value,
                onChange: ()=>{
                    store.commit("rowSelectedChanged", row);
                },
                onClick: (event)=>event.stopPropagation()
                ,
                modelValue: store.isSelected(row)
            });
        },
        sortable: false,
        resizable: false
    },
    index: {
        renderHeader ({ column  }) {
            return column.label || "#";
        },
        renderCell ({ column , $index  }) {
            let i = $index + 1;
            const index = column.index;
            if (typeof index === "number") i = $index + index;
            else if (typeof index === "function") i = index($index);
            return _vue.h("div", {
            }, [
                i
            ]);
        },
        sortable: false
    },
    expand: {
        renderHeader ({ column  }) {
            return column.label || "";
        },
        renderCell ({ row , store  }) {
            const { ns  } = store;
            const classes = [
                ns.e("expand-icon")
            ];
            if (store.states.expandRows.value.indexOf(row) > -1) classes.push(ns.em("expand-icon", "expanded"));
            const callback = function(e) {
                e.stopPropagation();
                store.toggleRowExpansion(row);
            };
            return _vue.h("div", {
                class: classes,
                onClick: callback
            }, {
                default: ()=>{
                    return [
                        _vue.h(_indexMjs1.ElIcon, null, {
                            default: ()=>{
                                return [
                                    _vue.h(_iconsVue.ArrowRight)
                                ];
                            }
                        })
                    ];
                }
            });
        },
        sortable: false,
        resizable: false
    }
};
function defaultRenderCell({ row , column , $index  }) {
    var _a;
    const property = column.property;
    const value = property && _objectsMjs.getPropByPath(row, property, false).v;
    if (column && column.formatter) return column.formatter(row, column, value, $index);
    return ((_a = value == null ? void 0 : value.toString) == null ? void 0 : _a.call(value)) || "";
}
function treeCellPrefix({ row , treeNode , store  }) {
    if (!treeNode) return null;
    const ele = [];
    const callback = function(e) {
        e.stopPropagation();
        store.loadOrToggle(row);
    };
    const { ns  } = store;
    if (treeNode.indent) ele.push(_vue.h("span", {
        class: ns.e("indent"),
        style: {
            "padding-left": `${treeNode.indent}px`
        }
    }));
    if (typeof treeNode.expanded === "boolean" && !treeNode.noLazyChildren) {
        const expandClasses = [
            ns.e("expand-icon"),
            treeNode.expanded ? ns.em("expand-icon", "expanded") : ""
        ];
        let icon = _iconsVue.ArrowRight;
        if (treeNode.loading) icon = _iconsVue.Loading;
        ele.push(_vue.h("div", {
            class: expandClasses,
            onClick: callback
        }, {
            default: ()=>{
                return [
                    _vue.h(_indexMjs1.ElIcon, {
                        class: {
                            [ns.is("loading")]: treeNode.loading
                        }
                    }, {
                        default: ()=>[
                                _vue.h(icon)
                            ]
                    })
                ];
            }
        }));
    } else ele.push(_vue.h("span", {
        class: ns.e("placeholder")
    }));
    return ele;
}

},{"vue":"gzxs9","../../checkbox/index.mjs":"jMNjD","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../utils/index.mjs":"dsdeP","../../../utils/objects.mjs":"1tXXV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"WIS6o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useWatcher
);
var _vue = require("vue");
var _indexMjs = require("../../../../utils/index.mjs");
var _utilMjs = require("../util.mjs");
var _shared = require("@vue/shared");
function useWatcher(owner, props_) {
    const instance = _vue.getCurrentInstance();
    const registerComplexWatchers = ()=>{
        const props = [
            "fixed"
        ];
        const aliases = {
            realWidth: "width",
            realMinWidth: "minWidth"
        };
        const allAliases = props.reduce((prev, cur)=>{
            prev[cur] = cur;
            return prev;
        }, aliases);
        Object.keys(allAliases).forEach((key)=>{
            const columnKey = aliases[key];
            if (_shared.hasOwn(props_, columnKey)) _vue.watch(()=>props_[columnKey]
            , (newVal)=>{
                let value = newVal;
                if (columnKey === "width" && key === "realWidth") value = _utilMjs.parseWidth(newVal);
                if (columnKey === "minWidth" && key === "realMinWidth") value = _utilMjs.parseMinWidth(newVal);
                instance.columnConfig.value[columnKey] = value;
                instance.columnConfig.value[key] = value;
                const updateColumns = columnKey === "fixed";
                owner.value.store.scheduleLayout(updateColumns);
            });
        });
    };
    const registerNormalWatchers = ()=>{
        const props = [
            "label",
            "filters",
            "filterMultiple",
            "sortable",
            "index",
            "formatter",
            "className",
            "labelClassName",
            "showOverflowTooltip"
        ];
        const aliases = {
            property: "prop",
            align: "realAlign",
            headerAlign: "realHeaderAlign"
        };
        const allAliases = props.reduce((prev, cur)=>{
            prev[cur] = cur;
            return prev;
        }, aliases);
        Object.keys(allAliases).forEach((key)=>{
            const columnKey = aliases[key];
            if (_shared.hasOwn(props_, columnKey)) _vue.watch(()=>props_[columnKey]
            , (newVal)=>{
                instance.columnConfig.value[key] = newVal;
            });
        });
    };
    return {
        registerComplexWatchers,
        registerNormalWatchers
    };
}

},{"vue":"gzxs9","../../../../utils/index.mjs":"dsdeP","../util.mjs":"isd9T","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"26vNQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useRender
);
var _vue = require("vue");
var _indexMjs = require("../../../../utils/index.mjs");
var _indexMjs1 = require("../../../../hooks/index.mjs");
var _configMjs = require("../config.mjs");
var _utilMjs = require("../util.mjs");
var _indexMjs2 = require("../../../../hooks/use-namespace/index.mjs");
var _errorMjs = require("../../../../utils/error.mjs");
function useRender(props, slots, owner) {
    const instance = _vue.getCurrentInstance();
    const columnId = _vue.ref("");
    const isSubColumn = _vue.ref(false);
    const realAlign = _vue.ref();
    const realHeaderAlign = _vue.ref();
    const ns = _indexMjs2.useNamespace("table");
    _vue.watchEffect(()=>{
        realAlign.value = props.align ? `is-${props.align}` : null;
        realAlign.value;
    });
    _vue.watchEffect(()=>{
        realHeaderAlign.value = props.headerAlign ? `is-${props.headerAlign}` : realAlign.value;
        realHeaderAlign.value;
    });
    const columnOrTableParent = _vue.computed(()=>{
        let parent = instance.vnode.vParent || instance.parent;
        while(parent && !parent.tableId && !parent.columnId)parent = parent.vnode.vParent || parent.parent;
        return parent;
    });
    const realWidth = _vue.ref(_utilMjs.parseWidth(props.width));
    const realMinWidth = _vue.ref(_utilMjs.parseMinWidth(props.minWidth));
    const setColumnWidth = (column)=>{
        if (realWidth.value) column.width = realWidth.value;
        if (realMinWidth.value) column.minWidth = realMinWidth.value;
        if (!column.minWidth) column.minWidth = 80;
        column.realWidth = Number(column.width === void 0 ? column.minWidth : column.width);
        return column;
    };
    const setColumnForcedProps = (column)=>{
        const type = column.type;
        const source = _configMjs.cellForced[type] || {
        };
        Object.keys(source).forEach((prop)=>{
            const value = source[prop];
            if (prop !== "className" && value !== void 0) column[prop] = value;
        });
        const className = _configMjs.getDefaultClassName(type);
        if (className) {
            const forceClass = `${_vue.unref(ns.namespace)}-${className}`;
            column.className = column.className ? `${column.className} ${forceClass}` : forceClass;
        }
        return column;
    };
    const checkSubColumn = (children)=>{
        if (children instanceof Array) children.forEach((child)=>check(child)
        );
        else check(children);
        function check(item) {
            var _a;
            if (((_a = item == null ? void 0 : item.type) == null ? void 0 : _a.name) === "ElTableColumn") item.vParent = instance;
        }
    };
    const setColumnRenders = (column)=>{
        if (props.renderHeader) _errorMjs.debugWarn("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.");
        else if (column.type !== "selection") column.renderHeader = (scope)=>{
            instance.columnConfig.value["label"];
            const renderHeader = slots.header;
            return renderHeader ? renderHeader(scope) : column.label;
        };
        let originRenderCell = column.renderCell;
        if (column.type === "expand") {
            column.renderCell = (data)=>_vue.h("div", {
                    class: "cell"
                }, [
                    originRenderCell(data)
                ])
            ;
            owner.value.renderExpanded = (data)=>{
                return slots.default ? slots.default(data) : slots.default;
            };
        } else {
            originRenderCell = originRenderCell || _configMjs.defaultRenderCell;
            column.renderCell = (data)=>{
                let children = null;
                if (slots.default) children = slots.default(data);
                else children = originRenderCell(data);
                const prefix = _configMjs.treeCellPrefix(data);
                const props2 = {
                    class: "cell",
                    style: {
                    }
                };
                if (column.showOverflowTooltip) {
                    props2.class = `${props2.class} ${_vue.unref(ns.namespace)}-tooltip`;
                    props2.style = {
                        width: `${(data.column.realWidth || Number(data.column.width)) - 1}px`
                    };
                }
                checkSubColumn(children);
                return _vue.h("div", props2, [
                    prefix,
                    children
                ]);
            };
        }
        return column;
    };
    const getPropsData = (...propsKey)=>{
        return propsKey.reduce((prev, cur)=>{
            if (Array.isArray(cur)) cur.forEach((key)=>{
                prev[key] = props[key];
            });
            return prev;
        }, {
        });
    };
    const getColumnElIndex = (children, child)=>{
        return [].indexOf.call(children, child);
    };
    return {
        columnId,
        realAlign,
        isSubColumn,
        realHeaderAlign,
        columnOrTableParent,
        setColumnWidth,
        setColumnForcedProps,
        setColumnRenders,
        getPropsData,
        getColumnElIndex
    };
}

},{"vue":"gzxs9","../../../../utils/index.mjs":"dsdeP","../../../../hooks/index.mjs":"1Ansp","../config.mjs":"dyUSW","../util.mjs":"isd9T","../../../../hooks/use-namespace/index.mjs":"a1pcf","../../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bbGA6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>defaultProps
);
var defaultProps = {
    type: {
        type: String,
        default: "default"
    },
    label: String,
    className: String,
    labelClassName: String,
    property: String,
    prop: String,
    width: {
        type: [
            String,
            Number
        ],
        default: ""
    },
    minWidth: {
        type: [
            String,
            Number
        ],
        default: ""
    },
    renderHeader: Function,
    sortable: {
        type: [
            Boolean,
            String
        ],
        default: false
    },
    sortMethod: Function,
    sortBy: [
        String,
        Function,
        Array
    ],
    resizable: {
        type: Boolean,
        default: true
    },
    columnKey: String,
    align: String,
    headerAlign: String,
    showTooltipWhenOverflow: Boolean,
    showOverflowTooltip: Boolean,
    fixed: [
        Boolean,
        String
    ],
    formatter: Function,
    selectable: Function,
    reserveSelection: Boolean,
    filterMethod: Function,
    filteredValue: Array,
    filters: Array,
    filterPlacement: String,
    filterMultiple: {
        type: Boolean,
        default: true
    },
    index: [
        Number,
        Function
    ],
    sortOrders: {
        type: Array,
        default: ()=>{
            return [
                "ascending",
                "descending",
                null
            ];
        },
        validator: (val)=>{
            return val.every((order)=>[
                    "ascending",
                    "descending",
                    null
                ].indexOf(order) > -1
            );
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3MxUG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tabsEmits", ()=>_tabsMjs.tabsEmits
);
parcelHelpers.export(exports, "tabsProps", ()=>_tabsMjs.tabsProps
);
parcelHelpers.export(exports, "tabBar", ()=>_tabBarMjs.tabBar
);
parcelHelpers.export(exports, "tabNavProps", ()=>_tabNavMjs.tabNavProps
);
parcelHelpers.export(exports, "tabPaneProps", ()=>_tabPaneMjs.tabPaneProps
);
parcelHelpers.export(exports, "ElTabPane", ()=>ElTabPane
);
parcelHelpers.export(exports, "ElTabs", ()=>ElTabs
);
parcelHelpers.export(exports, "default", ()=>ElTabs
);
var _indexMjs = require("../../utils/index.mjs");
var _tabsMjs = require("./src/tabs.mjs");
var _tabsMjsDefault = parcelHelpers.interopDefault(_tabsMjs);
var _tabPane2Mjs = require("./src/tab-pane2.mjs");
var _tabPane2MjsDefault = parcelHelpers.interopDefault(_tabPane2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _tabBarMjs = require("./src/tab-bar.mjs");
var _tabNavMjs = require("./src/tab-nav.mjs");
var _tabPaneMjs = require("./src/tab-pane.mjs");
const ElTabs = _installMjs.withInstall(_tabsMjsDefault.default, {
    TabPane: _tabPane2MjsDefault.default
});
const ElTabPane = _installMjs.withNoopInstall(_tabPane2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/tabs.mjs":"e8i7v","./src/tab-pane2.mjs":"03gdX","../../utils/vue/install.mjs":"4TMmv","./src/tab-bar.mjs":"dhrbU","./src/tab-nav.mjs":"6DFds","./src/tab-pane.mjs":"hD9Q9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e8i7v":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Tabs
);
parcelHelpers.export(exports, "tabsEmits", ()=>tabsEmits
);
parcelHelpers.export(exports, "tabsProps", ()=>tabsProps
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs3 = require("../../../tokens/index.mjs");
var _tabNavMjs = require("./tab-nav.mjs");
var _tabNavMjsDefault = parcelHelpers.interopDefault(_tabNavMjs);
var _propsMjs = require("../../../utils/vue/props.mjs");
var _eventMjs = require("../../../constants/event.mjs");
var _tabsMjs = require("../../../tokens/tabs.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
const tabsProps = _propsMjs.buildProps({
    type: {
        type: String,
        values: [
            "card",
            "border-card",
            ""
        ],
        default: ""
    },
    activeName: {
        type: String,
        default: ""
    },
    closable: Boolean,
    addable: Boolean,
    modelValue: {
        type: [
            String,
            Number
        ],
        default: ""
    },
    editable: Boolean,
    tabPosition: {
        type: String,
        values: [
            "top",
            "right",
            "bottom",
            "left"
        ],
        default: "top"
    },
    beforeLeave: {
        type: _propsMjs.definePropType(Function),
        default: ()=>true
    },
    stretch: Boolean
});
const tabsEmits = {
    [_eventMjs.UPDATE_MODEL_EVENT]: (tabName)=>typeof tabName === "string" || typeof tabName === "number"
    ,
    [_eventMjs.INPUT_EVENT]: (tabName)=>typeof tabName === "string" || typeof tabName === "number"
    ,
    "tab-click": (pane, ev)=>ev instanceof Event
    ,
    edit: (paneName, action)=>action === "remove" || action === "add"
    ,
    "tab-remove": (paneName)=>typeof paneName === "string" || typeof paneName === "number"
    ,
    "tab-add": ()=>true
};
const getPaneInstanceFromSlot = (vnode, paneInstanceList = [])=>{
    const children = vnode.children || [];
    Array.from(children).forEach((node)=>{
        let type = node.type;
        type = type.name || type;
        if (type === "ElTabPane" && node.component) paneInstanceList.push(node.component);
        else if (type === _vue.Fragment || type === "template") getPaneInstanceFromSlot(node, paneInstanceList);
    });
    return paneInstanceList;
};
var Tabs = _vue.defineComponent({
    name: "ElTabs",
    props: tabsProps,
    emits: tabsEmits,
    setup (props, { emit , slots , expose  }) {
        const instance = _vue.getCurrentInstance();
        const nav$ = _vue.ref();
        const panes = _vue.ref([]);
        const currentName = _vue.ref(props.modelValue || props.activeName || "0");
        const paneStatesMap = {
        };
        const updatePaneInstances = (isForceUpdate = false)=>{
            if (slots.default) {
                const children = instance.subTree.children;
                const content = Array.from(children).find(({ props: props2  })=>(props2 == null ? void 0 : props2.class) === "el-tabs__content"
                );
                if (!content) return;
                const paneInstanceList = getPaneInstanceFromSlot(content).map((paneComponent)=>paneStatesMap[paneComponent.uid]
                );
                const panesChanged = !(paneInstanceList.length === panes.value.length && paneInstanceList.every((pane, index)=>pane.uid === panes.value[index].uid
                ));
                if (isForceUpdate || panesChanged) panes.value = paneInstanceList;
            } else if (panes.value.length !== 0) panes.value = [];
        };
        const changeCurrentName = (value)=>{
            currentName.value = value;
            emit(_eventMjs.INPUT_EVENT, value);
            emit(_eventMjs.UPDATE_MODEL_EVENT, value);
        };
        const setCurrentName = (value)=>{
            var _a;
            if (currentName.value === value) return;
            const canLeave = (_a = props.beforeLeave) == null ? void 0 : _a.call(props, value, currentName.value);
            if (_shared.isPromise(canLeave)) canLeave.then(()=>{
                var _a2, _b;
                changeCurrentName(value);
                (_b = (_a2 = nav$.value) == null ? void 0 : _a2.removeFocus) == null || _b.call(_a2);
            }, _shared.NOOP);
            else if (canLeave !== false) changeCurrentName(value);
        };
        const handleTabClick = (tab, tabName, event)=>{
            if (tab.props.disabled) return;
            setCurrentName(tabName);
            emit("tab-click", tab, event);
        };
        const handleTabRemove = (pane, ev)=>{
            if (pane.props.disabled) return;
            ev.stopPropagation();
            emit("edit", pane.props.name, "remove");
            emit("tab-remove", pane.props.name);
        };
        const handleTabAdd = ()=>{
            emit("edit", null, "add");
            emit("tab-add");
        };
        _vue.onUpdated(()=>updatePaneInstances()
        );
        _vue.onMounted(()=>updatePaneInstances()
        );
        _vue.watch(()=>props.activeName
        , (modelValue)=>setCurrentName(modelValue)
        );
        _vue.watch(()=>props.modelValue
        , (modelValue)=>setCurrentName(modelValue)
        );
        _vue.watch(currentName, async ()=>{
            var _a, _b;
            updatePaneInstances(true);
            await _vue.nextTick();
            await ((_a = nav$.value) == null ? void 0 : _a.$nextTick());
            (_b = nav$.value) == null || _b.scrollToActiveTab();
        });
        _vue.provide(_tabsMjs.tabsRootContextKey, {
            props,
            currentName,
            updatePaneState: (pane)=>paneStatesMap[pane.uid] = pane
        });
        expose({
            currentName
        });
        return ()=>{
            const newButton = props.editable || props.addable ? _vue.h("span", {
                class: "el-tabs__new-tab",
                tabindex: "0",
                onClick: handleTabAdd,
                onKeydown: (ev)=>{
                    if (ev.code === _ariaMjs.EVENT_CODE.enter) handleTabAdd();
                }
            }, [
                _vue.h(_indexMjs2.ElIcon, {
                    class: "is-icon-plus"
                }, {
                    default: ()=>_vue.h(_iconsVue.Plus)
                })
            ]) : null;
            const header = _vue.h("div", {
                class: [
                    "el-tabs__header",
                    `is-${props.tabPosition}`
                ]
            }, [
                newButton,
                _vue.h(_tabNavMjsDefault.default, {
                    currentName: currentName.value,
                    editable: props.editable,
                    type: props.type,
                    panes: panes.value,
                    stretch: props.stretch,
                    ref: nav$,
                    onTabClick: handleTabClick,
                    onTabRemove: handleTabRemove
                })
            ]);
            const panels = _vue.h("div", {
                class: "el-tabs__content"
            }, [
                _vue.renderSlot(slots, "default")
            ]);
            return _vue.h("div", {
                class: {
                    "el-tabs": true,
                    "el-tabs--card": props.type === "card",
                    [`el-tabs--${props.tabPosition}`]: true,
                    "el-tabs--border-card": props.type === "border-card"
                }
            }, props.tabPosition !== "bottom" ? [
                header,
                panels
            ] : [
                panels,
                header
            ]);
        };
    }
});

},{"vue":"gzxs9","@vue/shared":"3SM3y","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../tokens/index.mjs":"wVNQi","./tab-nav.mjs":"6DFds","../../../utils/vue/props.mjs":"cpwWK","../../../constants/event.mjs":"92xVn","../../../tokens/tabs.mjs":"kNnQs","../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6DFds":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TabNav
);
parcelHelpers.export(exports, "tabNavProps", ()=>tabNavProps
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs3 = require("../../../tokens/index.mjs");
var _tabBar2Mjs = require("./tab-bar2.mjs");
var _tabBar2MjsDefault = parcelHelpers.interopDefault(_tabBar2Mjs);
var _propsMjs = require("../../../utils/vue/props.mjs");
var _typescriptMjs = require("../../../utils/typescript.mjs");
var _tabsMjs = require("../../../tokens/tabs.mjs");
var _errorMjs = require("../../../utils/error.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
const tabNavProps = _propsMjs.buildProps({
    panes: {
        type: _propsMjs.definePropType(Array),
        default: ()=>_typescriptMjs.mutable([])
    },
    currentName: {
        type: [
            String,
            Number
        ],
        default: ""
    },
    editable: Boolean,
    onTabClick: {
        type: _propsMjs.definePropType(Function),
        default: _shared.NOOP
    },
    onTabRemove: {
        type: _propsMjs.definePropType(Function),
        default: _shared.NOOP
    },
    type: {
        type: String,
        values: [
            "card",
            "border-card",
            ""
        ],
        default: ""
    },
    stretch: Boolean
});
const COMPONENT_NAME = "ElTabNav";
var TabNav = _vue.defineComponent({
    name: COMPONENT_NAME,
    props: tabNavProps,
    setup (props, { expose  }) {
        const visibility = _core.useDocumentVisibility();
        const focused = _core.useWindowFocus();
        const rootTabs = _vue.inject(_tabsMjs.tabsRootContextKey);
        if (!rootTabs) _errorMjs.throwError(COMPONENT_NAME, `ElTabNav must be nested inside ElTabs`);
        const scrollable = _vue.ref(false);
        const navOffset = _vue.ref(0);
        const isFocus = _vue.ref(false);
        const focusable = _vue.ref(true);
        const navScroll$ = _vue.ref();
        const nav$ = _vue.ref();
        const el$ = _vue.ref();
        const sizeName = _vue.computed(()=>[
                "top",
                "bottom"
            ].includes(rootTabs.props.tabPosition) ? "width" : "height"
        );
        const navStyle = _vue.computed(()=>{
            const dir = sizeName.value === "width" ? "X" : "Y";
            return {
                transform: `translate${dir}(-${navOffset.value}px)`
            };
        });
        const scrollPrev = ()=>{
            if (!navScroll$.value) return;
            const containerSize = navScroll$.value[`offset${_shared.capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (!currentOffset) return;
            const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
            navOffset.value = newOffset;
        };
        const scrollNext = ()=>{
            if (!navScroll$.value || !nav$.value) return;
            const navSize = nav$.value[`offset${_shared.capitalize(sizeName.value)}`];
            const containerSize = navScroll$.value[`offset${_shared.capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (navSize - currentOffset <= containerSize) return;
            const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
            navOffset.value = newOffset;
        };
        const scrollToActiveTab = ()=>{
            const nav = nav$.value;
            if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return;
            const activeTab = el$.value.querySelector(".is-active");
            if (!activeTab) return;
            const navScroll = navScroll$.value;
            const isHorizontal = [
                "top",
                "bottom"
            ].includes(rootTabs.props.tabPosition);
            const activeTabBounding = activeTab.getBoundingClientRect();
            const navScrollBounding = navScroll.getBoundingClientRect();
            const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
            const currentOffset = navOffset.value;
            let newOffset = currentOffset;
            if (isHorizontal) {
                if (activeTabBounding.left < navScrollBounding.left) newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
                if (activeTabBounding.right > navScrollBounding.right) newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
            } else {
                if (activeTabBounding.top < navScrollBounding.top) newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
                if (activeTabBounding.bottom > navScrollBounding.bottom) newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
            }
            newOffset = Math.max(newOffset, 0);
            navOffset.value = Math.min(newOffset, maxOffset);
        };
        const update = ()=>{
            if (!nav$.value || !navScroll$.value) return;
            const navSize = nav$.value[`offset${_shared.capitalize(sizeName.value)}`];
            const containerSize = navScroll$.value[`offset${_shared.capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (containerSize < navSize) {
                const currentOffset2 = navOffset.value;
                scrollable.value = scrollable.value || {
                };
                scrollable.value.prev = currentOffset2;
                scrollable.value.next = currentOffset2 + containerSize < navSize;
                if (navSize - currentOffset2 < containerSize) navOffset.value = navSize - containerSize;
            } else {
                scrollable.value = false;
                if (currentOffset > 0) navOffset.value = 0;
            }
        };
        const changeTab = (e)=>{
            const code = e.code;
            const { up , down , left , right  } = _ariaMjs.EVENT_CODE;
            if (![
                up,
                down,
                left,
                right
            ].includes(code)) return;
            const tabList = Array.from(e.currentTarget.querySelectorAll("[role=tab]"));
            const currentIndex = tabList.indexOf(e.target);
            let nextIndex;
            if (code === left || code === up) {
                if (currentIndex === 0) nextIndex = tabList.length - 1;
                else nextIndex = currentIndex - 1;
            } else if (currentIndex < tabList.length - 1) nextIndex = currentIndex + 1;
            else nextIndex = 0;
            tabList[nextIndex].focus();
            tabList[nextIndex].click();
            setFocus();
        };
        const setFocus = ()=>{
            if (focusable.value) isFocus.value = true;
        };
        const removeFocus = ()=>isFocus.value = false
        ;
        _vue.watch(visibility, (visibility2)=>{
            if (visibility2 === "hidden") focusable.value = false;
            else if (visibility2 === "visible") setTimeout(()=>focusable.value = true
            , 50);
        });
        _vue.watch(focused, (focused2)=>{
            if (focused2) setTimeout(()=>focusable.value = true
            , 50);
            else focusable.value = false;
        });
        _core.useResizeObserver(el$, update);
        _vue.onMounted(()=>setTimeout(()=>scrollToActiveTab()
            , 0)
        );
        _vue.onUpdated(()=>update()
        );
        expose({
            scrollToActiveTab,
            removeFocus
        });
        return ()=>{
            const scrollBtn = scrollable.value ? [
                _vue.h("span", {
                    class: [
                        "el-tabs__nav-prev",
                        scrollable.value.prev ? "" : "is-disabled"
                    ],
                    onClick: scrollPrev
                }, [
                    _vue.h(_indexMjs2.ElIcon, {
                    }, {
                        default: ()=>_vue.h(_iconsVue.ArrowLeft)
                    })
                ]),
                _vue.h("span", {
                    class: [
                        "el-tabs__nav-next",
                        scrollable.value.next ? "" : "is-disabled"
                    ],
                    onClick: scrollNext
                }, [
                    _vue.h(_indexMjs2.ElIcon, {
                    }, {
                        default: ()=>_vue.h(_iconsVue.ArrowRight)
                    })
                ])
            ] : null;
            const tabs = props.panes.map((pane, index)=>{
                var _a, _b;
                const tabName = pane.props.name || pane.index || `${index}`;
                const closable = pane.isClosable || props.editable;
                pane.index = `${index}`;
                const btnClose = closable ? _vue.h(_indexMjs2.ElIcon, {
                    class: "is-icon-close",
                    onClick: (ev)=>props.onTabRemove(pane, ev)
                }, {
                    default: ()=>_vue.h(_iconsVue.Close)
                }) : null;
                const tabLabelContent = ((_b = (_a = pane.instance.slots).label) == null ? void 0 : _b.call(_a)) || pane.props.label;
                const tabindex = pane.active ? 0 : -1;
                return _vue.h("div", {
                    class: {
                        "el-tabs__item": true,
                        [`is-${rootTabs.props.tabPosition}`]: true,
                        "is-active": pane.active,
                        "is-disabled": pane.props.disabled,
                        "is-closable": closable,
                        "is-focus": isFocus
                    },
                    id: `tab-${tabName}`,
                    key: `tab-${tabName}`,
                    "aria-controls": `pane-${tabName}`,
                    role: "tab",
                    "aria-selected": pane.active,
                    ref: `tab-${tabName}`,
                    tabindex,
                    onFocus: ()=>setFocus()
                    ,
                    onBlur: ()=>removeFocus()
                    ,
                    onClick: (ev)=>{
                        removeFocus();
                        props.onTabClick(pane, tabName, ev);
                    },
                    onKeydown: (ev)=>{
                        if (closable && (ev.code === _ariaMjs.EVENT_CODE.delete || ev.code === _ariaMjs.EVENT_CODE.backspace)) props.onTabRemove(pane, ev);
                    }
                }, [
                    tabLabelContent,
                    btnClose
                ]);
            });
            return _vue.h("div", {
                ref: el$,
                class: [
                    "el-tabs__nav-wrap",
                    scrollable.value ? "is-scrollable" : "",
                    `is-${rootTabs.props.tabPosition}`
                ]
            }, [
                scrollBtn,
                _vue.h("div", {
                    class: "el-tabs__nav-scroll",
                    ref: navScroll$
                }, [
                    _vue.h("div", {
                        class: [
                            "el-tabs__nav",
                            `is-${rootTabs.props.tabPosition}`,
                            props.stretch && [
                                "top",
                                "bottom"
                            ].includes(rootTabs.props.tabPosition) ? "is-stretch" : ""
                        ],
                        ref: nav$,
                        style: navStyle.value,
                        role: "tablist",
                        onKeydown: changeTab
                    }, [
                        !props.type ? _vue.h(_tabBar2MjsDefault.default, {
                            tabs: [
                                ...props.panes
                            ]
                        }) : null,
                        tabs
                    ])
                ])
            ]);
        };
    }
});

},{"vue":"gzxs9","@vue/shared":"3SM3y","@vueuse/core":"eEHP9","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../tokens/index.mjs":"wVNQi","./tab-bar2.mjs":"703Fv","../../../utils/vue/props.mjs":"cpwWK","../../../utils/typescript.mjs":"bRl53","../../../tokens/tabs.mjs":"kNnQs","../../../utils/error.mjs":"2zPBN","../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"703Fv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TabBar
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../tokens/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _tabBarMjs = require("./tab-bar.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _tabsMjs = require("../../../tokens/tabs.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const COMPONENT_NAME = "ElTabBar";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    props: _tabBarMjs.tabBar,
    setup (props) {
        const instance = _vue.getCurrentInstance();
        const rootTabs = _vue.inject(_tabsMjs.tabsRootContextKey);
        if (!rootTabs) _errorMjs.throwError(COMPONENT_NAME, "must use with ElTabs");
        const bar$ = _vue.ref();
        const barStyle = _vue.ref();
        const getBarStyle = ()=>{
            let offset = 0;
            let tabSize = 0;
            const sizeName = [
                "top",
                "bottom"
            ].includes(rootTabs.props.tabPosition) ? "width" : "height";
            const sizeDir = sizeName === "width" ? "x" : "y";
            props.tabs.every((tab)=>{
                var _a, _b, _c, _d;
                const $el = (_b = (_a = instance.parent) == null ? void 0 : _a.refs) == null ? void 0 : _b[`tab-${tab.paneName}`];
                if (!$el) return false;
                if (!tab.active) return true;
                tabSize = $el[`client${_shared.capitalize(sizeName)}`];
                const position = sizeDir === "x" ? "left" : "top";
                offset = $el.getBoundingClientRect()[position] - ((_d = (_c = $el.parentElement) == null ? void 0 : _c.getBoundingClientRect()[position]) != null ? _d : 0);
                const tabStyles = window.getComputedStyle($el);
                if (sizeName === "width") {
                    if (props.tabs.length > 1) tabSize -= parseFloat(tabStyles.paddingLeft) + parseFloat(tabStyles.paddingRight);
                    offset += parseFloat(tabStyles.paddingLeft);
                }
                return false;
            });
            return {
                [sizeName]: `${tabSize}px`,
                transform: `translate${_shared.capitalize(sizeDir)}(${offset}px)`
            };
        };
        const update = ()=>barStyle.value = getBarStyle()
        ;
        _vue.watch(()=>props.tabs
        , async ()=>{
            await _vue.nextTick();
            update();
        }, {
            immediate: true
        });
        _core.useResizeObserver(bar$, ()=>update()
        );
        return {
            bar$,
            rootTabs,
            barStyle,
            update
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "bar$",
        class: _vue.normalizeClass([
            "el-tabs__active-bar",
            `is-${_ctx.rootTabs.props.tabPosition}`
        ]),
        style: _vue.normalizeStyle(_ctx.barStyle)
    }, null, 6);
}
var TabBar = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vue/shared":"3SM3y","@vueuse/core":"eEHP9","../../../tokens/index.mjs":"wVNQi","../../../utils/index.mjs":"dsdeP","./tab-bar.mjs":"dhrbU","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../tokens/tabs.mjs":"kNnQs","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dhrbU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tabBar", ()=>tabBar
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _typescriptMjs = require("../../../utils/typescript.mjs");
const tabBar = _propsMjs.buildProps({
    tabs: {
        type: _propsMjs.definePropType(Array),
        default: ()=>_typescriptMjs.mutable([])
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","../../../utils/typescript.mjs":"bRl53","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"03gdX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TabPane
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../tokens/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _tabPaneMjs = require("./tab-pane.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _tabsMjs = require("../../../tokens/tabs.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const COMPONENT_NAME = "ElTabPane";
const _sfc_main = _vue.defineComponent({
    name: COMPONENT_NAME,
    props: _tabPaneMjs.tabPaneProps,
    setup (props) {
        const instance = _vue.getCurrentInstance();
        const tabsRoot = _vue.inject(_tabsMjs.tabsRootContextKey);
        if (!tabsRoot) _errorMjs.throwError(COMPONENT_NAME, `must use with ElTabs`);
        const index = _vue.ref();
        const loaded = _vue.ref(false);
        const isClosable = _vue.computed(()=>props.closable || tabsRoot.props.closable
        );
        const active = _core.eagerComputed(()=>tabsRoot.currentName.value === (props.name || index.value)
        );
        const paneName = _vue.computed(()=>props.name || index.value
        );
        const shouldBeRender = _core.eagerComputed(()=>!props.lazy || loaded.value || active.value
        );
        _vue.watch(active, (val)=>{
            if (val) loaded.value = true;
        });
        tabsRoot.updatePaneState(_vue.reactive({
            uid: instance.uid,
            instance: _vue.markRaw(instance),
            props,
            paneName,
            active,
            index,
            isClosable
        }));
        return {
            active,
            paneName,
            shouldBeRender
        };
    }
});
const _hoisted_1 = [
    "id",
    "aria-hidden",
    "aria-labelledby"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _ctx.shouldBeRender ? _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
        key: 0,
        id: `pane-${_ctx.paneName}`,
        class: "el-tab-pane",
        role: "tabpanel",
        "aria-hidden": !_ctx.active,
        "aria-labelledby": `tab-${_ctx.paneName}`
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 8, _hoisted_1)), [
        [
            _vue.vShow,
            _ctx.active
        ]
    ]) : _vue.createCommentVNode("v-if", true);
}
var TabPane = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../tokens/index.mjs":"wVNQi","../../../utils/index.mjs":"dsdeP","./tab-pane.mjs":"hD9Q9","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../tokens/tabs.mjs":"kNnQs","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hD9Q9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tabPaneProps", ()=>tabPaneProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const tabPaneProps = _propsMjs.buildProps({
    label: {
        type: String,
        default: ""
    },
    name: {
        type: [
            String,
            Number
        ],
        default: ""
    },
    closable: Boolean,
    disabled: Boolean,
    lazy: Boolean
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k6X13":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElTimeSelect", ()=>ElTimeSelect
);
parcelHelpers.export(exports, "default", ()=>_TimeSelect
);
var _timeSelectMjs = require("./src/time-select.mjs");
var _timeSelectMjsDefault = parcelHelpers.interopDefault(_timeSelectMjs);
_timeSelectMjsDefault.default.install = (app)=>{
    app.component(_timeSelectMjsDefault.default.name, _timeSelectMjsDefault.default);
};
const _TimeSelect = _timeSelectMjsDefault.default;
const ElTimeSelect = _TimeSelect;

},{"./src/time-select.mjs":"erV7I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"erV7I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TimeSelect
);
var _vue = require("vue");
var _dayjs = require("dayjs");
var _dayjsDefault = parcelHelpers.interopDefault(_dayjs);
var _customParseFormat = require("dayjs/plugin/customParseFormat");
var _customParseFormatDefault = parcelHelpers.interopDefault(_customParseFormat);
var _indexMjs = require("../../select/index.mjs");
var _indexMjs1 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
_dayjsDefault.default.extend(_customParseFormatDefault.default);
const { Option: ElOption  } = _indexMjs.ElSelect;
const parseTime = (time)=>{
    const values = (time || "").split(":");
    if (values.length >= 2) {
        let hours = parseInt(values[0], 10);
        const minutes = parseInt(values[1], 10);
        const timeUpper = time.toUpperCase();
        if (timeUpper.includes("AM") && hours === 12) hours = 0;
        else if (timeUpper.includes("PM") && hours !== 12) hours += 12;
        return {
            hours,
            minutes
        };
    }
    return null;
};
const compareTime = (time1, time2)=>{
    const value1 = parseTime(time1);
    const value2 = parseTime(time2);
    const minutes1 = value1.minutes + value1.hours * 60;
    const minutes2 = value2.minutes + value2.hours * 60;
    if (minutes1 === minutes2) return 0;
    return minutes1 > minutes2 ? 1 : -1;
};
const padTime = (time)=>{
    return `${time}`.padStart(2, "0");
};
const formatTime = (time)=>{
    return `${padTime(time.hours)}:${padTime(time.minutes)}`;
};
const nextTime = (time, step)=>{
    const timeValue = parseTime(time);
    const stepValue = parseTime(step);
    const next = {
        hours: timeValue.hours,
        minutes: timeValue.minutes
    };
    next.minutes += stepValue.minutes;
    next.hours += stepValue.hours;
    next.hours += Math.floor(next.minutes / 60);
    next.minutes = next.minutes % 60;
    return formatTime(next);
};
const _sfc_main = _vue.defineComponent({
    name: "ElTimeSelect",
    components: {
        ElSelect: _indexMjs.ElSelect,
        ElOption,
        ElIcon: _indexMjs1.ElIcon
    },
    model: {
        prop: "value",
        event: "change"
    },
    props: {
        format: {
            type: String,
            default: "HH:mm"
        },
        modelValue: String,
        disabled: {
            type: Boolean,
            default: false
        },
        editable: {
            type: Boolean,
            default: true
        },
        effect: {
            type: String,
            default: "light"
        },
        clearable: {
            type: Boolean,
            default: true
        },
        size: {
            type: String,
            default: "default",
            validator: (value)=>!value || [
                    "large",
                    "default",
                    "small"
                ].indexOf(value) !== -1
        },
        placeholder: {
            type: String,
            default: ""
        },
        start: {
            type: String,
            default: "09:00"
        },
        end: {
            type: String,
            default: "18:00"
        },
        step: {
            type: String,
            default: "00:30"
        },
        minTime: {
            type: String,
            default: ""
        },
        maxTime: {
            type: String,
            default: ""
        },
        name: {
            type: String,
            default: ""
        },
        prefixIcon: {
            type: [
                String,
                Object
            ],
            default: _iconsVue.Clock
        },
        clearIcon: {
            type: [
                String,
                Object
            ],
            default: _iconsVue.CircleClose
        }
    },
    emits: [
        "change",
        "blur",
        "focus",
        "update:modelValue"
    ],
    setup (props) {
        const select = _vue.ref(null);
        const value = _vue.computed(()=>props.modelValue
        );
        const start = _vue.computed(()=>{
            const time = parseTime(props.start);
            return formatTime(time);
        });
        const end = _vue.computed(()=>{
            const time = parseTime(props.end);
            return formatTime(time);
        });
        const step = _vue.computed(()=>{
            const time = parseTime(props.step);
            return formatTime(time);
        });
        const minTime = _vue.computed(()=>{
            const time = parseTime(props.minTime);
            return time ? formatTime(time) : null;
        });
        const maxTime = _vue.computed(()=>{
            const time = parseTime(props.maxTime);
            return time ? formatTime(time) : null;
        });
        const items = _vue.computed(()=>{
            const result = [];
            if (props.start && props.end && props.step) {
                let current = start.value;
                let currentTime;
                while(compareTime(current, end.value) <= 0){
                    currentTime = _dayjsDefault.default(current, "HH:mm").format(props.format);
                    result.push({
                        value: currentTime,
                        disabled: compareTime(current, minTime.value || "-1:-1") <= 0 || compareTime(current, maxTime.value || "100:100") >= 0
                    });
                    current = nextTime(current, step.value);
                }
            }
            return result;
        });
        const blur = ()=>{
            var _a, _b;
            (_b = (_a = select.value) == null ? void 0 : _a.blur) == null || _b.call(_a);
        };
        const focus = ()=>{
            var _a, _b;
            (_b = (_a = select.value) == null ? void 0 : _a.focus) == null || _b.call(_a);
        };
        return {
            select,
            value,
            items,
            blur,
            focus
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_option = _vue.resolveComponent("el-option");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_select = _vue.resolveComponent("el-select");
    return _vue.openBlock(), _vue.createBlock(_component_el_select, {
        ref: "select",
        "model-value": _ctx.value,
        disabled: _ctx.disabled,
        clearable: _ctx.clearable,
        "clear-icon": _ctx.clearIcon,
        size: _ctx.size,
        effect: _ctx.effect,
        placeholder: _ctx.placeholder,
        "default-first-option": "",
        filterable: _ctx.editable,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = (event)=>_ctx.$emit("update:modelValue", event)
        ),
        onChange: _cache[1] || (_cache[1] = (event)=>_ctx.$emit("change", event)
        ),
        onBlur: _cache[2] || (_cache[2] = (event)=>_ctx.$emit("blur", event)
        ),
        onFocus: _cache[3] || (_cache[3] = (event)=>_ctx.$emit("focus", event)
        )
    }, {
        prefix: _vue.withCtx(()=>[
                _ctx.prefixIcon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                    key: 0,
                    class: "el-input__prefix-icon"
                }, {
                    default: _vue.withCtx(()=>[
                            (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.prefixIcon)))
                        ]
                    ),
                    _: 1
                })) : _vue.createCommentVNode("v-if", true)
            ]
        ),
        default: _vue.withCtx(()=>[
                (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.items, (item)=>{
                    return _vue.openBlock(), _vue.createBlock(_component_el_option, {
                        key: item.value,
                        label: item.value,
                        value: item.value,
                        disabled: item.disabled
                    }, null, 8, [
                        "label",
                        "value",
                        "disabled"
                    ]);
                }), 128))
            ]
        ),
        _: 1
    }, 8, [
        "model-value",
        "disabled",
        "clearable",
        "clear-icon",
        "size",
        "effect",
        "placeholder",
        "filterable"
    ]);
}
var TimeSelect = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","dayjs":"NJZFB","dayjs/plugin/customParseFormat":"dmrpe","../../select/index.mjs":"llDRW","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2CPF0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timelineItemProps", ()=>_timelineItemMjs.timelineItemProps
);
parcelHelpers.export(exports, "ElTimeline", ()=>ElTimeline
);
parcelHelpers.export(exports, "ElTimelineItem", ()=>ElTimelineItem
);
parcelHelpers.export(exports, "default", ()=>ElTimeline
);
var _indexMjs = require("../../utils/index.mjs");
var _timelineMjs = require("./src/timeline.mjs");
var _timelineMjsDefault = parcelHelpers.interopDefault(_timelineMjs);
var _timelineItem2Mjs = require("./src/timeline-item2.mjs");
var _timelineItem2MjsDefault = parcelHelpers.interopDefault(_timelineItem2Mjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _timelineItemMjs = require("./src/timeline-item.mjs");
const ElTimeline = _installMjs.withInstall(_timelineMjsDefault.default, {
    TimelineItem: _timelineItem2MjsDefault.default
});
const ElTimelineItem = _installMjs.withNoopInstall(_timelineItem2MjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/timeline.mjs":"8KZ4F","./src/timeline-item2.mjs":"czNw5","../../utils/vue/install.mjs":"4TMmv","./src/timeline-item.mjs":"6SEpi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8KZ4F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Timeline
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const Timeline = _vue.defineComponent({
    name: "ElTimeline",
    setup (_, { slots  }) {
        const ns = _indexMjs1.useNamespace("timeline");
        _vue.provide("timeline", slots);
        return ()=>{
            return _vue.h("ul", {
                class: [
                    ns.b()
                ]
            }, [
                _vue.renderSlot(slots, "default")
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"czNw5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TimelineItem
);
var _vue = require("vue");
var _indexMjs = require("../../icon/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _timelineItemMjs = require("./timeline-item.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElTimelineItem",
    components: {
        ElIcon: _indexMjs.ElIcon
    },
    props: _timelineItemMjs.timelineItemProps,
    setup () {
        const ns = _indexMjs2.useNamespace("timeline-item");
        return {
            ns
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    return _vue.openBlock(), _vue.createElementBlock("li", {
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            {
                [_ctx.ns.e("center")]: _ctx.center
            }
        ])
    }, [
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("tail"))
        }, null, 2),
        !_ctx.$slots.dot ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 0,
            class: _vue.normalizeClass([
                _ctx.ns.e("node"),
                _ctx.ns.em("node", _ctx.size || ""),
                _ctx.ns.em("node", _ctx.type || ""),
                _ctx.ns.is("hollow", _ctx.hollow)
            ]),
            style: _vue.normalizeStyle({
                backgroundColor: _ctx.color
            })
        }, [
            _ctx.icon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                key: 0,
                class: _vue.normalizeClass(_ctx.ns.e("icon"))
            }, {
                default: _vue.withCtx(()=>[
                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.icon)))
                    ]
                ),
                _: 1
            }, 8, [
                "class"
            ])) : _vue.createCommentVNode("v-if", true)
        ], 6)) : _vue.createCommentVNode("v-if", true),
        _ctx.$slots.dot ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 1,
            class: _vue.normalizeClass(_ctx.ns.e("dot"))
        }, [
            _vue.renderSlot(_ctx.$slots, "dot")
        ], 2)) : _vue.createCommentVNode("v-if", true),
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("wrapper"))
        }, [
            !_ctx.hideTimestamp && _ctx.placement === "top" ? (_vue.openBlock(), _vue.createElementBlock("div", {
                key: 0,
                class: _vue.normalizeClass([
                    _ctx.ns.e("timestamp"),
                    _ctx.ns.is("top")
                ])
            }, _vue.toDisplayString(_ctx.timestamp), 3)) : _vue.createCommentVNode("v-if", true),
            _vue.createElementVNode("div", {
                class: _vue.normalizeClass(_ctx.ns.e("content"))
            }, [
                _vue.renderSlot(_ctx.$slots, "default")
            ], 2),
            !_ctx.hideTimestamp && _ctx.placement === "bottom" ? (_vue.openBlock(), _vue.createElementBlock("div", {
                key: 1,
                class: _vue.normalizeClass([
                    _ctx.ns.e("timestamp"),
                    _ctx.ns.is("bottom")
                ])
            }, _vue.toDisplayString(_ctx.timestamp), 3)) : _vue.createCommentVNode("v-if", true)
        ], 2)
    ], 2);
}
var TimelineItem = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../icon/index.mjs":"hnNTG","../../../hooks/index.mjs":"1Ansp","./timeline-item.mjs":"6SEpi","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6SEpi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timelineItemProps", ()=>timelineItemProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
const timelineItemProps = _propsMjs.buildProps({
    timestamp: {
        type: String,
        default: ""
    },
    hideTimestamp: {
        type: Boolean,
        default: false
    },
    center: {
        type: Boolean,
        default: false
    },
    placement: {
        type: String,
        default: "bottom"
    },
    type: {
        type: String,
        default: ""
    },
    color: {
        type: String,
        default: ""
    },
    size: {
        type: String,
        default: "normal"
    },
    icon: {
        type: _iconMjs.iconPropType,
        default: ""
    },
    hollow: {
        type: Boolean,
        default: false
    }
});

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","../../../utils/vue/icon.mjs":"3YbE5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"baYrE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CHANGE_EVENT", ()=>_eventMjs.CHANGE_EVENT
);
parcelHelpers.export(exports, "ElTransfer", ()=>ElTransfer
);
parcelHelpers.export(exports, "default", ()=>_Transfer
);
var _indexMjs = require("./src/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _transferMjs = require("./src/transfer.mjs");
var _eventMjs = require("../../constants/event.mjs");
_indexMjsDefault.default.install = (app)=>{
    app.component(_indexMjsDefault.default.name, _indexMjsDefault.default);
};
const _Transfer = _indexMjsDefault.default;
const ElTransfer = _Transfer;

},{"./src/index.mjs":"aMZoE","./src/transfer.mjs":"8WHxq","../../constants/event.mjs":"92xVn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aMZoE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Transfer
);
var _vue = require("vue");
var _indexMjs = require("../../button/index.mjs");
var _indexMjs1 = require("../../icon/index.mjs");
var _indexMjs2 = require("../../../tokens/index.mjs");
var _indexMjs3 = require("../../../constants/index.mjs");
var _indexMjs4 = require("../../../hooks/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _transferPanelMjs = require("./transfer-panel.mjs");
var _transferPanelMjsDefault = parcelHelpers.interopDefault(_transferPanelMjs);
var _useComputedDataMjs = require("./useComputedData.mjs");
var _useCheckedChangeMjs = require("./useCheckedChange.mjs");
var _useMoveMjs = require("./useMove.mjs");
var _transferMjs = require("./transfer.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _eventMjs = require("../../../constants/event.mjs");
var _indexMjs5 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs6 = require("../../../hooks/use-namespace/index.mjs");
var _formMjs = require("../../../tokens/form.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElTransfer",
    components: {
        TransferPanel: _transferPanelMjsDefault.default,
        ElButton: _indexMjs.ElButton,
        ElIcon: _indexMjs1.ElIcon,
        ArrowLeft: _iconsVue.ArrowLeft,
        ArrowRight: _iconsVue.ArrowRight
    },
    props: {
        data: {
            type: Array,
            default: ()=>[]
        },
        titles: {
            type: Array,
            default: ()=>[]
        },
        buttonTexts: {
            type: Array,
            default: ()=>[]
        },
        filterPlaceholder: {
            type: String,
            default: ""
        },
        filterMethod: Function,
        leftDefaultChecked: {
            type: Array,
            default: ()=>[]
        },
        rightDefaultChecked: {
            type: Array,
            default: ()=>[]
        },
        renderContent: Function,
        modelValue: {
            type: Array,
            default: ()=>[]
        },
        format: {
            type: Object,
            default: ()=>({
                })
        },
        filterable: {
            type: Boolean,
            default: false
        },
        props: {
            type: Object,
            default: ()=>({
                    label: "label",
                    key: "key",
                    disabled: "disabled"
                })
        },
        targetOrder: {
            type: String,
            default: "original",
            validator: (val)=>{
                return [
                    "original",
                    "push",
                    "unshift"
                ].includes(val);
            }
        }
    },
    emits: [
        _eventMjs.UPDATE_MODEL_EVENT,
        _eventMjs.CHANGE_EVENT,
        _useCheckedChangeMjs.LEFT_CHECK_CHANGE_EVENT,
        _useCheckedChangeMjs.RIGHT_CHECK_CHANGE_EVENT
    ],
    setup (props, { emit , slots  }) {
        const { t  } = _indexMjs5.useLocale();
        const ns = _indexMjs6.useNamespace("transfer");
        const elFormItem = _vue.inject(_formMjs.elFormItemKey, {
        });
        const checkedState = _vue.reactive({
            leftChecked: [],
            rightChecked: []
        });
        const { propsKey , sourceData , targetData  } = _useComputedDataMjs.useComputedData(props);
        const { onSourceCheckedChange , onTargetCheckedChange  } = _useCheckedChangeMjs.useCheckedChange(checkedState, emit);
        const { addToLeft , addToRight  } = _useMoveMjs.useMove(props, checkedState, propsKey, emit);
        const leftPanel = _vue.ref();
        const rightPanel = _vue.ref();
        const clearQuery = (which)=>{
            switch(which){
                case "left":
                    leftPanel.value.query = "";
                    break;
                case "right":
                    rightPanel.value.query = "";
                    break;
            }
        };
        const hasButtonTexts = _vue.computed(()=>props.buttonTexts.length === 2
        );
        const leftPanelTitle = _vue.computed(()=>props.titles[0] || t("el.transfer.titles.0")
        );
        const rightPanelTitle = _vue.computed(()=>props.titles[1] || t("el.transfer.titles.1")
        );
        const panelFilterPlaceholder = _vue.computed(()=>props.filterPlaceholder || t("el.transfer.filterPlaceholder")
        );
        _vue.watch(()=>props.modelValue
        , ()=>{
            var _a;
            (_a = elFormItem.validate) == null || _a.call(elFormItem, "change");
        });
        const optionRender = _vue.computed(()=>(option)=>{
                if (props.renderContent) return props.renderContent(_vue.h, option);
                if (slots.default) return slots.default({
                    option
                });
                return _vue.h("span", option[props.props.label] || option[props.props.key]);
            }
        );
        return {
            ns,
            sourceData,
            targetData,
            onSourceCheckedChange,
            onTargetCheckedChange,
            addToLeft,
            addToRight,
            ..._vue.toRefs(checkedState),
            hasButtonTexts,
            leftPanelTitle,
            rightPanelTitle,
            panelFilterPlaceholder,
            clearQuery,
            leftPanel,
            rightPanel,
            optionRender
        };
    }
});
const _hoisted_1 = {
    key: 0
};
const _hoisted_2 = {
    key: 0
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_transfer_panel = _vue.resolveComponent("transfer-panel");
    const _component_arrow_left = _vue.resolveComponent("arrow-left");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_button = _vue.resolveComponent("el-button");
    const _component_arrow_right = _vue.resolveComponent("arrow-right");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.ns.b())
    }, [
        _vue.createVNode(_component_transfer_panel, {
            ref: "leftPanel",
            data: _ctx.sourceData,
            "option-render": _ctx.optionRender,
            placeholder: _ctx.panelFilterPlaceholder,
            title: _ctx.leftPanelTitle,
            filterable: _ctx.filterable,
            format: _ctx.format,
            "filter-method": _ctx.filterMethod,
            "default-checked": _ctx.leftDefaultChecked,
            props: _ctx.props,
            onCheckedChange: _ctx.onSourceCheckedChange
        }, {
            default: _vue.withCtx(()=>[
                    _vue.renderSlot(_ctx.$slots, "left-footer")
                ]
            ),
            _: 3
        }, 8, [
            "data",
            "option-render",
            "placeholder",
            "title",
            "filterable",
            "format",
            "filter-method",
            "default-checked",
            "props",
            "onCheckedChange"
        ]),
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.e("buttons"))
        }, [
            _vue.createVNode(_component_el_button, {
                type: "primary",
                class: _vue.normalizeClass([
                    _ctx.ns.e("button"),
                    _ctx.ns.is("with-texts", _ctx.hasButtonTexts)
                ]),
                disabled: _ctx.rightChecked.length === 0,
                onClick: _ctx.addToLeft
            }, {
                default: _vue.withCtx(()=>[
                        _vue.createVNode(_component_el_icon, null, {
                            default: _vue.withCtx(()=>[
                                    _vue.createVNode(_component_arrow_left)
                                ]
                            ),
                            _: 1
                        }),
                        _ctx.buttonTexts[0] !== void 0 ? (_vue.openBlock(), _vue.createElementBlock("span", _hoisted_1, _vue.toDisplayString(_ctx.buttonTexts[0]), 1)) : _vue.createCommentVNode("v-if", true)
                    ]
                ),
                _: 1
            }, 8, [
                "class",
                "disabled",
                "onClick"
            ]),
            _vue.createVNode(_component_el_button, {
                type: "primary",
                class: _vue.normalizeClass([
                    _ctx.ns.e("button"),
                    _ctx.ns.is("with-texts", _ctx.hasButtonTexts)
                ]),
                disabled: _ctx.leftChecked.length === 0,
                onClick: _ctx.addToRight
            }, {
                default: _vue.withCtx(()=>[
                        _ctx.buttonTexts[1] !== void 0 ? (_vue.openBlock(), _vue.createElementBlock("span", _hoisted_2, _vue.toDisplayString(_ctx.buttonTexts[1]), 1)) : _vue.createCommentVNode("v-if", true),
                        _vue.createVNode(_component_el_icon, null, {
                            default: _vue.withCtx(()=>[
                                    _vue.createVNode(_component_arrow_right)
                                ]
                            ),
                            _: 1
                        })
                    ]
                ),
                _: 1
            }, 8, [
                "class",
                "disabled",
                "onClick"
            ])
        ], 2),
        _vue.createVNode(_component_transfer_panel, {
            ref: "rightPanel",
            data: _ctx.targetData,
            "option-render": _ctx.optionRender,
            placeholder: _ctx.panelFilterPlaceholder,
            filterable: _ctx.filterable,
            format: _ctx.format,
            "filter-method": _ctx.filterMethod,
            title: _ctx.rightPanelTitle,
            "default-checked": _ctx.rightDefaultChecked,
            props: _ctx.props,
            onCheckedChange: _ctx.onTargetCheckedChange
        }, {
            default: _vue.withCtx(()=>[
                    _vue.renderSlot(_ctx.$slots, "right-footer")
                ]
            ),
            _: 3
        }, 8, [
            "data",
            "option-render",
            "placeholder",
            "filterable",
            "format",
            "filter-method",
            "title",
            "default-checked",
            "props",
            "onCheckedChange"
        ])
    ], 2);
}
var Transfer = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../button/index.mjs":"64Ym1","../../icon/index.mjs":"hnNTG","../../../tokens/index.mjs":"wVNQi","../../../constants/index.mjs":"74Fbn","../../../hooks/index.mjs":"1Ansp","@element-plus/icons-vue":"b18uu","./transfer-panel.mjs":"40z9R","./useComputedData.mjs":"atIzm","./useCheckedChange.mjs":"1V3Sj","./useMove.mjs":"8jFRi","./transfer.mjs":"8WHxq","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../constants/event.mjs":"92xVn","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../tokens/form.mjs":"2r4O0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"40z9R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TransferPanel
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../checkbox/index.mjs");
var _indexMjs2 = require("../../input/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _useCheckMjs = require("./useCheck.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs4 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElTransferPanel",
    components: {
        ElCheckboxGroup: _indexMjs1.ElCheckboxGroup,
        ElCheckbox: _indexMjs1.ElCheckbox,
        ElInput: _indexMjs2.ElInput,
        OptionContent: ({ option  })=>option
    },
    props: _useCheckMjs.useCheckProps,
    emits: [
        _useCheckMjs.CHECKED_CHANGE_EVENT
    ],
    setup (props, { slots  }) {
        const { t  } = _indexMjs3.useLocale();
        const ns = _indexMjs4.useNamespace("transfer");
        const panelState = _vue.reactive({
            checked: [],
            allChecked: false,
            query: "",
            inputHover: false,
            checkChangeByUser: true
        });
        const { labelProp , keyProp , disabledProp , filteredData , checkedSummary , isIndeterminate , handleAllCheckedChange  } = _useCheckMjs.useCheck(props, panelState);
        const hasNoMatch = _vue.computed(()=>{
            return panelState.query.length > 0 && filteredData.value.length === 0;
        });
        const hasFooter = _vue.computed(()=>!!slots.default()[0].children.length
        );
        const { checked , allChecked , query , inputHover , checkChangeByUser  } = _vue.toRefs(panelState);
        return {
            ns,
            labelProp,
            keyProp,
            disabledProp,
            filteredData,
            checkedSummary,
            isIndeterminate,
            handleAllCheckedChange,
            checked,
            allChecked,
            query,
            inputHover,
            checkChangeByUser,
            hasNoMatch,
            SearchIcon: _iconsVue.Search,
            hasFooter,
            t
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_checkbox = _vue.resolveComponent("el-checkbox");
    const _component_el_input = _vue.resolveComponent("el-input");
    const _component_option_content = _vue.resolveComponent("option-content");
    const _component_el_checkbox_group = _vue.resolveComponent("el-checkbox-group");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass(_ctx.ns.b("panel"))
    }, [
        _vue.createElementVNode("p", {
            class: _vue.normalizeClass(_ctx.ns.be("panel", "header"))
        }, [
            _vue.createVNode(_component_el_checkbox, {
                modelValue: _ctx.allChecked,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>_ctx.allChecked = $event
                ),
                indeterminate: _ctx.isIndeterminate,
                onChange: _ctx.handleAllCheckedChange
            }, {
                default: _vue.withCtx(()=>[
                        _vue.createTextVNode(_vue.toDisplayString(_ctx.title) + " ", 1),
                        _vue.createElementVNode("span", null, _vue.toDisplayString(_ctx.checkedSummary), 1)
                    ]
                ),
                _: 1
            }, 8, [
                "modelValue",
                "indeterminate",
                "onChange"
            ])
        ], 2),
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass([
                _ctx.ns.be("panel", "body"),
                _ctx.ns.is("with-footer", _ctx.hasFooter)
            ])
        }, [
            _ctx.filterable ? (_vue.openBlock(), _vue.createBlock(_component_el_input, {
                key: 0,
                modelValue: _ctx.query,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>_ctx.query = $event
                ),
                class: _vue.normalizeClass(_ctx.ns.be("panel", "filter")),
                size: "default",
                placeholder: _ctx.placeholder,
                "prefix-icon": _ctx.SearchIcon,
                clearable: "",
                onMouseenter: _cache[2] || (_cache[2] = ($event)=>_ctx.inputHover = true
                ),
                onMouseleave: _cache[3] || (_cache[3] = ($event)=>_ctx.inputHover = false
                )
            }, null, 8, [
                "modelValue",
                "class",
                "placeholder",
                "prefix-icon"
            ])) : _vue.createCommentVNode("v-if", true),
            _vue.withDirectives(_vue.createVNode(_component_el_checkbox_group, {
                modelValue: _ctx.checked,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event)=>_ctx.checked = $event
                ),
                class: _vue.normalizeClass([
                    _ctx.ns.is("filterable", _ctx.filterable),
                    _ctx.ns.be("panel", "list")
                ])
            }, {
                default: _vue.withCtx(()=>[
                        (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.filteredData, (item)=>{
                            return _vue.openBlock(), _vue.createBlock(_component_el_checkbox, {
                                key: item[_ctx.keyProp],
                                class: _vue.normalizeClass(_ctx.ns.be("panel", "item")),
                                label: item[_ctx.keyProp],
                                disabled: item[_ctx.disabledProp]
                            }, {
                                default: _vue.withCtx(()=>[
                                        _vue.createVNode(_component_option_content, {
                                            option: _ctx.optionRender(item)
                                        }, null, 8, [
                                            "option"
                                        ])
                                    ]
                                ),
                                _: 2
                            }, 1032, [
                                "class",
                                "label",
                                "disabled"
                            ]);
                        }), 128))
                    ]
                ),
                _: 1
            }, 8, [
                "modelValue",
                "class"
            ]), [
                [
                    _vue.vShow,
                    !_ctx.hasNoMatch && _ctx.data.length > 0
                ]
            ]),
            _vue.withDirectives(_vue.createElementVNode("p", {
                class: _vue.normalizeClass(_ctx.ns.be("panel", "empty"))
            }, _vue.toDisplayString(_ctx.hasNoMatch ? _ctx.t("el.transfer.noMatch") : _ctx.t("el.transfer.noData")), 3), [
                [
                    _vue.vShow,
                    _ctx.hasNoMatch || _ctx.data.length === 0
                ]
            ])
        ], 2),
        _ctx.hasFooter ? (_vue.openBlock(), _vue.createElementBlock("p", {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.be("panel", "footer"))
        }, [
            _vue.renderSlot(_ctx.$slots, "default")
        ], 2)) : _vue.createCommentVNode("v-if", true)
    ], 2);
}
var TransferPanel = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../checkbox/index.mjs":"jMNjD","../../input/index.mjs":"18eQI","@element-plus/icons-vue":"b18uu","./useCheck.mjs":"iAHAV","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iAHAV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CHECKED_CHANGE_EVENT", ()=>CHECKED_CHANGE_EVENT
);
parcelHelpers.export(exports, "useCheck", ()=>useCheck
);
parcelHelpers.export(exports, "useCheckProps", ()=>useCheckProps
);
var _vue = require("vue");
const CHECKED_CHANGE_EVENT = "checked-change";
const useCheckProps = {
    data: {
        type: Array,
        default () {
            return [];
        }
    },
    optionRender: Function,
    placeholder: String,
    title: String,
    filterable: Boolean,
    format: Object,
    filterMethod: Function,
    defaultChecked: Array,
    props: Object
};
const useCheck = (props, panelState)=>{
    const { emit  } = _vue.getCurrentInstance();
    const labelProp = _vue.computed(()=>props.props.label || "label"
    );
    const keyProp = _vue.computed(()=>props.props.key || "key"
    );
    const disabledProp = _vue.computed(()=>props.props.disabled || "disabled"
    );
    const filteredData = _vue.computed(()=>{
        return props.data.filter((item)=>{
            if (typeof props.filterMethod === "function") return props.filterMethod(panelState.query, item);
            else {
                const label = item[labelProp.value] || item[keyProp.value].toString();
                return label.toLowerCase().includes(panelState.query.toLowerCase());
            }
        });
    });
    const checkableData = _vue.computed(()=>{
        return filteredData.value.filter((item)=>!item[disabledProp.value]
        );
    });
    const checkedSummary = _vue.computed(()=>{
        const checkedLength = panelState.checked.length;
        const dataLength = props.data.length;
        const { noChecked , hasChecked  } = props.format;
        if (noChecked && hasChecked) return checkedLength > 0 ? hasChecked.replace(/\${checked}/g, checkedLength.toString()).replace(/\${total}/g, dataLength.toString()) : noChecked.replace(/\${total}/g, dataLength.toString());
        else return `${checkedLength}/${dataLength}`;
    });
    const isIndeterminate = _vue.computed(()=>{
        const checkedLength = panelState.checked.length;
        return checkedLength > 0 && checkedLength < checkableData.value.length;
    });
    const updateAllChecked = ()=>{
        const checkableDataKeys = checkableData.value.map((item)=>item[keyProp.value]
        );
        panelState.allChecked = checkableDataKeys.length > 0 && checkableDataKeys.every((item)=>panelState.checked.includes(item)
        );
    };
    const handleAllCheckedChange = (value)=>{
        panelState.checked = value ? checkableData.value.map((item)=>item[keyProp.value]
        ) : [];
    };
    _vue.watch(()=>panelState.checked
    , (val, oldVal)=>{
        updateAllChecked();
        if (panelState.checkChangeByUser) {
            const movedKeys = val.concat(oldVal).filter((v)=>!val.includes(v) || !oldVal.includes(v)
            );
            emit(CHECKED_CHANGE_EVENT, val, movedKeys);
        } else {
            emit(CHECKED_CHANGE_EVENT, val);
            panelState.checkChangeByUser = true;
        }
    });
    _vue.watch(checkableData, ()=>{
        updateAllChecked();
    });
    _vue.watch(()=>props.data
    , ()=>{
        const checked = [];
        const filteredDataKeys = filteredData.value.map((item)=>item[keyProp.value]
        );
        panelState.checked.forEach((item)=>{
            if (filteredDataKeys.includes(item)) checked.push(item);
        });
        panelState.checkChangeByUser = false;
        panelState.checked = checked;
    });
    _vue.watch(()=>props.defaultChecked
    , (val, oldVal)=>{
        if (oldVal && val.length === oldVal.length && val.every((item)=>oldVal.includes(item)
        )) return;
        const checked = [];
        const checkableDataKeys = checkableData.value.map((item)=>item[keyProp.value]
        );
        val.forEach((item)=>{
            if (checkableDataKeys.includes(item)) checked.push(item);
        });
        panelState.checkChangeByUser = false;
        panelState.checked = checked;
    }, {
        immediate: true
    });
    return {
        labelProp,
        keyProp,
        disabledProp,
        filteredData,
        checkableData,
        checkedSummary,
        isIndeterminate,
        updateAllChecked,
        handleAllCheckedChange
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"atIzm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useComputedData", ()=>useComputedData
);
var _vue = require("vue");
const useComputedData = (props)=>{
    const propsKey = _vue.computed(()=>props.props.key
    );
    const dataObj = _vue.computed(()=>{
        return props.data.reduce((o, cur)=>(o[cur[propsKey.value]] = cur) && o
        , {
        });
    });
    const sourceData = _vue.computed(()=>{
        return props.data.filter((item)=>!props.modelValue.includes(item[propsKey.value])
        );
    });
    const targetData = _vue.computed(()=>{
        if (props.targetOrder === "original") return props.data.filter((item)=>props.modelValue.includes(item[propsKey.value])
        );
        else return props.modelValue.reduce((arr, cur)=>{
            const val = dataObj.value[cur];
            if (val) arr.push(val);
            return arr;
        }, []);
    });
    return {
        propsKey,
        sourceData,
        targetData
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1V3Sj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LEFT_CHECK_CHANGE_EVENT", ()=>LEFT_CHECK_CHANGE_EVENT
);
parcelHelpers.export(exports, "RIGHT_CHECK_CHANGE_EVENT", ()=>RIGHT_CHECK_CHANGE_EVENT
);
parcelHelpers.export(exports, "useCheckedChange", ()=>useCheckedChange
);
const LEFT_CHECK_CHANGE_EVENT = "left-check-change";
const RIGHT_CHECK_CHANGE_EVENT = "right-check-change";
const useCheckedChange = (checkedState, emit)=>{
    const onSourceCheckedChange = (val, movedKeys)=>{
        checkedState.leftChecked = val;
        if (movedKeys === void 0) return;
        emit(LEFT_CHECK_CHANGE_EVENT, val, movedKeys);
    };
    const onTargetCheckedChange = (val, movedKeys)=>{
        checkedState.rightChecked = val;
        if (movedKeys === void 0) return;
        emit(RIGHT_CHECK_CHANGE_EVENT, val, movedKeys);
    };
    return {
        onSourceCheckedChange,
        onTargetCheckedChange
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8jFRi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useMove", ()=>useMove
);
var _indexMjs = require("../../../constants/index.mjs");
var _eventMjs = require("../../../constants/event.mjs");
const useMove = (props, checkedState, propsKey, emit)=>{
    const _emit = (value, type, checked)=>{
        emit(_eventMjs.UPDATE_MODEL_EVENT, value);
        emit(_eventMjs.CHANGE_EVENT, value, type, checked);
    };
    const addToLeft = ()=>{
        const currentValue = props.modelValue.slice();
        checkedState.rightChecked.forEach((item)=>{
            const index = currentValue.indexOf(item);
            if (index > -1) currentValue.splice(index, 1);
        });
        _emit(currentValue, "left", checkedState.rightChecked);
    };
    const addToRight = ()=>{
        let currentValue = props.modelValue.slice();
        const itemsToBeMoved = props.data.filter((item)=>{
            const itemKey = item[propsKey.value];
            return checkedState.leftChecked.includes(itemKey) && !props.modelValue.includes(itemKey);
        }).map((item)=>item[propsKey.value]
        );
        currentValue = props.targetOrder === "unshift" ? itemsToBeMoved.concat(currentValue) : currentValue.concat(itemsToBeMoved);
        if (props.targetOrder === "original") currentValue = props.data.filter((item)=>currentValue.includes(item[propsKey.value])
        ).map((item)=>item[propsKey.value]
        );
        _emit(currentValue, "right", checkedState.leftChecked);
    };
    return {
        addToLeft,
        addToRight
    };
};

},{"../../../constants/index.mjs":"74Fbn","../../../constants/event.mjs":"92xVn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8WHxq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CHANGE_EVENT", ()=>_eventMjs.CHANGE_EVENT
);
var _indexMjs = require("../../../constants/index.mjs");
var _eventMjs = require("../../../constants/event.mjs");

},{"../../../constants/index.mjs":"74Fbn","../../../constants/event.mjs":"92xVn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bpXS0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElTree", ()=>ElTree
);
parcelHelpers.export(exports, "default", ()=>_Tree
);
var _treeMjs = require("./src/tree.mjs");
var _treeMjsDefault = parcelHelpers.interopDefault(_treeMjs);
_treeMjsDefault.default.install = (app)=>{
    app.component(_treeMjsDefault.default.name, _treeMjsDefault.default);
};
const _Tree = _treeMjsDefault.default;
const ElTree = _Tree;

},{"./src/tree.mjs":"U8x7W","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"U8x7W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Tree
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _treeStoreMjs = require("./model/tree-store.mjs");
var _treeStoreMjsDefault = parcelHelpers.interopDefault(_treeStoreMjs);
var _utilMjs = require("./model/util.mjs");
var _treeNodeMjs = require("./tree-node.mjs");
var _treeNodeMjsDefault = parcelHelpers.interopDefault(_treeNodeMjs);
var _useNodeExpandEventBroadcastMjs = require("./model/useNodeExpandEventBroadcast.mjs");
var _useDragNodeMjs = require("./model/useDragNode.mjs");
var _useKeydownMjs = require("./model/useKeydown.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElTree",
    components: {
        ElTreeNode: _treeNodeMjsDefault.default
    },
    props: {
        data: {
            type: Array,
            default: ()=>[]
        },
        emptyText: {
            type: String
        },
        renderAfterExpand: {
            type: Boolean,
            default: true
        },
        nodeKey: String,
        checkStrictly: Boolean,
        defaultExpandAll: Boolean,
        expandOnClickNode: {
            type: Boolean,
            default: true
        },
        checkOnClickNode: Boolean,
        checkDescendants: {
            type: Boolean,
            default: false
        },
        autoExpandParent: {
            type: Boolean,
            default: true
        },
        defaultCheckedKeys: Array,
        defaultExpandedKeys: Array,
        currentNodeKey: [
            String,
            Number
        ],
        renderContent: Function,
        showCheckbox: {
            type: Boolean,
            default: false
        },
        draggable: {
            type: Boolean,
            default: false
        },
        allowDrag: Function,
        allowDrop: Function,
        props: {
            type: Object,
            default: ()=>({
                    children: "children",
                    label: "label",
                    disabled: "disabled"
                })
        },
        lazy: {
            type: Boolean,
            default: false
        },
        highlightCurrent: Boolean,
        load: Function,
        filterNodeMethod: Function,
        accordion: Boolean,
        indent: {
            type: Number,
            default: 18
        },
        icon: [
            String,
            Object
        ]
    },
    emits: [
        "check-change",
        "current-change",
        "node-click",
        "node-contextmenu",
        "node-collapse",
        "node-expand",
        "check",
        "node-drag-start",
        "node-drag-end",
        "node-drop",
        "node-drag-leave",
        "node-drag-enter",
        "node-drag-over"
    ],
    setup (props, ctx) {
        const { t  } = _indexMjs1.useLocale();
        const ns = _indexMjs2.useNamespace("tree");
        const store = _vue.ref(new _treeStoreMjsDefault.default({
            key: props.nodeKey,
            data: props.data,
            lazy: props.lazy,
            props: props.props,
            load: props.load,
            currentNodeKey: props.currentNodeKey,
            checkStrictly: props.checkStrictly,
            checkDescendants: props.checkDescendants,
            defaultCheckedKeys: props.defaultCheckedKeys,
            defaultExpandedKeys: props.defaultExpandedKeys,
            autoExpandParent: props.autoExpandParent,
            defaultExpandAll: props.defaultExpandAll,
            filterNodeMethod: props.filterNodeMethod
        }));
        store.value.initialize();
        const root = _vue.ref(store.value.root);
        const currentNode = _vue.ref(null);
        const el$ = _vue.ref(null);
        const dropIndicator$ = _vue.ref(null);
        const { broadcastExpanded  } = _useNodeExpandEventBroadcastMjs.useNodeExpandEventBroadcast(props);
        const { dragState  } = _useDragNodeMjs.useDragNodeHandler({
            props,
            ctx,
            el$,
            dropIndicator$,
            store
        });
        _useKeydownMjs.useKeydown({
            el$
        }, store);
        const isEmpty = _vue.computed(()=>{
            const { childNodes  } = root.value;
            return !childNodes || childNodes.length === 0 || childNodes.every(({ visible  })=>!visible
            );
        });
        _vue.watch(()=>props.defaultCheckedKeys
        , (newVal)=>{
            store.value.setDefaultCheckedKey(newVal);
        });
        _vue.watch(()=>props.defaultExpandedKeys
        , (newVal)=>{
            store.value.setDefaultExpandedKeys(newVal);
        });
        _vue.watch(()=>props.data
        , (newVal)=>{
            store.value.setData(newVal);
        }, {
            deep: true
        });
        _vue.watch(()=>props.checkStrictly
        , (newVal)=>{
            store.value.checkStrictly = newVal;
        });
        const filter = (value)=>{
            if (!props.filterNodeMethod) throw new Error("[Tree] filterNodeMethod is required when filter");
            store.value.filter(value);
        };
        const getNodeKey$1 = (node)=>{
            return _utilMjs.getNodeKey(props.nodeKey, node.data);
        };
        const getNodePath = (data)=>{
            if (!props.nodeKey) throw new Error("[Tree] nodeKey is required in getNodePath");
            const node = store.value.getNode(data);
            if (!node) return [];
            const path = [
                node.data
            ];
            let parent = node.parent;
            while(parent && parent !== root.value){
                path.push(parent.data);
                parent = parent.parent;
            }
            return path.reverse();
        };
        const getCheckedNodes = (leafOnly, includeHalfChecked)=>{
            return store.value.getCheckedNodes(leafOnly, includeHalfChecked);
        };
        const getCheckedKeys = (leafOnly)=>{
            return store.value.getCheckedKeys(leafOnly);
        };
        const getCurrentNode = ()=>{
            const currentNode2 = store.value.getCurrentNode();
            return currentNode2 ? currentNode2.data : null;
        };
        const getCurrentKey = ()=>{
            if (!props.nodeKey) throw new Error("[Tree] nodeKey is required in getCurrentKey");
            const currentNode2 = getCurrentNode();
            return currentNode2 ? currentNode2[props.nodeKey] : null;
        };
        const setCheckedNodes = (nodes, leafOnly)=>{
            if (!props.nodeKey) throw new Error("[Tree] nodeKey is required in setCheckedNodes");
            store.value.setCheckedNodes(nodes, leafOnly);
        };
        const setCheckedKeys = (keys, leafOnly)=>{
            if (!props.nodeKey) throw new Error("[Tree] nodeKey is required in setCheckedKeys");
            store.value.setCheckedKeys(keys, leafOnly);
        };
        const setChecked = (data, checked, deep)=>{
            store.value.setChecked(data, checked, deep);
        };
        const getHalfCheckedNodes = ()=>{
            return store.value.getHalfCheckedNodes();
        };
        const getHalfCheckedKeys = ()=>{
            return store.value.getHalfCheckedKeys();
        };
        const setCurrentNode = (node, shouldAutoExpandParent = true)=>{
            if (!props.nodeKey) throw new Error("[Tree] nodeKey is required in setCurrentNode");
            store.value.setUserCurrentNode(node, shouldAutoExpandParent);
        };
        const setCurrentKey = (key, shouldAutoExpandParent = true)=>{
            if (!props.nodeKey) throw new Error("[Tree] nodeKey is required in setCurrentKey");
            store.value.setCurrentNodeKey(key, shouldAutoExpandParent);
        };
        const getNode = (data)=>{
            return store.value.getNode(data);
        };
        const remove = (data)=>{
            store.value.remove(data);
        };
        const append = (data, parentNode)=>{
            store.value.append(data, parentNode);
        };
        const insertBefore = (data, refNode)=>{
            store.value.insertBefore(data, refNode);
        };
        const insertAfter = (data, refNode)=>{
            store.value.insertAfter(data, refNode);
        };
        const handleNodeExpand = (nodeData, node, instance)=>{
            broadcastExpanded(node);
            ctx.emit("node-expand", nodeData, node, instance);
        };
        const updateKeyChildren = (key, data)=>{
            if (!props.nodeKey) throw new Error("[Tree] nodeKey is required in updateKeyChild");
            store.value.updateChildren(key, data);
        };
        _vue.provide("RootTree", {
            ctx,
            props,
            store,
            root,
            currentNode,
            instance: _vue.getCurrentInstance()
        });
        return {
            ns,
            store,
            root,
            currentNode,
            dragState,
            el$,
            dropIndicator$,
            isEmpty,
            filter,
            getNodeKey: getNodeKey$1,
            getNodePath,
            getCheckedNodes,
            getCheckedKeys,
            getCurrentNode,
            getCurrentKey,
            setCheckedNodes,
            setCheckedKeys,
            setChecked,
            getHalfCheckedNodes,
            getHalfCheckedKeys,
            setCurrentNode,
            setCurrentKey,
            t,
            getNode,
            remove,
            append,
            insertBefore,
            insertAfter,
            handleNodeExpand,
            updateKeyChildren
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    var _a;
    const _component_el_tree_node = _vue.resolveComponent("el-tree-node");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "el$",
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.is("dragging", !!_ctx.dragState.draggingNode),
            _ctx.ns.is("drop-not-allow", !_ctx.dragState.allowDrop),
            _ctx.ns.is("drop-inner", _ctx.dragState.dropType === "inner"),
            {
                [_ctx.ns.m("highlight-current")]: _ctx.highlightCurrent
            }
        ]),
        role: "tree"
    }, [
        (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.root.childNodes, (child)=>{
            return _vue.openBlock(), _vue.createBlock(_component_el_tree_node, {
                key: _ctx.getNodeKey(child),
                node: child,
                props: _ctx.props,
                accordion: _ctx.accordion,
                "render-after-expand": _ctx.renderAfterExpand,
                "show-checkbox": _ctx.showCheckbox,
                "render-content": _ctx.renderContent,
                onNodeExpand: _ctx.handleNodeExpand
            }, null, 8, [
                "node",
                "props",
                "accordion",
                "render-after-expand",
                "show-checkbox",
                "render-content",
                "onNodeExpand"
            ]);
        }), 128)),
        _ctx.isEmpty ? (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 0,
            class: _vue.normalizeClass(_ctx.ns.e("empty-block"))
        }, [
            _vue.createElementVNode("span", {
                class: _vue.normalizeClass(_ctx.ns.e("empty-text"))
            }, _vue.toDisplayString((_a = _ctx.emptyText) != null ? _a : _ctx.t("el.tree.emptyText")), 3)
        ], 2)) : _vue.createCommentVNode("v-if", true),
        _vue.withDirectives(_vue.createElementVNode("div", {
            ref: "dropIndicator$",
            class: _vue.normalizeClass(_ctx.ns.e("drop-indicator"))
        }, null, 2), [
            [
                _vue.vShow,
                _ctx.dragState.showDropIndicator
            ]
        ])
    ], 2);
}
var Tree = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./model/tree-store.mjs":"dtyUE","./model/util.mjs":"aMJ57","./tree-node.mjs":"14PM6","./model/useNodeExpandEventBroadcast.mjs":"iB6jO","./model/useDragNode.mjs":"8QzMv","./model/useKeydown.mjs":"jq905","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dtyUE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TreeStore
);
var _indexMjs = require("../../../../utils/index.mjs");
var _nodeMjs = require("./node.mjs");
var _nodeMjsDefault = parcelHelpers.interopDefault(_nodeMjs);
var _utilMjs = require("./util.mjs");
var _shared = require("@vue/shared");
class TreeStore {
    constructor(options){
        this.currentNode = null;
        this.currentNodeKey = null;
        for(const option in options)if (_shared.hasOwn(options, option)) this[option] = options[option];
        this.nodesMap = {
        };
    }
    initialize() {
        this.root = new _nodeMjsDefault.default({
            data: this.data,
            store: this
        });
        this.root.initialize();
        if (this.lazy && this.load) {
            const loadFn = this.load;
            loadFn(this.root, (data)=>{
                this.root.doCreateChildren(data);
                this._initDefaultCheckedNodes();
            });
        } else this._initDefaultCheckedNodes();
    }
    filter(value) {
        const filterNodeMethod = this.filterNodeMethod;
        const lazy = this.lazy;
        const traverse = function(node) {
            const childNodes = node.root ? node.root.childNodes : node.childNodes;
            childNodes.forEach((child)=>{
                child.visible = filterNodeMethod.call(child, value, child.data, child);
                traverse(child);
            });
            if (!node.visible && childNodes.length) {
                let allHidden = true;
                allHidden = !childNodes.some((child)=>child.visible
                );
                if (node.root) node.root.visible = allHidden === false;
                else node.visible = allHidden === false;
            }
            if (!value) return;
            if (node.visible && !node.isLeaf && !lazy) node.expand();
        };
        traverse(this);
    }
    setData(newVal) {
        const instanceChanged = newVal !== this.root.data;
        if (instanceChanged) {
            this.root.setData(newVal);
            this._initDefaultCheckedNodes();
        } else this.root.updateChildren();
    }
    getNode(data) {
        if (data instanceof _nodeMjsDefault.default) return data;
        const key = typeof data !== "object" ? data : _utilMjs.getNodeKey(this.key, data);
        return this.nodesMap[key] || null;
    }
    insertBefore(data, refData) {
        const refNode = this.getNode(refData);
        refNode.parent.insertBefore({
            data
        }, refNode);
    }
    insertAfter(data, refData) {
        const refNode = this.getNode(refData);
        refNode.parent.insertAfter({
            data
        }, refNode);
    }
    remove(data) {
        const node = this.getNode(data);
        if (node && node.parent) {
            if (node === this.currentNode) this.currentNode = null;
            node.parent.removeChild(node);
        }
    }
    append(data, parentData) {
        const parentNode = parentData ? this.getNode(parentData) : this.root;
        if (parentNode) parentNode.insertChild({
            data
        });
    }
    _initDefaultCheckedNodes() {
        const defaultCheckedKeys = this.defaultCheckedKeys || [];
        const nodesMap = this.nodesMap;
        defaultCheckedKeys.forEach((checkedKey)=>{
            const node = nodesMap[checkedKey];
            if (node) node.setChecked(true, !this.checkStrictly);
        });
    }
    _initDefaultCheckedNode(node) {
        const defaultCheckedKeys = this.defaultCheckedKeys || [];
        if (defaultCheckedKeys.indexOf(node.key) !== -1) node.setChecked(true, !this.checkStrictly);
    }
    setDefaultCheckedKey(newVal) {
        if (newVal !== this.defaultCheckedKeys) {
            this.defaultCheckedKeys = newVal;
            this._initDefaultCheckedNodes();
        }
    }
    registerNode(node) {
        const key = this.key;
        if (!node || !node.data) return;
        if (!key) this.nodesMap[node.id] = node;
        else {
            const nodeKey = node.key;
            if (nodeKey !== void 0) this.nodesMap[node.key] = node;
        }
    }
    deregisterNode(node) {
        const key = this.key;
        if (!key || !node || !node.data) return;
        node.childNodes.forEach((child)=>{
            this.deregisterNode(child);
        });
        delete this.nodesMap[node.key];
    }
    getCheckedNodes(leafOnly = false, includeHalfChecked = false) {
        const checkedNodes = [];
        const traverse = function(node) {
            const childNodes = node.root ? node.root.childNodes : node.childNodes;
            childNodes.forEach((child)=>{
                if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) checkedNodes.push(child.data);
                traverse(child);
            });
        };
        traverse(this);
        return checkedNodes;
    }
    getCheckedKeys(leafOnly = false) {
        return this.getCheckedNodes(leafOnly).map((data)=>(data || {
            })[this.key]
        );
    }
    getHalfCheckedNodes() {
        const nodes = [];
        const traverse = function(node) {
            const childNodes = node.root ? node.root.childNodes : node.childNodes;
            childNodes.forEach((child)=>{
                if (child.indeterminate) nodes.push(child.data);
                traverse(child);
            });
        };
        traverse(this);
        return nodes;
    }
    getHalfCheckedKeys() {
        return this.getHalfCheckedNodes().map((data)=>(data || {
            })[this.key]
        );
    }
    _getAllNodes() {
        const allNodes = [];
        const nodesMap = this.nodesMap;
        for(const nodeKey in nodesMap)if (_shared.hasOwn(nodesMap, nodeKey)) allNodes.push(nodesMap[nodeKey]);
        return allNodes;
    }
    updateChildren(key, data) {
        const node = this.nodesMap[key];
        if (!node) return;
        const childNodes = node.childNodes;
        for(let i = childNodes.length - 1; i >= 0; i--){
            const child = childNodes[i];
            this.remove(child.data);
        }
        for(let i1 = 0, j = data.length; i1 < j; i1++){
            const child = data[i1];
            this.append(child, node.data);
        }
    }
    _setCheckedKeys(key, leafOnly = false, checkedKeys) {
        const allNodes = this._getAllNodes().sort((a, b)=>b.level - a.level
        );
        const cache = /* @__PURE__ */ Object.create(null);
        const keys = Object.keys(checkedKeys);
        allNodes.forEach((node)=>node.setChecked(false, false)
        );
        for(let i = 0, j = allNodes.length; i < j; i++){
            const node = allNodes[i];
            const nodeKey = node.data[key].toString();
            const checked = keys.indexOf(nodeKey) > -1;
            if (!checked) {
                if (node.checked && !cache[nodeKey]) node.setChecked(false, false);
                continue;
            }
            let parent = node.parent;
            while(parent && parent.level > 0){
                cache[parent.data[key]] = true;
                parent = parent.parent;
            }
            if (node.isLeaf || this.checkStrictly) {
                node.setChecked(true, false);
                continue;
            }
            node.setChecked(true, true);
            if (leafOnly) {
                node.setChecked(false, false);
                const traverse = function(node2) {
                    const childNodes = node2.childNodes;
                    childNodes.forEach((child)=>{
                        if (!child.isLeaf) child.setChecked(false, false);
                        traverse(child);
                    });
                };
                traverse(node);
            }
        }
    }
    setCheckedNodes(array, leafOnly = false) {
        const key = this.key;
        const checkedKeys = {
        };
        array.forEach((item)=>{
            checkedKeys[(item || {
            })[key]] = true;
        });
        this._setCheckedKeys(key, leafOnly, checkedKeys);
    }
    setCheckedKeys(keys, leafOnly = false) {
        this.defaultCheckedKeys = keys;
        const key = this.key;
        const checkedKeys = {
        };
        keys.forEach((key2)=>{
            checkedKeys[key2] = true;
        });
        this._setCheckedKeys(key, leafOnly, checkedKeys);
    }
    setDefaultExpandedKeys(keys) {
        keys = keys || [];
        this.defaultExpandedKeys = keys;
        keys.forEach((key)=>{
            const node = this.getNode(key);
            if (node) node.expand(null, this.autoExpandParent);
        });
    }
    setChecked(data, checked, deep) {
        const node = this.getNode(data);
        if (node) node.setChecked(!!checked, deep);
    }
    getCurrentNode() {
        return this.currentNode;
    }
    setCurrentNode(currentNode) {
        const prevCurrentNode = this.currentNode;
        if (prevCurrentNode) prevCurrentNode.isCurrent = false;
        this.currentNode = currentNode;
        this.currentNode.isCurrent = true;
    }
    setUserCurrentNode(node, shouldAutoExpandParent = true) {
        const key = node[this.key];
        const currNode = this.nodesMap[key];
        this.setCurrentNode(currNode);
        if (shouldAutoExpandParent && this.currentNode.level > 1) this.currentNode.parent.expand(null, true);
    }
    setCurrentNodeKey(key, shouldAutoExpandParent = true) {
        if (key === null || key === void 0) {
            this.currentNode && (this.currentNode.isCurrent = false);
            this.currentNode = null;
            return;
        }
        const node = this.getNode(key);
        if (node) {
            this.setCurrentNode(node);
            if (shouldAutoExpandParent && this.currentNode.level > 1) this.currentNode.parent.expand(null, true);
        }
    }
}

},{"../../../../utils/index.mjs":"dsdeP","./node.mjs":"2yGLY","./util.mjs":"aMJ57","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2yGLY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Node
);
parcelHelpers.export(exports, "getChildState", ()=>getChildState
);
var _vue = require("vue");
var _indexMjs = require("../../../../utils/index.mjs");
var _utilMjs = require("./util.mjs");
var _shared = require("@vue/shared");
const getChildState = (node)=>{
    let all = true;
    let none = true;
    let allWithoutDisable = true;
    for(let i = 0, j = node.length; i < j; i++){
        const n = node[i];
        if (n.checked !== true || n.indeterminate) {
            all = false;
            if (!n.disabled) allWithoutDisable = false;
        }
        if (n.checked !== false || n.indeterminate) none = false;
    }
    return {
        all,
        none,
        allWithoutDisable,
        half: !all && !none
    };
};
const reInitChecked = function(node) {
    if (node.childNodes.length === 0) return;
    const { all , none , half  } = getChildState(node.childNodes);
    if (all) {
        node.checked = true;
        node.indeterminate = false;
    } else if (half) {
        node.checked = false;
        node.indeterminate = true;
    } else if (none) {
        node.checked = false;
        node.indeterminate = false;
    }
    const parent = node.parent;
    if (!parent || parent.level === 0) return;
    if (!node.store.checkStrictly) reInitChecked(parent);
};
const getPropertyFromData = function(node, prop) {
    const props = node.store.props;
    const data = node.data || {
    };
    const config = props[prop];
    if (typeof config === "function") return config(data, node);
    else if (typeof config === "string") return data[config];
    else if (typeof config === "undefined") {
        const dataProp = data[prop];
        return dataProp === void 0 ? "" : dataProp;
    }
};
let nodeIdSeed = 0;
class Node {
    constructor(options){
        this.id = nodeIdSeed++;
        this.text = null;
        this.checked = false;
        this.indeterminate = false;
        this.data = null;
        this.expanded = false;
        this.parent = null;
        this.visible = true;
        this.isCurrent = false;
        this.canFocus = false;
        for(const name in options)if (_shared.hasOwn(options, name)) this[name] = options[name];
        this.level = 0;
        this.loaded = false;
        this.childNodes = [];
        this.loading = false;
        if (this.parent) this.level = this.parent.level + 1;
    }
    initialize() {
        const store = this.store;
        if (!store) throw new Error("[Node]store is required!");
        store.registerNode(this);
        const props = store.props;
        if (props && typeof props.isLeaf !== "undefined") {
            const isLeaf = getPropertyFromData(this, "isLeaf");
            if (typeof isLeaf === "boolean") this.isLeafByUser = isLeaf;
        }
        if (store.lazy !== true && this.data) {
            this.setData(this.data);
            if (store.defaultExpandAll) {
                this.expanded = true;
                this.canFocus = true;
            }
        } else if (this.level > 0 && store.lazy && store.defaultExpandAll) this.expand();
        if (!Array.isArray(this.data)) _utilMjs.markNodeData(this, this.data);
        if (!this.data) return;
        const defaultExpandedKeys = store.defaultExpandedKeys;
        const key = store.key;
        if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) this.expand(null, store.autoExpandParent);
        if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {
            store.currentNode = this;
            store.currentNode.isCurrent = true;
        }
        if (store.lazy) store._initDefaultCheckedNode(this);
        this.updateLeafState();
        if (this.parent && (this.level === 1 || this.parent.expanded === true)) this.canFocus = true;
    }
    setData(data) {
        if (!Array.isArray(data)) _utilMjs.markNodeData(this, data);
        this.data = data;
        this.childNodes = [];
        let children;
        if (this.level === 0 && this.data instanceof Array) children = this.data;
        else children = getPropertyFromData(this, "children") || [];
        for(let i = 0, j = children.length; i < j; i++)this.insertChild({
            data: children[i]
        });
    }
    get label() {
        return getPropertyFromData(this, "label");
    }
    get key() {
        const nodeKey = this.store.key;
        if (this.data) return this.data[nodeKey];
        return null;
    }
    get disabled() {
        return getPropertyFromData(this, "disabled");
    }
    get nextSibling() {
        const parent = this.parent;
        if (parent) {
            const index = parent.childNodes.indexOf(this);
            if (index > -1) return parent.childNodes[index + 1];
        }
        return null;
    }
    get previousSibling() {
        const parent = this.parent;
        if (parent) {
            const index = parent.childNodes.indexOf(this);
            if (index > -1) return index > 0 ? parent.childNodes[index - 1] : null;
        }
        return null;
    }
    contains(target, deep = true) {
        return (this.childNodes || []).some((child)=>child === target || deep && child.contains(target)
        );
    }
    remove() {
        const parent = this.parent;
        if (parent) parent.removeChild(this);
    }
    insertChild(child, index, batch) {
        if (!child) throw new Error("InsertChild error: child is required.");
        if (!(child instanceof Node)) {
            if (!batch) {
                const children = this.getChildren(true);
                if (children.indexOf(child.data) === -1) {
                    if (typeof index === "undefined" || index < 0) children.push(child.data);
                    else children.splice(index, 0, child.data);
                }
            }
            Object.assign(child, {
                parent: this,
                store: this.store
            });
            child = _vue.reactive(new Node(child));
            if (child instanceof Node) child.initialize();
        }
        child.level = this.level + 1;
        if (typeof index === "undefined" || index < 0) this.childNodes.push(child);
        else this.childNodes.splice(index, 0, child);
        this.updateLeafState();
    }
    insertBefore(child, ref) {
        let index;
        if (ref) index = this.childNodes.indexOf(ref);
        this.insertChild(child, index);
    }
    insertAfter(child, ref) {
        let index;
        if (ref) {
            index = this.childNodes.indexOf(ref);
            if (index !== -1) index += 1;
        }
        this.insertChild(child, index);
    }
    removeChild(child) {
        const children = this.getChildren() || [];
        const dataIndex = children.indexOf(child.data);
        if (dataIndex > -1) children.splice(dataIndex, 1);
        const index = this.childNodes.indexOf(child);
        if (index > -1) {
            this.store && this.store.deregisterNode(child);
            child.parent = null;
            this.childNodes.splice(index, 1);
        }
        this.updateLeafState();
    }
    removeChildByData(data) {
        let targetNode = null;
        for(let i = 0; i < this.childNodes.length; i++)if (this.childNodes[i].data === data) {
            targetNode = this.childNodes[i];
            break;
        }
        if (targetNode) this.removeChild(targetNode);
    }
    expand(callback, expandParent) {
        const done = ()=>{
            if (expandParent) {
                let parent = this.parent;
                while(parent.level > 0){
                    parent.expanded = true;
                    parent = parent.parent;
                }
            }
            this.expanded = true;
            if (callback) callback();
            this.childNodes.forEach((item)=>{
                item.canFocus = true;
            });
        };
        if (this.shouldLoadData()) this.loadData((data)=>{
            if (Array.isArray(data)) {
                if (this.checked) this.setChecked(true, true);
                else if (!this.store.checkStrictly) reInitChecked(this);
                done();
            }
        });
        else done();
    }
    doCreateChildren(array, defaultProps = {
    }) {
        array.forEach((item)=>{
            this.insertChild(Object.assign({
                data: item
            }, defaultProps), void 0, true);
        });
    }
    collapse() {
        this.expanded = false;
        this.childNodes.forEach((item)=>{
            item.canFocus = false;
        });
    }
    shouldLoadData() {
        return this.store.lazy === true && this.store.load && !this.loaded;
    }
    updateLeafState() {
        if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== "undefined") {
            this.isLeaf = this.isLeafByUser;
            return;
        }
        const childNodes = this.childNodes;
        if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
            this.isLeaf = !childNodes || childNodes.length === 0;
            return;
        }
        this.isLeaf = false;
    }
    setChecked(value, deep, recursion, passValue) {
        this.indeterminate = value === "half";
        this.checked = value === true;
        if (this.store.checkStrictly) return;
        if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
            const { all , allWithoutDisable  } = getChildState(this.childNodes);
            if (!this.isLeaf && !all && allWithoutDisable) {
                this.checked = false;
                value = false;
            }
            const handleDescendants = ()=>{
                if (deep) {
                    const childNodes = this.childNodes;
                    for(let i = 0, j = childNodes.length; i < j; i++){
                        const child = childNodes[i];
                        passValue = passValue || value !== false;
                        const isCheck = child.disabled ? child.checked : passValue;
                        child.setChecked(isCheck, deep, true, passValue);
                    }
                    const { half , all: all2  } = getChildState(childNodes);
                    if (!all2) {
                        this.checked = all2;
                        this.indeterminate = half;
                    }
                }
            };
            if (this.shouldLoadData()) {
                this.loadData(()=>{
                    handleDescendants();
                    reInitChecked(this);
                }, {
                    checked: value !== false
                });
                return;
            } else handleDescendants();
        }
        const parent = this.parent;
        if (!parent || parent.level === 0) return;
        if (!recursion) reInitChecked(parent);
    }
    getChildren(forceInit = false) {
        if (this.level === 0) return this.data;
        const data = this.data;
        if (!data) return null;
        const props = this.store.props;
        let children = "children";
        if (props) children = props.children || "children";
        if (data[children] === void 0) data[children] = null;
        if (forceInit && !data[children]) data[children] = [];
        return data[children];
    }
    updateChildren() {
        const newData = this.getChildren() || [];
        const oldData = this.childNodes.map((node)=>node.data
        );
        const newDataMap = {
        };
        const newNodes = [];
        newData.forEach((item, index)=>{
            const key = item[_utilMjs.NODE_KEY];
            const isNodeExists = !!key && oldData.findIndex((data)=>data[_utilMjs.NODE_KEY] === key
            ) >= 0;
            if (isNodeExists) newDataMap[key] = {
                index,
                data: item
            };
            else newNodes.push({
                index,
                data: item
            });
        });
        if (!this.store.lazy) oldData.forEach((item)=>{
            if (!newDataMap[item[_utilMjs.NODE_KEY]]) this.removeChildByData(item);
        });
        newNodes.forEach(({ index , data  })=>{
            this.insertChild({
                data
            }, index);
        });
        this.updateLeafState();
    }
    loadData(callback, defaultProps = {
    }) {
        if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {
            this.loading = true;
            const resolve = (children)=>{
                this.loaded = true;
                this.loading = false;
                this.childNodes = [];
                this.doCreateChildren(children, defaultProps);
                this.updateLeafState();
                if (callback) callback.call(this, children);
            };
            this.store.load(this, resolve);
        } else if (callback) callback.call(this);
    }
}

},{"vue":"gzxs9","../../../../utils/index.mjs":"dsdeP","./util.mjs":"aMJ57","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aMJ57":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NODE_KEY", ()=>NODE_KEY
);
parcelHelpers.export(exports, "getNodeKey", ()=>getNodeKey
);
parcelHelpers.export(exports, "markNodeData", ()=>markNodeData
);
const NODE_KEY = "$treeNodeId";
const markNodeData = function(node, data) {
    if (!data || data[NODE_KEY]) return;
    Object.defineProperty(data, NODE_KEY, {
        value: node.id,
        enumerable: false,
        configurable: false,
        writable: false
    });
};
const getNodeKey = function(key, data) {
    if (!key) return data[NODE_KEY];
    return data[key];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"14PM6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElTreeNode
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _indexMjs = require("../../collapse-transition/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _indexMjs1 = require("../../checkbox/index.mjs");
var _indexMjs2 = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs3 = require("../../../utils/index.mjs");
var _indexMjs4 = require("../../../hooks/index.mjs");
var _treeNodeContentMjs = require("./tree-node-content.mjs");
var _treeNodeContentMjsDefault = parcelHelpers.interopDefault(_treeNodeContentMjs);
var _utilMjs = require("./model/util.mjs");
var _useNodeExpandEventBroadcastMjs = require("./model/useNodeExpandEventBroadcast.mjs");
var _useDragNodeMjs = require("./model/useDragNode.mjs");
var _nodeMjs = require("./model/node.mjs");
var _nodeMjsDefault = parcelHelpers.interopDefault(_nodeMjs);
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs5 = require("../../../hooks/use-namespace/index.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElTreeNode",
    components: {
        ElCollapseTransition: _indexMjsDefault.default,
        ElCheckbox: _indexMjs1.ElCheckbox,
        NodeContent: _treeNodeContentMjsDefault.default,
        ElIcon: _indexMjs2.ElIcon,
        Loading: _iconsVue.Loading
    },
    props: {
        node: {
            type: _nodeMjsDefault.default,
            default: ()=>({
                })
        },
        props: {
            type: Object,
            default: ()=>({
                })
        },
        accordion: Boolean,
        renderContent: Function,
        renderAfterExpand: Boolean,
        showCheckbox: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "node-expand"
    ],
    setup (props, ctx) {
        const ns = _indexMjs5.useNamespace("tree");
        const { broadcastExpanded  } = _useNodeExpandEventBroadcastMjs.useNodeExpandEventBroadcast(props);
        const tree = _vue.inject("RootTree");
        const expanded = _vue.ref(false);
        const childNodeRendered = _vue.ref(false);
        const oldChecked = _vue.ref(null);
        const oldIndeterminate = _vue.ref(null);
        const node$ = _vue.ref(null);
        const dragEvents = _vue.inject(_useDragNodeMjs.dragEventsKey);
        const instance = _vue.getCurrentInstance();
        _vue.provide("NodeInstance", instance);
        if (!tree) _errorMjs.debugWarn("Tree", "Can not find node's tree.");
        if (props.node.expanded) {
            expanded.value = true;
            childNodeRendered.value = true;
        }
        const childrenKey = tree.props["children"] || "children";
        _vue.watch(()=>{
            const children = props.node.data[childrenKey];
            return children && [
                ...children
            ];
        }, ()=>{
            props.node.updateChildren();
        });
        _vue.watch(()=>props.node.indeterminate
        , (val)=>{
            handleSelectChange(props.node.checked, val);
        });
        _vue.watch(()=>props.node.checked
        , (val)=>{
            handleSelectChange(val, props.node.indeterminate);
        });
        _vue.watch(()=>props.node.expanded
        , (val)=>{
            _vue.nextTick(()=>expanded.value = val
            );
            if (val) childNodeRendered.value = true;
        });
        const getNodeKey$1 = (node)=>{
            return _utilMjs.getNodeKey(tree.props.nodeKey, node.data);
        };
        const getNodeClass = (node)=>{
            const nodeClassFunc = props.props.class;
            if (!nodeClassFunc) return {
            };
            let className;
            if (_shared.isFunction(nodeClassFunc)) {
                const { data  } = node;
                className = nodeClassFunc(data, node);
            } else className = nodeClassFunc;
            if (_shared.isString(className)) return {
                [className]: true
            };
            else return className;
        };
        const handleSelectChange = (checked, indeterminate)=>{
            if (oldChecked.value !== checked || oldIndeterminate.value !== indeterminate) tree.ctx.emit("check-change", props.node.data, checked, indeterminate);
            oldChecked.value = checked;
            oldIndeterminate.value = indeterminate;
        };
        const handleClick = (e)=>{
            const store = tree.store.value;
            store.setCurrentNode(props.node);
            tree.ctx.emit("current-change", store.currentNode ? store.currentNode.data : null, store.currentNode);
            tree.currentNode.value = props.node;
            if (tree.props.expandOnClickNode) handleExpandIconClick();
            if (tree.props.checkOnClickNode && !props.node.disabled) handleCheckChange(null, {
                target: {
                    checked: !props.node.checked
                }
            });
            tree.ctx.emit("node-click", props.node.data, props.node, instance, e);
        };
        const handleContextMenu = (event)=>{
            if (tree.instance.vnode.props["onNodeContextmenu"]) {
                event.stopPropagation();
                event.preventDefault();
            }
            tree.ctx.emit("node-contextmenu", event, props.node.data, props.node, instance);
        };
        const handleExpandIconClick = ()=>{
            if (props.node.isLeaf) return;
            if (expanded.value) {
                tree.ctx.emit("node-collapse", props.node.data, props.node, instance);
                props.node.collapse();
            } else {
                props.node.expand();
                ctx.emit("node-expand", props.node.data, props.node, instance);
            }
        };
        const handleCheckChange = (value, ev)=>{
            props.node.setChecked(ev.target.checked, !tree.props.checkStrictly);
            _vue.nextTick(()=>{
                const store = tree.store.value;
                tree.ctx.emit("check", props.node.data, {
                    checkedNodes: store.getCheckedNodes(),
                    checkedKeys: store.getCheckedKeys(),
                    halfCheckedNodes: store.getHalfCheckedNodes(),
                    halfCheckedKeys: store.getHalfCheckedKeys()
                });
            });
        };
        const handleChildNodeExpand = (nodeData, node, instance2)=>{
            broadcastExpanded(node);
            tree.ctx.emit("node-expand", nodeData, node, instance2);
        };
        const handleDragStart = (event)=>{
            if (!tree.props.draggable) return;
            dragEvents.treeNodeDragStart({
                event,
                treeNode: props
            });
        };
        const handleDragOver = (event)=>{
            event.preventDefault();
            if (!tree.props.draggable) return;
            dragEvents.treeNodeDragOver({
                event,
                treeNode: {
                    $el: node$.value,
                    node: props.node
                }
            });
        };
        const handleDrop = (event)=>{
            event.preventDefault();
        };
        const handleDragEnd = (event)=>{
            if (!tree.props.draggable) return;
            dragEvents.treeNodeDragEnd(event);
        };
        return {
            ns,
            node$,
            tree,
            expanded,
            childNodeRendered,
            oldChecked,
            oldIndeterminate,
            getNodeKey: getNodeKey$1,
            getNodeClass,
            handleSelectChange,
            handleClick,
            handleContextMenu,
            handleExpandIconClick,
            handleCheckChange,
            handleChildNodeExpand,
            handleDragStart,
            handleDragOver,
            handleDrop,
            handleDragEnd,
            CaretRight: _iconsVue.CaretRight
        };
    }
});
const _hoisted_1 = [
    "aria-expanded",
    "aria-disabled",
    "aria-checked",
    "draggable",
    "data-key"
];
const _hoisted_2 = [
    "aria-expanded"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_checkbox = _vue.resolveComponent("el-checkbox");
    const _component_loading = _vue.resolveComponent("loading");
    const _component_node_content = _vue.resolveComponent("node-content");
    const _component_el_tree_node = _vue.resolveComponent("el-tree-node");
    const _component_el_collapse_transition = _vue.resolveComponent("el-collapse-transition");
    return _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
        ref: "node$",
        class: _vue.normalizeClass([
            _ctx.ns.b("node"),
            _ctx.ns.is("expanded", _ctx.expanded),
            _ctx.ns.is("current", _ctx.node.isCurrent),
            _ctx.ns.is("hidden", !_ctx.node.visible),
            _ctx.ns.is("focusable", !_ctx.node.disabled),
            _ctx.ns.is("checked", !_ctx.node.disabled && _ctx.node.checked),
            _ctx.getNodeClass(_ctx.node)
        ]),
        role: "treeitem",
        tabindex: "-1",
        "aria-expanded": _ctx.expanded,
        "aria-disabled": _ctx.node.disabled,
        "aria-checked": _ctx.node.checked,
        draggable: _ctx.tree.props.draggable,
        "data-key": _ctx.getNodeKey(_ctx.node),
        onClick: _cache[1] || (_cache[1] = _vue.withModifiers((...args)=>_ctx.handleClick && _ctx.handleClick(...args)
        , [
            "stop"
        ])),
        onContextmenu: _cache[2] || (_cache[2] = (...args)=>_ctx.handleContextMenu && _ctx.handleContextMenu(...args)
        ),
        onDragstart: _cache[3] || (_cache[3] = _vue.withModifiers((...args)=>_ctx.handleDragStart && _ctx.handleDragStart(...args)
        , [
            "stop"
        ])),
        onDragover: _cache[4] || (_cache[4] = _vue.withModifiers((...args)=>_ctx.handleDragOver && _ctx.handleDragOver(...args)
        , [
            "stop"
        ])),
        onDragend: _cache[5] || (_cache[5] = _vue.withModifiers((...args)=>_ctx.handleDragEnd && _ctx.handleDragEnd(...args)
        , [
            "stop"
        ])),
        onDrop: _cache[6] || (_cache[6] = _vue.withModifiers((...args)=>_ctx.handleDrop && _ctx.handleDrop(...args)
        , [
            "stop"
        ]))
    }, [
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.be("node", "content")),
            style: _vue.normalizeStyle({
                paddingLeft: (_ctx.node.level - 1) * _ctx.tree.props.indent + "px"
            })
        }, [
            _ctx.tree.props.icon || _ctx.CaretRight ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                key: 0,
                class: _vue.normalizeClass([
                    _ctx.ns.be("node", "expand-icon"),
                    _ctx.ns.is("leaf", _ctx.node.isLeaf),
                    {
                        expanded: !_ctx.node.isLeaf && _ctx.expanded
                    }
                ]),
                onClick: _vue.withModifiers(_ctx.handleExpandIconClick, [
                    "stop"
                ])
            }, {
                default: _vue.withCtx(()=>[
                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.tree.props.icon || _ctx.CaretRight)))
                    ]
                ),
                _: 1
            }, 8, [
                "class",
                "onClick"
            ])) : _vue.createCommentVNode("v-if", true),
            _ctx.showCheckbox ? (_vue.openBlock(), _vue.createBlock(_component_el_checkbox, {
                key: 1,
                "model-value": _ctx.node.checked,
                indeterminate: _ctx.node.indeterminate,
                disabled: !!_ctx.node.disabled,
                onClick: _cache[0] || (_cache[0] = _vue.withModifiers(()=>{
                }, [
                    "stop"
                ])),
                onChange: _ctx.handleCheckChange
            }, null, 8, [
                "model-value",
                "indeterminate",
                "disabled",
                "onChange"
            ])) : _vue.createCommentVNode("v-if", true),
            _ctx.node.loading ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                key: 2,
                class: _vue.normalizeClass([
                    _ctx.ns.be("node", "loading-icon"),
                    _ctx.ns.is("loading")
                ])
            }, {
                default: _vue.withCtx(()=>[
                        _vue.createVNode(_component_loading)
                    ]
                ),
                _: 1
            }, 8, [
                "class"
            ])) : _vue.createCommentVNode("v-if", true),
            _vue.createVNode(_component_node_content, {
                node: _ctx.node,
                "render-content": _ctx.renderContent
            }, null, 8, [
                "node",
                "render-content"
            ])
        ], 6),
        _vue.createVNode(_component_el_collapse_transition, null, {
            default: _vue.withCtx(()=>[
                    !_ctx.renderAfterExpand || _ctx.childNodeRendered ? _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
                        key: 0,
                        class: _vue.normalizeClass(_ctx.ns.be("node", "children")),
                        role: "group",
                        "aria-expanded": _ctx.expanded
                    }, [
                        (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.node.childNodes, (child)=>{
                            return _vue.openBlock(), _vue.createBlock(_component_el_tree_node, {
                                key: _ctx.getNodeKey(child),
                                "render-content": _ctx.renderContent,
                                "render-after-expand": _ctx.renderAfterExpand,
                                "show-checkbox": _ctx.showCheckbox,
                                node: child,
                                accordion: _ctx.accordion,
                                props: _ctx.props,
                                onNodeExpand: _ctx.handleChildNodeExpand
                            }, null, 8, [
                                "render-content",
                                "render-after-expand",
                                "show-checkbox",
                                "node",
                                "accordion",
                                "props",
                                "onNodeExpand"
                            ]);
                        }), 128))
                    ], 10, _hoisted_2)), [
                        [
                            _vue.vShow,
                            _ctx.expanded
                        ]
                    ]) : _vue.createCommentVNode("v-if", true)
                ]
            ),
            _: 1
        })
    ], 42, _hoisted_1)), [
        [
            _vue.vShow,
            _ctx.node.visible
        ]
    ]);
}
var ElTreeNode = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vue/shared":"3SM3y","../../collapse-transition/index.mjs":"kOsra","../../checkbox/index.mjs":"jMNjD","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./tree-node-content.mjs":"4TWj7","./model/util.mjs":"aMJ57","./model/useNodeExpandEventBroadcast.mjs":"iB6jO","./model/useDragNode.mjs":"8QzMv","./model/node.mjs":"2yGLY","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4TWj7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_sfc_main
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElTreeNodeContent",
    props: {
        node: {
            type: Object,
            required: true
        },
        renderContent: Function
    },
    setup (props) {
        const ns = _indexMjs1.useNamespace("tree");
        const nodeInstance = _vue.inject("NodeInstance");
        const tree = _vue.inject("RootTree");
        return ()=>{
            const node = props.node;
            const { data , store  } = node;
            return props.renderContent ? props.renderContent(_vue.h, {
                _self: nodeInstance,
                node,
                data,
                store
            }) : tree.ctx.slots.default ? tree.ctx.slots.default({
                node,
                data
            }) : _vue.h("span", {
                class: ns.be("node", "label")
            }, [
                node.label
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iB6jO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useNodeExpandEventBroadcast", ()=>useNodeExpandEventBroadcast
);
var _vue = require("vue");
function useNodeExpandEventBroadcast(props) {
    const parentNodeMap = _vue.inject("TreeNodeMap", null);
    const currentNodeMap = {
        treeNodeExpand: (node)=>{
            if (props.node !== node) props.node.collapse();
        },
        children: []
    };
    if (parentNodeMap) parentNodeMap.children.push(currentNodeMap);
    _vue.provide("TreeNodeMap", currentNodeMap);
    return {
        broadcastExpanded: (node)=>{
            if (!props.accordion) return;
            for (const childNode of currentNodeMap.children)childNode.treeNodeExpand(node);
        }
    };
}

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8QzMv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dragEventsKey", ()=>dragEventsKey
);
parcelHelpers.export(exports, "useDragNodeHandler", ()=>useDragNodeHandler
);
var _vue = require("vue");
var _indexMjs = require("../../../../utils/index.mjs");
var _indexMjs1 = require("../../../../hooks/index.mjs");
var _indexMjs2 = require("../../../../hooks/use-namespace/index.mjs");
var _styleMjs = require("../../../../utils/dom/style.mjs");
const dragEventsKey = Symbol("dragEvents");
function useDragNodeHandler({ props , ctx , el$ , dropIndicator$ , store  }) {
    const ns = _indexMjs2.useNamespace("tree");
    const dragState = _vue.ref({
        showDropIndicator: false,
        draggingNode: null,
        dropNode: null,
        allowDrop: true,
        dropType: null
    });
    const treeNodeDragStart = ({ event , treeNode  })=>{
        if (typeof props.allowDrag === "function" && !props.allowDrag(treeNode.node)) {
            event.preventDefault();
            return false;
        }
        event.dataTransfer.effectAllowed = "move";
        try {
            event.dataTransfer.setData("text/plain", "");
        } catch (e) {
        }
        dragState.value.draggingNode = treeNode;
        ctx.emit("node-drag-start", treeNode.node, event);
    };
    const treeNodeDragOver = ({ event , treeNode  })=>{
        const dropNode = treeNode;
        const oldDropNode = dragState.value.dropNode;
        if (oldDropNode && oldDropNode !== dropNode) _styleMjs.removeClass(oldDropNode.$el, ns.is("drop-inner"));
        const draggingNode = dragState.value.draggingNode;
        if (!draggingNode || !dropNode) return;
        let dropPrev = true;
        let dropInner = true;
        let dropNext = true;
        let userAllowDropInner = true;
        if (typeof props.allowDrop === "function") {
            dropPrev = props.allowDrop(draggingNode.node, dropNode.node, "prev");
            userAllowDropInner = dropInner = props.allowDrop(draggingNode.node, dropNode.node, "inner");
            dropNext = props.allowDrop(draggingNode.node, dropNode.node, "next");
        }
        event.dataTransfer.dropEffect = dropInner || dropPrev || dropNext ? "move" : "none";
        if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {
            if (oldDropNode) ctx.emit("node-drag-leave", draggingNode.node, oldDropNode.node, event);
            ctx.emit("node-drag-enter", draggingNode.node, dropNode.node, event);
        }
        if (dropPrev || dropInner || dropNext) dragState.value.dropNode = dropNode;
        if (dropNode.node.nextSibling === draggingNode.node) dropNext = false;
        if (dropNode.node.previousSibling === draggingNode.node) dropPrev = false;
        if (dropNode.node.contains(draggingNode.node, false)) dropInner = false;
        if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
            dropPrev = false;
            dropInner = false;
            dropNext = false;
        }
        const targetPosition = dropNode.$el.getBoundingClientRect();
        const treePosition = el$.value.getBoundingClientRect();
        let dropType;
        const prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;
        const nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;
        let indicatorTop = -9999;
        const distance = event.clientY - targetPosition.top;
        if (distance < targetPosition.height * prevPercent) dropType = "before";
        else if (distance > targetPosition.height * nextPercent) dropType = "after";
        else if (dropInner) dropType = "inner";
        else dropType = "none";
        const iconPosition = dropNode.$el.querySelector(`.${ns.be("node", "expand-icon")}`).getBoundingClientRect();
        const dropIndicator = dropIndicator$.value;
        if (dropType === "before") indicatorTop = iconPosition.top - treePosition.top;
        else if (dropType === "after") indicatorTop = iconPosition.bottom - treePosition.top;
        dropIndicator.style.top = `${indicatorTop}px`;
        dropIndicator.style.left = `${iconPosition.right - treePosition.left}px`;
        if (dropType === "inner") _styleMjs.addClass(dropNode.$el, ns.is("drop-inner"));
        else _styleMjs.removeClass(dropNode.$el, ns.is("drop-inner"));
        dragState.value.showDropIndicator = dropType === "before" || dropType === "after";
        dragState.value.allowDrop = dragState.value.showDropIndicator || userAllowDropInner;
        dragState.value.dropType = dropType;
        ctx.emit("node-drag-over", draggingNode.node, dropNode.node, event);
    };
    const treeNodeDragEnd = (event)=>{
        const { draggingNode , dropType , dropNode  } = dragState.value;
        event.preventDefault();
        event.dataTransfer.dropEffect = "move";
        if (draggingNode && dropNode) {
            const draggingNodeCopy = {
                data: draggingNode.node.data
            };
            if (dropType !== "none") draggingNode.node.remove();
            if (dropType === "before") dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
            else if (dropType === "after") dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
            else if (dropType === "inner") dropNode.node.insertChild(draggingNodeCopy);
            if (dropType !== "none") store.value.registerNode(draggingNodeCopy);
            _styleMjs.removeClass(dropNode.$el, ns.is("drop-inner"));
            ctx.emit("node-drag-end", draggingNode.node, dropNode.node, dropType, event);
            if (dropType !== "none") ctx.emit("node-drop", draggingNode.node, dropNode.node, dropType, event);
        }
        if (draggingNode && !dropNode) ctx.emit("node-drag-end", draggingNode.node, null, dropType, event);
        dragState.value.showDropIndicator = false;
        dragState.value.draggingNode = null;
        dragState.value.dropNode = null;
        dragState.value.allowDrop = true;
    };
    _vue.provide(dragEventsKey, {
        treeNodeDragStart,
        treeNodeDragOver,
        treeNodeDragEnd
    });
    return {
        dragState
    };
}

},{"vue":"gzxs9","../../../../utils/index.mjs":"dsdeP","../../../../hooks/index.mjs":"1Ansp","../../../../hooks/use-namespace/index.mjs":"a1pcf","../../../../utils/dom/style.mjs":"cA8Mp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jq905":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useKeydown", ()=>useKeydown
);
var _vue = require("vue");
var _indexMjs = require("../../../../utils/index.mjs");
var _indexMjs1 = require("../../../../constants/index.mjs");
var _indexMjs2 = require("../../../../hooks/index.mjs");
var _indexMjs3 = require("../../../../hooks/use-namespace/index.mjs");
var _eventMjs = require("../../../../utils/dom/event.mjs");
var _ariaMjs = require("../../../../constants/aria.mjs");
function useKeydown({ el$  }, store) {
    const ns = _indexMjs3.useNamespace("tree");
    const treeItems = _vue.shallowRef([]);
    const checkboxItems = _vue.shallowRef([]);
    _vue.onMounted(()=>{
        initTabIndex();
        _eventMjs.on(el$.value, "keydown", handleKeydown);
    });
    _vue.onBeforeUnmount(()=>{
        _eventMjs.off(el$.value, "keydown", handleKeydown);
    });
    _vue.onUpdated(()=>{
        treeItems.value = Array.from(el$.value.querySelectorAll("[role=treeitem]"));
        checkboxItems.value = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
    });
    _vue.watch(checkboxItems, (val)=>{
        val.forEach((checkbox)=>{
            checkbox.setAttribute("tabindex", "-1");
        });
    });
    const handleKeydown = (ev)=>{
        const currentItem = ev.target;
        if (currentItem.className.indexOf(ns.b("node")) === -1) return;
        const code = ev.code;
        treeItems.value = Array.from(el$.value.querySelectorAll(`.${ns.is("focusable")}[role=treeitem]`));
        const currentIndex = treeItems.value.indexOf(currentItem);
        let nextIndex;
        if ([
            _ariaMjs.EVENT_CODE.up,
            _ariaMjs.EVENT_CODE.down
        ].indexOf(code) > -1) {
            ev.preventDefault();
            if (code === _ariaMjs.EVENT_CODE.up) {
                nextIndex = currentIndex === -1 ? 0 : currentIndex !== 0 ? currentIndex - 1 : treeItems.value.length - 1;
                const startIndex = nextIndex;
                while(true){
                    if (store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus) break;
                    nextIndex--;
                    if (nextIndex === startIndex) {
                        nextIndex = -1;
                        break;
                    }
                    if (nextIndex < 0) nextIndex = treeItems.value.length - 1;
                }
            } else {
                nextIndex = currentIndex === -1 ? 0 : currentIndex < treeItems.value.length - 1 ? currentIndex + 1 : 0;
                const startIndex = nextIndex;
                while(true){
                    if (store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus) break;
                    nextIndex++;
                    if (nextIndex === startIndex) {
                        nextIndex = -1;
                        break;
                    }
                    if (nextIndex >= treeItems.value.length) nextIndex = 0;
                }
            }
            nextIndex !== -1 && treeItems.value[nextIndex].focus();
        }
        if ([
            _ariaMjs.EVENT_CODE.left,
            _ariaMjs.EVENT_CODE.right
        ].indexOf(code) > -1) {
            ev.preventDefault();
            currentItem.click();
        }
        const hasInput = currentItem.querySelector('[type="checkbox"]');
        if ([
            _ariaMjs.EVENT_CODE.enter,
            _ariaMjs.EVENT_CODE.space
        ].indexOf(code) > -1 && hasInput) {
            ev.preventDefault();
            hasInput.click();
        }
    };
    const initTabIndex = ()=>{
        var _a;
        treeItems.value = Array.from(el$.value.querySelectorAll(`.${ns.is("focusable")}[role=treeitem]`));
        checkboxItems.value = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
        const checkedItem = el$.value.querySelectorAll(`.${ns.is("checked")}[role=treeitem]`);
        if (checkedItem.length) {
            checkedItem[0].setAttribute("tabindex", "0");
            return;
        }
        (_a = treeItems.value[0]) == null || _a.setAttribute("tabindex", "0");
    };
}

},{"vue":"gzxs9","../../../../utils/index.mjs":"dsdeP","../../../../constants/index.mjs":"74Fbn","../../../../hooks/index.mjs":"1Ansp","../../../../hooks/use-namespace/index.mjs":"a1pcf","../../../../utils/dom/event.mjs":"fnXSh","../../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eqslC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElTreeV2", ()=>ElTreeV2
);
parcelHelpers.export(exports, "default", ()=>ElTreeV2
);
var _indexMjs = require("../../utils/index.mjs");
var _treeMjs = require("./src/tree.mjs");
var _treeMjsDefault = parcelHelpers.interopDefault(_treeMjs);
var _installMjs = require("../../utils/vue/install.mjs");
const ElTreeV2 = _installMjs.withInstall(_treeMjsDefault.default);

},{"../../utils/index.mjs":"dsdeP","./src/tree.mjs":"iHsvg","../../utils/vue/install.mjs":"4TMmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iHsvg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>TreeV2
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../virtual-list/index.mjs");
var _useTreeMjs = require("./composables/useTree.mjs");
var _treeNodeMjs = require("./tree-node.mjs");
var _treeNodeMjsDefault = parcelHelpers.interopDefault(_treeNodeMjs);
var _virtualTreeMjs = require("./virtual-tree.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _fixedSizeListMjs = require("../../virtual-list/src/components/fixed-size-list.mjs");
var _fixedSizeListMjsDefault = parcelHelpers.interopDefault(_fixedSizeListMjs);
var _indexMjs2 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElTreeV2",
    components: {
        ElTreeNode: _treeNodeMjsDefault.default,
        FixedSizeList: _fixedSizeListMjsDefault.default
    },
    props: _virtualTreeMjs.treeProps,
    emits: _virtualTreeMjs.treeEmits,
    setup (props, ctx) {
        _vue.provide(_virtualTreeMjs.ROOT_TREE_INJECTION_KEY, {
            ctx,
            props,
            instance: _vue.getCurrentInstance()
        });
        const { t  } = _indexMjs2.useLocale();
        const ns = _indexMjs3.useNamespace("tree");
        const { flattenTree , isNotEmpty , toggleExpand , isExpanded , isIndeterminate , isChecked , isDisabled , isCurrent , isForceHiddenExpandIcon , toggleCheckbox , handleNodeClick , handleNodeCheck , getCurrentNode , getCurrentKey , setCurrentKey , getCheckedKeys , getCheckedNodes , getHalfCheckedKeys , getHalfCheckedNodes , setChecked , setCheckedKeys , filter , setData  } = _useTreeMjs.useTree(props, ctx.emit);
        ctx.expose({
            getCurrentNode,
            getCurrentKey,
            setCurrentKey,
            getCheckedKeys,
            getCheckedNodes,
            getHalfCheckedKeys,
            getHalfCheckedNodes,
            setChecked,
            setCheckedKeys,
            filter,
            setData
        });
        return {
            t,
            ns,
            flattenTree,
            itemSize: 26,
            isNotEmpty,
            toggleExpand,
            toggleCheckbox,
            isExpanded,
            isIndeterminate,
            isChecked,
            isDisabled,
            isCurrent,
            isForceHiddenExpandIcon,
            handleNodeClick,
            handleNodeCheck
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    var _a;
    const _component_el_tree_node = _vue.resolveComponent("el-tree-node");
    const _component_fixed_size_list = _vue.resolveComponent("fixed-size-list");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            {
                [_ctx.ns.m("highlight-current")]: _ctx.highlightCurrent
            }
        ]),
        role: "tree"
    }, [
        _ctx.isNotEmpty ? (_vue.openBlock(), _vue.createBlock(_component_fixed_size_list, {
            key: 0,
            "class-name": _ctx.ns.b("virtual-list"),
            data: _ctx.flattenTree,
            total: _ctx.flattenTree.length,
            height: _ctx.height,
            "item-size": _ctx.itemSize,
            "perf-mode": _ctx.perfMode
        }, {
            default: _vue.withCtx(({ data , index , style  })=>[
                    (_vue.openBlock(), _vue.createBlock(_component_el_tree_node, {
                        key: data[index].key,
                        style: _vue.normalizeStyle(style),
                        node: data[index],
                        expanded: _ctx.isExpanded(data[index]),
                        "show-checkbox": _ctx.showCheckbox,
                        checked: _ctx.isChecked(data[index]),
                        indeterminate: _ctx.isIndeterminate(data[index]),
                        disabled: _ctx.isDisabled(data[index]),
                        current: _ctx.isCurrent(data[index]),
                        "hidden-expand-icon": _ctx.isForceHiddenExpandIcon(data[index]),
                        onClick: _ctx.handleNodeClick,
                        onToggle: _ctx.toggleExpand,
                        onCheck: _ctx.handleNodeCheck
                    }, null, 8, [
                        "style",
                        "node",
                        "expanded",
                        "show-checkbox",
                        "checked",
                        "indeterminate",
                        "disabled",
                        "current",
                        "hidden-expand-icon",
                        "onClick",
                        "onToggle",
                        "onCheck"
                    ]))
                ]
            ),
            _: 1
        }, 8, [
            "class-name",
            "data",
            "total",
            "height",
            "item-size",
            "perf-mode"
        ])) : (_vue.openBlock(), _vue.createElementBlock("div", {
            key: 1,
            class: _vue.normalizeClass(_ctx.ns.e("empty-block"))
        }, [
            _vue.createElementVNode("span", {
                class: _vue.normalizeClass(_ctx.ns.e("empty-text"))
            }, _vue.toDisplayString((_a = _ctx.emptyText) != null ? _a : _ctx.t("el.tree.emptyText")), 3)
        ], 2))
    ], 2);
}
var TreeV2 = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../virtual-list/index.mjs":"gcf4S","./composables/useTree.mjs":"cbEUc","./tree-node.mjs":"h2zXg","./virtual-tree.mjs":"h32mr","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../virtual-list/src/components/fixed-size-list.mjs":"eaMZD","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cbEUc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useTree", ()=>useTree
);
var _vue = require("vue");
var _virtualTreeMjs = require("../virtual-tree.mjs");
var _useCheckMjs = require("./useCheck.mjs");
var _useFilterMjs = require("./useFilter.mjs");
function useTree(props, emit) {
    const expandedKeySet = _vue.ref(new Set(props.defaultExpandedKeys));
    const currentKey = _vue.ref();
    const tree = _vue.shallowRef();
    _vue.watch(()=>props.currentNodeKey
    , (key)=>{
        currentKey.value = key;
    }, {
        immediate: true
    });
    _vue.watch(()=>props.data
    , (data)=>{
        setData(data);
    }, {
        immediate: true
    });
    const { isIndeterminate , isChecked , toggleCheckbox , getCheckedKeys , getCheckedNodes , getHalfCheckedKeys , getHalfCheckedNodes , setChecked , setCheckedKeys  } = _useCheckMjs.useCheck(props, tree);
    const { doFilter , hiddenNodeKeySet , isForceHiddenExpandIcon  } = _useFilterMjs.useFilter(props, tree);
    const valueKey = _vue.computed(()=>{
        var _a;
        return ((_a = props.props) == null ? void 0 : _a.value) || _virtualTreeMjs.TreeOptionsEnum.KEY;
    });
    const childrenKey = _vue.computed(()=>{
        var _a;
        return ((_a = props.props) == null ? void 0 : _a.children) || _virtualTreeMjs.TreeOptionsEnum.CHILDREN;
    });
    const disabledKey = _vue.computed(()=>{
        var _a;
        return ((_a = props.props) == null ? void 0 : _a.disabled) || _virtualTreeMjs.TreeOptionsEnum.DISABLED;
    });
    const labelKey = _vue.computed(()=>{
        var _a;
        return ((_a = props.props) == null ? void 0 : _a.label) || _virtualTreeMjs.TreeOptionsEnum.LABEL;
    });
    const flattenTree = _vue.computed(()=>{
        const expandedKeys = expandedKeySet.value;
        const hiddenKeys = hiddenNodeKeySet.value;
        const flattenNodes = [];
        const nodes = tree.value && tree.value.treeNodes || [];
        function traverse() {
            const stack = [];
            for(let i = nodes.length - 1; i >= 0; --i)stack.push(nodes[i]);
            while(stack.length){
                const node = stack.pop();
                if (!node) continue;
                if (!hiddenKeys.has(node.key)) flattenNodes.push(node);
                if (expandedKeys.has(node.key)) {
                    const children = node.children;
                    if (children) {
                        const length = children.length;
                        for(let i = length - 1; i >= 0; --i)stack.push(children[i]);
                    }
                }
            }
        }
        traverse();
        return flattenNodes;
    });
    const isNotEmpty = _vue.computed(()=>{
        return flattenTree.value.length > 0;
    });
    function createTree(data) {
        const treeNodeMap = /* @__PURE__ */ new Map();
        const levelTreeNodeMap = /* @__PURE__ */ new Map();
        let maxLevel = 1;
        function traverse(nodes, level = 1, parent) {
            var _a;
            const siblings = [];
            for(let index = 0; index < nodes.length; ++index){
                const rawNode = nodes[index];
                const value = getKey(rawNode);
                const node = {
                    level,
                    key: value,
                    data: rawNode
                };
                node.label = getLabel(rawNode);
                node.parent = parent;
                const children = getChildren(rawNode);
                node.disabled = getDisabled(rawNode);
                node.isLeaf = !children || children.length === 0;
                if (children && children.length) node.children = traverse(children, level + 1, node);
                siblings.push(node);
                treeNodeMap.set(value, node);
                if (!levelTreeNodeMap.has(level)) levelTreeNodeMap.set(level, []);
                (_a = levelTreeNodeMap.get(level)) == null || _a.push(node);
            }
            if (level > maxLevel) maxLevel = level;
            return siblings;
        }
        const treeNodes = traverse(data);
        return {
            treeNodeMap,
            levelTreeNodeMap,
            maxLevel,
            treeNodes
        };
    }
    function filter(query) {
        const keys = doFilter(query);
        if (keys) expandedKeySet.value = keys;
    }
    function getChildren(node) {
        return node[childrenKey.value];
    }
    function getKey(node) {
        if (!node) return "";
        return node[valueKey.value];
    }
    function getDisabled(node) {
        return node[disabledKey.value];
    }
    function getLabel(node) {
        return node[labelKey.value];
    }
    function toggleExpand(node) {
        const expandedKeys = expandedKeySet.value;
        if (expandedKeys.has(node.key)) collapse(node);
        else expand(node);
    }
    function handleNodeClick(node, e) {
        emit(_virtualTreeMjs.NODE_CLICK, node.data, node, e);
        handleCurrentChange(node);
        if (props.expandOnClickNode) toggleExpand(node);
        if (props.showCheckbox && props.checkOnClickNode && !node.disabled) toggleCheckbox(node, !isChecked(node), true);
    }
    function handleCurrentChange(node) {
        if (!isCurrent(node)) {
            currentKey.value = node.key;
            emit(_virtualTreeMjs.CURRENT_CHANGE, node.data, node);
        }
    }
    function handleNodeCheck(node, checked) {
        toggleCheckbox(node, checked);
    }
    function expand(node) {
        const keySet = expandedKeySet.value;
        if ((tree == null ? void 0 : tree.value) && props.accordion) {
            const { treeNodeMap  } = tree.value;
            keySet.forEach((key)=>{
                const node2 = treeNodeMap.get(key);
                if (node2 && node2.level === node2.level) keySet.delete(key);
            });
        }
        keySet.add(node.key);
        emit(_virtualTreeMjs.NODE_EXPAND, node.data, node);
    }
    function collapse(node) {
        expandedKeySet.value.delete(node.key);
        emit(_virtualTreeMjs.NODE_COLLAPSE, node.data, node);
    }
    function isExpanded(node) {
        return expandedKeySet.value.has(node.key);
    }
    function isDisabled(node) {
        return !!node.disabled;
    }
    function isCurrent(node) {
        const current = currentKey.value;
        return !!current && current === node.key;
    }
    function getCurrentNode() {
        var _a, _b;
        if (!currentKey.value) return void 0;
        return (_b = (_a = tree == null ? void 0 : tree.value) == null ? void 0 : _a.treeNodeMap.get(currentKey.value)) == null ? void 0 : _b.data;
    }
    function getCurrentKey() {
        return currentKey.value;
    }
    function setCurrentKey(key) {
        currentKey.value = key;
    }
    function setData(data) {
        _vue.nextTick(()=>tree.value = createTree(data)
        );
    }
    return {
        tree,
        flattenTree,
        isNotEmpty,
        getKey,
        getChildren,
        toggleExpand,
        toggleCheckbox,
        isExpanded,
        isChecked,
        isIndeterminate,
        isDisabled,
        isCurrent,
        isForceHiddenExpandIcon,
        handleNodeClick,
        handleNodeCheck,
        getCurrentNode,
        getCurrentKey,
        setCurrentKey,
        getCheckedKeys,
        getCheckedNodes,
        getHalfCheckedKeys,
        getHalfCheckedNodes,
        setChecked,
        setCheckedKeys,
        filter,
        setData
    };
}

},{"vue":"gzxs9","../virtual-tree.mjs":"h32mr","./useCheck.mjs":"cZRMb","./useFilter.mjs":"BkXIb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h32mr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CURRENT_CHANGE", ()=>CURRENT_CHANGE
);
parcelHelpers.export(exports, "NODE_CHECK", ()=>NODE_CHECK
);
parcelHelpers.export(exports, "NODE_CHECK_CHANGE", ()=>NODE_CHECK_CHANGE
);
parcelHelpers.export(exports, "NODE_CLICK", ()=>NODE_CLICK
);
parcelHelpers.export(exports, "NODE_COLLAPSE", ()=>NODE_COLLAPSE
);
parcelHelpers.export(exports, "NODE_CONTEXTMENU", ()=>NODE_CONTEXTMENU
);
parcelHelpers.export(exports, "NODE_EXPAND", ()=>NODE_EXPAND
);
parcelHelpers.export(exports, "ROOT_TREE_INJECTION_KEY", ()=>ROOT_TREE_INJECTION_KEY
);
parcelHelpers.export(exports, "SetOperationEnum", ()=>SetOperationEnum
);
parcelHelpers.export(exports, "TreeOptionsEnum", ()=>TreeOptionsEnum
);
parcelHelpers.export(exports, "treeEmits", ()=>treeEmits
);
parcelHelpers.export(exports, "treeNodeContentProps", ()=>treeNodeContentProps
);
parcelHelpers.export(exports, "treeNodeEmits", ()=>treeNodeEmits
);
parcelHelpers.export(exports, "treeNodeProps", ()=>treeNodeProps
);
parcelHelpers.export(exports, "treeProps", ()=>treeProps
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _typescriptMjs = require("../../../utils/typescript.mjs");
const ROOT_TREE_INJECTION_KEY = Symbol();
const EMPTY_NODE = {
    key: -1,
    level: -1,
    data: {
    }
};
var TreeOptionsEnum = /* @__PURE__ */ ((TreeOptionsEnum2)=>{
    TreeOptionsEnum2["KEY"] = "id";
    TreeOptionsEnum2["LABEL"] = "label";
    TreeOptionsEnum2["CHILDREN"] = "children";
    TreeOptionsEnum2["DISABLED"] = "disabled";
    return TreeOptionsEnum2;
})(TreeOptionsEnum || {
});
var SetOperationEnum = /* @__PURE__ */ ((SetOperationEnum2)=>{
    SetOperationEnum2["ADD"] = "add";
    SetOperationEnum2["DELETE"] = "delete";
    return SetOperationEnum2;
})(SetOperationEnum || {
});
const treeProps = _propsMjs.buildProps({
    data: {
        type: _propsMjs.definePropType(Array),
        default: ()=>_typescriptMjs.mutable([])
    },
    emptyText: {
        type: String
    },
    height: {
        type: Number,
        default: 200
    },
    props: {
        type: _propsMjs.definePropType(Object),
        default: ()=>_typescriptMjs.mutable({
                children: "children" /* CHILDREN */ ,
                label: "label" /* LABEL */ ,
                disabled: "disabled" /* DISABLED */ ,
                value: "id" /* KEY */ 
            })
    },
    highlightCurrent: {
        type: Boolean,
        default: false
    },
    showCheckbox: {
        type: Boolean,
        default: false
    },
    defaultCheckedKeys: {
        type: _propsMjs.definePropType(Array),
        default: ()=>_typescriptMjs.mutable([])
    },
    checkStrictly: {
        type: Boolean,
        default: false
    },
    defaultExpandedKeys: {
        type: _propsMjs.definePropType(Array),
        default: ()=>_typescriptMjs.mutable([])
    },
    indent: {
        type: Number,
        default: 16
    },
    icon: {
        type: String
    },
    expandOnClickNode: {
        type: Boolean,
        default: true
    },
    checkOnClickNode: {
        type: Boolean,
        default: false
    },
    currentNodeKey: {
        type: _propsMjs.definePropType([
            String,
            Number
        ])
    },
    accordion: {
        type: Boolean,
        default: false
    },
    filterMethod: {
        type: _propsMjs.definePropType(Function)
    },
    perfMode: {
        type: Boolean,
        default: true
    }
});
const treeNodeProps = _propsMjs.buildProps({
    node: {
        type: _propsMjs.definePropType(Object),
        default: ()=>_typescriptMjs.mutable(EMPTY_NODE)
    },
    expanded: {
        type: Boolean,
        default: false
    },
    checked: {
        type: Boolean,
        default: false
    },
    indeterminate: {
        type: Boolean,
        default: false
    },
    showCheckbox: {
        type: Boolean,
        default: false
    },
    disabled: {
        type: Boolean,
        default: false
    },
    current: {
        type: Boolean,
        default: false
    },
    hiddenExpandIcon: {
        type: Boolean,
        default: false
    }
});
const treeNodeContentProps = _propsMjs.buildProps({
    node: {
        type: _propsMjs.definePropType(Object),
        required: true
    }
});
const NODE_CLICK = "node-click";
const NODE_EXPAND = "node-expand";
const NODE_COLLAPSE = "node-collapse";
const CURRENT_CHANGE = "current-change";
const NODE_CHECK = "check";
const NODE_CHECK_CHANGE = "check-change";
const NODE_CONTEXTMENU = "node-contextmenu";
const treeEmits = {
    [NODE_CLICK]: (data, node, e)=>data && node && e
    ,
    [NODE_EXPAND]: (data, node)=>data && node
    ,
    [NODE_COLLAPSE]: (data, node)=>data && node
    ,
    [CURRENT_CHANGE]: (data, node)=>data && node
    ,
    [NODE_CHECK]: (data, checkedInfo)=>data && checkedInfo
    ,
    [NODE_CHECK_CHANGE]: (data, checked)=>data && typeof checked === "boolean"
    ,
    [NODE_CONTEXTMENU]: (event, data, node)=>event && data && node
};
const treeNodeEmits = {
    click: (node, e)=>!!(node && e)
    ,
    toggle: (node)=>!!node
    ,
    check: (node, checked)=>node && typeof checked === "boolean"
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","../../../utils/typescript.mjs":"bRl53","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cZRMb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useCheck", ()=>useCheck
);
var _vue = require("vue");
var _virtualTreeMjs = require("../virtual-tree.mjs");
function useCheck(props, tree) {
    const checkedKeys = _vue.ref(/* @__PURE__ */ new Set());
    const indeterminateKeys = _vue.ref(/* @__PURE__ */ new Set());
    const { emit  } = _vue.getCurrentInstance();
    _vue.watch(()=>tree.value
    , ()=>{
        return _vue.nextTick(()=>{
            _setCheckedKeys(props.defaultCheckedKeys);
        });
    }, {
        immediate: true
    });
    const updateCheckedKeys = ()=>{
        if (!tree.value || !props.showCheckbox || props.checkStrictly) return;
        const { levelTreeNodeMap , maxLevel  } = tree.value;
        const checkedKeySet = checkedKeys.value;
        const indeterminateKeySet = /* @__PURE__ */ new Set();
        for(let level = maxLevel - 1; level >= 1; --level){
            const nodes = levelTreeNodeMap.get(level);
            if (!nodes) continue;
            nodes.forEach((node)=>{
                const children = node.children;
                if (children) {
                    let allChecked = true;
                    let hasChecked = false;
                    for(let i = 0; i < children.length; ++i){
                        const childNode = children[i];
                        const key = childNode.key;
                        if (checkedKeySet.has(key)) hasChecked = true;
                        else if (indeterminateKeySet.has(key)) {
                            allChecked = false;
                            hasChecked = true;
                            break;
                        } else allChecked = false;
                    }
                    if (allChecked) checkedKeySet.add(node.key);
                    else if (hasChecked) {
                        indeterminateKeySet.add(node.key);
                        checkedKeySet.delete(node.key);
                    } else {
                        checkedKeySet.delete(node.key);
                        indeterminateKeySet.delete(node.key);
                    }
                }
            });
        }
        indeterminateKeys.value = indeterminateKeySet;
    };
    const isChecked = (node)=>checkedKeys.value.has(node.key)
    ;
    const isIndeterminate = (node)=>indeterminateKeys.value.has(node.key)
    ;
    const toggleCheckbox = (node, isChecked2, nodeClick = true)=>{
        const checkedKeySet = checkedKeys.value;
        const toggle = (node2, checked)=>{
            checkedKeySet[checked ? _virtualTreeMjs.SetOperationEnum.ADD : _virtualTreeMjs.SetOperationEnum.DELETE](node2.key);
            const children = node2.children;
            if (!props.checkStrictly && children) children.forEach((childNode)=>{
                if (!childNode.disabled) toggle(childNode, checked);
            });
        };
        toggle(node, isChecked2);
        updateCheckedKeys();
        if (nodeClick) afterNodeCheck(node, isChecked2);
    };
    const afterNodeCheck = (node, checked)=>{
        const { checkedNodes , checkedKeys: checkedKeys2  } = getChecked();
        const { halfCheckedNodes , halfCheckedKeys  } = getHalfChecked();
        emit(_virtualTreeMjs.NODE_CHECK, node.data, {
            checkedKeys: checkedKeys2,
            checkedNodes,
            halfCheckedKeys,
            halfCheckedNodes
        });
        emit(_virtualTreeMjs.NODE_CHECK_CHANGE, node.data, checked);
    };
    function getCheckedKeys(leafOnly = false) {
        return getChecked(leafOnly).checkedKeys;
    }
    function getCheckedNodes(leafOnly = false) {
        return getChecked(leafOnly).checkedNodes;
    }
    function getHalfCheckedKeys() {
        return getHalfChecked().halfCheckedKeys;
    }
    function getHalfCheckedNodes() {
        return getHalfChecked().halfCheckedNodes;
    }
    function getChecked(leafOnly = false) {
        const checkedNodes = [];
        const keys = [];
        if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
            const { treeNodeMap  } = tree.value;
            checkedKeys.value.forEach((key)=>{
                const node = treeNodeMap.get(key);
                if (node && (!leafOnly || leafOnly && node.isLeaf)) {
                    keys.push(key);
                    checkedNodes.push(node.data);
                }
            });
        }
        return {
            checkedKeys: keys,
            checkedNodes
        };
    }
    function getHalfChecked() {
        const halfCheckedNodes = [];
        const halfCheckedKeys = [];
        if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
            const { treeNodeMap  } = tree.value;
            indeterminateKeys.value.forEach((key)=>{
                const node = treeNodeMap.get(key);
                if (node) {
                    halfCheckedKeys.push(key);
                    halfCheckedNodes.push(node.data);
                }
            });
        }
        return {
            halfCheckedNodes,
            halfCheckedKeys
        };
    }
    function setCheckedKeys(keys) {
        checkedKeys.value.clear();
        _setCheckedKeys(keys);
    }
    function setChecked(key, isChecked2) {
        if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
            const node = tree.value.treeNodeMap.get(key);
            if (node) toggleCheckbox(node, isChecked2, false);
        }
    }
    function _setCheckedKeys(keys) {
        if (tree == null ? void 0 : tree.value) {
            const { treeNodeMap  } = tree.value;
            if (props.showCheckbox && treeNodeMap && keys) for(let i = 0; i < keys.length; ++i){
                const key = keys[i];
                const node = treeNodeMap.get(key);
                if (node && !isChecked(node)) toggleCheckbox(node, true, false);
            }
        }
    }
    return {
        updateCheckedKeys,
        toggleCheckbox,
        isChecked,
        isIndeterminate,
        getCheckedKeys,
        getCheckedNodes,
        getHalfCheckedKeys,
        getHalfCheckedNodes,
        setChecked,
        setCheckedKeys
    };
}

},{"vue":"gzxs9","../virtual-tree.mjs":"h32mr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"BkXIb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useFilter", ()=>useFilter
);
var _vue = require("vue");
var _shared = require("@vue/shared");
function useFilter(props, tree) {
    const hiddenNodeKeySet = _vue.ref(/* @__PURE__ */ new Set([]));
    const hiddenExpandIconKeySet = _vue.ref(/* @__PURE__ */ new Set([]));
    const filterable = _vue.computed(()=>{
        return _shared.isFunction(props.filterMethod);
    });
    function doFilter(query) {
        var _a;
        if (!filterable.value) return;
        const expandKeySet = /* @__PURE__ */ new Set();
        const hiddenExpandIconKeys = hiddenExpandIconKeySet.value;
        const hiddenKeys = hiddenNodeKeySet.value;
        const family = [];
        const nodes = ((_a = tree.value) == null ? void 0 : _a.treeNodes) || [];
        const filter = props.filterMethod;
        hiddenKeys.clear();
        function traverse(nodes2) {
            nodes2.forEach((node)=>{
                family.push(node);
                if (filter == null ? void 0 : filter(query, node.data)) family.forEach((member)=>{
                    expandKeySet.add(member.key);
                });
                else if (node.isLeaf) hiddenKeys.add(node.key);
                const children = node.children;
                if (children) traverse(children);
                if (!node.isLeaf) {
                    if (!expandKeySet.has(node.key)) hiddenKeys.add(node.key);
                    else if (children) {
                        let allHidden = true;
                        for(let i = 0; i < children.length; ++i){
                            const childNode = children[i];
                            if (!hiddenKeys.has(childNode.key)) {
                                allHidden = false;
                                break;
                            }
                        }
                        if (allHidden) hiddenExpandIconKeys.add(node.key);
                        else hiddenExpandIconKeys.delete(node.key);
                    }
                }
                family.pop();
            });
        }
        traverse(nodes);
        return expandKeySet;
    }
    function isForceHiddenExpandIcon(node) {
        return hiddenExpandIconKeySet.value.has(node.key);
    }
    return {
        hiddenExpandIconKeySet,
        hiddenNodeKeySet,
        doFilter,
        isForceHiddenExpandIcon
    };
}

},{"vue":"gzxs9","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h2zXg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElTreeNode
);
var _vue = require("vue");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs = require("../../icon/index.mjs");
var _indexMjs1 = require("../../checkbox/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _treeNodeContentMjs = require("./tree-node-content.mjs");
var _treeNodeContentMjsDefault = parcelHelpers.interopDefault(_treeNodeContentMjs);
var _virtualTreeMjs = require("./virtual-tree.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../hooks/use-namespace/index.mjs");
const DEFAULT_ICON = "caret-right";
const _sfc_main = _vue.defineComponent({
    name: "ElTreeNode",
    components: {
        ElIcon: _indexMjs.ElIcon,
        CaretRight: _iconsVue.CaretRight,
        ElCheckbox: _indexMjs1.ElCheckbox,
        ElNodeContent: _treeNodeContentMjsDefault.default
    },
    props: _virtualTreeMjs.treeNodeProps,
    emits: _virtualTreeMjs.treeNodeEmits,
    setup (props, { emit  }) {
        const tree = _vue.inject(_virtualTreeMjs.ROOT_TREE_INJECTION_KEY);
        const ns = _indexMjs3.useNamespace("tree");
        const indent = _vue.computed(()=>{
            var _a;
            return (_a = tree == null ? void 0 : tree.props.indent) != null ? _a : 16;
        });
        const icon = _vue.computed(()=>{
            var _a;
            return (_a = tree == null ? void 0 : tree.props.icon) != null ? _a : DEFAULT_ICON;
        });
        const handleClick = (e)=>{
            emit("click", props.node, e);
        };
        const handleExpandIconClick = ()=>{
            emit("toggle", props.node);
        };
        const handleCheckChange = (value)=>{
            emit("check", props.node, value);
        };
        const handleContextMenu = (event)=>{
            var _a, _b, _c, _d;
            if ((_c = (_b = (_a = tree == null ? void 0 : tree.instance) == null ? void 0 : _a.vnode) == null ? void 0 : _b.props) == null ? void 0 : _c["onNodeContextmenu"]) {
                event.stopPropagation();
                event.preventDefault();
            }
            tree == null || tree.ctx.emit(_virtualTreeMjs.NODE_CONTEXTMENU, event, (_d = props.node) == null ? void 0 : _d.data, props.node);
        };
        return {
            ns,
            indent,
            icon,
            handleClick,
            handleExpandIconClick,
            handleCheckChange,
            handleContextMenu
        };
    }
});
const _hoisted_1 = [
    "aria-expanded",
    "aria-disabled",
    "aria-checked",
    "data-key"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    var _a, _b, _c;
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_el_checkbox = _vue.resolveComponent("el-checkbox");
    const _component_el_node_content = _vue.resolveComponent("el-node-content");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        ref: "node$",
        class: _vue.normalizeClass([
            _ctx.ns.b("node"),
            _ctx.ns.is("expanded", _ctx.expanded),
            _ctx.ns.is("current", _ctx.current),
            _ctx.ns.is("focusable", !_ctx.disabled),
            _ctx.ns.is("checked", !_ctx.disabled && _ctx.checked)
        ]),
        role: "treeitem",
        tabindex: "-1",
        "aria-expanded": _ctx.expanded,
        "aria-disabled": _ctx.disabled,
        "aria-checked": _ctx.checked,
        "data-key": (_a = _ctx.node) == null ? void 0 : _a.key,
        onClick: _cache[1] || (_cache[1] = _vue.withModifiers((...args)=>_ctx.handleClick && _ctx.handleClick(...args)
        , [
            "stop"
        ])),
        onContextmenu: _cache[2] || (_cache[2] = (...args)=>_ctx.handleContextMenu && _ctx.handleContextMenu(...args)
        )
    }, [
        _vue.createElementVNode("div", {
            class: _vue.normalizeClass(_ctx.ns.be("node", "content")),
            style: _vue.normalizeStyle({
                paddingLeft: `${(_ctx.node.level - 1) * _ctx.indent}px`
            })
        }, [
            _ctx.icon ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                key: 0,
                class: _vue.normalizeClass([
                    _ctx.ns.is("leaf", !!((_b = _ctx.node) == null ? void 0 : _b.isLeaf)),
                    _ctx.ns.is("hidden", _ctx.hiddenExpandIcon),
                    {
                        expanded: !((_c = _ctx.node) == null ? void 0 : _c.isLeaf) && _ctx.expanded
                    },
                    _ctx.ns.be("node", "expand-icon")
                ]),
                onClick: _vue.withModifiers(_ctx.handleExpandIconClick, [
                    "stop"
                ])
            }, {
                default: _vue.withCtx(()=>[
                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.icon)))
                    ]
                ),
                _: 1
            }, 8, [
                "class",
                "onClick"
            ])) : _vue.createCommentVNode("v-if", true),
            _ctx.showCheckbox ? (_vue.openBlock(), _vue.createBlock(_component_el_checkbox, {
                key: 1,
                "model-value": _ctx.checked,
                indeterminate: _ctx.indeterminate,
                disabled: _ctx.disabled,
                onChange: _ctx.handleCheckChange,
                onClick: _cache[0] || (_cache[0] = _vue.withModifiers(()=>{
                }, [
                    "stop"
                ]))
            }, null, 8, [
                "model-value",
                "indeterminate",
                "disabled",
                "onChange"
            ])) : _vue.createCommentVNode("v-if", true),
            _vue.createVNode(_component_el_node_content, {
                node: _ctx.node
            }, null, 8, [
                "node"
            ])
        ], 6)
    ], 42, _hoisted_1);
}
var ElTreeNode = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@element-plus/icons-vue":"b18uu","../../icon/index.mjs":"hnNTG","../../checkbox/index.mjs":"jMNjD","../../../hooks/index.mjs":"1Ansp","./tree-node-content.mjs":"fzPSZ","./virtual-tree.mjs":"h32mr","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fzPSZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ElNodeContent
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _virtualTreeMjs = require("./virtual-tree.mjs");
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
var ElNodeContent = _vue.defineComponent({
    name: "ElTreeNodeContent",
    props: _virtualTreeMjs.treeNodeContentProps,
    setup (props) {
        const tree = _vue.inject(_virtualTreeMjs.ROOT_TREE_INJECTION_KEY);
        const ns = _indexMjs1.useNamespace("tree");
        return ()=>{
            const node = props.node;
            const { data  } = node;
            return (tree == null ? void 0 : tree.ctx.slots.default) ? tree.ctx.slots.default({
                node,
                data
            }) : _vue.h("span", {
                class: ns.be("node", "label")
            }, [
                node == null ? void 0 : node.label
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","./virtual-tree.mjs":"h32mr","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fvmYn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElUpload", ()=>ElUpload
);
parcelHelpers.export(exports, "default", ()=>_Upload
);
var _indexMjs = require("./src/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
_indexMjsDefault.default.install = (app)=>{
    app.component(_indexMjsDefault.default.name, _indexMjsDefault.default);
};
const _Upload = _indexMjsDefault.default;
const ElUpload = _Upload;

},{"./src/index.mjs":"cVPG9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cVPG9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_sfc_main
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _indexMjs = require("../../../tokens/index.mjs");
var _ajaxMjs = require("./ajax.mjs");
var _ajaxMjsDefault = parcelHelpers.interopDefault(_ajaxMjs);
var _uploadListMjs = require("./upload-list.mjs");
var _uploadListMjsDefault = parcelHelpers.interopDefault(_uploadListMjs);
var _uploadMjs = require("./upload.mjs");
var _uploadMjsDefault = parcelHelpers.interopDefault(_uploadMjs);
var _useHandlersMjs = require("./useHandlers.mjs");
var _useHandlersMjsDefault = parcelHelpers.interopDefault(_useHandlersMjs);
var _formMjs = require("../../../tokens/form.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElUpload",
    components: {
        Upload: _uploadMjsDefault.default,
        UploadList: _uploadListMjsDefault.default
    },
    props: {
        action: {
            type: String,
            required: true
        },
        headers: {
            type: Object,
            default: ()=>({
                })
        },
        method: {
            type: String,
            default: "post"
        },
        data: {
            type: Object,
            default: ()=>({
                })
        },
        multiple: {
            type: Boolean,
            default: false
        },
        name: {
            type: String,
            default: "file"
        },
        drag: {
            type: Boolean,
            default: false
        },
        withCredentials: Boolean,
        showFileList: {
            type: Boolean,
            default: true
        },
        accept: {
            type: String,
            default: ""
        },
        type: {
            type: String,
            default: "select"
        },
        beforeUpload: {
            type: Function,
            default: _shared.NOOP
        },
        beforeRemove: {
            type: Function,
            default: _shared.NOOP
        },
        onRemove: {
            type: Function,
            default: _shared.NOOP
        },
        onChange: {
            type: Function,
            default: _shared.NOOP
        },
        onPreview: {
            type: Function,
            default: _shared.NOOP
        },
        onSuccess: {
            type: Function,
            default: _shared.NOOP
        },
        onProgress: {
            type: Function,
            default: _shared.NOOP
        },
        onError: {
            type: Function,
            default: _shared.NOOP
        },
        fileList: {
            type: Array,
            default: ()=>{
                return [];
            }
        },
        autoUpload: {
            type: Boolean,
            default: true
        },
        listType: {
            type: String,
            default: "text"
        },
        httpRequest: {
            type: Function,
            default: _ajaxMjsDefault.default
        },
        disabled: Boolean,
        limit: {
            type: Number,
            default: null
        },
        onExceed: {
            type: Function,
            default: ()=>_shared.NOOP
        }
    },
    setup (props) {
        const elForm = _vue.inject(_formMjs.elFormKey, {
        });
        const uploadDisabled = _vue.computed(()=>{
            return props.disabled || elForm.disabled;
        });
        const { abort , clearFiles , handleError , handleProgress , handleStart , handleSuccess , handleRemove , submit , uploadRef , uploadFiles  } = _useHandlersMjsDefault.default(props);
        _vue.provide("uploader", _vue.getCurrentInstance());
        _vue.onBeforeUnmount(()=>{
            uploadFiles.value.forEach((file)=>{
                if (file.url && file.url.indexOf("blob:") === 0) URL.revokeObjectURL(file.url);
            });
        });
        return {
            abort,
            dragOver: _vue.ref(false),
            draging: _vue.ref(false),
            handleError,
            handleProgress,
            handleRemove,
            handleStart,
            handleSuccess,
            uploadDisabled,
            uploadFiles,
            uploadRef,
            submit,
            clearFiles
        };
    },
    render () {
        var _a, _b;
        let uploadList;
        if (this.showFileList) uploadList = _vue.h(_uploadListMjsDefault.default, {
            disabled: this.uploadDisabled,
            listType: this.listType,
            files: this.uploadFiles,
            onRemove: this.handleRemove,
            handlePreview: this.onPreview
        }, this.$slots.file ? {
            default: (props)=>{
                return this.$slots.file({
                    file: props.file
                });
            }
        } : null);
        else uploadList = null;
        const uploadData = {
            type: this.type,
            drag: this.drag,
            action: this.action,
            multiple: this.multiple,
            "before-upload": this.beforeUpload,
            "with-credentials": this.withCredentials,
            headers: this.headers,
            method: this.method,
            name: this.name,
            data: this.data,
            accept: this.accept,
            fileList: this.uploadFiles,
            autoUpload: this.autoUpload,
            listType: this.listType,
            disabled: this.uploadDisabled,
            limit: this.limit,
            "on-exceed": this.onExceed,
            "on-start": this.handleStart,
            "on-progress": this.handleProgress,
            "on-success": this.handleSuccess,
            "on-error": this.handleError,
            "on-preview": this.onPreview,
            "on-remove": this.handleRemove,
            "http-request": this.httpRequest,
            ref: "uploadRef"
        };
        const trigger = this.$slots.trigger || this.$slots.default;
        const uploadComponent = _vue.h(_uploadMjsDefault.default, uploadData, {
            default: ()=>trigger == null ? void 0 : trigger()
        });
        return _vue.h("div", [
            this.listType === "picture-card" ? uploadList : null,
            this.$slots.trigger ? [
                uploadComponent,
                this.$slots.default()
            ] : uploadComponent,
            (_b = (_a = this.$slots).tip) == null ? void 0 : _b.call(_a),
            this.listType !== "picture-card" ? uploadList : null
        ]);
    }
});

},{"vue":"gzxs9","@vue/shared":"3SM3y","../../../tokens/index.mjs":"wVNQi","./ajax.mjs":"gJ6d0","./upload-list.mjs":"d1cnX","./upload.mjs":"6BYtt","./useHandlers.mjs":"algou","../../../tokens/form.mjs":"2r4O0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gJ6d0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>upload
);
var _indexMjs = require("../../../utils/index.mjs");
var _shared = require("@vue/shared");
function getError(action, option, xhr) {
    let msg;
    if (xhr.response) msg = `${xhr.response.error || xhr.response}`;
    else if (xhr.responseText) msg = `${xhr.responseText}`;
    else msg = `fail to ${option.method} ${action} ${xhr.status}`;
    const err = new Error(msg);
    err.status = xhr.status;
    err.method = option.method;
    err.url = action;
    return err;
}
function getBody(xhr) {
    const text = xhr.responseText || xhr.response;
    if (!text) return text;
    try {
        return JSON.parse(text);
    } catch (e) {
        return text;
    }
}
function upload(option) {
    if (typeof XMLHttpRequest === "undefined") return;
    const xhr = new XMLHttpRequest();
    const action = option.action;
    if (xhr.upload) xhr.upload.onprogress = function progress(e) {
        if (e.total > 0) e.percent = e.loaded / e.total * 100;
        option.onProgress(e);
    };
    const formData = new FormData();
    if (option.data) Object.keys(option.data).forEach((key)=>{
        formData.append(key, option.data[key]);
    });
    formData.append(option.filename, option.file, option.file.name);
    xhr.onerror = function error() {
        option.onError(getError(action, option, xhr));
    };
    xhr.onload = function onload() {
        if (xhr.status < 200 || xhr.status >= 300) return option.onError(getError(action, option, xhr));
        option.onSuccess(getBody(xhr));
    };
    xhr.open(option.method, action, true);
    if (option.withCredentials && "withCredentials" in xhr) xhr.withCredentials = true;
    const headers = option.headers || {
    };
    for(const item in headers)if (_shared.hasOwn(headers, item) && headers[item] !== null) xhr.setRequestHeader(item, headers[item]);
    if (headers instanceof Headers) headers.forEach((value, key)=>{
        xhr.setRequestHeader(key, value);
    });
    xhr.send(formData);
    return xhr;
}

},{"../../../utils/index.mjs":"dsdeP","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d1cnX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>UploadList
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _indexMjs = require("../../icon/index.mjs");
var _iconsVue = require("@element-plus/icons-vue");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _indexMjs2 = require("../../progress/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs3 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs4 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElUploadList",
    components: {
        ElProgress: _indexMjs2.ElProgress,
        ElIcon: _indexMjs.ElIcon,
        Document: _iconsVue.Document,
        Delete: _iconsVue.Delete,
        Close: _iconsVue.Close,
        ZoomIn: _iconsVue.ZoomIn,
        Check: _iconsVue.Check,
        CircleCheck: _iconsVue.CircleCheck
    },
    props: {
        files: {
            type: Array,
            default: ()=>[]
        },
        disabled: {
            type: Boolean,
            default: false
        },
        handlePreview: {
            type: Function,
            default: ()=>_shared.NOOP
        },
        listType: {
            type: String,
            default: "text"
        }
    },
    emits: [
        "remove"
    ],
    setup (props, { emit  }) {
        const { t  } = _indexMjs3.useLocale();
        const nsUpload = _indexMjs4.useNamespace("upload");
        const nsIcon = _indexMjs4.useNamespace("icon");
        const nsList = _indexMjs4.useNamespace("list");
        const handleClick = (file)=>{
            props.handlePreview(file);
        };
        const onFileClicked = (e)=>{
            e.target.focus();
        };
        const handleRemove = (file)=>{
            emit("remove", file);
        };
        return {
            focusing: _vue.ref(false),
            handleClick,
            handleRemove,
            onFileClicked,
            t,
            nsUpload,
            nsIcon,
            nsList
        };
    }
});
const _hoisted_1 = [
    "onKeydown"
];
const _hoisted_2 = [
    "src"
];
const _hoisted_3 = [
    "onClick"
];
const _hoisted_4 = [
    "onClick"
];
const _hoisted_5 = [
    "onClick"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_document = _vue.resolveComponent("document");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_circle_check = _vue.resolveComponent("circle-check");
    const _component_check = _vue.resolveComponent("check");
    const _component_close = _vue.resolveComponent("close");
    const _component_el_progress = _vue.resolveComponent("el-progress");
    const _component_zoom_in = _vue.resolveComponent("zoom-in");
    const _component_delete = _vue.resolveComponent("delete");
    return _vue.openBlock(), _vue.createBlock(_vue.TransitionGroup, {
        tag: "ul",
        class: _vue.normalizeClass([
            _ctx.nsUpload.b("list"),
            _ctx.nsUpload.bm("list", _ctx.listType),
            _ctx.nsUpload.is("disabled", _ctx.disabled)
        ]),
        name: _ctx.nsList.b()
    }, {
        default: _vue.withCtx(()=>[
                (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.files, (file)=>{
                    return _vue.openBlock(), _vue.createElementBlock("li", {
                        key: file.uid || file,
                        class: _vue.normalizeClass([
                            _ctx.nsUpload.be("list", "item"),
                            _ctx.nsUpload.is(file.status),
                            {
                                focusing: _ctx.focusing
                            }
                        ]),
                        tabindex: "0",
                        onKeydown: _vue.withKeys(($event)=>!_ctx.disabled && _ctx.handleRemove(file)
                        , [
                            "delete"
                        ]),
                        onFocus: _cache[0] || (_cache[0] = ($event)=>_ctx.focusing = true
                        ),
                        onBlur: _cache[1] || (_cache[1] = ($event)=>_ctx.focusing = false
                        ),
                        onClick: _cache[2] || (_cache[2] = (...args)=>_ctx.onFileClicked && _ctx.onFileClicked(...args)
                        )
                    }, [
                        _vue.renderSlot(_ctx.$slots, "default", {
                            file
                        }, ()=>[
                                file.status !== "uploading" && [
                                    "picture-card",
                                    "picture"
                                ].includes(_ctx.listType) ? (_vue.openBlock(), _vue.createElementBlock("img", {
                                    key: 0,
                                    class: _vue.normalizeClass(_ctx.nsUpload.be("list", "item-thumbnail")),
                                    src: file.url,
                                    alt: ""
                                }, null, 10, _hoisted_2)) : _vue.createCommentVNode("v-if", true),
                                _vue.createElementVNode("a", {
                                    class: _vue.normalizeClass(_ctx.nsUpload.be("list", "item-name")),
                                    onClick: ($event)=>_ctx.handleClick(file)
                                }, [
                                    _vue.createVNode(_component_el_icon, {
                                        class: _vue.normalizeClass(_ctx.nsIcon.m("document"))
                                    }, {
                                        default: _vue.withCtx(()=>[
                                                _vue.createVNode(_component_document)
                                            ]
                                        ),
                                        _: 1
                                    }, 8, [
                                        "class"
                                    ]),
                                    _vue.createTextVNode(" " + _vue.toDisplayString(file.name), 1)
                                ], 10, _hoisted_3),
                                _vue.createElementVNode("label", {
                                    class: _vue.normalizeClass(_ctx.nsUpload.be("list", "item-status-label"))
                                }, [
                                    _ctx.listType === "text" ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                        key: 0,
                                        class: _vue.normalizeClass([
                                            _ctx.nsIcon.m("upload-success"),
                                            _ctx.nsIcon.m("circle-check")
                                        ])
                                    }, {
                                        default: _vue.withCtx(()=>[
                                                _vue.createVNode(_component_circle_check)
                                            ]
                                        ),
                                        _: 1
                                    }, 8, [
                                        "class"
                                    ])) : [
                                        "picture-card",
                                        "picture"
                                    ].includes(_ctx.listType) ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                        key: 1,
                                        class: _vue.normalizeClass([
                                            _ctx.nsIcon.m("upload-success"),
                                            _ctx.nsIcon.m("check")
                                        ])
                                    }, {
                                        default: _vue.withCtx(()=>[
                                                _vue.createVNode(_component_check)
                                            ]
                                        ),
                                        _: 1
                                    }, 8, [
                                        "class"
                                    ])) : _vue.createCommentVNode("v-if", true)
                                ], 2),
                                !_ctx.disabled ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                    key: 1,
                                    class: _vue.normalizeClass(_ctx.nsIcon.m("close")),
                                    onClick: ($event)=>_ctx.handleRemove(file)
                                }, {
                                    default: _vue.withCtx(()=>[
                                            _vue.createVNode(_component_close)
                                        ]
                                    ),
                                    _: 2
                                }, 1032, [
                                    "class",
                                    "onClick"
                                ])) : _vue.createCommentVNode("v-if", true),
                                _vue.createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
                                _vue.createCommentVNode(" This is a bug which needs to be fixed "),
                                _vue.createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
                                !_ctx.disabled ? (_vue.openBlock(), _vue.createElementBlock("i", {
                                    key: 2,
                                    class: _vue.normalizeClass(_ctx.nsIcon.m("close-tip"))
                                }, _vue.toDisplayString(_ctx.t("el.upload.deleteTip")), 3)) : _vue.createCommentVNode("v-if", true),
                                file.status === "uploading" ? (_vue.openBlock(), _vue.createBlock(_component_el_progress, {
                                    key: 3,
                                    type: _ctx.listType === "picture-card" ? "circle" : "line",
                                    "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
                                    percentage: +file.percentage,
                                    style: {
                                        "margin-top": "0.5rem"
                                    }
                                }, null, 8, [
                                    "type",
                                    "stroke-width",
                                    "percentage"
                                ])) : _vue.createCommentVNode("v-if", true),
                                _ctx.listType === "picture-card" ? (_vue.openBlock(), _vue.createElementBlock("span", {
                                    key: 4,
                                    class: _vue.normalizeClass(_ctx.nsUpload.be("list", "item-actions"))
                                }, [
                                    _vue.createElementVNode("span", {
                                        class: _vue.normalizeClass(_ctx.nsUpload.be("list", "item-preview")),
                                        onClick: ($event)=>_ctx.handlePreview(file)
                                    }, [
                                        _vue.createVNode(_component_el_icon, {
                                            class: _vue.normalizeClass(_ctx.nsIcon.m("zoom-in"))
                                        }, {
                                            default: _vue.withCtx(()=>[
                                                    _vue.createVNode(_component_zoom_in)
                                                ]
                                            ),
                                            _: 1
                                        }, 8, [
                                            "class"
                                        ])
                                    ], 10, _hoisted_4),
                                    !_ctx.disabled ? (_vue.openBlock(), _vue.createElementBlock("span", {
                                        key: 0,
                                        class: _vue.normalizeClass(_ctx.nsUpload.be("list", "item-delete")),
                                        onClick: ($event)=>_ctx.handleRemove(file)
                                    }, [
                                        _vue.createVNode(_component_el_icon, {
                                            class: _vue.normalizeClass(_ctx.nsIcon.m("delete"))
                                        }, {
                                            default: _vue.withCtx(()=>[
                                                    _vue.createVNode(_component_delete)
                                                ]
                                            ),
                                            _: 1
                                        }, 8, [
                                            "class"
                                        ])
                                    ], 10, _hoisted_5)) : _vue.createCommentVNode("v-if", true)
                                ], 2)) : _vue.createCommentVNode("v-if", true)
                            ]
                        )
                    ], 42, _hoisted_1);
                }), 128))
            ]
        ),
        _: 3
    }, 8, [
        "class",
        "name"
    ]);
}
var UploadList = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vue/shared":"3SM3y","../../icon/index.mjs":"hnNTG","@element-plus/icons-vue":"b18uu","../../../hooks/index.mjs":"1Ansp","../../progress/index.mjs":"9ijV7","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6BYtt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Upload
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _ajaxMjs = require("./ajax.mjs");
var _ajaxMjsDefault = parcelHelpers.interopDefault(_ajaxMjs);
var _uploadDraggerMjs = require("./upload-dragger.mjs");
var _uploadDraggerMjsDefault = parcelHelpers.interopDefault(_uploadDraggerMjs);
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs2 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    components: {
        UploadDragger: _uploadDraggerMjsDefault.default
    },
    props: {
        type: {
            type: String,
            default: ""
        },
        action: {
            type: String,
            required: true
        },
        name: {
            type: String,
            default: "file"
        },
        data: {
            type: Object,
            default: ()=>null
        },
        headers: {
            type: Object,
            default: ()=>null
        },
        method: {
            type: String,
            default: "post"
        },
        withCredentials: {
            type: Boolean,
            default: false
        },
        multiple: {
            type: Boolean,
            default: null
        },
        accept: {
            type: String,
            default: ""
        },
        onStart: {
            type: Function,
            default: _shared.NOOP
        },
        onProgress: {
            type: Function,
            default: _shared.NOOP
        },
        onSuccess: {
            type: Function,
            default: _shared.NOOP
        },
        onError: {
            type: Function,
            default: _shared.NOOP
        },
        beforeUpload: {
            type: Function,
            default: _shared.NOOP
        },
        drag: {
            type: Boolean,
            default: false
        },
        onPreview: {
            type: Function,
            default: _shared.NOOP
        },
        onRemove: {
            type: Function,
            default: _shared.NOOP
        },
        fileList: {
            type: Array,
            default: ()=>[]
        },
        autoUpload: {
            type: Boolean,
            default: true
        },
        listType: {
            type: String,
            default: "text"
        },
        httpRequest: {
            type: Function,
            default: ()=>_ajaxMjsDefault.default
        },
        disabled: Boolean,
        limit: {
            type: Number,
            default: null
        },
        onExceed: {
            type: Function,
            default: _shared.NOOP
        }
    },
    setup (props) {
        const reqs = _vue.ref({
        });
        const ns = _indexMjs2.useNamespace("upload");
        const mouseover = _vue.ref(false);
        const inputRef = _vue.ref(null);
        function uploadFiles(files) {
            if (props.limit && props.fileList.length + files.length > props.limit) {
                props.onExceed(files, props.fileList);
                return;
            }
            let postFiles = Array.from(files);
            if (!props.multiple) postFiles = postFiles.slice(0, 1);
            if (postFiles.length === 0) return;
            postFiles.forEach((rawFile)=>{
                props.onStart(rawFile);
                if (props.autoUpload) upload(rawFile);
            });
        }
        function upload(rawFile) {
            inputRef.value.value = null;
            if (!props.beforeUpload) return post(rawFile);
            const before = props.beforeUpload(rawFile);
            if (before instanceof Promise) before.then((processedFile)=>{
                const fileType = Object.prototype.toString.call(processedFile);
                if (fileType === "[object File]" || fileType === "[object Blob]") {
                    if (fileType === "[object Blob]") processedFile = new File([
                        processedFile
                    ], rawFile.name, {
                        type: rawFile.type
                    });
                    for(const p in rawFile)if (_shared.hasOwn(rawFile, p)) processedFile[p] = rawFile[p];
                    post(processedFile);
                } else post(rawFile);
            }).catch(()=>{
                props.onRemove(null, rawFile);
            });
            else if (before !== false) post(rawFile);
            else props.onRemove(null, rawFile);
        }
        function abort(file) {
            const _reqs = reqs.value;
            if (file) {
                let uid = file;
                if (file.uid) uid = file.uid;
                if (_reqs[uid]) _reqs[uid].abort();
            } else Object.keys(_reqs).forEach((uid)=>{
                if (_reqs[uid]) _reqs[uid].abort();
                delete _reqs[uid];
            });
        }
        function post(rawFile) {
            const { uid  } = rawFile;
            const options = {
                headers: props.headers,
                withCredentials: props.withCredentials,
                file: rawFile,
                data: props.data,
                method: props.method,
                filename: props.name,
                action: props.action,
                onProgress: (e)=>{
                    props.onProgress(e, rawFile);
                },
                onSuccess: (res)=>{
                    props.onSuccess(res, rawFile);
                    delete reqs.value[uid];
                },
                onError: (err)=>{
                    props.onError(err, rawFile);
                    delete reqs.value[uid];
                }
            };
            const req = props.httpRequest(options);
            reqs.value[uid] = req;
            if (req instanceof Promise) req.then(options.onSuccess, options.onError);
        }
        function handleChange(e) {
            const files = e.target.files;
            if (!files) return;
            uploadFiles(files);
        }
        function handleClick() {
            if (!props.disabled) {
                inputRef.value.value = null;
                inputRef.value.click();
            }
        }
        function handleKeydown() {
            handleClick();
        }
        return {
            ns,
            reqs,
            mouseover,
            inputRef,
            abort,
            post,
            handleChange,
            handleClick,
            handleKeydown,
            upload,
            uploadFiles
        };
    }
});
const _hoisted_1 = [
    "name",
    "multiple",
    "accept"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_upload_dragger = _vue.resolveComponent("upload-dragger");
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.m(_ctx.listType)
        ]),
        tabindex: "0",
        onClick: _cache[1] || (_cache[1] = (...args)=>_ctx.handleClick && _ctx.handleClick(...args)
        ),
        onKeydown: _cache[2] || (_cache[2] = _vue.withKeys(_vue.withModifiers((...args)=>_ctx.handleKeydown && _ctx.handleKeydown(...args)
        , [
            "self"
        ]), [
            "enter",
            "space"
        ]))
    }, [
        _ctx.drag ? (_vue.openBlock(), _vue.createBlock(_component_upload_dragger, {
            key: 0,
            disabled: _ctx.disabled,
            onFile: _ctx.uploadFiles
        }, {
            default: _vue.withCtx(()=>[
                    _vue.renderSlot(_ctx.$slots, "default")
                ]
            ),
            _: 3
        }, 8, [
            "disabled",
            "onFile"
        ])) : _vue.renderSlot(_ctx.$slots, "default", {
            key: 1
        }),
        _vue.createElementVNode("input", {
            ref: "inputRef",
            class: _vue.normalizeClass(_ctx.ns.e("input")),
            type: "file",
            name: _ctx.name,
            multiple: _ctx.multiple,
            accept: _ctx.accept,
            onChange: _cache[0] || (_cache[0] = (...args)=>_ctx.handleChange && _ctx.handleChange(...args)
            )
        }, null, 42, _hoisted_1)
    ], 34);
}
var Upload = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vue/shared":"3SM3y","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./ajax.mjs":"gJ6d0","./upload-dragger.mjs":"24CcF","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"24CcF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>UploadDragger
);
var _vue = require("vue");
var _indexMjs = require("../../../hooks/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs1 = require("../../../hooks/use-namespace/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElUploadDrag",
    props: {
        disabled: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "file"
    ],
    setup (props, { emit  }) {
        const uploader = _vue.inject("uploader", {
        });
        const ns = _indexMjs1.useNamespace("upload");
        const dragover = _vue.ref(false);
        function onDrop(e) {
            var _a;
            if (props.disabled || !uploader) return;
            const accept = ((_a = uploader.props) == null ? void 0 : _a.accept) || uploader.accept;
            dragover.value = false;
            if (!accept) {
                emit("file", e.dataTransfer.files);
                return;
            }
            emit("file", Array.from(e.dataTransfer.files).filter((file)=>{
                const { type , name  } = file;
                const extension = name.indexOf(".") > -1 ? `.${name.split(".").pop()}` : "";
                const baseType = type.replace(/\/.*$/, "");
                return accept.split(",").map((type2)=>type2.trim()
                ).filter((type2)=>type2
                ).some((acceptedType)=>{
                    if (acceptedType.startsWith(".")) return extension === acceptedType;
                    if (/\/\*$/.test(acceptedType)) return baseType === acceptedType.replace(/\/\*$/, "");
                    if (/^[^/]+\/[^/]+$/.test(acceptedType)) return type === acceptedType;
                    return false;
                });
            }));
        }
        function onDragover() {
            if (!props.disabled) dragover.value = true;
        }
        return {
            ns,
            dragover,
            onDrop,
            onDragover
        };
    }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return _vue.openBlock(), _vue.createElementBlock("div", {
        class: _vue.normalizeClass([
            _ctx.ns.b("dragger"),
            _ctx.ns.is("dragover", _ctx.dragover)
        ]),
        onDrop: _cache[0] || (_cache[0] = _vue.withModifiers((...args)=>_ctx.onDrop && _ctx.onDrop(...args)
        , [
            "prevent"
        ])),
        onDragover: _cache[1] || (_cache[1] = _vue.withModifiers((...args)=>_ctx.onDragover && _ctx.onDragover(...args)
        , [
            "prevent"
        ])),
        onDragleave: _cache[2] || (_cache[2] = _vue.withModifiers(($event)=>_ctx.dragover = false
        , [
            "prevent"
        ]))
    }, [
        _vue.renderSlot(_ctx.$slots, "default")
    ], 34);
}
var UploadDragger = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../hooks/index.mjs":"1Ansp","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../hooks/use-namespace/index.mjs":"a1pcf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"algou":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useHandlers
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _lodashUnified = require("lodash-unified");
function getFile(rawFile, uploadFiles) {
    return uploadFiles.find((file)=>file.uid === rawFile.uid
    );
}
function genUid(seed) {
    return Date.now() + seed;
}
var useHandlers = (props)=>{
    const uploadFiles = _vue.ref([]);
    const uploadRef = _vue.ref(null);
    let tempIndex = 1;
    function abort(file) {
        uploadRef.value.abort(file);
    }
    function clearFiles(status = [
        "ready",
        "uploading",
        "success",
        "fail"
    ]) {
        uploadFiles.value = uploadFiles.value.filter((row)=>{
            return !status.includes(row.status);
        });
    }
    function handleError(err, rawFile) {
        const file = getFile(rawFile, uploadFiles.value);
        file.status = "fail";
        uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
        props.onError(err, file, uploadFiles.value);
        props.onChange(file, uploadFiles.value);
    }
    function handleProgress(ev, rawFile) {
        const file = getFile(rawFile, uploadFiles.value);
        props.onProgress(ev, file, uploadFiles.value);
        file.status = "uploading";
        file.percentage = ev.percent || 0;
    }
    function handleSuccess(res, rawFile) {
        const file = getFile(rawFile, uploadFiles.value);
        if (file) {
            file.status = "success";
            file.response = res;
            props.onSuccess(res, file, uploadFiles.value);
            props.onChange(file, uploadFiles.value);
        }
    }
    function handleStart(rawFile) {
        const uid = genUid(tempIndex++);
        rawFile.uid = uid;
        const file = {
            name: rawFile.name,
            percentage: 0,
            status: "ready",
            size: rawFile.size,
            raw: rawFile,
            uid
        };
        if (props.listType === "picture-card" || props.listType === "picture") try {
            file.url = URL.createObjectURL(rawFile);
        } catch (err) {
            console.error("[Element Error][Upload]", err);
            props.onError(err, file, uploadFiles.value);
        }
        uploadFiles.value.push(file);
        props.onChange(file, uploadFiles.value);
    }
    function handleRemove(file, raw) {
        if (raw) file = getFile(raw, uploadFiles.value);
        const revokeObjectURL = ()=>{
            if (file.url && file.url.indexOf("blob:") === 0) URL.revokeObjectURL(file.url);
        };
        const doRemove = ()=>{
            abort(file);
            const fileList = uploadFiles.value;
            fileList.splice(fileList.indexOf(file), 1);
            props.onRemove(file, fileList);
            revokeObjectURL();
        };
        if (!props.beforeRemove) doRemove();
        else if (typeof props.beforeRemove === "function") {
            const before = props.beforeRemove(file, uploadFiles.value);
            if (before instanceof Promise) before.then(()=>{
                doRemove();
            }).catch(_shared.NOOP);
            else if (before !== false) doRemove();
        }
    }
    function submit() {
        uploadFiles.value.filter((file)=>file.status === "ready"
        ).forEach((file)=>{
            uploadRef.value.upload(file.raw);
        });
    }
    _vue.watch(()=>props.listType
    , (val)=>{
        if (val === "picture-card" || val === "picture") uploadFiles.value = uploadFiles.value.map((file)=>{
            if (!file.url && file.raw) try {
                file.url = URL.createObjectURL(file.raw);
            } catch (err) {
                props.onError(err, file, uploadFiles.value);
            }
            return file;
        });
    });
    _vue.watch(()=>props.fileList
    , (fileList)=>{
        uploadFiles.value = fileList.map((file)=>{
            const cloneFile = _lodashUnified.cloneDeep(file);
            return {
                ...cloneFile,
                uid: file.uid || genUid(tempIndex++),
                status: file.status || "success"
            };
        });
    }, {
        immediate: true,
        deep: true
    });
    return {
        abort,
        clearFiles,
        handleError,
        handleProgress,
        handleStart,
        handleSuccess,
        handleRemove,
        submit,
        uploadFiles,
        uploadRef
    };
};

},{"vue":"gzxs9","@vue/shared":"3SM3y","lodash-unified":"4Oj4p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j9kKF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Plugins
);
var _indexMjs = require("./components/infinite-scroll/index.mjs");
var _indexMjs1 = require("./components/loading/index.mjs");
var _indexMjs2 = require("./components/message/index.mjs");
var _indexMjs3 = require("./components/message-box/index.mjs");
var _indexMjs4 = require("./components/notification/index.mjs");
var _indexMjs5 = require("./components/popover/index.mjs");
var Plugins = [
    _indexMjs.ElInfiniteScroll,
    _indexMjs1.ElLoading,
    _indexMjs2.ElMessage,
    _indexMjs3.ElMessageBox,
    _indexMjs4.ElNotification,
    _indexMjs5.ElPopoverDirective
];

},{"./components/infinite-scroll/index.mjs":"fffis","./components/loading/index.mjs":"9QQSv","./components/message/index.mjs":"hqiSY","./components/message-box/index.mjs":"lPFAH","./components/notification/index.mjs":"a0vte","./components/popover/index.mjs":"cnet0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fffis":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElInfiniteScroll", ()=>ElInfiniteScroll
);
parcelHelpers.export(exports, "default", ()=>_InfiniteScroll
);
var _indexMjs = require("./src/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
const _InfiniteScroll = _indexMjsDefault.default;
_InfiniteScroll.install = (app)=>{
    app.directive("InfiniteScroll", _InfiniteScroll);
};
const ElInfiniteScroll = _InfiniteScroll;

},{"./src/index.mjs":"k09xo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k09xo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CHECK_INTERVAL", ()=>CHECK_INTERVAL
);
parcelHelpers.export(exports, "DEFAULT_DELAY", ()=>DEFAULT_DELAY
);
parcelHelpers.export(exports, "DEFAULT_DISTANCE", ()=>DEFAULT_DISTANCE
);
parcelHelpers.export(exports, "SCOPE", ()=>SCOPE
);
parcelHelpers.export(exports, "default", ()=>InfiniteScroll
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _lodashUnified = require("lodash-unified");
var _indexMjs = require("../../../utils/index.mjs");
var _positionMjs = require("../../../utils/dom/position.mjs");
var _errorMjs = require("../../../utils/error.mjs");
var _scrollMjs = require("../../../utils/dom/scroll.mjs");
const SCOPE = "ElInfiniteScroll";
const CHECK_INTERVAL = 50;
const DEFAULT_DELAY = 200;
const DEFAULT_DISTANCE = 0;
const attributes = {
    delay: {
        type: Number,
        default: DEFAULT_DELAY
    },
    distance: {
        type: Number,
        default: DEFAULT_DISTANCE
    },
    disabled: {
        type: Boolean,
        default: false
    },
    immediate: {
        type: Boolean,
        default: true
    }
};
const getScrollOptions = (el, instance)=>{
    return Object.entries(attributes).reduce((acm, [name, option])=>{
        var _a, _b;
        const { type , default: defaultValue  } = option;
        const attrVal = el.getAttribute(`infinite-scroll-${name}`);
        let value = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue;
        value = value === "false" ? false : value;
        value = type(value);
        acm[name] = Number.isNaN(value) ? defaultValue : value;
        return acm;
    }, {
    });
};
const destroyObserver = (el)=>{
    const { observer  } = el[SCOPE];
    if (observer) {
        observer.disconnect();
        delete el[SCOPE].observer;
    }
};
const handleScroll = (el, cb)=>{
    const { container , containerEl , instance , observer , lastScrollTop  } = el[SCOPE];
    const { disabled , distance  } = getScrollOptions(el, instance);
    const { clientHeight , scrollHeight , scrollTop  } = containerEl;
    const delta = scrollTop - lastScrollTop;
    el[SCOPE].lastScrollTop = scrollTop;
    if (observer || disabled || delta < 0) return;
    let shouldTrigger = false;
    if (container === el) shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;
    else {
        const { clientTop , scrollHeight: height  } = el;
        const offsetTop = _positionMjs.getOffsetTopDistance(el, containerEl);
        shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;
    }
    if (shouldTrigger) cb.call(instance);
};
function checkFull(el, cb) {
    const { containerEl , instance  } = el[SCOPE];
    const { disabled  } = getScrollOptions(el, instance);
    if (disabled || containerEl.clientHeight === 0) return;
    if (containerEl.scrollHeight <= containerEl.clientHeight) cb.call(instance);
    else destroyObserver(el);
}
const InfiniteScroll = {
    async mounted (el, binding) {
        const { instance , value: cb  } = binding;
        if (!_shared.isFunction(cb)) _errorMjs.throwError(SCOPE, "'v-infinite-scroll' binding value must be a function");
        await _vue.nextTick();
        const { delay , immediate  } = getScrollOptions(el, instance);
        const container = _scrollMjs.getScrollContainer(el, true);
        const containerEl = container === window ? document.documentElement : container;
        const onScroll = _lodashUnified.throttle(handleScroll.bind(null, el, cb), delay);
        if (!container) return;
        el[SCOPE] = {
            instance,
            container,
            containerEl,
            delay,
            cb,
            onScroll,
            lastScrollTop: containerEl.scrollTop
        };
        if (immediate) {
            const observer = new MutationObserver(_lodashUnified.throttle(checkFull.bind(null, el, cb), CHECK_INTERVAL));
            el[SCOPE].observer = observer;
            observer.observe(el, {
                childList: true,
                subtree: true
            });
            checkFull(el, cb);
        }
        container.addEventListener("scroll", onScroll);
    },
    unmounted (el) {
        const { container , onScroll  } = el[SCOPE];
        container == null || container.removeEventListener("scroll", onScroll);
        destroyObserver(el);
    },
    async updated (el) {
        if (!el[SCOPE]) await _vue.nextTick();
        const { containerEl , cb , observer  } = el[SCOPE];
        if (containerEl.clientHeight && observer) checkFull(el, cb);
    }
};

},{"vue":"gzxs9","@vue/shared":"3SM3y","lodash-unified":"4Oj4p","../../../utils/index.mjs":"dsdeP","../../../utils/dom/position.mjs":"cYzxx","../../../utils/error.mjs":"2zPBN","../../../utils/dom/scroll.mjs":"hpitc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9QQSv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElLoading", ()=>ElLoading
);
parcelHelpers.export(exports, "ElLoadingDirective", ()=>ElLoadingDirective
);
parcelHelpers.export(exports, "ElLoadingService", ()=>ElLoadingService
);
parcelHelpers.export(exports, "default", ()=>ElLoading
);
var _serviceMjs = require("./src/service.mjs");
var _directiveMjs = require("./src/directive.mjs");
var _typesMjs = require("./src/types.mjs");
const ElLoading = {
    install (app) {
        app.directive("loading", _directiveMjs.vLoading);
        app.config.globalProperties.$loading = _serviceMjs.Loading;
    },
    directive: _directiveMjs.vLoading,
    service: _serviceMjs.Loading
};
const ElLoadingDirective = _directiveMjs.vLoading;
const ElLoadingService = _serviceMjs.Loading;

},{"./src/service.mjs":"liyLr","./src/directive.mjs":"5St7w","./src/types.mjs":"8XuWc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"liyLr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Loading", ()=>Loading
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _loadingMjs = require("./loading.mjs");
var _indexMjs2 = require("../../../hooks/use-z-index/index.mjs");
var _styleMjs = require("../../../utils/dom/style.mjs");
let fullscreenInstance = void 0;
const Loading = function(options = {
}) {
    if (!_core.isClient) return void 0;
    const resolved = resolveOptions(options);
    if (resolved.fullscreen && fullscreenInstance) {
        fullscreenInstance.remvoeElLoadingChild();
        fullscreenInstance.close();
    }
    const instance = _loadingMjs.createLoadingComponent({
        ...resolved,
        closed: ()=>{
            var _a;
            (_a = resolved.closed) == null || _a.call(resolved);
            if (resolved.fullscreen) fullscreenInstance = void 0;
        }
    });
    addStyle(resolved, resolved.parent, instance);
    addClassList(resolved, resolved.parent, instance);
    resolved.parent.vLoadingAddClassList = ()=>addClassList(resolved, resolved.parent, instance)
    ;
    let loadingNumber = resolved.parent.getAttribute("loading-number");
    if (!loadingNumber) loadingNumber = "1";
    else loadingNumber = `${Number.parseInt(loadingNumber) + 1}`;
    resolved.parent.setAttribute("loading-number", loadingNumber);
    resolved.parent.appendChild(instance.$el);
    _vue.nextTick(()=>instance.visible.value = resolved.visible
    );
    if (resolved.fullscreen) fullscreenInstance = instance;
    return instance;
};
const resolveOptions = (options)=>{
    var _a, _b, _c, _d;
    let target;
    if (_shared.isString(options.target)) target = (_a = document.querySelector(options.target)) != null ? _a : document.body;
    else target = options.target || document.body;
    return {
        parent: target === document.body || options.body ? document.body : target,
        background: options.background || "",
        svg: options.svg || "",
        svgViewBox: options.svgViewBox || "",
        spinner: options.spinner || false,
        text: options.text || "",
        fullscreen: target === document.body && ((_b = options.fullscreen) != null ? _b : true),
        lock: (_c = options.lock) != null ? _c : false,
        customClass: options.customClass || "",
        visible: (_d = options.visible) != null ? _d : true,
        target
    };
};
const addStyle = async (options, parent, instance)=>{
    const { nextZIndex  } = _indexMjs2.useZIndex();
    const maskStyle = {
    };
    if (options.fullscreen) {
        instance.originalPosition.value = _styleMjs.getStyle(document.body, "position");
        instance.originalOverflow.value = _styleMjs.getStyle(document.body, "overflow");
        maskStyle.zIndex = nextZIndex();
    } else if (options.parent === document.body) {
        instance.originalPosition.value = _styleMjs.getStyle(document.body, "position");
        await _vue.nextTick();
        for (const property of [
            "top",
            "left"
        ]){
            const scroll = property === "top" ? "scrollTop" : "scrollLeft";
            maskStyle[property] = `${options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] - parseInt(_styleMjs.getStyle(document.body, `margin-${property}`), 10)}px`;
        }
        for (const property1 of [
            "height",
            "width"
        ])maskStyle[property1] = `${options.target.getBoundingClientRect()[property1]}px`;
    } else instance.originalPosition.value = _styleMjs.getStyle(parent, "position");
    for (const [key, value] of Object.entries(maskStyle))instance.$el.style[key] = value;
};
const addClassList = (options, parent, instance)=>{
    if (instance.originalPosition.value !== "absolute" && instance.originalPosition.value !== "fixed") _styleMjs.addClass(parent, "el-loading-parent--relative");
    else _styleMjs.removeClass(parent, "el-loading-parent--relative");
    if (options.fullscreen && options.lock) _styleMjs.addClass(parent, "el-loading-parent--hidden");
    else _styleMjs.removeClass(parent, "el-loading-parent--hidden");
};

},{"vue":"gzxs9","@vue/shared":"3SM3y","@vueuse/core":"eEHP9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","./loading.mjs":"80wJT","../../../hooks/use-z-index/index.mjs":"7aKZA","../../../utils/dom/style.mjs":"cA8Mp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"80wJT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createLoadingComponent", ()=>createLoadingComponent
);
var _vue = require("vue");
var _indexMjs = require("../../../utils/index.mjs");
var _styleMjs = require("../../../utils/dom/style.mjs");
function createLoadingComponent(options) {
    let afterLeaveTimer;
    const afterLeaveFlag = _vue.ref(false);
    const data = _vue.reactive({
        ...options,
        originalPosition: "",
        originalOverflow: "",
        visible: false
    });
    function setText(text) {
        data.text = text;
    }
    function destroySelf() {
        const target = data.parent;
        if (!target.vLoadingAddClassList) {
            let loadingNumber = target.getAttribute("loading-number");
            loadingNumber = Number.parseInt(loadingNumber) - 1;
            if (!loadingNumber) {
                _styleMjs.removeClass(target, "el-loading-parent--relative");
                target.removeAttribute("loading-number");
            } else target.setAttribute("loading-number", loadingNumber.toString());
            _styleMjs.removeClass(target, "el-loading-parent--hidden");
        }
        remvoeElLoadingChild();
    }
    function remvoeElLoadingChild() {
        var _a, _b;
        (_b = (_a = vm.$el) == null ? void 0 : _a.parentNode) == null || _b.removeChild(vm.$el);
    }
    function close() {
        var _a;
        if (options.beforeClose && !options.beforeClose()) return;
        const target = data.parent;
        target.vLoadingAddClassList = void 0;
        afterLeaveFlag.value = true;
        clearTimeout(afterLeaveTimer);
        afterLeaveTimer = window.setTimeout(()=>{
            if (afterLeaveFlag.value) {
                afterLeaveFlag.value = false;
                destroySelf();
            }
        }, 400);
        data.visible = false;
        (_a = options.closed) == null || _a.call(options);
    }
    function handleAfterLeave() {
        if (!afterLeaveFlag.value) return;
        afterLeaveFlag.value = false;
        destroySelf();
    }
    const elLoadingComponent = {
        name: "ElLoading",
        setup () {
            return ()=>{
                const svg = data.spinner || data.svg;
                const spinner = _vue.h("svg", {
                    class: "circular",
                    viewBox: data.svgViewBox ? data.svgViewBox : "25 25 50 50",
                    ...svg ? {
                        innerHTML: svg
                    } : {
                    }
                }, [
                    _vue.h("circle", {
                        class: "path",
                        cx: "50",
                        cy: "50",
                        r: "20",
                        fill: "none"
                    })
                ]);
                const spinnerText = data.text ? _vue.h("p", {
                    class: "el-loading-text"
                }, [
                    data.text
                ]) : void 0;
                return _vue.h(_vue.Transition, {
                    name: "el-loading-fade",
                    onAfterLeave: handleAfterLeave
                }, {
                    default: _vue.withCtx(()=>[
                            _vue.withDirectives(_vue.createVNode("div", {
                                style: {
                                    backgroundColor: data.background || ""
                                },
                                class: [
                                    "el-loading-mask",
                                    data.customClass,
                                    data.fullscreen ? "is-fullscreen" : ""
                                ]
                            }, [
                                _vue.h("div", {
                                    class: "el-loading-spinner"
                                }, [
                                    spinner,
                                    spinnerText
                                ])
                            ]), [
                                [
                                    _vue.vShow,
                                    data.visible
                                ]
                            ])
                        ]
                    )
                });
            };
        }
    };
    const vm = _vue.createApp(elLoadingComponent).mount(document.createElement("div"));
    return {
        ..._vue.toRefs(data),
        setText,
        remvoeElLoadingChild,
        close,
        handleAfterLeave,
        vm,
        get $el () {
            return vm.$el;
        }
    };
}

},{"vue":"gzxs9","../../../utils/index.mjs":"dsdeP","../../../utils/dom/style.mjs":"cA8Mp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5St7w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "vLoading", ()=>vLoading
);
var _vue = require("vue");
var _shared = require("@vue/shared");
var _serviceMjs = require("./service.mjs");
const INSTANCE_KEY = Symbol("ElLoading");
const createInstance = (el, binding)=>{
    var _a, _b, _c, _d;
    const vm = binding.instance;
    const getBindingProp = (key)=>_shared.isObject(binding.value) ? binding.value[key] : void 0
    ;
    const resolveExpression = (key)=>{
        const data = _shared.isString(key) && (vm == null ? void 0 : vm[key]) || key;
        if (data) return _vue.ref(data);
        else return data;
    };
    const getProp = (name)=>resolveExpression(getBindingProp(name) || el.getAttribute(`element-loading-${_shared.hyphenate(name)}`))
    ;
    const fullscreen = (_a = getBindingProp("fullscreen")) != null ? _a : binding.modifiers.fullscreen;
    const options = {
        text: getProp("text"),
        svg: getProp("svg"),
        svgViewBox: getProp("svgViewBox"),
        spinner: getProp("spinner"),
        background: getProp("background"),
        customClass: getProp("customClass"),
        fullscreen,
        target: (_b = getBindingProp("target")) != null ? _b : fullscreen ? void 0 : el,
        body: (_c = getBindingProp("body")) != null ? _c : binding.modifiers.body,
        lock: (_d = getBindingProp("lock")) != null ? _d : binding.modifiers.lock
    };
    el[INSTANCE_KEY] = {
        options,
        instance: _serviceMjs.Loading(options)
    };
};
const updateOptions = (newOptions, originalOptions)=>{
    for (const key of Object.keys(originalOptions))if (_vue.isRef(originalOptions[key])) originalOptions[key].value = newOptions[key];
};
const vLoading = {
    mounted (el, binding) {
        if (binding.value) createInstance(el, binding);
    },
    updated (el, binding) {
        const instance = el[INSTANCE_KEY];
        if (binding.oldValue !== binding.value) {
            if (binding.value && !binding.oldValue) createInstance(el, binding);
            else if (binding.value && binding.oldValue) {
                if (_shared.isObject(binding.value)) updateOptions(binding.value, instance.options);
            } else instance == null || instance.instance.close();
        }
    },
    unmounted (el) {
        var _a;
        (_a = el[INSTANCE_KEY]) == null || _a.instance.close();
    }
};

},{"vue":"gzxs9","@vue/shared":"3SM3y","./service.mjs":"liyLr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8XuWc":[function(require,module,exports) {

},{}],"hqiSY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "messageEmits", ()=>_messageMjs.messageEmits
);
parcelHelpers.export(exports, "messageProps", ()=>_messageMjs.messageProps
);
parcelHelpers.export(exports, "messageTypes", ()=>_messageMjs.messageTypes
);
parcelHelpers.export(exports, "ElMessage", ()=>ElMessage
);
parcelHelpers.export(exports, "default", ()=>ElMessage
);
var _indexMjs = require("../../utils/index.mjs");
var _messageMethodMjs = require("./src/message-method.mjs");
var _messageMethodMjsDefault = parcelHelpers.interopDefault(_messageMethodMjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _messageMjs = require("./src/message.mjs");
const ElMessage = _installMjs.withInstallFunction(_messageMethodMjsDefault.default, "$message");

},{"../../utils/index.mjs":"dsdeP","./src/message-method.mjs":"3pGsu","../../utils/vue/install.mjs":"4TMmv","./src/message.mjs":"exwnb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3pGsu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "close", ()=>close
);
parcelHelpers.export(exports, "closeAll", ()=>closeAll
);
parcelHelpers.export(exports, "default", ()=>message
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../hooks/index.mjs");
var _configProviderMjs = require("../../config-provider/src/config-provider.mjs");
var _message2Mjs = require("./message2.mjs");
var _message2MjsDefault = parcelHelpers.interopDefault(_message2Mjs);
var _messageMjs = require("./message.mjs");
var _indexMjs2 = require("../../../hooks/use-z-index/index.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const instances = [];
let seed = 1;
const message = function(options = {
}) {
    if (!_core.isClient) return {
        close: ()=>void 0
    };
    if (_core.isNumber(_configProviderMjs.messageConfig.max) && instances.length >= _configProviderMjs.messageConfig.max) return {
        close: ()=>void 0
    };
    if (!_vue.isVNode(options) && typeof options === "object" && options.grouping && !_vue.isVNode(options.message) && instances.length) {
        const tempVm = instances.find((item)=>{
            var _a, _b, _c;
            return `${(_b = (_a = item.vm.props) == null ? void 0 : _a.message) != null ? _b : ""}` === `${(_c = options.message) != null ? _c : ""}`;
        });
        if (tempVm) {
            tempVm.vm.component.props.repeatNum += 1;
            tempVm.vm.component.props.type = options == null ? void 0 : options.type;
            return {
                close: ()=>vm.component.proxy.visible = false
            };
        }
    }
    if (typeof options === "string" || _vue.isVNode(options)) options = {
        message: options
    };
    let verticalOffset = options.offset || 20;
    instances.forEach(({ vm: vm2  })=>{
        var _a;
        verticalOffset += (((_a = vm2.el) == null ? void 0 : _a.offsetHeight) || 0) + 16;
    });
    verticalOffset += 16;
    const { nextZIndex  } = _indexMjs2.useZIndex();
    const id = `message_${seed++}`;
    const userOnClose = options.onClose;
    const props = {
        zIndex: nextZIndex(),
        offset: verticalOffset,
        ...options,
        id,
        onClose: ()=>{
            close(id, userOnClose);
        }
    };
    let appendTo = document.body;
    if (options.appendTo instanceof HTMLElement) appendTo = options.appendTo;
    else if (typeof options.appendTo === "string") appendTo = document.querySelector(options.appendTo);
    if (!(appendTo instanceof HTMLElement)) {
        _errorMjs.debugWarn("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body.");
        appendTo = document.body;
    }
    const container = document.createElement("div");
    container.className = `container_${id}`;
    const message2 = props.message;
    const vm = _vue.createVNode(_message2MjsDefault.default, props, _vue.isVNode(props.message) ? {
        default: ()=>message2
    } : null);
    vm.props.onDestroy = ()=>{
        _vue.render(null, container);
    };
    _vue.render(vm, container);
    instances.push({
        vm
    });
    appendTo.appendChild(container.firstElementChild);
    return {
        close: ()=>vm.component.proxy.visible = false
    };
};
_messageMjs.messageTypes.forEach((type)=>{
    message[type] = (options = {
    })=>{
        if (typeof options === "string" || _vue.isVNode(options)) options = {
            message: options
        };
        return message({
            ...options,
            type
        });
    };
});
function close(id, userOnClose) {
    const idx = instances.findIndex(({ vm: vm2  })=>id === vm2.component.props.id
    );
    if (idx === -1) return;
    const { vm  } = instances[idx];
    if (!vm) return;
    userOnClose == null || userOnClose(vm);
    const removedHeight = vm.el.offsetHeight;
    instances.splice(idx, 1);
    const len = instances.length;
    if (len < 1) return;
    for(let i = idx; i < len; i++){
        const pos = parseInt(instances[i].vm.el.style["top"], 10) - removedHeight - 16;
        instances[i].vm.component.props.offset = pos;
    }
}
function closeAll() {
    var _a;
    for(let i = instances.length - 1; i >= 0; i--){
        const instance = instances[i].vm.component;
        (_a = instance == null ? void 0 : instance.proxy) == null || _a.close();
    }
}
message.closeAll = closeAll;

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../utils/index.mjs":"dsdeP","../../../hooks/index.mjs":"1Ansp","../../config-provider/src/config-provider.mjs":"jXq22","./message2.mjs":"7FjiR","./message.mjs":"exwnb","../../../hooks/use-z-index/index.mjs":"7aKZA","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7FjiR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>MessageConstructor
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../badge/index.mjs");
var _indexMjs3 = require("../../icon/index.mjs");
var _indexMjs4 = require("../../../hooks/index.mjs");
var _messageMjs = require("./message.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _indexMjs5 = require("../../../hooks/use-namespace/index.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElMessage",
    components: {
        ElBadge: _indexMjs2.ElBadge,
        ElIcon: _indexMjs3.ElIcon,
        ..._iconMjs.TypeComponents
    },
    props: _messageMjs.messageProps,
    emits: _messageMjs.messageEmits,
    setup (props) {
        const ns = _indexMjs5.useNamespace("message");
        const visible = _vue.ref(false);
        const badgeType = _vue.ref(props.type ? props.type === "error" ? "danger" : props.type : "info");
        let stopTimer = void 0;
        const typeClass = _vue.computed(()=>{
            const type = props.type;
            return {
                [ns.bm("icon", type)]: type && _iconMjs.TypeComponentsMap[type]
            };
        });
        const iconComponent = _vue.computed(()=>{
            return props.icon || _iconMjs.TypeComponentsMap[props.type] || "";
        });
        const customStyle = _vue.computed(()=>({
                top: `${props.offset}px`,
                zIndex: props.zIndex
            })
        );
        function startTimer() {
            if (props.duration > 0) ({ stop: stopTimer  } = _core.useTimeoutFn(()=>{
                if (visible.value) close();
            }, props.duration));
        }
        function clearTimer() {
            stopTimer == null || stopTimer();
        }
        function close() {
            visible.value = false;
        }
        function keydown({ code  }) {
            if (code === _ariaMjs.EVENT_CODE.esc) {
                if (visible.value) close();
            } else startTimer();
        }
        _vue.onMounted(()=>{
            startTimer();
            visible.value = true;
        });
        _vue.watch(()=>props.repeatNum
        , ()=>{
            clearTimer();
            startTimer();
        });
        _core.useEventListener(document, "keydown", keydown);
        return {
            ns,
            typeClass,
            iconComponent,
            customStyle,
            visible,
            badgeType,
            close,
            clearTimer,
            startTimer
        };
    }
});
const _hoisted_1 = [
    "id"
];
const _hoisted_2 = [
    "innerHTML"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_badge = _vue.resolveComponent("el-badge");
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_close = _vue.resolveComponent("close");
    return _vue.openBlock(), _vue.createBlock(_vue.Transition, {
        name: _ctx.ns.b("fade"),
        onBeforeLeave: _ctx.onClose,
        onAfterLeave: _cache[2] || (_cache[2] = ($event)=>_ctx.$emit("destroy")
        )
    }, {
        default: _vue.withCtx(()=>[
                _vue.withDirectives(_vue.createElementVNode("div", {
                    id: _ctx.id,
                    class: _vue.normalizeClass([
                        _ctx.ns.b(),
                        {
                            [_ctx.ns.m(_ctx.type)]: _ctx.type && !_ctx.icon
                        },
                        _ctx.ns.is("center", _ctx.center),
                        _ctx.ns.is("closable", _ctx.showClose),
                        _ctx.customClass
                    ]),
                    style: _vue.normalizeStyle(_ctx.customStyle),
                    role: "alert",
                    onMouseenter: _cache[0] || (_cache[0] = (...args)=>_ctx.clearTimer && _ctx.clearTimer(...args)
                    ),
                    onMouseleave: _cache[1] || (_cache[1] = (...args)=>_ctx.startTimer && _ctx.startTimer(...args)
                    )
                }, [
                    _ctx.repeatNum > 1 ? (_vue.openBlock(), _vue.createBlock(_component_el_badge, {
                        key: 0,
                        value: _ctx.repeatNum,
                        type: _ctx.badgeType,
                        class: _vue.normalizeClass(_ctx.ns.e("badge"))
                    }, null, 8, [
                        "value",
                        "type",
                        "class"
                    ])) : _vue.createCommentVNode("v-if", true),
                    _ctx.iconComponent ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 1,
                        class: _vue.normalizeClass([
                            _ctx.ns.e("icon"),
                            _ctx.typeClass
                        ])
                    }, {
                        default: _vue.withCtx(()=>[
                                (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.iconComponent)))
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "class"
                    ])) : _vue.createCommentVNode("v-if", true),
                    _vue.renderSlot(_ctx.$slots, "default", {
                    }, ()=>[
                            !_ctx.dangerouslyUseHTMLString ? (_vue.openBlock(), _vue.createElementBlock("p", {
                                key: 0,
                                class: _vue.normalizeClass(_ctx.ns.e("content"))
                            }, _vue.toDisplayString(_ctx.message), 3)) : (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                                key: 1
                            }, [
                                _vue.createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                                _vue.createElementVNode("p", {
                                    class: _vue.normalizeClass(_ctx.ns.e("content")),
                                    innerHTML: _ctx.message
                                }, null, 10, _hoisted_2)
                            ], 2112))
                        ]
                    ),
                    _ctx.showClose ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 2,
                        class: _vue.normalizeClass(_ctx.ns.e("closeBtn")),
                        onClick: _vue.withModifiers(_ctx.close, [
                            "stop"
                        ])
                    }, {
                        default: _vue.withCtx(()=>[
                                _vue.createVNode(_component_close)
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "class",
                        "onClick"
                    ])) : _vue.createCommentVNode("v-if", true)
                ], 46, _hoisted_1), [
                    [
                        _vue.vShow,
                        _ctx.visible
                    ]
                ])
            ]
        ),
        _: 3
    }, 8, [
        "name",
        "onBeforeLeave"
    ]);
}
var MessageConstructor = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../badge/index.mjs":"gvyeW","../../icon/index.mjs":"hnNTG","../../../hooks/index.mjs":"1Ansp","./message.mjs":"exwnb","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/vue/icon.mjs":"3YbE5","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"exwnb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "messageEmits", ()=>messageEmits
);
parcelHelpers.export(exports, "messageProps", ()=>messageProps
);
parcelHelpers.export(exports, "messageTypes", ()=>messageTypes
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
var _iconMjs = require("../../../utils/vue/icon.mjs");
const messageTypes = [
    "success",
    "info",
    "warning",
    "error"
];
const messageProps = _propsMjs.buildProps({
    customClass: {
        type: String,
        default: ""
    },
    center: {
        type: Boolean,
        default: false
    },
    dangerouslyUseHTMLString: {
        type: Boolean,
        default: false
    },
    duration: {
        type: Number,
        default: 3000
    },
    icon: {
        type: _iconMjs.iconPropType,
        default: ""
    },
    id: {
        type: String,
        default: ""
    },
    message: {
        type: _propsMjs.definePropType([
            String,
            Object
        ]),
        default: ""
    },
    onClose: {
        type: _propsMjs.definePropType(Function),
        required: false
    },
    showClose: {
        type: Boolean,
        default: false
    },
    type: {
        type: String,
        values: messageTypes,
        default: "info"
    },
    offset: {
        type: Number,
        default: 20
    },
    zIndex: {
        type: Number,
        default: 0
    },
    grouping: {
        type: Boolean,
        default: false
    },
    repeatNum: {
        type: Number,
        default: 1
    }
});
const messageEmits = {
    destroy: ()=>true
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","../../../utils/vue/icon.mjs":"3YbE5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lPFAH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElMessageBox", ()=>ElMessageBox
);
parcelHelpers.export(exports, "default", ()=>_MessageBox
);
var _messageBoxMjs = require("./src/messageBox.mjs");
var _messageBoxMjsDefault = parcelHelpers.interopDefault(_messageBoxMjs);
var _messageBoxTypeMjs = require("./src/message-box.type.mjs");
const _MessageBox = _messageBoxMjsDefault.default;
_MessageBox.install = (app)=>{
    app.config.globalProperties.$msgbox = _MessageBox;
    app.config.globalProperties.$messageBox = _MessageBox;
    app.config.globalProperties.$alert = _MessageBox.alert;
    app.config.globalProperties.$confirm = _MessageBox.confirm;
    app.config.globalProperties.$prompt = _MessageBox.prompt;
};
const ElMessageBox = _MessageBox;

},{"./src/messageBox.mjs":"4byx5","./src/message-box.type.mjs":"qGcgU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4byx5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>MessageBox
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("./index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _shared = require("@vue/shared");
const messageInstance = /* @__PURE__ */ new Map();
const initInstance = (props, container)=>{
    const vnode = _vue.h(_indexMjsDefault.default, props);
    _vue.render(vnode, container);
    document.body.appendChild(container.firstElementChild);
    return vnode.component;
};
const genContainer = ()=>{
    return document.createElement("div");
};
const showMessage = (options)=>{
    const container = genContainer();
    options.onVanish = ()=>{
        _vue.render(null, container);
        messageInstance.delete(vm);
    };
    options.onAction = (action)=>{
        const currentMsg = messageInstance.get(vm);
        let resolve;
        if (options.showInput) resolve = {
            value: vm.inputValue,
            action
        };
        else resolve = action;
        if (options.callback) options.callback(resolve, instance.proxy);
        else if (action === "cancel" || action === "close") {
            if (options.distinguishCancelAndClose && action !== "cancel") currentMsg.reject("close");
            else currentMsg.reject("cancel");
        } else currentMsg.resolve(resolve);
    };
    const instance = initInstance(options, container);
    const vm = instance.proxy;
    for(const prop in options)if (_shared.hasOwn(options, prop) && !_shared.hasOwn(vm.$props, prop)) vm[prop] = options[prop];
    _vue.watch(()=>vm.message
    , (newVal, oldVal)=>{
        if (_vue.isVNode(newVal)) instance.slots.default = ()=>[
                newVal
            ]
        ;
        else if (_vue.isVNode(oldVal) && !_vue.isVNode(newVal)) delete instance.slots.default;
    }, {
        immediate: true
    });
    vm.visible = true;
    return vm;
};
function MessageBox(options) {
    if (!_core.isClient) return;
    let callback;
    if (_shared.isString(options) || _vue.isVNode(options)) options = {
        message: options
    };
    else callback = options.callback;
    return new Promise((resolve, reject)=>{
        const vm = showMessage(options);
        messageInstance.set(vm, {
            options,
            callback,
            resolve,
            reject
        });
    });
}
MessageBox.alert = (message, title, options)=>{
    if (typeof title === "object") {
        options = title;
        title = "";
    } else if (title === void 0) title = "";
    return MessageBox(Object.assign({
        title,
        message,
        type: "",
        closeOnPressEscape: false,
        closeOnClickModal: false
    }, options, {
        boxType: "alert"
    }));
};
MessageBox.confirm = (message, title, options)=>{
    if (typeof title === "object") {
        options = title;
        title = "";
    } else if (title === void 0) title = "";
    return MessageBox(Object.assign({
        title,
        message,
        type: "",
        showCancelButton: true
    }, options, {
        boxType: "confirm"
    }));
};
MessageBox.prompt = (message, title, options)=>{
    if (typeof title === "object") {
        options = title;
        title = "";
    } else if (title === void 0) title = "";
    return MessageBox(Object.assign({
        title,
        message,
        showCancelButton: true,
        showInput: true,
        type: ""
    }, options, {
        boxType: "prompt"
    }));
};
MessageBox.close = ()=>{
    messageInstance.forEach((_, vm)=>{
        vm.doClose();
    });
    messageInstance.clear();
};

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../utils/index.mjs":"dsdeP","./index.mjs":"gppwD","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gppwD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>MessageBoxConstructor
);
var _vue = require("vue");
var _indexMjs = require("../../button/index.mjs");
var _indexMjs1 = require("../../../directives/index.mjs");
var _indexMjs2 = require("../../../hooks/index.mjs");
var _indexMjs3 = require("../../input/index.mjs");
var _indexMjs4 = require("../../overlay/index.mjs");
var _indexMjs5 = require("../../../utils/index.mjs");
var _indexMjs6 = require("../../../constants/index.mjs");
var _indexMjs7 = require("../../icon/index.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _indexMjs8 = require("../../../directives/trap-focus/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs8);
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _validatorMjs = require("../../../utils/vue/validator.mjs");
var _indexMjs9 = require("../../../hooks/use-locale/index.mjs");
var _indexMjs10 = require("../../../hooks/use-z-index/index.mjs");
var _indexMjs11 = require("../../../hooks/use-common-props/index.mjs");
var _indexMjs12 = require("../../../hooks/use-draggable/index.mjs");
var _eventMjs = require("../../../utils/dom/event.mjs");
var _indexMjs13 = require("../../../hooks/use-same-target/index.mjs");
var _indexMjs14 = require("../../../hooks/use-modal/index.mjs");
var _indexMjs15 = require("../../../hooks/use-prevent-global/index.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
var _indexMjs16 = require("../../../hooks/use-lockscreen/index.mjs");
var _indexMjs17 = require("../../../hooks/use-restore-active/index.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElMessageBox",
    directives: {
        TrapFocus: _indexMjsDefault.default
    },
    components: {
        ElButton: _indexMjs.ElButton,
        ElInput: _indexMjs3.ElInput,
        ElOverlay: _indexMjs4.ElOverlay,
        ElIcon: _indexMjs7.ElIcon,
        ..._iconMjs.TypeComponents
    },
    inheritAttrs: false,
    props: {
        buttonSize: {
            type: String,
            validator: _validatorMjs.isValidComponentSize
        },
        modal: {
            type: Boolean,
            default: true
        },
        lockScroll: {
            type: Boolean,
            default: true
        },
        showClose: {
            type: Boolean,
            default: true
        },
        closeOnClickModal: {
            type: Boolean,
            default: true
        },
        closeOnPressEscape: {
            type: Boolean,
            default: true
        },
        closeOnHashChange: {
            type: Boolean,
            default: true
        },
        center: Boolean,
        draggable: Boolean,
        roundButton: {
            default: false,
            type: Boolean
        },
        container: {
            type: String,
            default: "body"
        },
        boxType: {
            type: String,
            default: ""
        }
    },
    emits: [
        "vanish",
        "action"
    ],
    setup (props, { emit  }) {
        const { t  } = _indexMjs9.useLocale();
        const visible = _vue.ref(false);
        const { nextZIndex  } = _indexMjs10.useZIndex();
        const state = _vue.reactive({
            beforeClose: null,
            callback: null,
            cancelButtonText: "",
            cancelButtonClass: "",
            confirmButtonText: "",
            confirmButtonClass: "",
            customClass: "",
            customStyle: {
            },
            dangerouslyUseHTMLString: false,
            distinguishCancelAndClose: false,
            icon: "",
            inputPattern: null,
            inputPlaceholder: "",
            inputType: "text",
            inputValue: null,
            inputValidator: null,
            inputErrorMessage: "",
            message: null,
            modalFade: true,
            modalClass: "",
            showCancelButton: false,
            showConfirmButton: true,
            type: "",
            title: void 0,
            showInput: false,
            action: "",
            confirmButtonLoading: false,
            cancelButtonLoading: false,
            confirmButtonDisabled: false,
            editorErrorMessage: "",
            validateError: false,
            zIndex: nextZIndex()
        });
        const typeClass = _vue.computed(()=>{
            const type = state.type;
            return type && _iconMjs.TypeComponentsMap[type] ? `el-message-box-icon--${type}` : "";
        });
        const btnSize = _indexMjs11.useSize(_vue.computed(()=>props.buttonSize
        ), {
            prop: true,
            form: true,
            formItem: true
        });
        const iconComponent = _vue.computed(()=>state.icon || _iconMjs.TypeComponentsMap[state.type] || ""
        );
        const hasMessage = _vue.computed(()=>!!state.message
        );
        const rootRef = _vue.ref();
        const headerRef = _vue.ref();
        const inputRef = _vue.ref();
        const confirmRef = _vue.ref();
        const confirmButtonClasses = _vue.computed(()=>state.confirmButtonClass
        );
        _vue.watch(()=>state.inputValue
        , async (val)=>{
            await _vue.nextTick();
            if (props.boxType === "prompt" && val !== null) validate();
        }, {
            immediate: true
        });
        _vue.watch(()=>visible.value
        , (val)=>{
            if (val) {
                if (props.boxType === "alert" || props.boxType === "confirm") _vue.nextTick().then(()=>{
                    var _a, _b, _c;
                    (_c = (_b = (_a = confirmRef.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.focus) == null || _c.call(_b);
                });
                state.zIndex = nextZIndex();
            }
            if (props.boxType !== "prompt") return;
            if (val) _vue.nextTick().then(()=>{
                if (inputRef.value && inputRef.value.$el) getInputElement().focus();
            });
            else {
                state.editorErrorMessage = "";
                state.validateError = false;
            }
        });
        const draggable = _vue.computed(()=>props.draggable
        );
        _indexMjs12.useDraggable(rootRef, headerRef, draggable);
        _vue.onMounted(async ()=>{
            await _vue.nextTick();
            if (props.closeOnHashChange) _eventMjs.on(window, "hashchange", doClose);
        });
        _vue.onBeforeUnmount(()=>{
            if (props.closeOnHashChange) _eventMjs.off(window, "hashchange", doClose);
        });
        function doClose() {
            if (!visible.value) return;
            visible.value = false;
            _vue.nextTick(()=>{
                if (state.action) emit("action", state.action);
            });
        }
        const handleWrapperClick = ()=>{
            if (props.closeOnClickModal) handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
        };
        const overlayEvent = _indexMjs13.useSameTarget(handleWrapperClick);
        const handleInputEnter = ()=>{
            if (state.inputType !== "textarea") return handleAction("confirm");
        };
        const handleAction = (action)=>{
            var _a;
            if (props.boxType === "prompt" && action === "confirm" && !validate()) return;
            state.action = action;
            if (state.beforeClose) (_a = state.beforeClose) == null || _a.call(state, action, state, doClose);
            else doClose();
        };
        const validate = ()=>{
            if (props.boxType === "prompt") {
                const inputPattern = state.inputPattern;
                if (inputPattern && !inputPattern.test(state.inputValue || "")) {
                    state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
                    state.validateError = true;
                    return false;
                }
                const inputValidator = state.inputValidator;
                if (typeof inputValidator === "function") {
                    const validateResult = inputValidator(state.inputValue);
                    if (validateResult === false) {
                        state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
                        state.validateError = true;
                        return false;
                    }
                    if (typeof validateResult === "string") {
                        state.editorErrorMessage = validateResult;
                        state.validateError = true;
                        return false;
                    }
                }
            }
            state.editorErrorMessage = "";
            state.validateError = false;
            return true;
        };
        const getInputElement = ()=>{
            const inputRefs = inputRef.value.$refs;
            return inputRefs.input || inputRefs.textarea;
        };
        const handleClose = ()=>{
            handleAction("close");
        };
        if (props.closeOnPressEscape) _indexMjs14.useModal({
            handleClose
        }, visible);
        else _indexMjs15.usePreventGlobal(visible, "keydown", (e)=>e.code === _ariaMjs.EVENT_CODE.esc
        );
        if (props.lockScroll) _indexMjs16.useLockscreen(visible);
        _indexMjs17.useRestoreActive(visible);
        return {
            ..._vue.toRefs(state),
            overlayEvent,
            visible,
            hasMessage,
            typeClass,
            btnSize,
            iconComponent,
            confirmButtonClasses,
            rootRef,
            headerRef,
            inputRef,
            confirmRef,
            doClose,
            handleClose,
            handleWrapperClick,
            handleInputEnter,
            handleAction,
            t
        };
    }
});
const _hoisted_1 = [
    "aria-label"
];
const _hoisted_2 = {
    key: 0,
    ref: "headerRef",
    class: "el-message-box__header"
};
const _hoisted_3 = {
    class: "el-message-box__title"
};
const _hoisted_4 = {
    class: "el-message-box__content"
};
const _hoisted_5 = {
    class: "el-message-box__container"
};
const _hoisted_6 = {
    key: 1,
    class: "el-message-box__message"
};
const _hoisted_7 = {
    key: 0
};
const _hoisted_8 = [
    "innerHTML"
];
const _hoisted_9 = {
    class: "el-message-box__input"
};
const _hoisted_10 = {
    class: "el-message-box__btns"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_close = _vue.resolveComponent("close");
    const _component_el_input = _vue.resolveComponent("el-input");
    const _component_el_button = _vue.resolveComponent("el-button");
    const _component_el_overlay = _vue.resolveComponent("el-overlay");
    const _directive_trap_focus = _vue.resolveDirective("trap-focus");
    return _vue.openBlock(), _vue.createBlock(_vue.Transition, {
        name: "fade-in-linear",
        onAfterLeave: _cache[11] || (_cache[11] = ($event)=>_ctx.$emit("vanish")
        )
    }, {
        default: _vue.withCtx(()=>[
                _vue.withDirectives(_vue.createVNode(_component_el_overlay, {
                    "z-index": _ctx.zIndex,
                    "overlay-class": [
                        "is-message-box",
                        _ctx.modalClass
                    ],
                    mask: _ctx.modal
                }, {
                    default: _vue.withCtx(()=>[
                            _vue.createElementVNode("div", {
                                class: "el-overlay-message-box",
                                onClick: _cache[8] || (_cache[8] = (...args)=>_ctx.overlayEvent.onClick && _ctx.overlayEvent.onClick(...args)
                                ),
                                onMousedown: _cache[9] || (_cache[9] = (...args)=>_ctx.overlayEvent.onMousedown && _ctx.overlayEvent.onMousedown(...args)
                                ),
                                onMouseup: _cache[10] || (_cache[10] = (...args)=>_ctx.overlayEvent.onMouseup && _ctx.overlayEvent.onMouseup(...args)
                                )
                            }, [
                                _vue.withDirectives((_vue.openBlock(), _vue.createElementBlock("div", {
                                    ref: "rootRef",
                                    role: "dialog",
                                    "aria-label": _ctx.title || "dialog",
                                    "aria-modal": "true",
                                    class: _vue.normalizeClass([
                                        "el-message-box",
                                        _ctx.customClass,
                                        {
                                            "el-message-box--center": _ctx.center,
                                            "is-draggable": _ctx.draggable
                                        }
                                    ]),
                                    style: _vue.normalizeStyle(_ctx.customStyle),
                                    onClick: _cache[7] || (_cache[7] = _vue.withModifiers(()=>{
                                    }, [
                                        "stop"
                                    ]))
                                }, [
                                    _ctx.title !== null && _ctx.title !== void 0 ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_2, [
                                        _vue.createElementVNode("div", _hoisted_3, [
                                            _ctx.iconComponent && _ctx.center ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                                key: 0,
                                                class: _vue.normalizeClass([
                                                    "el-message-box__status",
                                                    _ctx.typeClass
                                                ])
                                            }, {
                                                default: _vue.withCtx(()=>[
                                                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.iconComponent)))
                                                    ]
                                                ),
                                                _: 1
                                            }, 8, [
                                                "class"
                                            ])) : _vue.createCommentVNode("v-if", true),
                                            _vue.createElementVNode("span", null, _vue.toDisplayString(_ctx.title), 1)
                                        ]),
                                        _ctx.showClose ? (_vue.openBlock(), _vue.createElementBlock("button", {
                                            key: 0,
                                            type: "button",
                                            class: "el-message-box__headerbtn",
                                            "aria-label": "Close",
                                            onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")
                                            ),
                                            onKeydown: _cache[1] || (_cache[1] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")
                                            , [
                                                "prevent"
                                            ]), [
                                                "enter"
                                            ]))
                                        }, [
                                            _vue.createVNode(_component_el_icon, {
                                                class: "el-message-box__close"
                                            }, {
                                                default: _vue.withCtx(()=>[
                                                        _vue.createVNode(_component_close)
                                                    ]
                                                ),
                                                _: 1
                                            })
                                        ], 32)) : _vue.createCommentVNode("v-if", true)
                                    ], 512)) : _vue.createCommentVNode("v-if", true),
                                    _vue.createElementVNode("div", _hoisted_4, [
                                        _vue.createElementVNode("div", _hoisted_5, [
                                            _ctx.iconComponent && !_ctx.center && _ctx.hasMessage ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                                                key: 0,
                                                class: _vue.normalizeClass([
                                                    "el-message-box__status",
                                                    _ctx.typeClass
                                                ])
                                            }, {
                                                default: _vue.withCtx(()=>[
                                                        (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.iconComponent)))
                                                    ]
                                                ),
                                                _: 1
                                            }, 8, [
                                                "class"
                                            ])) : _vue.createCommentVNode("v-if", true),
                                            _ctx.hasMessage ? (_vue.openBlock(), _vue.createElementBlock("div", _hoisted_6, [
                                                _vue.renderSlot(_ctx.$slots, "default", {
                                                }, ()=>[
                                                        !_ctx.dangerouslyUseHTMLString ? (_vue.openBlock(), _vue.createElementBlock("p", _hoisted_7, _vue.toDisplayString(_ctx.message), 1)) : (_vue.openBlock(), _vue.createElementBlock("p", {
                                                            key: 1,
                                                            innerHTML: _ctx.message
                                                        }, null, 8, _hoisted_8))
                                                    ]
                                                )
                                            ])) : _vue.createCommentVNode("v-if", true)
                                        ]),
                                        _vue.withDirectives(_vue.createElementVNode("div", _hoisted_9, [
                                            _vue.createVNode(_component_el_input, {
                                                ref: "inputRef",
                                                modelValue: _ctx.inputValue,
                                                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event)=>_ctx.inputValue = $event
                                                ),
                                                type: _ctx.inputType,
                                                placeholder: _ctx.inputPlaceholder,
                                                class: _vue.normalizeClass({
                                                    invalid: _ctx.validateError
                                                }),
                                                onKeydown: _vue.withKeys(_vue.withModifiers(_ctx.handleInputEnter, [
                                                    "prevent"
                                                ]), [
                                                    "enter"
                                                ])
                                            }, null, 8, [
                                                "modelValue",
                                                "type",
                                                "placeholder",
                                                "class",
                                                "onKeydown"
                                            ]),
                                            _vue.createElementVNode("div", {
                                                class: "el-message-box__errormsg",
                                                style: _vue.normalizeStyle({
                                                    visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                                                })
                                            }, _vue.toDisplayString(_ctx.editorErrorMessage), 5)
                                        ], 512), [
                                            [
                                                _vue.vShow,
                                                _ctx.showInput
                                            ]
                                        ])
                                    ]),
                                    _vue.createElementVNode("div", _hoisted_10, [
                                        _ctx.showCancelButton ? (_vue.openBlock(), _vue.createBlock(_component_el_button, {
                                            key: 0,
                                            loading: _ctx.cancelButtonLoading,
                                            class: _vue.normalizeClass([
                                                _ctx.cancelButtonClass
                                            ]),
                                            round: _ctx.roundButton,
                                            size: _ctx.btnSize,
                                            onClick: _cache[3] || (_cache[3] = ($event)=>_ctx.handleAction("cancel")
                                            ),
                                            onKeydown: _cache[4] || (_cache[4] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.handleAction("cancel")
                                            , [
                                                "prevent"
                                            ]), [
                                                "enter"
                                            ]))
                                        }, {
                                            default: _vue.withCtx(()=>[
                                                    _vue.createTextVNode(_vue.toDisplayString(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                                                ]
                                            ),
                                            _: 1
                                        }, 8, [
                                            "loading",
                                            "class",
                                            "round",
                                            "size"
                                        ])) : _vue.createCommentVNode("v-if", true),
                                        _vue.withDirectives(_vue.createVNode(_component_el_button, {
                                            ref: "confirmRef",
                                            type: "primary",
                                            loading: _ctx.confirmButtonLoading,
                                            class: _vue.normalizeClass([
                                                _ctx.confirmButtonClasses
                                            ]),
                                            round: _ctx.roundButton,
                                            disabled: _ctx.confirmButtonDisabled,
                                            size: _ctx.btnSize,
                                            onClick: _cache[5] || (_cache[5] = ($event)=>_ctx.handleAction("confirm")
                                            ),
                                            onKeydown: _cache[6] || (_cache[6] = _vue.withKeys(_vue.withModifiers(($event)=>_ctx.handleAction("confirm")
                                            , [
                                                "prevent"
                                            ]), [
                                                "enter"
                                            ]))
                                        }, {
                                            default: _vue.withCtx(()=>[
                                                    _vue.createTextVNode(_vue.toDisplayString(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                                                ]
                                            ),
                                            _: 1
                                        }, 8, [
                                            "loading",
                                            "class",
                                            "round",
                                            "disabled",
                                            "size"
                                        ]), [
                                            [
                                                _vue.vShow,
                                                _ctx.showConfirmButton
                                            ]
                                        ])
                                    ])
                                ], 14, _hoisted_1)), [
                                    [
                                        _directive_trap_focus
                                    ]
                                ])
                            ], 32)
                        ]
                    ),
                    _: 3
                }, 8, [
                    "z-index",
                    "overlay-class",
                    "mask"
                ]), [
                    [
                        _vue.vShow,
                        _ctx.visible
                    ]
                ])
            ]
        ),
        _: 3
    });
}
var MessageBoxConstructor = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../button/index.mjs":"64Ym1","../../../directives/index.mjs":"aRbJ2","../../../hooks/index.mjs":"1Ansp","../../input/index.mjs":"18eQI","../../overlay/index.mjs":"2HJvE","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../icon/index.mjs":"hnNTG","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../directives/trap-focus/index.mjs":"lw3sX","../../../utils/vue/icon.mjs":"3YbE5","../../../utils/vue/validator.mjs":"4UnBa","../../../hooks/use-locale/index.mjs":"c1HoA","../../../hooks/use-z-index/index.mjs":"7aKZA","../../../hooks/use-common-props/index.mjs":"05czU","../../../hooks/use-draggable/index.mjs":"3SWUw","../../../utils/dom/event.mjs":"fnXSh","../../../hooks/use-same-target/index.mjs":"duu8u","../../../hooks/use-modal/index.mjs":"klFTZ","../../../hooks/use-prevent-global/index.mjs":"3Sy0W","../../../constants/aria.mjs":"jS6iK","../../../hooks/use-lockscreen/index.mjs":"f9Ur8","../../../hooks/use-restore-active/index.mjs":"9OlL1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"qGcgU":[function(require,module,exports) {

},{}],"a0vte":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "notificationEmits", ()=>_notificationMjs.notificationEmits
);
parcelHelpers.export(exports, "notificationProps", ()=>_notificationMjs.notificationProps
);
parcelHelpers.export(exports, "notificationTypes", ()=>_notificationMjs.notificationTypes
);
parcelHelpers.export(exports, "ElNotification", ()=>ElNotification
);
parcelHelpers.export(exports, "default", ()=>ElNotification
);
var _indexMjs = require("../../utils/index.mjs");
var _notifyMjs = require("./src/notify.mjs");
var _notifyMjsDefault = parcelHelpers.interopDefault(_notifyMjs);
var _installMjs = require("../../utils/vue/install.mjs");
var _notificationMjs = require("./src/notification.mjs");
const ElNotification = _installMjs.withInstallFunction(_notifyMjsDefault.default, "$notify");

},{"../../utils/index.mjs":"dsdeP","./src/notify.mjs":"6X0Fg","../../utils/vue/install.mjs":"4TMmv","./src/notification.mjs":"9l71J","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6X0Fg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "close", ()=>close
);
parcelHelpers.export(exports, "closeAll", ()=>closeAll
);
parcelHelpers.export(exports, "default", ()=>notify
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../hooks/index.mjs");
var _indexMjs1 = require("../../../utils/index.mjs");
var _notification2Mjs = require("./notification2.mjs");
var _notification2MjsDefault = parcelHelpers.interopDefault(_notification2Mjs);
var _notificationMjs = require("./notification.mjs");
var _indexMjs2 = require("../../../hooks/use-z-index/index.mjs");
var _errorMjs = require("../../../utils/error.mjs");
const notifications = {
    "top-left": [],
    "top-right": [],
    "bottom-left": [],
    "bottom-right": []
};
const GAP_SIZE = 16;
let seed = 1;
const notify = function(options = {
}) {
    if (!_core.isClient) return {
        close: ()=>void 0
    };
    if (typeof options === "string" || _vue.isVNode(options)) options = {
        message: options
    };
    const position = options.position || "top-right";
    let verticalOffset = options.offset || 0;
    notifications[position].forEach(({ vm: vm2  })=>{
        var _a;
        verticalOffset += (((_a = vm2.el) == null ? void 0 : _a.offsetHeight) || 0) + GAP_SIZE;
    });
    verticalOffset += GAP_SIZE;
    const { nextZIndex  } = _indexMjs2.useZIndex();
    const id = `notification_${seed++}`;
    const userOnClose = options.onClose;
    const props = {
        zIndex: nextZIndex(),
        offset: verticalOffset,
        ...options,
        id,
        onClose: ()=>{
            close(id, position, userOnClose);
        }
    };
    let appendTo = document.body;
    if (options.appendTo instanceof HTMLElement) appendTo = options.appendTo;
    else if (typeof options.appendTo === "string") appendTo = document.querySelector(options.appendTo);
    if (!(appendTo instanceof HTMLElement)) {
        _errorMjs.debugWarn("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body.");
        appendTo = document.body;
    }
    const container = document.createElement("div");
    const vm = _vue.createVNode(_notification2MjsDefault.default, props, _vue.isVNode(props.message) ? {
        default: ()=>props.message
    } : null);
    vm.props.onDestroy = ()=>{
        _vue.render(null, container);
    };
    _vue.render(vm, container);
    notifications[position].push({
        vm
    });
    appendTo.appendChild(container.firstElementChild);
    return {
        close: ()=>{
            vm.component.proxy.visible = false;
        }
    };
};
_notificationMjs.notificationTypes.forEach((type)=>{
    notify[type] = (options = {
    })=>{
        if (typeof options === "string" || _vue.isVNode(options)) options = {
            message: options
        };
        return notify({
            ...options,
            type
        });
    };
});
function close(id, position, userOnClose) {
    const orientedNotifications = notifications[position];
    const idx = orientedNotifications.findIndex(({ vm: vm2  })=>{
        var _a;
        return ((_a = vm2.component) == null ? void 0 : _a.props.id) === id;
    });
    if (idx === -1) return;
    const { vm  } = orientedNotifications[idx];
    if (!vm) return;
    userOnClose == null || userOnClose(vm);
    const removedHeight = vm.el.offsetHeight;
    const verticalPos = position.split("-")[0];
    orientedNotifications.splice(idx, 1);
    const len = orientedNotifications.length;
    if (len < 1) return;
    for(let i = idx; i < len; i++){
        const { el , component  } = orientedNotifications[i].vm;
        const pos = parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;
        component.props.offset = pos;
    }
}
function closeAll() {
    for (const orientedNotifications of Object.values(notifications))orientedNotifications.forEach(({ vm  })=>{
        vm.component.proxy.visible = false;
    });
}
notify.closeAll = closeAll;

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../hooks/index.mjs":"1Ansp","../../../utils/index.mjs":"dsdeP","./notification2.mjs":"7GoDv","./notification.mjs":"9l71J","../../../hooks/use-z-index/index.mjs":"7aKZA","../../../utils/error.mjs":"2zPBN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7GoDv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>NotificationConstructor
);
var _vue = require("vue");
var _core = require("@vueuse/core");
var _indexMjs = require("../../../utils/index.mjs");
var _indexMjs1 = require("../../../constants/index.mjs");
var _indexMjs2 = require("../../icon/index.mjs");
var _indexMjs3 = require("../../../hooks/index.mjs");
var _notificationMjs = require("./notification.mjs");
var _pluginVueExportHelperMjs = require("../../../_virtual/plugin-vue_export-helper.mjs");
var _pluginVueExportHelperMjsDefault = parcelHelpers.interopDefault(_pluginVueExportHelperMjs);
var _iconMjs = require("../../../utils/vue/icon.mjs");
var _indexMjs4 = require("../../../hooks/use-namespace/index.mjs");
var _ariaMjs = require("../../../constants/aria.mjs");
const _sfc_main = _vue.defineComponent({
    name: "ElNotification",
    components: {
        ElIcon: _indexMjs2.ElIcon,
        ..._iconMjs.TypeComponents
    },
    props: _notificationMjs.notificationProps,
    emits: _notificationMjs.notificationEmits,
    setup (props) {
        const ns = _indexMjs4.useNamespace("notification");
        const visible = _vue.ref(false);
        let timer = void 0;
        const typeClass = _vue.computed(()=>{
            const type = props.type;
            return type && _iconMjs.TypeComponentsMap[props.type] ? ns.m(type) : "";
        });
        const iconComponent = _vue.computed(()=>{
            return _iconMjs.TypeComponentsMap[props.type] || props.icon || "";
        });
        const horizontalClass = _vue.computed(()=>props.position.endsWith("right") ? "right" : "left"
        );
        const verticalProperty = _vue.computed(()=>props.position.startsWith("top") ? "top" : "bottom"
        );
        const positionStyle = _vue.computed(()=>{
            return {
                [verticalProperty.value]: `${props.offset}px`,
                zIndex: props.zIndex
            };
        });
        function startTimer() {
            if (props.duration > 0) ({ stop: timer  } = _core.useTimeoutFn(()=>{
                if (visible.value) close();
            }, props.duration));
        }
        function clearTimer() {
            timer == null || timer();
        }
        function close() {
            visible.value = false;
        }
        function onKeydown({ code  }) {
            if (code === _ariaMjs.EVENT_CODE.delete || code === _ariaMjs.EVENT_CODE.backspace) clearTimer();
            else if (code === _ariaMjs.EVENT_CODE.esc) {
                if (visible.value) close();
            } else startTimer();
        }
        _vue.onMounted(()=>{
            startTimer();
            visible.value = true;
        });
        _core.useEventListener(document, "keydown", onKeydown);
        return {
            ns,
            horizontalClass,
            typeClass,
            iconComponent,
            positionStyle,
            visible,
            close,
            clearTimer,
            startTimer
        };
    }
});
const _hoisted_1 = [
    "id"
];
const _hoisted_2 = [
    "textContent"
];
const _hoisted_3 = {
    key: 0
};
const _hoisted_4 = [
    "innerHTML"
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_el_icon = _vue.resolveComponent("el-icon");
    const _component_close = _vue.resolveComponent("close");
    return _vue.openBlock(), _vue.createBlock(_vue.Transition, {
        name: _ctx.ns.b("fade"),
        onBeforeLeave: _ctx.onClose,
        onAfterLeave: _cache[3] || (_cache[3] = ($event)=>_ctx.$emit("destroy")
        )
    }, {
        default: _vue.withCtx(()=>[
                _vue.withDirectives(_vue.createElementVNode("div", {
                    id: _ctx.id,
                    class: _vue.normalizeClass([
                        _ctx.ns.b(),
                        _ctx.customClass,
                        _ctx.horizontalClass
                    ]),
                    style: _vue.normalizeStyle(_ctx.positionStyle),
                    role: "alert",
                    onMouseenter: _cache[0] || (_cache[0] = (...args)=>_ctx.clearTimer && _ctx.clearTimer(...args)
                    ),
                    onMouseleave: _cache[1] || (_cache[1] = (...args)=>_ctx.startTimer && _ctx.startTimer(...args)
                    ),
                    onClick: _cache[2] || (_cache[2] = (...args)=>_ctx.onClick && _ctx.onClick(...args)
                    )
                }, [
                    _ctx.iconComponent ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                        key: 0,
                        class: _vue.normalizeClass([
                            _ctx.ns.e("icon"),
                            _ctx.typeClass
                        ])
                    }, {
                        default: _vue.withCtx(()=>[
                                (_vue.openBlock(), _vue.createBlock(_vue.resolveDynamicComponent(_ctx.iconComponent)))
                            ]
                        ),
                        _: 1
                    }, 8, [
                        "class"
                    ])) : _vue.createCommentVNode("v-if", true),
                    _vue.createElementVNode("div", {
                        class: _vue.normalizeClass(_ctx.ns.e("group"))
                    }, [
                        _vue.createElementVNode("h2", {
                            class: _vue.normalizeClass(_ctx.ns.e("title")),
                            textContent: _vue.toDisplayString(_ctx.title)
                        }, null, 10, _hoisted_2),
                        _vue.withDirectives(_vue.createElementVNode("div", {
                            class: _vue.normalizeClass(_ctx.ns.e("content")),
                            style: _vue.normalizeStyle(!!_ctx.title ? void 0 : {
                                margin: 0
                            })
                        }, [
                            _vue.renderSlot(_ctx.$slots, "default", {
                            }, ()=>[
                                    !_ctx.dangerouslyUseHTMLString ? (_vue.openBlock(), _vue.createElementBlock("p", _hoisted_3, _vue.toDisplayString(_ctx.message), 1)) : (_vue.openBlock(), _vue.createElementBlock(_vue.Fragment, {
                                        key: 1
                                    }, [
                                        _vue.createCommentVNode(" Caution here, message could've been compromized, nerver use user's input as message "),
                                        _vue.createCommentVNode(" eslint-disable-next-line "),
                                        _vue.createElementVNode("p", {
                                            innerHTML: _ctx.message
                                        }, null, 8, _hoisted_4)
                                    ], 2112))
                                ]
                            )
                        ], 6), [
                            [
                                _vue.vShow,
                                _ctx.message
                            ]
                        ]),
                        _ctx.showClose ? (_vue.openBlock(), _vue.createBlock(_component_el_icon, {
                            key: 0,
                            class: _vue.normalizeClass(_ctx.ns.e("closeBtn")),
                            onClick: _vue.withModifiers(_ctx.close, [
                                "stop"
                            ])
                        }, {
                            default: _vue.withCtx(()=>[
                                    _vue.createVNode(_component_close)
                                ]
                            ),
                            _: 1
                        }, 8, [
                            "class",
                            "onClick"
                        ])) : _vue.createCommentVNode("v-if", true)
                    ], 2)
                ], 46, _hoisted_1), [
                    [
                        _vue.vShow,
                        _ctx.visible
                    ]
                ])
            ]
        ),
        _: 3
    }, 8, [
        "name",
        "onBeforeLeave"
    ]);
}
var NotificationConstructor = /* @__PURE__ */ _pluginVueExportHelperMjsDefault.default(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","@vueuse/core":"eEHP9","../../../utils/index.mjs":"dsdeP","../../../constants/index.mjs":"74Fbn","../../icon/index.mjs":"hnNTG","../../../hooks/index.mjs":"1Ansp","./notification.mjs":"9l71J","../../../_virtual/plugin-vue_export-helper.mjs":"acxEY","../../../utils/vue/icon.mjs":"3YbE5","../../../hooks/use-namespace/index.mjs":"a1pcf","../../../constants/aria.mjs":"jS6iK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9l71J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "notificationEmits", ()=>notificationEmits
);
parcelHelpers.export(exports, "notificationProps", ()=>notificationProps
);
parcelHelpers.export(exports, "notificationTypes", ()=>notificationTypes
);
var _indexMjs = require("../../../utils/index.mjs");
var _propsMjs = require("../../../utils/vue/props.mjs");
const notificationTypes = [
    "success",
    "info",
    "warning",
    "error"
];
const notificationProps = _propsMjs.buildProps({
    customClass: {
        type: String,
        default: ""
    },
    dangerouslyUseHTMLString: {
        type: Boolean,
        default: false
    },
    duration: {
        type: Number,
        default: 4500
    },
    icon: {
        type: _propsMjs.definePropType([
            String,
            Object
        ]),
        default: ""
    },
    id: {
        type: String,
        default: ""
    },
    message: {
        type: _propsMjs.definePropType([
            String,
            Object
        ]),
        default: ""
    },
    offset: {
        type: Number,
        default: 0
    },
    onClick: {
        type: _propsMjs.definePropType(Function),
        default: ()=>void 0
    },
    onClose: {
        type: _propsMjs.definePropType(Function),
        required: true
    },
    position: {
        type: String,
        values: [
            "top-right",
            "top-left",
            "bottom-right",
            "bottom-left"
        ],
        default: "top-right"
    },
    showClose: {
        type: Boolean,
        default: true
    },
    title: {
        type: String,
        default: ""
    },
    type: {
        type: String,
        values: [
            ...notificationTypes,
            ""
        ],
        default: ""
    },
    zIndex: {
        type: Number,
        default: 0
    }
});
const notificationEmits = {
    destroy: ()=>true
};

},{"../../../utils/index.mjs":"dsdeP","../../../utils/vue/props.mjs":"cpwWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d9xVn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElAffix", ()=>_indexMjs1.ElAffix
);
parcelHelpers.export(exports, "ElAlert", ()=>_indexMjs2.ElAlert
);
parcelHelpers.export(exports, "ElAutocomplete", ()=>_indexMjs3.ElAutocomplete
);
parcelHelpers.export(exports, "ElAvatar", ()=>_indexMjs4.ElAvatar
);
parcelHelpers.export(exports, "ElBacktop", ()=>_indexMjs5.ElBacktop
);
parcelHelpers.export(exports, "ElBadge", ()=>_indexMjs6.ElBadge
);
parcelHelpers.export(exports, "ElBreadcrumb", ()=>_indexMjs7.ElBreadcrumb
);
parcelHelpers.export(exports, "ElBreadcrumbItem", ()=>_indexMjs7.ElBreadcrumbItem
);
parcelHelpers.export(exports, "ElButton", ()=>_indexMjs8.ElButton
);
parcelHelpers.export(exports, "ElButtonGroup", ()=>_indexMjs8.ElButtonGroup
);
parcelHelpers.export(exports, "ElCalendar", ()=>_indexMjs9.ElCalendar
);
parcelHelpers.export(exports, "ElCard", ()=>_indexMjs10.ElCard
);
parcelHelpers.export(exports, "ElCarousel", ()=>_indexMjs11.ElCarousel
);
parcelHelpers.export(exports, "ElCarouselItem", ()=>_indexMjs11.ElCarouselItem
);
parcelHelpers.export(exports, "ElCascader", ()=>_indexMjs12.ElCascader
);
parcelHelpers.export(exports, "ElCascaderPanel", ()=>_indexMjs13.ElCascaderPanel
);
parcelHelpers.export(exports, "ElCheckTag", ()=>_indexMjs14.ElCheckTag
);
parcelHelpers.export(exports, "ElCheckbox", ()=>_indexMjs15.ElCheckbox
);
parcelHelpers.export(exports, "ElCheckboxButton", ()=>_indexMjs15.ElCheckboxButton
);
parcelHelpers.export(exports, "ElCheckboxGroup", ()=>_indexMjs15.ElCheckboxGroup
);
parcelHelpers.export(exports, "ElCol", ()=>_indexMjs16.ElCol
);
parcelHelpers.export(exports, "ElCollapse", ()=>_indexMjs17.ElCollapse
);
parcelHelpers.export(exports, "ElCollapseItem", ()=>_indexMjs17.ElCollapseItem
);
parcelHelpers.export(exports, "ElCollapseTransition", ()=>_indexMjs18.ElCollapseTransition
);
parcelHelpers.export(exports, "ElColorPicker", ()=>_indexMjs19.ElColorPicker
);
parcelHelpers.export(exports, "ElConfigProvider", ()=>_indexMjs20.ElConfigProvider
);
parcelHelpers.export(exports, "ElAside", ()=>_indexMjs21.ElAside
);
parcelHelpers.export(exports, "ElContainer", ()=>_indexMjs21.ElContainer
);
parcelHelpers.export(exports, "ElFooter", ()=>_indexMjs21.ElFooter
);
parcelHelpers.export(exports, "ElHeader", ()=>_indexMjs21.ElHeader
);
parcelHelpers.export(exports, "ElMain", ()=>_indexMjs21.ElMain
);
parcelHelpers.export(exports, "ElDatePicker", ()=>_indexMjs22.ElDatePicker
);
parcelHelpers.export(exports, "ElDescriptions", ()=>_indexMjs23.ElDescriptions
);
parcelHelpers.export(exports, "ElDescriptionsItem", ()=>_indexMjs23.ElDescriptionsItem
);
parcelHelpers.export(exports, "ElDialog", ()=>_indexMjs24.ElDialog
);
parcelHelpers.export(exports, "ElDivider", ()=>_indexMjs25.ElDivider
);
parcelHelpers.export(exports, "ElDrawer", ()=>_indexMjs26.ElDrawer
);
parcelHelpers.export(exports, "ElDropdown", ()=>_indexMjs27.ElDropdown
);
parcelHelpers.export(exports, "ElDropdownItem", ()=>_indexMjs27.ElDropdownItem
);
parcelHelpers.export(exports, "ElDropdownMenu", ()=>_indexMjs27.ElDropdownMenu
);
parcelHelpers.export(exports, "ElEmpty", ()=>_indexMjs28.ElEmpty
);
parcelHelpers.export(exports, "ElForm", ()=>_indexMjs29.ElForm
);
parcelHelpers.export(exports, "ElFormItem", ()=>_indexMjs29.ElFormItem
);
parcelHelpers.export(exports, "ElIcon", ()=>_indexMjs30.ElIcon
);
parcelHelpers.export(exports, "ElImage", ()=>_indexMjs31.ElImage
);
parcelHelpers.export(exports, "ElImageViewer", ()=>_indexMjs32.ElImageViewer
);
parcelHelpers.export(exports, "ElInput", ()=>_indexMjs33.ElInput
);
parcelHelpers.export(exports, "ElInputNumber", ()=>_indexMjs34.ElInputNumber
);
parcelHelpers.export(exports, "ElLink", ()=>_indexMjs35.ElLink
);
parcelHelpers.export(exports, "ElMenu", ()=>_indexMjs36.ElMenu
);
parcelHelpers.export(exports, "ElMenuItem", ()=>_indexMjs36.ElMenuItem
);
parcelHelpers.export(exports, "ElMenuItemGroup", ()=>_indexMjs36.ElMenuItemGroup
);
parcelHelpers.export(exports, "ElSubMenu", ()=>_indexMjs36.ElSubMenu
);
parcelHelpers.export(exports, "ElOverlay", ()=>_indexMjs37.ElOverlay
);
parcelHelpers.export(exports, "ElPageHeader", ()=>_indexMjs38.ElPageHeader
);
parcelHelpers.export(exports, "ElPagination", ()=>_indexMjs39.ElPagination
);
parcelHelpers.export(exports, "ElPopconfirm", ()=>_indexMjs40.ElPopconfirm
);
parcelHelpers.export(exports, "ElPopper", ()=>_indexMjs41.ElPopper
);
parcelHelpers.export(exports, "ElProgress", ()=>_indexMjs42.ElProgress
);
parcelHelpers.export(exports, "ElRadio", ()=>_indexMjs43.ElRadio
);
parcelHelpers.export(exports, "ElRadioButton", ()=>_indexMjs43.ElRadioButton
);
parcelHelpers.export(exports, "ElRadioGroup", ()=>_indexMjs43.ElRadioGroup
);
parcelHelpers.export(exports, "ElRate", ()=>_indexMjs44.ElRate
);
parcelHelpers.export(exports, "ElResult", ()=>_indexMjs45.ElResult
);
parcelHelpers.export(exports, "ElRow", ()=>_indexMjs46.ElRow
);
parcelHelpers.export(exports, "ElScrollbar", ()=>_indexMjs47.ElScrollbar
);
parcelHelpers.export(exports, "ElOption", ()=>_indexMjs48.ElOption
);
parcelHelpers.export(exports, "ElOptionGroup", ()=>_indexMjs48.ElOptionGroup
);
parcelHelpers.export(exports, "ElSelect", ()=>_indexMjs48.ElSelect
);
parcelHelpers.export(exports, "ElSelectV2", ()=>_indexMjs49.ElSelectV2
);
parcelHelpers.export(exports, "ElSkeleton", ()=>_indexMjs50.ElSkeleton
);
parcelHelpers.export(exports, "ElSkeletonItem", ()=>_indexMjs50.ElSkeletonItem
);
parcelHelpers.export(exports, "ElSlider", ()=>_indexMjs51.ElSlider
);
parcelHelpers.export(exports, "ElSpace", ()=>_indexMjs52.ElSpace
);
parcelHelpers.export(exports, "ElStep", ()=>_indexMjs53.ElStep
);
parcelHelpers.export(exports, "ElSteps", ()=>_indexMjs53.ElSteps
);
parcelHelpers.export(exports, "ElSwitch", ()=>_indexMjs54.ElSwitch
);
parcelHelpers.export(exports, "ElTable", ()=>_indexMjs55.ElTable
);
parcelHelpers.export(exports, "ElTableColumn", ()=>_indexMjs55.ElTableColumn
);
parcelHelpers.export(exports, "ElTabPane", ()=>_indexMjs56.ElTabPane
);
parcelHelpers.export(exports, "ElTabs", ()=>_indexMjs56.ElTabs
);
parcelHelpers.export(exports, "ElTag", ()=>_indexMjs57.ElTag
);
parcelHelpers.export(exports, "ElTimePicker", ()=>_indexMjs58.ElTimePicker
);
parcelHelpers.export(exports, "ElTimeSelect", ()=>_indexMjs59.ElTimeSelect
);
parcelHelpers.export(exports, "ElTimeline", ()=>_indexMjs60.ElTimeline
);
parcelHelpers.export(exports, "ElTimelineItem", ()=>_indexMjs60.ElTimelineItem
);
parcelHelpers.export(exports, "ElTooltip", ()=>_indexMjs61.ElTooltip
);
parcelHelpers.export(exports, "ElTransfer", ()=>_indexMjs62.ElTransfer
);
parcelHelpers.export(exports, "ElTree", ()=>_indexMjs63.ElTree
);
parcelHelpers.export(exports, "ElTreeV2", ()=>_indexMjs64.ElTreeV2
);
parcelHelpers.export(exports, "ElUpload", ()=>_indexMjs65.ElUpload
);
parcelHelpers.export(exports, "ElInfiniteScroll", ()=>_indexMjs66.ElInfiniteScroll
);
parcelHelpers.export(exports, "ElLoading", ()=>_indexMjs67.ElLoading
);
parcelHelpers.export(exports, "ElLoadingDirective", ()=>_indexMjs67.ElLoadingDirective
);
parcelHelpers.export(exports, "ElLoadingService", ()=>_indexMjs67.ElLoadingService
);
parcelHelpers.export(exports, "ElMessage", ()=>_indexMjs68.ElMessage
);
parcelHelpers.export(exports, "ElMessageBox", ()=>_indexMjs69.ElMessageBox
);
parcelHelpers.export(exports, "ElNotification", ()=>_indexMjs70.ElNotification
);
parcelHelpers.export(exports, "ElPopover", ()=>_indexMjs71.ElPopover
);
parcelHelpers.export(exports, "ElPopoverDirective", ()=>_indexMjs71.ElPopoverDirective
);
parcelHelpers.export(exports, "affixEmits", ()=>_affixMjs.affixEmits
);
parcelHelpers.export(exports, "affixProps", ()=>_affixMjs.affixProps
);
parcelHelpers.export(exports, "alertEffects", ()=>_alertMjs.alertEffects
);
parcelHelpers.export(exports, "alertEmits", ()=>_alertMjs.alertEmits
);
parcelHelpers.export(exports, "alertProps", ()=>_alertMjs.alertProps
);
parcelHelpers.export(exports, "avatarEmits", ()=>_avatarMjs.avatarEmits
);
parcelHelpers.export(exports, "avatarProps", ()=>_avatarMjs.avatarProps
);
parcelHelpers.export(exports, "backtopEmits", ()=>_backtopMjs.backtopEmits
);
parcelHelpers.export(exports, "backtopProps", ()=>_backtopMjs.backtopProps
);
parcelHelpers.export(exports, "badgeProps", ()=>_badgeMjs.badgeProps
);
parcelHelpers.export(exports, "breadcrumbProps", ()=>_breadcrumbMjs.breadcrumbProps
);
parcelHelpers.export(exports, "breadcrumbItemProps", ()=>_breadcrumbItemMjs.breadcrumbItemProps
);
parcelHelpers.export(exports, "buttonEmits", ()=>_buttonMjs.buttonEmits
);
parcelHelpers.export(exports, "buttonNativeTypes", ()=>_buttonMjs.buttonNativeTypes
);
parcelHelpers.export(exports, "buttonProps", ()=>_buttonMjs.buttonProps
);
parcelHelpers.export(exports, "buttonTypes", ()=>_buttonMjs.buttonTypes
);
parcelHelpers.export(exports, "calendarEmits", ()=>_calendarMjs.calendarEmits
);
parcelHelpers.export(exports, "calendarProps", ()=>_calendarMjs.calendarProps
);
parcelHelpers.export(exports, "cardProps", ()=>_cardMjs.cardProps
);
parcelHelpers.export(exports, "CASCADER_PANEL_INJECTION_KEY", ()=>_typesMjs.CASCADER_PANEL_INJECTION_KEY
);
parcelHelpers.export(exports, "ExpandTrigger", ()=>_typesMjs.ExpandTrigger
);
parcelHelpers.export(exports, "CommonProps", ()=>_configMjs.CommonProps
);
parcelHelpers.export(exports, "DefaultProps", ()=>_configMjs.DefaultProps
);
parcelHelpers.export(exports, "useCascaderConfig", ()=>_configMjs.useCascaderConfig
);
parcelHelpers.export(exports, "checkTagEmits", ()=>_checkTagMjs.checkTagEmits
);
parcelHelpers.export(exports, "checkTagProps", ()=>_checkTagMjs.checkTagProps
);
parcelHelpers.export(exports, "colProps", ()=>_colMjs.colProps
);
parcelHelpers.export(exports, "configProviderProps", ()=>_configProviderMjs.configProviderProps
);
parcelHelpers.export(exports, "messageConfig", ()=>_configProviderMjs.messageConfig
);
parcelHelpers.export(exports, "useDialog", ()=>_useDialogMjs.useDialog
);
parcelHelpers.export(exports, "dialogEmits", ()=>_dialogMjs.dialogEmits
);
parcelHelpers.export(exports, "dialogProps", ()=>_dialogMjs.dialogProps
);
parcelHelpers.export(exports, "dividerProps", ()=>_dividerMjs.dividerProps
);
parcelHelpers.export(exports, "drawerEmits", ()=>_drawerMjs.drawerEmits
);
parcelHelpers.export(exports, "drawerProps", ()=>_drawerMjs.drawerProps
);
parcelHelpers.export(exports, "DROPDOWN_COLLECTION_INJECTION_KEY", ()=>_dropdownMjs.DROPDOWN_COLLECTION_INJECTION_KEY
);
parcelHelpers.export(exports, "DROPDOWN_COLLECTION_ITEM_INJECTION_KEY", ()=>_dropdownMjs.DROPDOWN_COLLECTION_ITEM_INJECTION_KEY
);
parcelHelpers.export(exports, "ElCollection", ()=>_dropdownMjs.ElCollection
);
parcelHelpers.export(exports, "ElCollectionItem", ()=>_dropdownMjs.ElCollectionItem
);
parcelHelpers.export(exports, "FIRST_KEYS", ()=>_dropdownMjs.FIRST_KEYS
);
parcelHelpers.export(exports, "FIRST_LAST_KEYS", ()=>_dropdownMjs.FIRST_LAST_KEYS
);
parcelHelpers.export(exports, "LAST_KEYS", ()=>_dropdownMjs.LAST_KEYS
);
parcelHelpers.export(exports, "dropdownItemProps", ()=>_dropdownMjs.dropdownItemProps
);
parcelHelpers.export(exports, "dropdownMenuProps", ()=>_dropdownMjs.dropdownMenuProps
);
parcelHelpers.export(exports, "dropdownProps", ()=>_dropdownMjs.dropdownProps
);
parcelHelpers.export(exports, "DROPDOWN_INJECTION_KEY", ()=>_tokensMjs.DROPDOWN_INJECTION_KEY
);
parcelHelpers.export(exports, "emptyProps", ()=>_emptyMjs.emptyProps
);
parcelHelpers.export(exports, "iconProps", ()=>_iconMjs.iconProps
);
parcelHelpers.export(exports, "imageEmits", ()=>_imageMjs.imageEmits
);
parcelHelpers.export(exports, "imageProps", ()=>_imageMjs.imageProps
);
parcelHelpers.export(exports, "imageViewerEmits", ()=>_imageViewerMjs.imageViewerEmits
);
parcelHelpers.export(exports, "imageViewerProps", ()=>_imageViewerMjs.imageViewerProps
);
parcelHelpers.export(exports, "inputEmits", ()=>_inputMjs.inputEmits
);
parcelHelpers.export(exports, "inputProps", ()=>_inputMjs.inputProps
);
parcelHelpers.export(exports, "inputNumberEmits", ()=>_inputNumberMjs.inputNumberEmits
);
parcelHelpers.export(exports, "inputNumberProps", ()=>_inputNumberMjs.inputNumberProps
);
parcelHelpers.export(exports, "linkEmits", ()=>_linkMjs.linkEmits
);
parcelHelpers.export(exports, "linkProps", ()=>_linkMjs.linkProps
);
parcelHelpers.export(exports, "menuEmits", ()=>_menuMjs.menuEmits
);
parcelHelpers.export(exports, "menuProps", ()=>_menuMjs.menuProps
);
parcelHelpers.export(exports, "menuItemEmits", ()=>_menuItemMjs.menuItemEmits
);
parcelHelpers.export(exports, "menuItemProps", ()=>_menuItemMjs.menuItemProps
);
parcelHelpers.export(exports, "menuItemGroupProps", ()=>_menuItemGroupMjs.menuItemGroupProps
);
parcelHelpers.export(exports, "subMenuProps", ()=>_subMenuMjs.subMenuProps
);
parcelHelpers.export(exports, "overlayEmits", ()=>_overlayMjs.overlayEmits
);
parcelHelpers.export(exports, "overlayProps", ()=>_overlayMjs.overlayProps
);
parcelHelpers.export(exports, "pageHeaderEmits", ()=>_pageHeaderMjs.pageHeaderEmits
);
parcelHelpers.export(exports, "pageHeaderProps", ()=>_pageHeaderMjs.pageHeaderProps
);
parcelHelpers.export(exports, "paginationEmits", ()=>_paginationMjs.paginationEmits
);
parcelHelpers.export(exports, "paginationProps", ()=>_paginationMjs.paginationProps
);
parcelHelpers.export(exports, "popconfirmProps", ()=>_popconfirmMjs.popconfirmProps
);
parcelHelpers.export(exports, "ElPopperArrow", ()=>_arrowMjsDefault.default
);
parcelHelpers.export(exports, "ElPopperTrigger", ()=>_triggerMjsDefault.default
);
parcelHelpers.export(exports, "ElPopperContent", ()=>_contentMjsDefault.default
);
parcelHelpers.export(exports, "useDeprecateAppendToBody", ()=>_deprecationMjs.useDeprecateAppendToBody
);
parcelHelpers.export(exports, "Effect", ()=>_popperMjs.Effect
);
parcelHelpers.export(exports, "usePopperArrowProps", ()=>_popperMjs.usePopperArrowProps
);
parcelHelpers.export(exports, "usePopperContentProps", ()=>_popperMjs.usePopperContentProps
);
parcelHelpers.export(exports, "usePopperCoreConfigProps", ()=>_popperMjs.usePopperCoreConfigProps
);
parcelHelpers.export(exports, "usePopperProps", ()=>_popperMjs.usePopperProps
);
parcelHelpers.export(exports, "usePopperTriggerProps", ()=>_popperMjs.usePopperTriggerProps
);
parcelHelpers.export(exports, "POPPER_CONTENT_INJECTION_KEY", ()=>_tokensMjs1.POPPER_CONTENT_INJECTION_KEY
);
parcelHelpers.export(exports, "POPPER_INJECTION_KEY", ()=>_tokensMjs1.POPPER_INJECTION_KEY
);
parcelHelpers.export(exports, "progressProps", ()=>_progressMjs.progressProps
);
parcelHelpers.export(exports, "radioEmits", ()=>_radioMjs.radioEmits
);
parcelHelpers.export(exports, "radioProps", ()=>_radioMjs.radioProps
);
parcelHelpers.export(exports, "radioPropsBase", ()=>_radioMjs.radioPropsBase
);
parcelHelpers.export(exports, "useRadio", ()=>_radioMjs.useRadio
);
parcelHelpers.export(exports, "radioGroupEmits", ()=>_radioGroupMjs.radioGroupEmits
);
parcelHelpers.export(exports, "radioGroupProps", ()=>_radioGroupMjs.radioGroupProps
);
parcelHelpers.export(exports, "radioButtonProps", ()=>_radioButtonMjs.radioButtonProps
);
parcelHelpers.export(exports, "rateEmits", ()=>_rateMjs.rateEmits
);
parcelHelpers.export(exports, "rateProps", ()=>_rateMjs.rateProps
);
parcelHelpers.export(exports, "IconComponentMap", ()=>_resultMjs.IconComponentMap
);
parcelHelpers.export(exports, "IconMap", ()=>_resultMjs.IconMap
);
parcelHelpers.export(exports, "resultProps", ()=>_resultMjs.resultProps
);
parcelHelpers.export(exports, "rowProps", ()=>_rowMjs.rowProps
);
parcelHelpers.export(exports, "BAR_MAP", ()=>_utilMjs.BAR_MAP
);
parcelHelpers.export(exports, "renderThumbStyle", ()=>_utilMjs.renderThumbStyle
);
parcelHelpers.export(exports, "scrollbarEmits", ()=>_scrollbarMjs.scrollbarEmits
);
parcelHelpers.export(exports, "scrollbarProps", ()=>_scrollbarMjs.scrollbarProps
);
parcelHelpers.export(exports, "thumbProps", ()=>_thumbMjs.thumbProps
);
parcelHelpers.export(exports, "selectGroupKey", ()=>_tokenMjs.selectGroupKey
);
parcelHelpers.export(exports, "selectKey", ()=>_tokenMjs.selectKey
);
parcelHelpers.export(exports, "selectV2InjectionKey", ()=>_tokenMjs1.selectV2InjectionKey
);
parcelHelpers.export(exports, "skeletonProps", ()=>_skeletonMjs.skeletonProps
);
parcelHelpers.export(exports, "skeletonItemProps", ()=>_skeletonItemMjs.skeletonItemProps
);
parcelHelpers.export(exports, "spaceProps", ()=>_spaceMjs.spaceProps
);
parcelHelpers.export(exports, "useSpace", ()=>_useSpaceMjs.useSpace
);
parcelHelpers.export(exports, "switchEmits", ()=>_switchMjs.switchEmits
);
parcelHelpers.export(exports, "switchProps", ()=>_switchMjs.switchProps
);
parcelHelpers.export(exports, "tabsEmits", ()=>_tabsMjs.tabsEmits
);
parcelHelpers.export(exports, "tabsProps", ()=>_tabsMjs.tabsProps
);
parcelHelpers.export(exports, "tabBar", ()=>_tabBarMjs.tabBar
);
parcelHelpers.export(exports, "tabNavProps", ()=>_tabNavMjs.tabNavProps
);
parcelHelpers.export(exports, "tabPaneProps", ()=>_tabPaneMjs.tabPaneProps
);
parcelHelpers.export(exports, "tagEmits", ()=>_tagMjs.tagEmits
);
parcelHelpers.export(exports, "tagProps", ()=>_tagMjs.tagProps
);
parcelHelpers.export(exports, "extractDateFormat", ()=>_dateUtilsMjs.extractDateFormat
);
parcelHelpers.export(exports, "extractTimeFormat", ()=>_dateUtilsMjs.extractTimeFormat
);
parcelHelpers.export(exports, "rangeArr", ()=>_dateUtilsMjs.rangeArr
);
parcelHelpers.export(exports, "DEFAULT_FORMATS_DATE", ()=>_constantMjs.DEFAULT_FORMATS_DATE
);
parcelHelpers.export(exports, "DEFAULT_FORMATS_DATEPICKER", ()=>_constantMjs.DEFAULT_FORMATS_DATEPICKER
);
parcelHelpers.export(exports, "DEFAULT_FORMATS_TIME", ()=>_constantMjs.DEFAULT_FORMATS_TIME
);
parcelHelpers.export(exports, "timePickerDefaultProps", ()=>_propsMjs.timePickerDefaultProps
);
parcelHelpers.export(exports, "CommonPicker", ()=>_pickerMjsDefault.default
);
parcelHelpers.export(exports, "TimePickPanel", ()=>_panelTimePickMjsDefault.default
);
parcelHelpers.export(exports, "timelineItemProps", ()=>_timelineItemMjs.timelineItemProps
);
parcelHelpers.export(exports, "useTooltipContentProps", ()=>_tooltipMjs.useTooltipContentProps
);
parcelHelpers.export(exports, "useTooltipProps", ()=>_tooltipMjs.useTooltipProps
);
parcelHelpers.export(exports, "useTooltipTriggerProps", ()=>_tooltipMjs.useTooltipTriggerProps
);
parcelHelpers.export(exports, "TOOLTIP_INJECTION_KEY", ()=>_tokensMjs2.TOOLTIP_INJECTION_KEY
);
parcelHelpers.export(exports, "CHANGE_EVENT", ()=>_eventMjs.CHANGE_EVENT
);
parcelHelpers.export(exports, "FixedSizeList", ()=>_fixedSizeListMjsDefault.default
);
parcelHelpers.export(exports, "DynamicSizeList", ()=>_dynamicSizeListMjsDefault.default
);
parcelHelpers.export(exports, "FixedSizeGrid", ()=>_fixedSizeGridMjsDefault.default
);
parcelHelpers.export(exports, "DynamicSizeGrid", ()=>_dynamicSizeGridMjsDefault.default
);
parcelHelpers.export(exports, "virtualizedGridProps", ()=>_propsMjs1.virtualizedGridProps
);
parcelHelpers.export(exports, "virtualizedListProps", ()=>_propsMjs1.virtualizedListProps
);
parcelHelpers.export(exports, "virtualizedProps", ()=>_propsMjs1.virtualizedProps
);
parcelHelpers.export(exports, "virtualizedScrollbarProps", ()=>_propsMjs1.virtualizedScrollbarProps
);
parcelHelpers.export(exports, "messageEmits", ()=>_messageMjs.messageEmits
);
parcelHelpers.export(exports, "messageProps", ()=>_messageMjs.messageProps
);
parcelHelpers.export(exports, "messageTypes", ()=>_messageMjs.messageTypes
);
parcelHelpers.export(exports, "notificationEmits", ()=>_notificationMjs.notificationEmits
);
parcelHelpers.export(exports, "notificationProps", ()=>_notificationMjs.notificationProps
);
parcelHelpers.export(exports, "notificationTypes", ()=>_notificationMjs.notificationTypes
);
var _indexMjs = require("./virtual-list/index.mjs");
var _indexMjs1 = require("./affix/index.mjs");
var _indexMjs2 = require("./alert/index.mjs");
var _indexMjs3 = require("./autocomplete/index.mjs");
var _indexMjs4 = require("./avatar/index.mjs");
var _indexMjs5 = require("./backtop/index.mjs");
var _indexMjs6 = require("./badge/index.mjs");
var _indexMjs7 = require("./breadcrumb/index.mjs");
var _indexMjs8 = require("./button/index.mjs");
var _indexMjs9 = require("./calendar/index.mjs");
var _indexMjs10 = require("./card/index.mjs");
var _indexMjs11 = require("./carousel/index.mjs");
var _indexMjs12 = require("./cascader/index.mjs");
var _indexMjs13 = require("./cascader-panel/index.mjs");
var _indexMjs14 = require("./check-tag/index.mjs");
var _indexMjs15 = require("./checkbox/index.mjs");
var _indexMjs16 = require("./col/index.mjs");
var _indexMjs17 = require("./collapse/index.mjs");
var _indexMjs18 = require("./collapse-transition/index.mjs");
var _indexMjs19 = require("./color-picker/index.mjs");
var _indexMjs20 = require("./config-provider/index.mjs");
var _indexMjs21 = require("./container/index.mjs");
var _indexMjs22 = require("./date-picker/index.mjs");
var _indexMjs23 = require("./descriptions/index.mjs");
var _indexMjs24 = require("./dialog/index.mjs");
var _indexMjs25 = require("./divider/index.mjs");
var _indexMjs26 = require("./drawer/index.mjs");
var _indexMjs27 = require("./dropdown/index.mjs");
var _indexMjs28 = require("./empty/index.mjs");
var _indexMjs29 = require("./form/index.mjs");
var _indexMjs30 = require("./icon/index.mjs");
var _indexMjs31 = require("./image/index.mjs");
var _indexMjs32 = require("./image-viewer/index.mjs");
var _indexMjs33 = require("./input/index.mjs");
var _indexMjs34 = require("./input-number/index.mjs");
var _indexMjs35 = require("./link/index.mjs");
var _indexMjs36 = require("./menu/index.mjs");
var _indexMjs37 = require("./overlay/index.mjs");
var _indexMjs38 = require("./page-header/index.mjs");
var _indexMjs39 = require("./pagination/index.mjs");
var _indexMjs40 = require("./popconfirm/index.mjs");
var _indexMjs41 = require("./popper/index.mjs");
var _indexMjs42 = require("./progress/index.mjs");
var _indexMjs43 = require("./radio/index.mjs");
var _indexMjs44 = require("./rate/index.mjs");
var _indexMjs45 = require("./result/index.mjs");
var _indexMjs46 = require("./row/index.mjs");
var _indexMjs47 = require("./scrollbar/index.mjs");
var _indexMjs48 = require("./select/index.mjs");
var _indexMjs49 = require("./select-v2/index.mjs");
var _indexMjs50 = require("./skeleton/index.mjs");
var _indexMjs51 = require("./slider/index.mjs");
var _indexMjs52 = require("./space/index.mjs");
var _indexMjs53 = require("./steps/index.mjs");
var _indexMjs54 = require("./switch/index.mjs");
var _indexMjs55 = require("./table/index.mjs");
var _indexMjs56 = require("./tabs/index.mjs");
var _indexMjs57 = require("./tag/index.mjs");
var _indexMjs58 = require("./time-picker/index.mjs");
var _indexMjs59 = require("./time-select/index.mjs");
var _indexMjs60 = require("./timeline/index.mjs");
var _indexMjs61 = require("./tooltip/index.mjs");
var _indexMjs62 = require("./transfer/index.mjs");
var _indexMjs63 = require("./tree/index.mjs");
var _indexMjs64 = require("./tree-v2/index.mjs");
var _indexMjs65 = require("./upload/index.mjs");
var _indexMjs66 = require("./infinite-scroll/index.mjs");
var _indexMjs67 = require("./loading/index.mjs");
var _indexMjs68 = require("./message/index.mjs");
var _indexMjs69 = require("./message-box/index.mjs");
var _indexMjs70 = require("./notification/index.mjs");
var _indexMjs71 = require("./popover/index.mjs");
var _affixMjs = require("./affix/src/affix.mjs");
var _alertMjs = require("./alert/src/alert.mjs");
var _avatarMjs = require("./avatar/src/avatar.mjs");
var _backtopMjs = require("./backtop/src/backtop.mjs");
var _badgeMjs = require("./badge/src/badge.mjs");
var _breadcrumbMjs = require("./breadcrumb/src/breadcrumb.mjs");
var _breadcrumbItemMjs = require("./breadcrumb/src/breadcrumb-item.mjs");
var _buttonMjs = require("./button/src/button.mjs");
var _calendarMjs = require("./calendar/src/calendar.mjs");
var _cardMjs = require("./card/src/card.mjs");
var _typesMjs = require("./cascader-panel/src/types.mjs");
var _configMjs = require("./cascader-panel/src/config.mjs");
var _checkTagMjs = require("./check-tag/src/check-tag.mjs");
var _colMjs = require("./col/src/col.mjs");
var _configProviderMjs = require("./config-provider/src/config-provider.mjs");
var _useDialogMjs = require("./dialog/src/use-dialog.mjs");
var _dialogMjs = require("./dialog/src/dialog.mjs");
var _dividerMjs = require("./divider/src/divider.mjs");
var _drawerMjs = require("./drawer/src/drawer.mjs");
var _dropdownMjs = require("./dropdown/src/dropdown.mjs");
var _tokensMjs = require("./dropdown/src/tokens.mjs");
var _emptyMjs = require("./empty/src/empty.mjs");
var _iconMjs = require("./icon/src/icon.mjs");
var _imageMjs = require("./image/src/image.mjs");
var _imageViewerMjs = require("./image-viewer/src/image-viewer.mjs");
var _inputMjs = require("./input/src/input.mjs");
var _inputNumberMjs = require("./input-number/src/input-number.mjs");
var _linkMjs = require("./link/src/link.mjs");
var _menuMjs = require("./menu/src/menu.mjs");
var _menuItemMjs = require("./menu/src/menu-item.mjs");
var _menuItemGroupMjs = require("./menu/src/menu-item-group.mjs");
var _subMenuMjs = require("./menu/src/sub-menu.mjs");
var _overlayMjs = require("./overlay/src/overlay.mjs");
var _pageHeaderMjs = require("./page-header/src/page-header.mjs");
var _paginationMjs = require("./pagination/src/pagination.mjs");
var _popconfirmMjs = require("./popconfirm/src/popconfirm.mjs");
var _arrowMjs = require("./popper/src/arrow.mjs");
var _arrowMjsDefault = parcelHelpers.interopDefault(_arrowMjs);
var _triggerMjs = require("./popper/src/trigger.mjs");
var _triggerMjsDefault = parcelHelpers.interopDefault(_triggerMjs);
var _contentMjs = require("./popper/src/content.mjs");
var _contentMjsDefault = parcelHelpers.interopDefault(_contentMjs);
var _deprecationMjs = require("./popper/src/deprecation.mjs");
var _popperMjs = require("./popper/src/popper.mjs");
var _tokensMjs1 = require("./popper/src/tokens.mjs");
var _progressMjs = require("./progress/src/progress.mjs");
var _radioMjs = require("./radio/src/radio.mjs");
var _radioGroupMjs = require("./radio/src/radio-group.mjs");
var _radioButtonMjs = require("./radio/src/radio-button.mjs");
var _rateMjs = require("./rate/src/rate.mjs");
var _resultMjs = require("./result/src/result.mjs");
var _rowMjs = require("./row/src/row.mjs");
var _utilMjs = require("./scrollbar/src/util.mjs");
var _scrollbarMjs = require("./scrollbar/src/scrollbar.mjs");
var _thumbMjs = require("./scrollbar/src/thumb.mjs");
var _tokenMjs = require("./select/src/token.mjs");
var _tokenMjs1 = require("./select-v2/src/token.mjs");
var _skeletonMjs = require("./skeleton/src/skeleton.mjs");
var _skeletonItemMjs = require("./skeleton/src/skeleton-item.mjs");
var _spaceMjs = require("./space/src/space.mjs");
var _useSpaceMjs = require("./space/src/use-space.mjs");
var _switchMjs = require("./switch/src/switch.mjs");
var _tabsMjs = require("./tabs/src/tabs.mjs");
var _tabBarMjs = require("./tabs/src/tab-bar.mjs");
var _tabNavMjs = require("./tabs/src/tab-nav.mjs");
var _tabPaneMjs = require("./tabs/src/tab-pane.mjs");
var _tagMjs = require("./tag/src/tag.mjs");
var _dateUtilsMjs = require("./time-picker/src/common/date-utils.mjs");
var _constantMjs = require("./time-picker/src/common/constant.mjs");
var _propsMjs = require("./time-picker/src/common/props.mjs");
var _pickerMjs = require("./time-picker/src/common/picker.mjs");
var _pickerMjsDefault = parcelHelpers.interopDefault(_pickerMjs);
var _panelTimePickMjs = require("./time-picker/src/time-picker-com/panel-time-pick.mjs");
var _panelTimePickMjsDefault = parcelHelpers.interopDefault(_panelTimePickMjs);
var _timelineItemMjs = require("./timeline/src/timeline-item.mjs");
var _tooltipMjs = require("./tooltip/src/tooltip.mjs");
var _tokensMjs2 = require("./tooltip/src/tokens.mjs");
var _eventMjs = require("../constants/event.mjs");
var _fixedSizeListMjs = require("./virtual-list/src/components/fixed-size-list.mjs");
var _fixedSizeListMjsDefault = parcelHelpers.interopDefault(_fixedSizeListMjs);
var _dynamicSizeListMjs = require("./virtual-list/src/components/dynamic-size-list.mjs");
var _dynamicSizeListMjsDefault = parcelHelpers.interopDefault(_dynamicSizeListMjs);
var _fixedSizeGridMjs = require("./virtual-list/src/components/fixed-size-grid.mjs");
var _fixedSizeGridMjsDefault = parcelHelpers.interopDefault(_fixedSizeGridMjs);
var _dynamicSizeGridMjs = require("./virtual-list/src/components/dynamic-size-grid.mjs");
var _dynamicSizeGridMjsDefault = parcelHelpers.interopDefault(_dynamicSizeGridMjs);
var _propsMjs1 = require("./virtual-list/src/props.mjs");
var _messageMjs = require("./message/src/message.mjs");
var _notificationMjs = require("./notification/src/notification.mjs");

},{"./virtual-list/index.mjs":"gcf4S","./affix/index.mjs":"fMcKf","./alert/index.mjs":"jX4vK","./autocomplete/index.mjs":"lnNbL","./avatar/index.mjs":"edhpQ","./backtop/index.mjs":"iA9M1","./badge/index.mjs":"gvyeW","./breadcrumb/index.mjs":"6p9GR","./button/index.mjs":"64Ym1","./calendar/index.mjs":"iyUgV","./card/index.mjs":"ftRFC","./carousel/index.mjs":"DjiER","./cascader/index.mjs":"hgxNT","./cascader-panel/index.mjs":"cvCE6","./check-tag/index.mjs":"2yvIi","./checkbox/index.mjs":"jMNjD","./col/index.mjs":"iutZ4","./collapse/index.mjs":"2aUAi","./collapse-transition/index.mjs":"kOsra","./color-picker/index.mjs":"kWiGH","./config-provider/index.mjs":"5LcSW","./container/index.mjs":"7nKg2","./date-picker/index.mjs":"fdWz7","./descriptions/index.mjs":"aXmMH","./dialog/index.mjs":"iXu3z","./divider/index.mjs":"8bcJq","./drawer/index.mjs":"DJoCd","./dropdown/index.mjs":"dk8yW","./empty/index.mjs":"5bPkj","./form/index.mjs":"hQT2m","./icon/index.mjs":"hnNTG","./image/index.mjs":"hFVHx","./image-viewer/index.mjs":"39t5l","./input/index.mjs":"18eQI","./input-number/index.mjs":"1U2Gu","./link/index.mjs":"18DrN","./menu/index.mjs":"5wfdz","./overlay/index.mjs":"2HJvE","./page-header/index.mjs":"cmyvF","./pagination/index.mjs":"ep8iT","./popconfirm/index.mjs":"ds8jY","./popper/index.mjs":"kIV7g","./progress/index.mjs":"9ijV7","./radio/index.mjs":"fekfn","./rate/index.mjs":"8o4Y1","./result/index.mjs":"lHyTs","./row/index.mjs":"7Vl2s","./scrollbar/index.mjs":"kXLHt","./select/index.mjs":"llDRW","./select-v2/index.mjs":"lUvDZ","./skeleton/index.mjs":"2N5x8","./slider/index.mjs":"6YyBo","./space/index.mjs":"fdm11","./steps/index.mjs":"9fit0","./switch/index.mjs":"aErYv","./table/index.mjs":"imp1h","./tabs/index.mjs":"3MxUG","./tag/index.mjs":"96fQG","./time-picker/index.mjs":"4TaeO","./time-select/index.mjs":"k6X13","./timeline/index.mjs":"2CPF0","./tooltip/index.mjs":"kiwBC","./transfer/index.mjs":"baYrE","./tree/index.mjs":"bpXS0","./tree-v2/index.mjs":"eqslC","./upload/index.mjs":"fvmYn","./infinite-scroll/index.mjs":"fffis","./loading/index.mjs":"9QQSv","./message/index.mjs":"hqiSY","./message-box/index.mjs":"lPFAH","./notification/index.mjs":"a0vte","./popover/index.mjs":"cnet0","./affix/src/affix.mjs":"31RpQ","./alert/src/alert.mjs":"bmmdq","./avatar/src/avatar.mjs":"aSZOT","./backtop/src/backtop.mjs":"9ygQ4","./badge/src/badge.mjs":"4pSua","./breadcrumb/src/breadcrumb.mjs":"iV9UH","./breadcrumb/src/breadcrumb-item.mjs":"5U0qo","./button/src/button.mjs":"8GILO","./calendar/src/calendar.mjs":"4X2do","./card/src/card.mjs":"a9FEd","./cascader-panel/src/types.mjs":"5MNj5","./cascader-panel/src/config.mjs":"8uFuI","./check-tag/src/check-tag.mjs":"fL3TX","./col/src/col.mjs":"hxnIP","./config-provider/src/config-provider.mjs":"jXq22","./dialog/src/use-dialog.mjs":"kcxXl","./dialog/src/dialog.mjs":"imlUB","./divider/src/divider.mjs":"X6LID","./drawer/src/drawer.mjs":"6GsxM","./dropdown/src/dropdown.mjs":"7C9Hj","./dropdown/src/tokens.mjs":"ghjhG","./empty/src/empty.mjs":"6dOm6","./icon/src/icon.mjs":"buNkD","./image/src/image.mjs":"hhtmC","./image-viewer/src/image-viewer.mjs":"kIWgu","./input/src/input.mjs":"8Zju5","./input-number/src/input-number.mjs":"hcBfX","./link/src/link.mjs":"cyxqy","./menu/src/menu.mjs":"5fjO6","./menu/src/menu-item.mjs":"5FnwZ","./menu/src/menu-item-group.mjs":"foLPD","./menu/src/sub-menu.mjs":"d2lRI","./overlay/src/overlay.mjs":"fWAgM","./page-header/src/page-header.mjs":"wnNZL","./pagination/src/pagination.mjs":"3DWdA","./popconfirm/src/popconfirm.mjs":"PeZMy","./popper/src/arrow.mjs":"fjUPr","./popper/src/trigger.mjs":"3POmC","./popper/src/content.mjs":"lN2o5","./popper/src/deprecation.mjs":"jm0Kb","./popper/src/popper.mjs":"lCFux","./popper/src/tokens.mjs":"cbHZm","./progress/src/progress.mjs":"iea9L","./radio/src/radio.mjs":"gDfxw","./radio/src/radio-group.mjs":"ifp6r","./radio/src/radio-button.mjs":"eTDbS","./rate/src/rate.mjs":"eT6Re","./result/src/result.mjs":"lxN2C","./row/src/row.mjs":"f4k9l","./scrollbar/src/util.mjs":"eBQCF","./scrollbar/src/scrollbar.mjs":"123QS","./scrollbar/src/thumb.mjs":"gZPgI","./select/src/token.mjs":"cOSZy","./select-v2/src/token.mjs":"lk8V6","./skeleton/src/skeleton.mjs":"9BfJP","./skeleton/src/skeleton-item.mjs":"3Kx1r","./space/src/space.mjs":"5tyjs","./space/src/use-space.mjs":"gYCpP","./switch/src/switch.mjs":"77sPp","./tabs/src/tabs.mjs":"e8i7v","./tabs/src/tab-bar.mjs":"dhrbU","./tabs/src/tab-nav.mjs":"6DFds","./tabs/src/tab-pane.mjs":"hD9Q9","./tag/src/tag.mjs":"i4Ov7","./time-picker/src/common/date-utils.mjs":"3CJdm","./time-picker/src/common/constant.mjs":"b75g0","./time-picker/src/common/props.mjs":"gx1qH","./time-picker/src/common/picker.mjs":"3jAyz","./time-picker/src/time-picker-com/panel-time-pick.mjs":"351Kw","./timeline/src/timeline-item.mjs":"6SEpi","./tooltip/src/tooltip.mjs":"7LVFi","./tooltip/src/tokens.mjs":"a6G79","../constants/event.mjs":"92xVn","./virtual-list/src/components/fixed-size-list.mjs":"eaMZD","./virtual-list/src/components/dynamic-size-list.mjs":"ggHfi","./virtual-list/src/components/fixed-size-grid.mjs":"fyL0k","./virtual-list/src/components/dynamic-size-grid.mjs":"9Fq2m","./virtual-list/src/props.mjs":"2CLE6","./message/src/message.mjs":"exwnb","./notification/src/notification.mjs":"9l71J","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lBbja":[function() {},{}],"dwH06":[function() {},{}],"cLzs3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require('script:./App.vue');
    if (script.__esModule) script = script.default;
    script.render = require('template:./App.vue').render;
    require('custom:./App.vue').default(script);
    script.__scopeId = 'data-v-35924b';
    script.__file = "D:\\Workspace\\cutting-mat\\axios\\test\\App.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = '35924b-hmr';
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord('35924b-hmr', script)) __VUE_HMR_RUNTIME__.reload('35924b-hmr', script);
        }, 0);
    });
}
exports.default = script;

},{"script:./App.vue":"553Kl","template:./App.vue":"kD4VB","custom:./App.vue":"jw1co","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"553Kl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
//import { util } from "@/core";
var _header = require("./components/header");
var _headerDefault = parcelHelpers.interopDefault(_header);
var _homePage = require("./components/HomePage");
var _homePageDefault = parcelHelpers.interopDefault(_homePage);
var _footer = require("./components/footer");
var _footerDefault = parcelHelpers.interopDefault(_footer);
exports.default = {
    components: {
        myHeader: _headerDefault.default,
        myFooter: _footerDefault.default,
        HomePage: _homePageDefault.default
    },
    data () {
        return {
            screen: {
            }
        };
    },
    methods: {
    },
    created () {
        // const { width, height } = window.screen;
        const { innerWidth , innerHeight  } = window;
        this.screen = {
            width: innerWidth,
            height: innerHeight
        };
    }
};

},{"./components/header":"8iO5q","./components/HomePage":"8R3j4","./components/footer":"31jvg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8iO5q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require('script:./header.vue');
    if (script.__esModule) script = script.default;
    script.render = require('template:./header.vue').render;
    script.__cssModules = require('style:./header.vue').default;
    require('custom:./header.vue').default(script);
    script.__scopeId = 'data-v-c050cd';
    script.__file = "D:\\Workspace\\cutting-mat\\axios\\test\\components\\header.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = 'c050cd-hmr';
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord('c050cd-hmr', script)) __VUE_HMR_RUNTIME__.reload('c050cd-hmr', script);
        }, 0);
    });
}
exports.default = script;

},{"script:./header.vue":"kcfng","template:./header.vue":"8TESb","style:./header.vue":"iiSDd","custom:./header.vue":"8ckpe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kcfng":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    name: "myHeader",
    data () {
        return {
        };
    },
    methods: {
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8TESb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render
);
var _vue = require("vue");
const _withScopeId = (n)=>(_vue.pushScopeId("data-v-c050cd"), n = n(), _vue.popScopeId(), n)
;
const _hoisted_1 = {
    class: "header flex-row align-center"
};
const _hoisted_2 = {
    class: "center flex-1"
};
const _hoisted_3 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ _vue.createElementVNode("a", {
        class: "link",
        target: "_blank",
        title: "Github",
        href: "https://github.com/cutting-mat/axios"
    }, [
        /*#__PURE__*/ _vue.createElementVNode("svg", {
            height: "32",
            viewBox: "0 0 16 16",
            version: "1.1",
            width: "32",
            "data-view-component": "true"
        }, [
            /*#__PURE__*/ _vue.createElementVNode("path", {
                "fill-rule": "evenodd",
                d: "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
            })
        ])
    ], -1 /* HOISTED */ )
);
function render(_ctx, _cache) {
    return _vue.openBlock(), _vue.createElementBlock("header", _hoisted_1, [
        _vue.createElementVNode("h1", {
            class: "logo",
            onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.$router.push('/')
            )
        }, "@cutting-mat/axios"),
        _vue.createElementVNode("div", _hoisted_2, [
            _vue.renderSlot(_ctx.$slots, "default")
        ]),
        _hoisted_3
    ]);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender('c050cd-hmr', render);
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iiSDd":[function() {},{}],"8ckpe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{
};
exports.default = (script)=>{
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8R3j4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require('script:./HomePage.vue');
    if (script.__esModule) script = script.default;
    script.render = require('template:./HomePage.vue').render;
    script.__cssModules = require('style:./HomePage.vue').default;
    require('custom:./HomePage.vue').default(script);
    script.__scopeId = 'data-v-5d0597';
    script.__file = "D:\\Workspace\\cutting-mat\\axios\\test\\components\\HomePage.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = '5d0597-hmr';
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord('5d0597-hmr', script)) __VUE_HMR_RUNTIME__.reload('5d0597-hmr', script);
        }, 0);
    });
}
exports.default = script;

},{"script:./HomePage.vue":"2AWxQ","template:./HomePage.vue":"1pKkE","style:./HomePage.vue":"cdGAC","custom:./HomePage.vue":"1qp6r","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2AWxQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axios = require("../../src/axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
// åˆ›å»ºè¯·æ±‚å®žä¾‹
const instance = _axiosDefault.default.create({
    headers: {
        "Content-Type": "application/json"
    }
});
exports.default = {
    data () {
        return {
            log: [],
            responseCache: _axios.responseCache
        };
    },
    methods: {
        clear () {
            this.log = [];
        },
        testRequest (cacheOption) {
            return instance.get("http://yapi.smart-xwork.cn/mock/154414/return/test", null, {
                cache: cacheOption
            }).then((res)=>{
                this.log.push(`${new Date().getTime()}: ${JSON.stringify(res.data)}`);
            }).catch((err)=>{
                this.log.push(`${new Date().getTime()}: ${err.message || err}`);
            });
        },
        multiRequest (cacheOption) {
            for(let i = 0; i < 3; i++)this.testRequest(cacheOption);
        }
    },
    created () {
    }
};

},{"../../src/axios":"3x04S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3x04S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "responseCache", ()=>responseCache
);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
// åŽŸå§‹ axios.create
const axiosCreate = _axiosDefault.default.create;
let responseCache = {
};
_axiosDefault.default.create = function(config) {
    const instance = axiosCreate(config);
    const axiosGet = instance.get;
    // æ›¿æ¢å®žä¾‹çš„ get()
    instance.get = function(url1, params1, opt) {
        opt = Object.assign({
            cache: null
        }, opt || {
        });
        const paramsStr = Object.prototype.toString.call(params1) === "[object Object]" ? JSON.stringify(params1) : "";
        const requestKey = `${url1}?${paramsStr}`;
        const createPromise = function(url, params) {
            return axiosGet(url, params).then((res)=>{
                if (opt.cache === true || opt.cache === "update") responseCache[requestKey].status = "resolved";
                else delete responseCache[requestKey];
                return res;
            }).catch((err)=>{
                delete responseCache[requestKey];
                return err;
            });
        };
        if (!responseCache[requestKey] || responseCache[requestKey].status !== "pending" && opt.cache === "update" || opt.cache === false // ä¸éœ€è¦ç¼“å­˜
        ) // console.log('åˆ›å»ºç¼“å­˜å¯¹è±¡', requestKey)
        responseCache[requestKey] = {
            status: "pending",
            promise: createPromise(url1, params1)
        };
        return responseCache[requestKey].promise;
    };
    return instance;
};
exports.default = _axiosDefault.default;

},{"axios":"jo6P5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jo6P5":[function(require,module,exports) {
module.exports = require('./lib/axios');

},{"./lib/axios":"63MyY"}],"63MyY":[function(require,module,exports) {
'use strict';
var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */ function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind(Axios.prototype.request, context);
    // Copy axios.prototype to instance
    utils.extend(instance, Axios.prototype, context);
    // Copy context to instance
    utils.extend(instance, context);
    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
}
// Create the default instance to be exported
var axios = createInstance(defaults);
// Expose Axios class to allow class inheritance
axios.Axios = Axios;
// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');
axios.VERSION = require('./env/data').version;
// Expose all/spread
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = require('./helpers/spread');
// Expose isAxiosError
axios.isAxiosError = require('./helpers/isAxiosError');
module.exports = axios;
// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./utils":"5By4s","./helpers/bind":"haRQb","./core/Axios":"cpqD8","./core/mergeConfig":"b85oP","./defaults":"lTJJ4","./cancel/Cancel":"kjMy2","./cancel/CancelToken":"45wzn","./cancel/isCancel":"a0VmF","./env/data":"h29L9","./helpers/spread":"dyQ8N","./helpers/isAxiosError":"eyiLq"}],"5By4s":[function(require,module,exports) {
'use strict';
var bind = require('./helpers/bind');
// utils is a library of generic helper functions non-specific to axios
var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */ function isArray(val) {
    return Array.isArray(val);
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */ function isUndefined(val) {
    return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ function isArrayBuffer(val) {
    return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */ function isFormData(val) {
    return toString.call(val) === '[object FormData]';
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
    else result = val && val.buffer && isArrayBuffer(val.buffer);
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */ function isString(val) {
    return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */ function isNumber(val) {
    return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */ function isObject(val) {
    return val !== null && typeof val === 'object';
}
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */ function isPlainObject(val) {
    if (toString.call(val) !== '[object Object]') return false;
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */ function isDate(val) {
    return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */ function isFile(val) {
    return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */ function isBlob(val) {
    return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ function isFunction(val) {
    return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */ function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ function isURLSearchParams(val) {
    return toString.call(val) === '[object URLSearchParams]';
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */ function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */ function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) return false;
    return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */ function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') return;
    // Force an array if not already something iterable
    if (typeof obj !== 'object') /*eslint no-param-reassign:0*/ obj = [
        obj
    ];
    if (isArray(obj)) // Iterate over array values
    for(var i = 0, l = obj.length; i < l; i++)fn.call(null, obj[i], i, obj);
    else {
        // Iterate over object keys
        for(var key in obj)if (Object.prototype.hasOwnProperty.call(obj, key)) fn.call(null, obj[key], key, obj);
    }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */ function merge() {
    var result = {
    };
    function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) result[key] = merge(result[key], val);
        else if (isPlainObject(val)) result[key] = merge({
        }, val);
        else if (isArray(val)) result[key] = val.slice();
        else result[key] = val;
    }
    for(var i = 0, l = arguments.length; i < l; i++)forEach(arguments[i], assignValue);
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */ function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') a[key] = bind(val, thisArg);
        else a[key] = val;
    });
    return a;
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */ function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) content = content.slice(1);
    return content;
}
module.exports = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isPlainObject: isPlainObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    extend: extend,
    trim: trim,
    stripBOM: stripBOM
};

},{"./helpers/bind":"haRQb"}],"haRQb":[function(require,module,exports) {
'use strict';
module.exports = function bind(fn, thisArg) {
    return function wrap() {
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; i++)args[i] = arguments[i];
        return fn.apply(thisArg, args);
    };
};

},{}],"cpqD8":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');
var validator = require('../helpers/validator');
var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */ function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
    };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */ Axios.prototype.request = function request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
        config = config || {
        };
        config.url = configOrUrl;
    } else config = configOrUrl || {
    };
    config = mergeConfig(this.defaults, config);
    // Set config.method
    if (config.method) config.method = config.method.toLowerCase();
    else if (this.defaults.method) config.method = this.defaults.method.toLowerCase();
    else config.method = 'get';
    var transitional = config.transitional;
    if (transitional !== undefined) validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
    // filter out skipped interceptors
    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) return;
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    var promise;
    if (!synchronousRequestInterceptors) {
        var chain = [
            dispatchRequest,
            undefined
        ];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while(chain.length)promise = promise.then(chain.shift(), chain.shift());
        return promise;
    }
    var newConfig = config;
    while(requestInterceptorChain.length){
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
            newConfig = onFulfilled(newConfig);
        } catch (error) {
            onRejected(error);
            break;
        }
    }
    try {
        promise = dispatchRequest(newConfig);
    } catch (error) {
        return Promise.reject(error);
    }
    while(responseInterceptorChain.length)promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
    return promise;
};
Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};
// Provide aliases for supported request methods
utils.forEach([
    'delete',
    'get',
    'head',
    'options'
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {
        }, {
            method: method,
            url: url,
            data: (config || {
            }).data
        }));
    };
});
utils.forEach([
    'post',
    'put',
    'patch'
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {
        }, {
            method: method,
            url: url,
            data: data
        }));
    };
});
module.exports = Axios;

},{"./../utils":"5By4s","../helpers/buildURL":"3bwC2","./InterceptorManager":"1VRIM","./dispatchRequest":"6sjJ6","./mergeConfig":"b85oP","../helpers/validator":"9vgkY"}],"3bwC2":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */ module.exports = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/ if (!params) return url;
    var serializedParams;
    if (paramsSerializer) serializedParams = paramsSerializer(params);
    else if (utils.isURLSearchParams(params)) serializedParams = params.toString();
    else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === 'undefined') return;
            if (utils.isArray(val)) key = key + '[]';
            else val = [
                val
            ];
            utils.forEach(val, function parseValue(v) {
                if (utils.isDate(v)) v = v.toISOString();
                else if (utils.isObject(v)) v = JSON.stringify(v);
                parts.push(encode(key) + '=' + encode(v));
            });
        });
        serializedParams = parts.join('&');
    }
    if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) url = url.slice(0, hashmarkIndex);
        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }
    return url;
};

},{"./../utils":"5By4s"}],"1VRIM":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
function InterceptorManager() {
    this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */ InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
    this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */ InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) this.handlers[id] = null;
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */ InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) fn(h);
    });
};
module.exports = InterceptorManager;

},{"./../utils":"5By4s"}],"6sjJ6":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');
var Cancel = require('../cancel/Cancel');
/**
 * Throws a `Cancel` if cancellation has been requested.
 */ function throwIfCancellationRequested(config) {
    if (config.cancelToken) config.cancelToken.throwIfRequested();
    if (config.signal && config.signal.aborted) throw new Cancel('canceled');
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */ module.exports = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    // Ensure headers exist
    config.headers = config.headers || {
    };
    // Transform request data
    config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
    // Flatten headers
    config.headers = utils.merge(config.headers.common || {
    }, config.headers[config.method] || {
    }, config.headers);
    utils.forEach([
        'delete',
        'get',
        'head',
        'post',
        'put',
        'patch',
        'common'
    ], function cleanHeaderConfig(method) {
        delete config.headers[method];
    });
    var adapter = config.adapter || defaults.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        // Transform response data
        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
        return response;
    }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
        }
        return Promise.reject(reason);
    });
};

},{"./../utils":"5By4s","./transformData":"eRqJY","../cancel/isCancel":"a0VmF","../defaults":"lTJJ4","../cancel/Cancel":"kjMy2"}],"eRqJY":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
var defaults = require('./../defaults');
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */ module.exports = function transformData(data, headers, fns) {
    var context = this || defaults;
    /*eslint no-param-reassign:0*/ utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
    });
    return data;
};

},{"./../utils":"5By4s","./../defaults":"lTJJ4"}],"lTJJ4":[function(require,module,exports) {
'use strict';
var process = require("process");
var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');
var enhanceError = require('./core/enhanceError');
var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
};
function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) headers['Content-Type'] = value;
}
function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== 'undefined') // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
    else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') // For node use HTTP adapter
    adapter = require('./adapters/http');
    return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
    if (utils.isString(rawValue)) try {
        (parser || JSON.parse)(rawValue);
        return utils.trim(rawValue);
    } catch (e) {
        if (e.name !== 'SyntaxError') throw e;
    }
    return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
    transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
    },
    adapter: getDefaultAdapter(),
    transformRequest: [
        function transformRequest(data, headers) {
            normalizeHeaderName(headers, 'Accept');
            normalizeHeaderName(headers, 'Content-Type');
            if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) return data;
            if (utils.isArrayBufferView(data)) return data.buffer;
            if (utils.isURLSearchParams(data)) {
                setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
                return data.toString();
            }
            if (utils.isObject(data) || headers && headers['Content-Type'] === 'application/json') {
                setContentTypeIfUnset(headers, 'application/json');
                return stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            var transitional = this.transitional || defaults.transitional;
            var silentJSONParsing = transitional && transitional.silentJSONParsing;
            var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';
            if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) try {
                return JSON.parse(data);
            } catch (e) {
                if (strictJSONParsing) {
                    if (e.name === 'SyntaxError') throw enhanceError(e, this, 'E_JSON_PARSE');
                    throw e;
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    },
    headers: {
        common: {
            'Accept': 'application/json, text/plain, */*'
        }
    }
};
utils.forEach([
    'delete',
    'get',
    'head'
], function forEachMethodNoData(method) {
    defaults.headers[method] = {
    };
});
utils.forEach([
    'post',
    'put',
    'patch'
], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

},{"process":"d5jf4","./utils":"5By4s","./helpers/normalizeHeaderName":"adBZo","./core/enhanceError":"itUQr","./adapters/xhr":"ldm57","./adapters/http":"ldm57"}],"adBZo":[function(require,module,exports) {
'use strict';
var utils = require('../utils');
module.exports = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
        }
    });
};

},{"../utils":"5By4s"}],"itUQr":[function(require,module,exports) {
'use strict';
/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */ module.exports = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) error.code = code;
    error.request = request;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        };
    };
    return error;
};

},{}],"ldm57":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
var settle = require('./../core/settle');
var cookies = require('./../helpers/cookies');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');
var defaults = require('../defaults');
var Cancel = require('../cancel/Cancel');
module.exports = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
            if (config.cancelToken) config.cancelToken.unsubscribe(onCanceled);
            if (config.signal) config.signal.removeEventListener('abort', onCanceled);
        }
        if (utils.isFormData(requestData)) delete requestHeaders['Content-Type']; // Let the browser set it
        var request = new XMLHttpRequest();
        // HTTP basic authentication
        if (config.auth) {
            var username = config.auth.username || '';
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
            requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        // Set the request timeout in MS
        request.timeout = config.timeout;
        function onloadend() {
            if (!request) return;
            // Prepare the response
            var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
            var response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config: config,
                request: request
            };
            settle(function _resolve(value) {
                resolve(value);
                done();
            }, function _reject(err) {
                reject(err);
                done();
            }, response);
            // Clean up request
            request = null;
        }
        if ('onloadend' in request) // Use onloadend if available
        request.onloadend = onloadend;
        else // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) return;
            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) return;
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
        };
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) return;
            reject(createError('Request aborted', config, 'ECONNABORTED', request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(createError('Network Error', config, null, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
            var transitional = config.transitional || defaults.transitional;
            if (config.timeoutErrorMessage) timeoutErrorMessage = config.timeoutErrorMessage;
            reject(createError(timeoutErrorMessage, config, transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED', request));
            // Clean up request
            request = null;
        };
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
            // Add xsrf header
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;
            if (xsrfValue) requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
        // Add headers to the request
        if ('setRequestHeader' in request) utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') // Remove Content-Type if data is undefined
            delete requestHeaders[key];
            else // Otherwise add header to the request
            request.setRequestHeader(key, val);
        });
        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) request.withCredentials = !!config.withCredentials;
        // Add responseType to request if needed
        if (responseType && responseType !== 'json') request.responseType = config.responseType;
        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') request.addEventListener('progress', config.onDownloadProgress);
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) request.upload.addEventListener('progress', config.onUploadProgress);
        if (config.cancelToken || config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = function(cancel) {
                if (!request) return;
                reject(!cancel || cancel && cancel.type ? new Cancel('canceled') : cancel);
                request.abort();
                request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
        }
        if (!requestData) requestData = null;
        // Send the request
        request.send(requestData);
    });
};

},{"./../utils":"5By4s","./../core/settle":"dD9aC","./../helpers/cookies":"4WJjt","./../helpers/buildURL":"3bwC2","../core/buildFullPath":"1I5TW","./../helpers/parseHeaders":"kqDd5","./../helpers/isURLSameOrigin":"lxXtv","../core/createError":"5nVS9","../defaults":"lTJJ4","../cancel/Cancel":"kjMy2"}],"dD9aC":[function(require,module,exports) {
'use strict';
var createError = require('./createError');
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */ module.exports = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) resolve(response);
    else reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
};

},{"./createError":"5nVS9"}],"5nVS9":[function(require,module,exports) {
'use strict';
var enhanceError = require('./enhanceError');
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */ module.exports = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":"itUQr"}],"4WJjt":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
(function standardBrowserEnv() {
    return {
        write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + '=' + encodeURIComponent(value));
            if (utils.isNumber(expires)) cookie.push('expires=' + new Date(expires).toGMTString());
            if (utils.isString(path)) cookie.push('path=' + path);
            if (utils.isString(domain)) cookie.push('domain=' + domain);
            if (secure === true) cookie.push('secure');
            document.cookie = cookie.join('; ');
        },
        read: function read(name) {
            var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
            return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
            this.write(name, '', Date.now() - 86400000);
        }
    };
})() : // Non standard browser env (web workers, react-native) lack needed support.
(function nonStandardBrowserEnv() {
    return {
        write: function write() {
        },
        read: function read() {
            return null;
        },
        remove: function remove() {
        }
    };
})();

},{"./../utils":"5By4s"}],"1I5TW":[function(require,module,exports) {
'use strict';
var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */ module.exports = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) return combineURLs(baseURL, requestedURL);
    return requestedURL;
};

},{"../helpers/isAbsoluteURL":"jD6NM","../helpers/combineURLs":"brOWK"}],"jD6NM":[function(require,module,exports) {
'use strict';
/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */ module.exports = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};

},{}],"brOWK":[function(require,module,exports) {
'use strict';
/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */ module.exports = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

},{}],"kqDd5":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
    'age',
    'authorization',
    'content-length',
    'content-type',
    'etag',
    'expires',
    'from',
    'host',
    'if-modified-since',
    'if-unmodified-since',
    'last-modified',
    'location',
    'max-forwards',
    'proxy-authorization',
    'referer',
    'retry-after',
    'user-agent'
];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */ module.exports = function parseHeaders(headers) {
    var parsed = {
    };
    var key;
    var val;
    var i;
    if (!headers) return parsed;
    utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) return;
            if (key === 'set-cookie') parsed[key] = (parsed[key] ? parsed[key] : []).concat([
                val
            ]);
            else parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
    });
    return parsed;
};

},{"./../utils":"5By4s"}],"lxXtv":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
(function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;
    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */ function resolveURL(url) {
        var href = url;
        if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute('href', href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
    }
    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */ return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
})() : // Non standard browser envs (web workers, react-native) lack needed support.
(function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
        return true;
    };
})();

},{"./../utils":"5By4s"}],"kjMy2":[function(require,module,exports) {
'use strict';
/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */ function Cancel(message) {
    this.message = message;
}
Cancel.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
};
Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

},{}],"a0VmF":[function(require,module,exports) {
'use strict';
module.exports = function isCancel(value) {
    return !!(value && value.__CANCEL__);
};

},{}],"b85oP":[function(require,module,exports) {
'use strict';
var utils = require('../utils');
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */ module.exports = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {
    };
    var config = {
    };
    function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) return utils.merge(target, source);
        else if (utils.isPlainObject(source)) return utils.merge({
        }, source);
        else if (utils.isArray(source)) return source.slice();
        return source;
    }
    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) return getMergedValue(config1[prop], config2[prop]);
        else if (!utils.isUndefined(config1[prop])) return getMergedValue(undefined, config1[prop]);
    }
    // eslint-disable-next-line consistent-return
    function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) return getMergedValue(undefined, config2[prop]);
    }
    // eslint-disable-next-line consistent-return
    function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) return getMergedValue(undefined, config2[prop]);
        else if (!utils.isUndefined(config1[prop])) return getMergedValue(undefined, config1[prop]);
    }
    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(prop) {
        if (prop in config2) return getMergedValue(config1[prop], config2[prop]);
        else if (prop in config1) return getMergedValue(undefined, config1[prop]);
    }
    var mergeMap = {
        'url': valueFromConfig2,
        'method': valueFromConfig2,
        'data': valueFromConfig2,
        'baseURL': defaultToConfig2,
        'transformRequest': defaultToConfig2,
        'transformResponse': defaultToConfig2,
        'paramsSerializer': defaultToConfig2,
        'timeout': defaultToConfig2,
        'timeoutMessage': defaultToConfig2,
        'withCredentials': defaultToConfig2,
        'adapter': defaultToConfig2,
        'responseType': defaultToConfig2,
        'xsrfCookieName': defaultToConfig2,
        'xsrfHeaderName': defaultToConfig2,
        'onUploadProgress': defaultToConfig2,
        'onDownloadProgress': defaultToConfig2,
        'decompress': defaultToConfig2,
        'maxContentLength': defaultToConfig2,
        'maxBodyLength': defaultToConfig2,
        'transport': defaultToConfig2,
        'httpAgent': defaultToConfig2,
        'httpsAgent': defaultToConfig2,
        'cancelToken': defaultToConfig2,
        'socketPath': defaultToConfig2,
        'responseEncoding': defaultToConfig2,
        'validateStatus': mergeDirectKeys
    };
    utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
};

},{"../utils":"5By4s"}],"9vgkY":[function(require,module,exports) {
'use strict';
var VERSION = require('../env/data').version;
var validators = {
};
// eslint-disable-next-line func-names
[
    'object',
    'boolean',
    'number',
    'function',
    'string',
    'symbol'
].forEach(function(type, i) {
    validators[type] = function validator(thing) {
        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
    };
});
var deprecatedWarnings = {
};
/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */ validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
        return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
    }
    // eslint-disable-next-line func-names
    return function(value, opt, opts) {
        if (validator === false) throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));
        if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */ function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== 'object') throw new TypeError('options must be an object');
    var keys = Object.keys(options);
    var i = keys.length;
    while(i-- > 0){
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
            var value = options[opt];
            var result = value === undefined || validator(value, opt, options);
            if (result !== true) throw new TypeError('option ' + opt + ' must be ' + result);
            continue;
        }
        if (allowUnknown !== true) throw Error('Unknown option ' + opt);
    }
}
module.exports = {
    assertOptions: assertOptions,
    validators: validators
};

},{"../env/data":"h29L9"}],"h29L9":[function(require,module,exports) {
module.exports = {
    "version": "0.26.0"
};

},{}],"45wzn":[function(require,module,exports) {
'use strict';
var Cancel = require('./Cancel');
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */ function CancelToken(executor) {
    if (typeof executor !== 'function') throw new TypeError('executor must be a function.');
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
    });
    var token = this;
    // eslint-disable-next-line func-names
    this.promise.then(function(cancel) {
        if (!token._listeners) return;
        var i;
        var l = token._listeners.length;
        for(i = 0; i < l; i++)token._listeners[i](cancel);
        token._listeners = null;
    });
    // eslint-disable-next-line func-names
    this.promise.then = function(onfulfilled) {
        var _resolve;
        // eslint-disable-next-line func-names
        var promise = new Promise(function(resolve) {
            token.subscribe(resolve);
            _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
            token.unsubscribe(_resolve);
        };
        return promise;
    };
    executor(function cancel(message) {
        if (token.reason) // Cancellation has already been requested
        return;
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
    });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */ CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) throw this.reason;
};
/**
 * Subscribe to the cancel signal
 */ CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
        listener(this.reason);
        return;
    }
    if (this._listeners) this._listeners.push(listener);
    else this._listeners = [
        listener
    ];
};
/**
 * Unsubscribe from the cancel signal
 */ CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) return;
    var index = this._listeners.indexOf(listener);
    if (index !== -1) this._listeners.splice(index, 1);
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */ CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
        cancel = c;
    });
    return {
        token: token,
        cancel: cancel
    };
};
module.exports = CancelToken;

},{"./Cancel":"kjMy2"}],"dyQ8N":[function(require,module,exports) {
'use strict';
/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */ module.exports = function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
};

},{}],"eyiLq":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */ module.exports = function isAxiosError(payload) {
    return utils.isObject(payload) && payload.isAxiosError === true;
};

},{"./../utils":"5By4s"}],"1pKkE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render
);
var _vue = require("vue");
const _withScopeId = (n)=>(_vue.pushScopeId("data-v-5d0597"), n = n(), _vue.popScopeId(), n)
;
const _hoisted_1 = {
    class: "wrap"
};
const _hoisted_2 = /*#__PURE__*/ _vue.createStaticVNode("<h1 class=\"maintitle\" data-v-5d0597>Axiosçš„å‡çº§æ›¿ä»£å“</h1><h2 class=\"subtitle\" data-v-5d0597>æ— ä»»ä½•å‰¯ä½œç”¨ï¼Œä»…ä»…ä¸º Instance.get() æ‰©å±•ç¼“å­˜åŠŸèƒ½</h2><div data-v-5d0597><a href=\"https://github.com/cutting-mat/axios/blob/main/README_CN.md\" target=\"_blank\" class=\"myBtn\" data-v-5d0597><i class=\"el-icon-magic-stick\" data-v-5d0597></i> å¿«é€Ÿå¼€å§‹ </a><a href=\"https://www.npmjs.com/package/axios\" target=\"_blank\" class=\"myBtn\" data-v-5d0597><i class=\"el-icon-reading\" data-v-5d0597></i> Axios æ–‡æ¡£ </a></div><h3 class=\"channeltitle\" data-v-5d0597>æ¼”ç¤º</h3>", 4);
const _hoisted_6 = /*#__PURE__*/ _vue.createTextVNode(" è¯·æ±‚(ç¼“å­˜å¼€) ");
const _hoisted_7 = /*#__PURE__*/ _vue.createTextVNode(" è¯·æ±‚(ç¼“å­˜å…³) ");
const _hoisted_8 = /*#__PURE__*/ _vue.createTextVNode(" è¯·æ±‚(æ›´æ–°ç¼“å­˜) ");
const _hoisted_9 = /*#__PURE__*/ _vue.createTextVNode(" å¹¶å‘3æ¬¡è¯·æ±‚(é»˜è®¤) ");
const _hoisted_10 = /*#__PURE__*/ _vue.createTextVNode(" å¹¶å‘3æ¬¡è¯·æ±‚(ç¼“å­˜å…³) ");
const _hoisted_11 = {
    class: "log"
};
const _hoisted_12 = /*#__PURE__*/ _vue.createTextVNode(" æ¸…ç©ºæ—¥å¿— ");
function render(_ctx, _cache) {
    const _component_el_button = _vue.resolveComponent("el-button");
    return _vue.openBlock(), _vue.createElementBlock("div", null, [
        _vue.createElementVNode("div", _hoisted_1, [
            _hoisted_2,
            _vue.createVNode(_component_el_button, {
                onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.testRequest(true)
                )
            }, {
                default: _vue.withCtx(()=>[
                        _hoisted_6
                    ]
                ),
                _: 1 /* STABLE */ 
            }),
            _vue.createVNode(_component_el_button, {
                onClick: _cache[1] || (_cache[1] = ($event)=>_ctx.testRequest(false)
                )
            }, {
                default: _vue.withCtx(()=>[
                        _hoisted_7
                    ]
                ),
                _: 1 /* STABLE */ 
            }),
            _vue.createVNode(_component_el_button, {
                onClick: _cache[2] || (_cache[2] = ($event)=>_ctx.testRequest('update')
                )
            }, {
                default: _vue.withCtx(()=>[
                        _hoisted_8
                    ]
                ),
                _: 1 /* STABLE */ 
            }),
            _vue.createVNode(_component_el_button, {
                onClick: _cache[3] || (_cache[3] = ($event)=>_ctx.multiRequest()
                )
            }, {
                default: _vue.withCtx(()=>[
                        _hoisted_9
                    ]
                ),
                _: 1 /* STABLE */ 
            }),
            _vue.createVNode(_component_el_button, {
                onClick: _cache[4] || (_cache[4] = ($event)=>_ctx.multiRequest(false)
                )
            }, {
                default: _vue.withCtx(()=>[
                        _hoisted_10
                    ]
                ),
                _: 1 /* STABLE */ 
            }),
            _vue.createElementVNode("div", _hoisted_11, [
                _vue.createVNode(_component_el_button, {
                    size: "mini",
                    onClick: _cache[5] || (_cache[5] = ($event)=>_ctx.clear()
                    )
                }, {
                    default: _vue.withCtx(()=>[
                            _hoisted_12
                        ]
                    ),
                    _: 1 /* STABLE */ 
                }),
                (_vue.openBlock(true), _vue.createElementBlock(_vue.Fragment, null, _vue.renderList(_ctx.log, (item, index)=>{
                    return _vue.openBlock(), _vue.createElementBlock("div", {
                        key: index
                    }, _vue.toDisplayString(item), 1 /* TEXT */ );
                }), 128 /* KEYED_FRAGMENT */ ))
            ])
        ])
    ]);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender('5d0597-hmr', render);
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cdGAC":[function() {},{}],"1qp6r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{
};
exports.default = (script)=>{
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"31jvg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require('script:./footer.vue');
    if (script.__esModule) script = script.default;
    script.render = require('template:./footer.vue').render;
    script.__cssModules = require('style:./footer.vue').default;
    require('custom:./footer.vue').default(script);
    script.__scopeId = 'data-v-9a90fe';
    script.__file = "D:\\Workspace\\cutting-mat\\axios\\test\\components\\footer.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = '9a90fe-hmr';
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord('9a90fe-hmr', script)) __VUE_HMR_RUNTIME__.reload('9a90fe-hmr', script);
        }, 0);
    });
}
exports.default = script;

},{"script:./footer.vue":"fcqZ0","template:./footer.vue":"aqwAS","style:./footer.vue":"gNvgs","custom:./footer.vue":"gYqaK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fcqZ0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    data () {
        return {
        };
    },
    methods: {
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aqwAS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render
);
var _vue = require("vue");
const _withScopeId = (n)=>(_vue.pushScopeId("data-v-9a90fe"), n = n(), _vue.popScopeId(), n)
;
const _hoisted_1 = {
    class: "foot"
};
const _hoisted_2 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ _vue.createElementVNode("p", null, [
        /*#__PURE__*/ _vue.createTextVNode(" Â© 2022 - 3022 Author "),
        /*#__PURE__*/ _vue.createElementVNode("a", {
            href: "https://refined-x.com/",
            target: "_blank"
        }, "é›…Xå…±èµ"),
        /*#__PURE__*/ _vue.createTextVNode(" Github "),
        /*#__PURE__*/ _vue.createElementVNode("a", {
            href: "https://github.com/cutting-mat/axios",
            target: "_blank"
        }, "@cutting-mat/axios")
    ], -1 /* HOISTED */ )
);
const _hoisted_3 = [
    _hoisted_2
];
function render(_ctx, _cache) {
    return _vue.openBlock(), _vue.createElementBlock("footer", _hoisted_1, _hoisted_3);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender('9a90fe-hmr', render);
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gNvgs":[function() {},{}],"gYqaK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{
};
exports.default = (script)=>{
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kD4VB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render
);
var _vue = require("vue");
function render(_ctx, _cache) {
    const _component_myHeader = _vue.resolveComponent("myHeader");
    const _component_HomePage = _vue.resolveComponent("HomePage");
    const _component_myFooter = _vue.resolveComponent("myFooter");
    return _vue.openBlock(), _vue.createElementBlock(_vue.Fragment, null, [
        _vue.createVNode(_component_myHeader),
        _vue.createVNode(_component_HomePage, {
            class: "flex-1 scrollbar"
        }),
        _vue.createVNode(_component_myFooter)
    ], 64 /* STABLE_FRAGMENT */ );
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender('35924b-hmr', render);
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jw1co":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{
};
exports.default = (script)=>{
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["iQ6VI","azjEx"], "azjEx", "parcelRequired53f")

//# sourceMappingURL=index.127ec4a8.js.map
